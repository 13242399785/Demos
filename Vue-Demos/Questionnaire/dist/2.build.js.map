{"version":3,"sources":["webpack:///2.build.js","webpack:///Data.vue","webpack:///./src/components/Data.vue?64be","webpack:///./src/components/Data.vue?0fb9","webpack:///./src/components/Data.vue","webpack:///./src/components/Data.vue?a463","webpack:///./src/echarts.js"],"names":["webpackJsonp","16","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_echarts","_echarts2","data","typeMap","radio","checkbox","textarea","vuex","getters","questionnaire","state","currentQuestionnaire","questionnaireList","actions","setCurrentQuest","_ref","item","dispatch","route","_ref2","_this","this","to","next","id","params","questId","forEach","parseInt","directives","echarts","bind","self","vm","$nextTick","instance","init","el","update","newVal","oldVal","seriesData","option","type","selections","push","Math","random","grid","top","bottom","title","text","textAlign","yAxis","xAxis","series","radius","name","setOption","unbind","dispose","24","31","38","__vue_script__","__vue_template__","options","template","44","content","locals","50","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","global","root","factory","apply","undefined","require","define","normalize","baseId","indexOf","basePath","split","namePath","baseLen","length","nameLen","cutBaseTerms","cutNameTerms","pathLoop","i","slice","concat","join","createRequire","localRequire","callback","cacheMods","getModExports","Array","getModsExports","ids","es","mod","mods","l","min","arg","Error","defined","factoryReturn","deps","zrUtil","event","method","registerVisual","curry","registerLayout","registerProcessor","barLayoutGrid","ecModel","eachSeriesByType","seriesModel","getData","setVisual","graphic","layout","extendComponentModel","layoutMode","ignoreSize","defaultOption","zlevel","z","show","target","subtext","subtarget","left","backgroundColor","borderColor","borderWidth","padding","itemGap","textStyle","fontSize","fontWeight","color","subtextStyle","extendComponentView","render","titleModel","api","group","removeAll","get","textStyleModel","getModel","subtextStyleModel","textBaseline","textEl","Text","style","textFont","getFont","fill","getTextColor","z2","textRect","getBoundingRect","subText","subTextEl","y","height","link","sublink","silent","on","window","open","add","groupRect","layoutOption","getBoxLayoutParams","width","layoutRect","getLayoutRect","getWidth","getHeight","x","attr","alignStyle","textVerticalAlign","setStyle","margin","getItemStyle","rect","Rect","shape","subPixelOptimizeRect","gridModel","coordinateSystem","getRect","defaults","registerPreprocessor","numberUtil","formatUtil","IntervalScale","intervalScaleProto","prototype","mathCeil","ceil","mathFloor","floor","ONE_SECOND","ONE_MINUTE","ONE_HOUR","ONE_DAY","bisect","a","lo","hi","mid","TimeScale","extend","getLabel","val","stepLvl","_stepLvl","date","Date","formatTime","niceExtent","approxTickNum","fixMin","fixMax","extent","_extent","Infinity","d","getFullYear","getMonth","getDate","niceTicks","interval","_interval","round","span","approxInterval","scaleLevelsLen","scaleLevels","idx","level","yearSpan","yearStep","nice","_niceExtent","parse","parseDate","each","methodName","call","create","createRegisterEventWithLowercaseName","eventName","handler","context","toLowerCase","Eventful","MessageCenter","ECharts","dom","theme","opts","prioritySortFunc","b","prio","themeStorage","_dom","_zr","zrender","renderer","devicePixelRatio","_theme","clone","_chartsViews","_chartsMap","_componentsViews","_componentsMap","_api","ExtensionAPI","_coordSysMgr","CoordinateSystemManager","_messageCenter","_initEvents","resize","_pendingActions","timsort","visualFuncs","dataProcessorFuncs","animation","_onframe","toggleHighlight","payload","_model","eachComponent","mainType","query","index","chartView","__viewId","__alive","invokeUpdateMethod","component","componentModel","__model","updateZ","eachSeries","chart","updateProgressiveAndBlend","updateHoverLayerStatus","prepareView","isComponent","viewList","viewMap","zr","componentType","model","viewId","view","classType","ComponentModel","parseClassType","Clazz","ComponentView","getClass","main","sub","ChartView","__id","remove","splice","processData","process","func","stackSeriesData","stackedDataMap","stack","previousStack","stackedOn","doLayout","visual","isLayout","doVisualEncoding","clearColorPalette","doRender","componentView","storage","elCount","traverse","isGroup","env","node","useHoverLayer","ignore","frameDrawNum","needProgressive","progressive","stopAnimation","blendMode","canvasSupported","console","warn","enableConnect","updateConnectedChartsStatus","charts","status","otherChart","STATUS_KEY","STATUS_PENDING","STATUS_UPDATING","STATUS_UPDATED","eventActionMap","actionType","eventType","connectedGroups","action","makeActionFromEvent","otherCharts","instances","dispatchAction","GlobalModel","OptionManager","SeriesModel","colorTool","PRIORITY_PROCESSOR_FILTER","PRIORITY_PROCESSOR_STATISTIC","PRIORITY_VISUAL_LAYOUT","PRIORITY_VISUAL_GLOBAL","PRIORITY_VISUAL_CHART","PRIORITY_VISUAL_COMPONENT","PRIORITY_VISUAL_BRUSH","IN_MAIN_PROCESS","HAS_GRADIENT_OR_PATTERN_BG","OPTION_UPDATED","off","one","mixin","echartsProto","updateMethods","prepareAndUpdate","getDom","getZr","notMerge","lazyUpdate","assert","optionManager","optionPreprocessorFuncs","refreshImmediately","_flushPendingActions","setTheme","log","getOption","getRenderedCanvas","pixelRatio","list","getDisplayList","painter","getDataURL","excludeComponents","excludesComponentViews","url","toDataURL","getConnectedDataURL","groupId","mathMin","mathMax","max","MAX_NUMBER","right","canvasList","dpr","canvas","boundingRect","getBoundingClientRect","targetCanvas","createCanvas","img","Image","image","coordSysMgr","restoreData","isSingleCanvas","configLayer","clearColor","colorArr","stringify","colorStops","background","updateView","clearAllVisual","updateVisual","updateLayout","highlight","downplay","optionChanged","resetOption","_loadingFX","showLoading","cfg","isObject","hideLoading","loadingEffects","eventObj","actionWrap","actionInfo","updateMethod","payloads","batched","batch","map","eventObjBatch","isHighlightOrDownplay","batchItem","trigger","pendingActions","shift","MOUSE_EVENT_NAMES","eveName","e","dataIndex","dataModel","getSeriesByIndex","seriesIndex","getDataParams","dataType","eventData","isDisposed","_disposed","clear","idBase","groupIdBase","DOM_ATTRIBUTE_KEY","version","dependencies","replace","isDom","nodeName","toUpperCase","clientWidth","clientHeight","setAttribute","connect","isArray","disConnect","getInstanceByDom","key","getAttribute","getInstanceById","registerTheme","preprocessorFunc","priority","processorFunc","isNaN","registerAction","registerCoordinateSystem","CoordinateSystem","register","layoutFunc","visualFunc","registerLoading","loadingFx","superClass","extendSeriesModel","extendChartView","setCanvasCreator","creator","noop","List","Model","number","format","matrix","vector","util","PRIORITY","PROCESSOR","FILTER","STATISTIC","VISUAL","LAYOUT","GLOBAL","CHART","COMPONENT","BRUSH","Scale","scaleProto","mathPow","pow","mathLog","LogScale","base","getTicks","scale","setExtent","start","end","getExtent","unionExtent","quantity","err","abs","updateDataSelected","uid","hasAnimation","getName","selectedOffset","from","seriesId","toggleItemSelected","getItemGraphicEl","getItemLayout","isSelected","midAngle","startAngle","endAngle","dx","cos","dy","sin","offset","position","animate","when","PiePiece","onEmphasis","polyline","hoverIgnore","onNormal","normalIgnore","Group","sector","Sector","Polyline","updateData","getLabelStyle","labelModel","labelPosition","isLabelInside","getItemVisual","opacity","retrieve","hostModel","getFormattedLabel","piePieceProto","firstCreate","animateTo","r","childAt","itemModel","getItemModel","sectorShape","label","setShape","updateProps","itemStyleModel","visualColor","useStyle","lineJoin","hoverStyle","ifEnableAnimation","_updateLabel","setHoverStyle","labelLine","labelText","labelLayout","points","linePoints","verticalAlign","font","rotation","origin","labelHoverModel","labelLineModel","labelLineHoverModel","stroke","getLineStyle","smooth","inherits","Pie","sectorGroup","_sectorGroup","oldData","_data","isFirstRender","onSectorClick","selectedMode","diff","piePiece","eachChild","child","setItemGraphicEl","newIdx","oldIdx","execute","count","removeClipPath","setClipPath","_createClipPath","cx","cy","clockwise","cb","clipPath","r0","initProps","PI","modelUtil","completeDimensions","dataSelectableMixin","PieSeries","superApply","arguments","legendDataProvider","_dataBeforeProcessed","updateSelectedMap","_defaultLabelLine","mergeOption","newOption","superCall","getInitialData","dimensions","initData","sum","getSum","percent","toFixed","$vars","defaultEmphasis","labelLineNormalOpt","normal","labelLineEmphasisOpt","emphasis","legendHoverLink","hoverAnimation","center","minAngle","avoidLabelOverlap","rotate","length2","lineStyle","itemStyle","animationEasing","seriesType","actionInfos","selected","subType","source","result","len","isBuildInObject","hasOwnProperty","merge","overwrite","targetProp","sourceProp","mergeAll","targetAndSources","overlay","document","createElement","getContext","_ctx","array","clazz","baseClazz","F","clazzPrototype","prop","constructor","isArrayLike","nativeForEach","nativeMap","reduce","memo","nativeReduce","filter","nativeFilter","find","args","nativeSlice","objToString","isFunction","isString","BUILTIN_OBJECT","nodeType","values","Function","condition","message","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","toString","arrayProto","paletteScope","eachRawSeriesByType","dataAll","getRawData","idxMap","isSeriesFiltered","rawIdx","getRawIndex","filteredIdx","singleDataColor","setItemVisual","getColorFromPalette","parsePercent","PI2","RADIAN","size","unitRadian","roseType","getDataExtent","restAngle","valueSumLargerThanMinAngle","currentAngle","dir","angle","setItemLayout","linearMap","legendModels","findComponents","filterSelf","isAxisUsedInTheGrid","axisModel","findGridModel","getLabelUnionRect","axis","labels","getFormattedLabels","step","labelCount","isLabelIgnored","singleRect","getTextRect","union","Grid","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","updateAxisTransfrom","coordBase","axisExtent","axisExtentSum","toGlobalCoord","dim","coord","toLocalCoord","findAxesModels","axesTypes","axisType","queryComponents","isCartesian2D","axisHelper","Cartesian2D","Axis2D","ifAxisCrossZero","niceScaleExtent","gridProto","_rect","ifAxisCanNotOnZero","otherAxisDim","axes","axesMap","_updateScale","onZero","adjustAxes","axesList","isHorizontal","gridRect","inverse","labelUnionRect","getAxis","axisIndex","axesMapOnDim","getCartesian","xAxisIndex","yAxisIndex","coordList","createAxisCreator","axisPosition","axisPositionUsed","createScaleByModel","isCategory","onBand","axesCount","cartesian","addAxis","coordDimToDataDim","axesModels","xAxisModel","yAxisModel","componentIndex","grids","createListFromArray","coordSys","getMarkerPosition","pt","dataToPoint","getLayout","offsetIndex","getBaseAxis","NaN","brushSelector","barMinHeight","fixLayoutWithLineWidth","lineWidth","signX","signY","coordinateSystemType","_renderOnCartesian","createRect","isUpdate","barBorderWidthQuery","enableAnimation","rectShape","animateProperty","animateTarget","baseAxis","hasValue","newIndex","oldIndex","_updateStyle","setLabel","labelPositionOutside","setText","textPosition","eachItemGraphicEl","getBarItemStyle","hoverLabelModel","rectStyle","getRawValue","getSeriesStackId","getAxisKey","calBarWidthAndOffset","barSeries","columnsMap","bandWidth","getBandWidth","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","stackId","maxWidth","barWidth","barMaxWidth","barGap","barCategoryGap","coordSysName","barGapPercent","autoWidth","column","lastColumn","widthSum","barWidthAndOffset","getSeriesByType","lastStackCoords","columnLayoutInfo","columnOffset","columnWidth","valueAxis","getOtherAxis","valueAxisStart","dataToCoord","getGlobalExtent","coords","dataToPoints","setLayout","p","n","sign","lastCoord","hasFillOrStroke","fillOrStroke","liftColor","lift","cacheElementStl","__hoverStlDirty","__hoverStl","normalStyle","__normalStl","doSingleEnterHover","__isHover","__zr","addHover","doSingleLeaveHover","normalStl","removeHover","doEnterHover","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","props","animatableModel","animationEnabled","getShallow","postfix","duration","animationDelay","pathTool","Path","Circle","Ring","Polygon","Line","BezierCurve","Arc","CompoundPath","LinearGradient","RadialGradient","BoundingRect","extendShape","extendPath","pathData","extendFromString","makePath","path","createFromString","aspect","resizePath","mergePath","applyTransform","pathRect","m","calculateTransform","subPixelOptimizeLine","param","subPixelOptimize","x1","x2","y1","y2","originX","originY","originWidth","originHeight","positiveOrNegative","doubledPosition","labelColor","textDistance","textFill","getTransform","ancestor","mat","identity","mul","getLocalTransform","parent","vertex","transform","invert","transformDirection","direction","hBase","vBase","groupTransition","g1","g2","getElMap","g","elMap","anid","getAnimatableProps","elMap1","oldEl","newProp","boxLayout","orient","maxHeight","currentLineMaxSize","nextX","nextY","nextChild","nextChildRect","moveX","newline","moveY","LOCATION_PARAMS","box","vbox","hbox","getAvailableSize","positionInfo","containerRect","containerWidth","containerHeight","parseFloat","normalizeCssArray","verticalMargin","horizontalMargin","positionGroup","mergeLayoutParam","targetOption","opt","names","newParams","newValueCount","merged","mergedValueCount","enoughParamNumber","hasProp","copy","hNames","vNames","hResult","vResult","getLayoutParams","copyLayoutParams","_trim","str","RADIAN_EPSILON","domain","range","clamp","subDomain","subRange","all","match","precision","asc","arr","sort","getPrecision","getPrecisionSafe","dotIndex","getPixelPrecision","dataExtent","pixelExtent","LN10","dataQuantity","sizeQuantity","MAX_SAFE_INTEGER","remRadian","radian","pi2","isRadianAroundZero","ret","nf","exp10","f","textContain","addCommas","toCamelCase","group1","encodeHTML","String","TPL_VAR_ALIAS","wrapVar","varName","seriesIdx","formatTpl","tpl","paramsList","seriesLen","alias","k","s2d","M","h","getHours","getMinutes","s","getSeconds","capitalFirst","charAt","substr","truncateText","roundingErrorFix","thisExtent","other","getInterval","setInterval","ticks","safeLimit","tick","getTicksLabels","splitNumber","isFinite","reverse","expandSize","detect","ua","os","browser","firefox","ie","edge","touchEventsSupported","pointerEventsSupported","navigator","userAgent","chartInstance","echartsAPIList","mergeTheme","hasClass","initBase","baseOption","OPTION_INNER_KEY","_seriesIndices","globalDefault","getComponentsByTypes","componentsMap","types","makeKeyInfo","mapResult","idMap","existCpt","exist","determineSubType","keyInfo","idNum","newCptOption","existComponent","createSeriesIndices","seriesModels","filterBySubType","components","cpt","assertSeriesInitialized","parentModel","_optionManager","mountOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","mediaOption","visitComponent","newCptOptionList","normalizeToArray","mappingToExists","dependentModels","resultItem","ComponentModelClass","optionUpdated","extraOpt","newCptTypes","componentOption","topologicalTravel","getAllClassMainTypes","isIdInner","getTheme","getComponent","cpts","isIdArray","isNameArray","getQueryCond","q","indexAttr","idAttr","nameAttr","doFilter","res","queryCond","queryResult","getSeriesByName","oneSeries","getSeries","rawSeriesIndex","eachRawSeries","filterSeries","filteredSeries","componentTypes","_timelineOptions","_mediaList","_mediaDefault","_currentMediaIndices","_optionBackup","_newBaseOption","parseRawOption","rawOption","isNew","mediaDefault","timelineOptions","mediaList","timelineOpt","timeline","media","singleMedia","preProcess","applyMediaQuery","ecWidth","ecHeight","realMap","aspectratio","applicatable","matched","QUERY_REG","operator","realAttr","compare","real","expect","indicesEquals","indices1","indices2","oldOption","newCptOpt","oldCptOpt","oldOptionBackup","newParsedOption","isRecreate","optionBackup","timelineModel","getCurrentIndex","indices","_coordinateSystems","coordinateSystemCreators","coordinateSystems","coordinateSystemCreator","colorPaletteMixin","visualColorAccessPath","mergeDefaultAndTheme","cloneShallow","getDefaultOption","LABEL_OPTIONS","fillDataTextStyle","newSeriesOption","getLinkedData","setData","coordDim","dataDimToCoordDim","dataDim","formatTooltip","multipleSeries","formatArrayValue","dimInfo","getDimensionInfo","dimType","formattedValue","colorEl","seriesName","scope","getAxisTooltipDataIndex","dataFormatMixin","getDependencies","getClassesByMainType","arrayPush","clazzUtil","componentUtil","$constructor","getUID","inputPositionParams","themeModel","isInit","optList","Class","__defaultOption","enableClassManagement","registerWhenExtend","enableSubTypeDefaulter","enableTopologicalTravel","Component","componentProto","enableClassExtend","Chart","elSetState","childCount","dataIndices","indexOfName","chartProto","delInstance","guid","Handler","Storage","Animation","HandlerProxy","useVML","painterCtors","ZRender","getInstance","registerPainter","Ctor","rendererType","vml","handerProxy","getViewportRoot","stage","_needsRefresh","_needsRefreshHover","refreshHoverImmediately","oldDelFromMap","delFromMap","oldAddToMap","addToMap","elId","removeSelfFromZr","addSelfToZr","getId","addRoot","delRoot","zLevel","config","refresh","refreshHover","clearHover","clearAnimation","pathToImage","setCursorStyle","cursorStyle","eventHandler","stop","arrySlice","_$handlers","_h","ctx","isSilent","newList","argLen","triggerWithContext","clampCssByte","clampCssAngle","clampCssFloat","parseCssInt","parseCssFloat","cssHueToRgb","m1","m2","lerp","colorStr","kCSSColorTable","op","ep","fname","alpha","pop","hsla2rgba","iv","hsla","rgba","rgba2hsla","H","S","R","G","B","vMin","vMax","delta","L","deltaR","deltaG","deltaB","toHex","fastMapToColor","normalizedValue","colors","out","leftIndex","rightIndex","leftColor","rightColor","dv","mapToColor","fullOutput","modifyHSL","modifyAlpha","arrColor","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","minRunLength","DEFAULT_MIN_MERGE","makeAscendingRun","runHi","reverseRun","t","binaryInsertionSort","pivot","gallopLeft","hint","lastOffset","maxOffset","tmp","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","tmpStorageLength","DEFAULT_TMP_STORAGE_LENGTH","stackLength","remaining","ts","minRun","force","Gradient","encodeColor","colorAccessPath","set","compatLayoutProperties","LAYOUT_PROPERTIES","compatStyle","COMPATITABLE_COMPONENTS","COMPATITABLE_SERIES","seriesOpt","clockWise","pointerColor","dataRange","visualMap","componentName","textColor","maskColor","mask","arc","lineCap","labelRect","animateShape","delay","ArrayCtor","Float32Array","out0","out1","out2","out3","out4","out5","translate","v","rad","aa","ac","atx","ab","ad","aty","st","ct","vx","vy","det","ignoreParent","thisParentModel","isEmpty","setReadOnly","properties","normalizeDimensions","cloneListForMapAndSample","original","excludeDimensions","allDimensions","transferProperties","_storage","originalStorage","dimStore","UNDEFINED","globalObj","Float64Array","Int32Array","dataCtors","float","int","ordinal","time","DataDiffer","TRANSFERABLE_PROPERTIES","__wrappedMethods","propName","dimensionInfos","dimensionNames","dimensionName","dimensionInfo","stackable","_dimensionInfos","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_rawData","listProto","hasItemOption","getDimension","nameList","dimValueGetter","dimensionInfoMap","idList","nameRepeatCount","DataCtor","dataItem","dimName","dimIndex","getDataItemValue","isDataItemOption","converDataValue","dimStorage","stackedValue","getValues","dimData","dimExtent","rawIndex","indexOfRawIndex","indexOfNearest","maxDistance","nearestIdx","minDist","Number","MAX_VALUE","dist","getRawDataItem","dims","dimSize","newIndices","keep","mapArray","tmpRetValue","retValue","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","originalIndices","frameValues","frameIndices","frameSize","otherList","otherIdList","getVisual","clearItemLayouts","itemVisual","setItemDataAndSeriesIndex","dimensionInfoList","wrapMethod","injectFunction","originalMethod","TRANSFERABLE_METHODS","CHANGABLE_METHODS","v1","v2","scaleAndAdd","sqrt","lenSquare","div","dot","distance","distanceSquare","negate","lengthSquare","distSquare","contain","OrdinalScale","getScaleExtent","originalExtent","getMin","getMax","crossZero","getNeedCrossZero","boundaryGap","minInterval","intervalScale","getCategories","getAxisLabelInterval","tickCoords","isAxisHorizontal","textSpaceTakenRect","autoLabelInterval","accumulatedLabelInterval","tickCoord","intersect","labelFormatter","Cartesian","getAxesByScale","containPoint","point","axisX","axisY","containData","pointToData","coordToData","Axis","axisLabelInterval","coordExtent","getLabelInterval","labelInterval","_labelInterval","containLabel","processArc","fa","fs","rx","ry","psiDeg","cmd","psi","xp","mathCos","mathSin","yp","lambda","mathSqrt","cxp","cyp","theta","vAngle","u","dTheta","vRatio","addData","createPathProxyFromString","cs","cc","RegExp","prevCmd","cpx","cpy","PathProxy","CMD","c","ctlPtx","ctlPty","C","Q","A","Z","toStatic","createPathOptions","pathProxy","buildPath","transformPath","rebuildPath","dirty","vMag","acos","pathEls","pathList","pathEl","__dirty","pathBundle","appendPath","Displayable","pathContain","Pattern","getCanvasPattern","__dirtyPath","strokeContainThreshold","brush","prevEl","hasStroke","hasFill","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","setTransform","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDash","lineDashOffset","ctxLineDash","setLineDash","getGlobalScale","setScale","beginPath","setLineDashOffset","restoreTransform","drawRectText","shapeCfg","inBundle","needsUpdateRect","rectWithStroke","_rectWithStroke","w","lineScale","strokeNoScale","getLineScale","localPos","transformCoordToLocal","containStroke","dirtyPath","__clipTarget","loop","attrKV","Sub","extendFrom","defaultShape","thisShape","addColorStop","Element","_children","__storage","children","childOfName","_doAdd","addBefore","nextSibling","addChildrenToStorage","delChildrenFromStorage","includeChildren","tmpRect","tmpMat","invisible","childRect","lineHeight","measureText","textLines","fillText","strokeText","ZImage","LRU","globalImageCache","src","_image","cachedImgObj","onload","pending","put","sWidth","sHeight","sx","sy","drawImage","moveTo","unitX","unitY","lineTo","closePath","roundRectHelper","polyHelper","smoothConstraint","pointAt","someVectorAt","isTangent","cpx2","cpy2","cubicDerivativeAt","cubicAt","cpx1","cpy1","quadraticDerivativeAt","quadraticAt","curveTool","vec2","quadraticSubdivide","cubicSubdivide","quadraticCurveTo","bezierCurveTo","tangentAt","globalCoord","paths","_updatePathDirty","beforeBrush","afterBrush","v2ApplyTransform","mathAbs","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","getTextWidth","textWidthCache","textWidthCacheCounter","TEXT_CACHE_MAX","textLineLen","adjustTextPositionOnRect","textHeight","halfHeight","ellipsis","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","j","subLength","estimateLength","charCode","charCodeAt","nubmerUtil","subOpts","emphasisOpt","normalOpt","subOptName","createDataFormatModel","rawValue","rawDataIndex","itemOpt","componentSubType","formatter","exists","newCptOptions","cptOption","compressBatches","batchA","batchB","makeMap","sourceBatch","otherMap","otherDataIndices","lenj","mapToArray","isData","mapA","mapB","platform","fontFamily","fontStyle","animationDuration","animationDurationUpdate","animationEasingUpdate","animationThreshold","progressiveThreshold","hoverLayerThreshold","_colorIdx","_colorNameMap","colorIdx","colorNameMap","colorPalette","curve","bbox","min2","max2","hasTypedArray","_len","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","exceedUnit","_needsDash","_dashedLineTo","x3","y3","_dashedBezierTo","_dashedQuadraticTo","anticlockwise","arcTo","x0","y0","lineDashSum","appendSize","appendPathData","_expandData","_prevCmd","newData","dash","dashSum","nDash","bezierLen","tmpLen","xi","yi","fromLine","fromCubic","fromQuadratic","fromArc","ux","uy","scaleX","scaleY","isEllipse","nPoint","mathAtan2","atan2","TYPE_DELIMITER","IS_CONTAINER","RootClass","proto","ExtendedClass","entity","makeContainer","container","registerClass","componentTypeMain","throwWhenNotFound","o","hasSubTypes","originalExtend","Style","__clipPaths","RectText","draggable","dragging","culling","cursor","rectHover","rectContain","animateStyle","isAroundEqual","EPSILON","swapExtrema","extrema","windingCubic","nRoots","cubicRootAt","roots","y0_","y1_","nExtrema","unit","x_","cubicExtrema","windingQuadratic","quadraticRootAt","quadraticExtremum","y_","windingArc","normalizeRadian","containPath","isStroke","windingLine","cubic","quadratic","_x","line","excludes","getLineDash","lineType","rank","repeat","_canvasPattern","createPattern","getAreaStyle","gTextStyleModel","align","baseline","getBorderLineDash","createLinearGradient","canvasGradient","createRadialGradient","STYLE_COMMON_PROPS","shadowBlur","shadowOffsetX","shadowOffsetY","textStroke","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textTransform","textRotation","blend","prevStyle","firstDraw","styleName","globalAlpha","globalCompositeOperation","otherStyle","newStyle","styleProto","maxValue","lastIndexOf","save","shadowColor","textShadowColor","restore","Transformable","Animatable","drift","decomposeTransform","beforeUpdate","afterUpdate","updateTransform","hide","animators","addAnimator","removeAnimator","dimAxisMapper","_axes","_dimList","getAxes","scaleType","_dataCoordConvert","input","dimList","output","idStart","isNotAroundZero","mIdentity","transformableProto","needLocalTransform","parentHasTransform","invTransform","tmpTransform","transformCoordToGlobal","Animator","animatingShape","pathSplitted","animator","during","done","forwardToLast","easing","_animateToShallow","objShallow","propertyCount","DELIMITER","subTypeDefaulters","registerSubTypeDefaulter","defaulter","dependencyGetter","makeDepndencyGraph","fullNameList","graph","noEntryList","thisItem","createDependencyGraphItem","originalDeps","availableDeps","getAvailableDependencies","entryCount","dependentName","predecessor","thatItem","successor","dep","targetNameList","removeEdge","succComponentType","removeEdgeAndAdd","targetNameSet","currComponentType","currVertex","isInTargetNameSet","fixExtentWithBands","nTick","normalizedExtent","getTicksCoords","alignWithLabel","bands","getBands","getLabelsCoords","debugMode","defaultGetter","defaultSetter","interpolateNumber","p0","p1","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","arraySlice","isArraySame","catmullRomInterpolateArray","p2","p3","t2","t3","catmullRomInterpolate","v0","cloneValue","rgba2String","createTrackClip","oneTrackDone","keyframes","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","lastValue","_target","lastFrame","lastFramePercent","onframe","frame","clip","Clip","life","_loop","_delay","ondestroy","_tracks","_clipCount","_doneList","_onframeList","_clipList","tracks","_doneCallback","doneList","lastClip","clipCount","addClip","oldOnFrame","clipList","removeClip","getClips","getAxisType","axisDim","axisModelCreator","AxisModel","_resetRange","setRange","rangeStart","rangeEnd","extraOption","_life","_initialized","onrestart","easingFuncs","globalTime","_startTime","easingFunc","schedule","fire","restart","_needsRemove","remainder","axisDefault","AXIS_TYPES","axisName","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","linear","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","asin","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","nameLocation","nameRotate","nameTruncate","nameTextStyle","nameGap","triggerEvent","tooltip","axisLine","axisTick","inside","axisLabel","splitLine","splitArea","areaStyle","categoryAxis","timeAxis","logAxis","logBase","firstDataNotNull","ifNeedCompleteOrdinalData","sampleItem","creators","registeredCoordSys","axesInfo","categoryIndex","createNameList","categories","categoryAxesModels","isStackable","getDimTypeByAxis","categoryAxisModel","categoryDim","dataLen","cartesian2d","xAxisType","yAxisType","isXAxisCateogry","isYAxisCategory","polar","polarModel","angleAxisModel","findAxisModel","radiusAxisModel","radiusAxisType","angleAxisType","isAngleAxisCateogry","isRadiusAxisCateogry","geo","isAroundZero","onet","t1","disc","K","discSqrt","Y1","Y2","ONE_THIRD","T","ASqrt","THREE_SQRT","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","prev","d1","d2","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","divider","quadraticProjectPoint","v2Create","extremity","fromPoints","xDim","yDim","tx","ty","vec2Min","vec2Max","defaultKeyGetter","oldArr","newArr","oldKeyGetter","newKeyGetter","_old","_new","_oldKeyGetter","_newKeyGetter","initIndexMap","keyArr","keyGetter","existence","_add","_update","_remove","oldDataIndexMap","newDataIndexMap","oldDataKeyArr","newDataKeyArr","unshift","defaultNames","extraPrefix","value0","retrieveValue","guessOrdinal","_l","_a","_b","_s","LinkedList","head","tail","linkedListProto","insert","entry","Entry","insertEntry","maxSize","_list","_map","_maxSize","LRUProto","leastUsedEntry","smoothSpline","smoothBezier","controlPoints","cp1","cp2","interpolate","isLoop","segs","pos","w2","w3","v2Min","v2Max","v2Scale","v2Distance","v2Add","constraint","prevPoint","nextPoint","cps","d0","cp0","r1","r2","r3","r4","total","shapeCompareFunc","_elements","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","displayList","_updateAndAddDisplayable","clipPaths","elements","_renderList","displayableSortFunc","makeEventPacket","eveType","cancelBubble","offsetX","zrX","offsetY","zrY","gestureEvent","pinchX","pinchY","pinchScale","wheelDelta","zrDelta","EmptyProxy","isHover","displayable","Draggable","handlerNames","proxy","_hovered","_lastTouchMoment","_lastX","_lastY","mousemove","hovered","findHover","lastHovered","setCursor","dispatchToElement","mouseout","eventArgs","targetEl","eventPacket","eachOtherLayer","layer","exclude","_downel","_upel","Dispatcher","requestAnimationFrame","_clips","_running","_time","_pausedTime","_pauseStart","_paused","clips","getTime","deferredEvents","deferredClips","_startLoop","pause","resume","eventNameFix","processGesture","gestureMgr","_gestureMgr","gestureInfo","recognize","setTouchTimer","_touching","clearTimeout","_touchTimer","setTimeout","useTouchEvent","initDomHandler","makeMouseHandler","fn","touchHandlerNames","_handlers","domHandlers","mouseHandlerNames","HandlerDomProxy","mountHandlers","addEventListener","GestureMgr","eventTool","removeEventListener","normalizeEvent","TOUCH_CLICK_DELAY","element","toElement","relatedTarget","parentNode","touchstart","mousedown","touchmove","touchend","mouseup","click","handlerDomProxyProto","parseInt10","isLayerValid","isBuildin","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","prevClipPaths","doClip","createRoot","domRoot","domRootStyle","overflow","Layer","MAX_PROGRESSIVE_LAYER_NUMBER","Painter","singleCanvas","_singleCanvas","rootStyle","innerHTML","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","initContext","_getWidth","_getHeight","_domRoot","appendChild","_createPathToImage","_progressiveLayers","_hoverlayer","_hoverElements","paintAll","_paintList","_startProgessive","__hoverMir","elMirror","__from","hoverElements","hoverLayer","getLayer","originalEl","_doPaintEl","token","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuildinLayer","flushProgressiveLayer","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","prevClipLayer","prevElClipPaths","insertLayer","layersMap","prevLayer","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","layerConfig","delLayer","removeChild","display","clearLayer","imageLayer","stl","defaultView","getComputedStyle","paddingLeft","paddingRight","paddingTop","paddingBottom","_pathToImage","clearRect","pathTransform","ImageShape","imgShape","me","_dragStart","_drag","_dragEnd","draggingTarget","_draggingTarget","_y","dropTarget","lastDropTarget","_dropTarget","clientToLocal","clientX","clientY","isTouch","touch","targetTouches","changedTouches","detail","isDomLevel2","attachEvent","detachEvent","preventDefault","stopPropagation","returnValue","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","pointPair","eventUtil","_track","_doTrack","_recognize","touches","trackItem","recognizers","pinch","track","pinchEnd","pinchPre","pinchCenter","returnFalse","createDom","newDom","newDomStyle","domStyle","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","createBackBuffer","clearAll","haveMotionBLur","clearColorGradientOrPattern","__canvasGradient","fillRect","compatItemStyle","itemStyleOpt","POSSIBLE_STYLES","normalItemStyleOpt","emphasisItemStyleOpt","markPoint","markLine","mpData","mlData","targetList","_selectTargetMap","targetMap","select","unSelect","toggleSelected","layoutAxis","getZero","theAxis","rawAxisPosition","rectBound","axisOffset","posMap","dirMap","labelDirection","tickDirection","nameDirection","labelOffset","labelRotation","AxisBuilder","ifIgnoreOnTick","axisBuilderAttrs","selfBuilderAttrs","AxisView","oldAxisGroup","_axisGroup","axisBuilder","getGroup","_splitLine","splitLineModel","lineStyleModel","lineColors","lineInterval","lineCount","ticksCoords","colorIndex","_splitArea","splitAreaModel","areaStyleModel","areaColors","prevX","prevY","areaInterval","adjustSingleSide","viewWidth","viewHeight","shiftDown","shiftUp","changeX","isDownList","lastDeltaX","deltaY","deltaX","lastY","upList","downList","avoidOverlap","labelLayoutList","leftList","rightList","hasLabelRotate","textX","textY","labelLineLen","labelLineLen2","labelRotate","makeAxisEventDataBase","innerTextLayout","rotationDiff","endTextLayout","textRotate","onLeft","tooltipOpt","dumbGroup","_transform","_dumbGroup","hasBuilder","builders","pt1","pt2","tickModel","tickLen","tickInterval","isTwoLabelOverlapped","current","firstRect","nextRect","axisLabelShow","labelMargin","categoryData","textEls","itemTextStyleModel","labelBeforeFormat","targetType","firstLabel","nextLabel","lastLabel","prevLabel","gapSignal","nameRotation","axisNameAvailableWidth","truncateOpt","truncatedText","formatterParams","__fullText","__truncatedText","rawTick"],"mappings":"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ACA,IACA,EACA,GAEAC,WACA,IACA,IACA,GACA,GAEAC,OACA,IACA,IACA,GACA,GAEAC,gBACA,IACA,IACA,IACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,SACA,IACA,GACA,GACA,GAEAC,MACA,EACA,IACA,IACA,GAEAC,UACA,EACA,EACA,IACA,GAEAC,UACA,EACA,IACA,IACA,GAEAC,eACA,IACA,IACA,GACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,WACA,EACA,IACA,EACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,aACA,IACA,EACA,IACA,GAEAC,gBACA,GACA,IACA,GACA,GAEAC,YACA,IACA,IACA,EACA,GAEAC,YACA,IACA,GACA,IACA,GAEAC,SACA,IACA,EACA,EACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,cACA,IACA,IACA,IACA,GAEAC,eACA,GACA,GACA,IACA,GAEAC,eACA,GACA,GACA,GACA,GAEAC,eACA,GACA,GACA,GACA,GAEAC,eACA,EACA,IACA,IACA,GAEAC,YACA,IACA,EACA,IACA,GAEAC,UACA,IACA,GACA,IACA,GAEAC,aACA,EACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,YACA,GACA,IACA,IACA,GAEAC,WACA,IACA,GACA,GACA,GAEAC,aACA,IACA,IACA,IACA,GAEAC,aACA,GACA,IACA,GACA,GAEAC,SACA,IACA,EACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,MACA,IACA,IACA,EACA,GAEAC,WACA,IACA,IACA,GACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,OACA,EACA,IACA,EACA,GAEAC,aACA,IACA,IACA,GACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,WACA,IACA,GACA,GACA,GAEAC,QACA,GACA,EACA,IACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,eACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,EACA,GAEAC,cACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,sBACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,aACA,IACA,IACA,IACA,GAEAC,eACA,GACA,IACA,IACA,GAEAC,cACA,IACA,IACA,IACA,GAEAC,gBACA,IACA,IACA,IACA,GAEAC,gBACA,IACA,IACA,IACA,GAEAC,gBACA,IACA,IACA,IACA,GAEAC,aACA,IACA,IACA,IACA,GAEAC,MACA,EACA,IACA,EACA,GAEAC,WACA,GACA,IACA,GACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,SACA,IACA,EACA,IACA,GAEAC,QACA,IACA,EACA,EACA,GAEAC,kBACA,IACA,IACA,IACA,GAEAC,YACA,EACA,EACA,IACA,GAEAC,cACA,IACA,GACA,IACA,GAEAC,cACA,IACA,IACA,IACA,GAEAC,gBACA,GACA,IACA,IACA,GAEAC,iBACA,IACA,IACA,IACA,GAEAC,mBACA,EACA,IACA,IACA,GAEAC,iBACA,GACA,IACA,IACA,GAEAC,iBACA,IACA,GACA,IACA,GAEAC,cACA,GACA,GACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,aACA,IACA,IACA,IACA,GAEAC,MACA,EACA,EACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,OACA,IACA,IACA,EACA,GAEAC,WACA,IACA,IACA,GACA,GAEAC,QACA,IACA,IACA,EACA,GAEAC,WACA,IACA,GACA,EACA,GAEAC,QACA,IACA,IACA,IACA,GAEAC,eACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,eACA,IACA,IACA,IACA,GAEAC,eACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,MACA,IACA,IACA,GACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,QACA,IACA,EACA,IACA,GAEAC,KACA,IACA,EACA,EACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,WACA,GACA,IACA,IACA,GAEAC,aACA,IACA,GACA,GACA,GAEAC,QACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,GACA,GAEAC,UACA,GACA,IACA,GACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,QACA,IACA,GACA,GACA,GAEAC,QACA,IACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,WACA,IACA,GACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,aACA,EACA,IACA,IACA,GAEAC,WACA,GACA,IACA,IACA,GAEAC,KACA,IACA,IACA,IACA,GAEAC,MACA,EACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,QACA,IACA,GACA,GACA,GAEAC,WACA,GACA,IACA,IACA,GAEAC,QACA,IACA,IACA,IACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,QACA,IACA,IACA,EACA,GAEAC,aACA,IACA,IACA,GACA,GAkWA,QACAtzC,QACA0rB,OACA0d,QACAC,iBACAS,aACAE,YACAC,cACA19B,eAGA1X,EAAA,qCAIA,QAAA0+C,GAAAnoB,GAEA,IADA,GAAA5U,GAAA,EACA4U,GAAAooB,GACAh9B,GAAA,EAAA4U,EACAA,IAAA,CAEA,OAAAA,GAAA5U,EAEA,QAAAi9B,GAAA71B,EAAAjgB,EAAAC,EAAA+hC,GACA,GAAA+T,GAAA/1C,EAAA,CACA,IAAA+1C,IAAA91C,EACA,QAEA,IAAA+hC,EAAA/hB,EAAA81B,KAAA91B,EAAAjgB,IAAA,GACA,KAAA+1C,EAAA91C,GAAA+hC,EAAA/hB,EAAA81B,GAAA91B,EAAA81B,EAAA,OACAA,GAEAC,GAAA/1B,EAAAjgB,EAAA+1C,OAEA,MAAAA,EAAA91C,GAAA+hC,EAAA/hB,EAAA81B,GAAA91B,EAAA81B,EAAA,QACAA,GAGA,OAAAA,GAAA/1C,EAEA,QAAAg2C,GAAA/1B,EAAAjgB,EAAAC,GAEA,IADAA,IACAD,EAAAC,GAAA,CACA,GAAAg2C,GAAAh2B,EAAAjgB,EACAigB,GAAAjgB,KAAAigB,EAAAhgB,GACAggB,EAAAhgB,KAAAg2C,GAGA,QAAAC,GAAAj2B,EAAAjgB,EAAAC,EAAAwV,EAAAusB,GAIA,IAHAvsB,IAAAzV,GACAyV,IAEcA,EAAAxV,EAAYwV,IAAA,CAK1B,IAJA,GAGAvV,GAHAi2C,EAAAl2B,EAAAxK,GACA3a,EAAAkF,EACA2N,EAAA8H,EAEA3a,EAAA6S,GACAzN,EAAApF,EAAA6S,IAAA,EACAq0B,EAAAmU,EAAAl2B,EAAA/f,IAAA,EACAyN,EAAAzN,EAEApF,EAAAoF,EAAA,CAGA,IAAAutB,GAAAhY,EAAA3a,CACA,QAAA2yB,GACA,OACAxN,EAAAnlB,EAAA,GAAAmlB,EAAAnlB,EAAA,EACA,QACAmlB,EAAAnlB,EAAA,GAAAmlB,EAAAnlB,EAAA,EACA,QACAmlB,EAAAnlB,EAAA,GAAAmlB,EAAAnlB,EACA,MACA,SACA,KAAA2yB,EAAA,GACAxN,EAAAnlB,EAAA2yB,GAAAxN,EAAAnlB,EAAA2yB,EAAA,GACAA,IAGAxN,EAAAnlB,GAAAq7C,GAGA,QAAAC,GAAArkD,EAAAkuB,EAAAxK,EAAA/d,EAAA2+C,EAAArU,GACA,GAAAsU,GAAA,EACAC,EAAA,EACAr/B,EAAA,CACA,IAAA8qB,EAAAjwC,EAAAkuB,EAAAxK,EAAA4gC,IAAA,GAEA,IADAE,EAAA7+C,EAAA2+C,EACAn/B,EAAAq/B,GAAAvU,EAAAjwC,EAAAkuB,EAAAxK,EAAA4gC,EAAAn/B,IAAA,GACAo/B,EAAAp/B,EACAA,MAAA,KACAA,GAAA,IACAA,EAAAq/B,EAGAr/B,GAAAq/B,IACAr/B,EAAAq/B,GAEAD,GAAAD,EACAn/B,GAAAm/B,MACS,CAET,IADAE,EAAAF,EAAA,EACAn/B,EAAAq/B,GAAAvU,EAAAjwC,EAAAkuB,EAAAxK,EAAA4gC,EAAAn/B,KAAA,GACAo/B,EAAAp/B,EACAA,MAAA,KACAA,GAAA,IACAA,EAAAq/B,EAGAr/B,GAAAq/B,IACAr/B,EAAAq/B,EAEA,IAAAC,GAAAF,CACAA,GAAAD,EAAAn/B,EACAA,EAAAm/B,EAAAG,EAGA,IADAF,IACAA,EAAAp/B,GAAA,CACA,GAAAma,GAAAilB,GAAAp/B,EAAAo/B,IAAA,EACAtU,GAAAjwC,EAAAkuB,EAAAxK,EAAA4b,IAAA,EACAilB,EAAAjlB,EAAA,EAEAna,EAAAma,EAGA,MAAAna,GAEA,QAAAu/B,GAAA1kD,EAAAkuB,EAAAxK,EAAA/d,EAAA2+C,EAAArU,GACA,GAAAsU,GAAA,EACAC,EAAA,EACAr/B,EAAA,CACA,IAAA8qB,EAAAjwC,EAAAkuB,EAAAxK,EAAA4gC,IAAA,GAEA,IADAE,EAAAF,EAAA,EACAn/B,EAAAq/B,GAAAvU,EAAAjwC,EAAAkuB,EAAAxK,EAAA4gC,EAAAn/B,IAAA,GACAo/B,EAAAp/B,EACAA,MAAA,KACAA,GAAA,IACAA,EAAAq/B,EAGAr/B,GAAAq/B,IACAr/B,EAAAq/B,EAEA,IAAAC,GAAAF,CACAA,GAAAD,EAAAn/B,EACAA,EAAAm/B,EAAAG,MACS,CAET,IADAD,EAAA7+C,EAAA2+C,EACAn/B,EAAAq/B,GAAAvU,EAAAjwC,EAAAkuB,EAAAxK,EAAA4gC,EAAAn/B,KAAA,GACAo/B,EAAAp/B,EACAA,MAAA,KACAA,GAAA,IACAA,EAAAq/B,EAGAr/B,GAAAq/B,IACAr/B,EAAAq/B,GAEAD,GAAAD,EACAn/B,GAAAm/B,EAGA,IADAC,IACAA,EAAAp/B,GAAA,CACA,GAAAma,GAAAilB,GAAAp/B,EAAAo/B,IAAA,EACAtU,GAAAjwC,EAAAkuB,EAAAxK,EAAA4b,IAAA,EACAna,EAAAma,EAEAilB,EAAAjlB,EAAA,EAGA,MAAAna,GAEA,QAAAw/B,GAAAz2B,EAAA+hB,GAgBA,QAAA2U,GAAAC,EAAAC,GACAC,EAAAC,GAAAH,EACAI,EAAAD,GAAAF,EACAE,GAAA,EAEA,QAAAE,KACA,KAAAF,EAAA,IACA,GAAAtpB,GAAAspB,EAAA,CACA,IAAAtpB,GAAA,GAAAupB,EAAAvpB,EAAA,IAAAupB,EAAAvpB,GAAAupB,EAAAvpB,EAAA,IAAAA,GAAA,GAAAupB,EAAAvpB,EAAA,IAAAupB,EAAAvpB,GAAAupB,EAAAvpB,EAAA,GACAupB,EAAAvpB,EAAA,GAAAupB,EAAAvpB,EAAA,IACAA,QAEiB,IAAAupB,EAAAvpB,GAAAupB,EAAAvpB,EAAA,GACjB,KAEAypB,GAAAzpB,IAGA,QAAA0pB,KACA,KAAAJ,EAAA,IACA,GAAAtpB,GAAAspB,EAAA,CACAtpB,GAAA,GAAAupB,EAAAvpB,EAAA,GAAAupB,EAAAvpB,EAAA,IACAA,IAEAypB,EAAAzpB,IAGA,QAAAypB,GAAAn/C,GACA,GAAAq/C,GAAAN,EAAA/+C,GACAs/C,EAAAL,EAAAj/C,GACAu/C,EAAAR,EAAA/+C,EAAA,GACA0mB,EAAAu4B,EAAAj/C,EAAA,EACAi/C,GAAAj/C,GAAAs/C,EAAA54B,EACA1mB,IAAAg/C,EAAA,IACAD,EAAA/+C,EAAA,GAAA++C,EAAA/+C,EAAA,GACAi/C,EAAAj/C,EAAA,GAAAi/C,EAAAj/C,EAAA,IAEAg/C,GACA,IAAAtd,GAAAgd,EAAAx2B,EAAAq3B,GAAAr3B,EAAAm3B,EAAAC,EAAA,EAAArV,EACAoV,IAAA3d,EACA4d,GAAA5d,EACA,IAAA4d,IAGA54B,EAAA23B,EAAAn2B,EAAAm3B,EAAAC,EAAA,GAAAp3B,EAAAq3B,EAAA74B,IAAA,EAAAujB,GACA,IAAAvjB,IAGA44B,GAAA54B,EACA84B,EAAAH,EAAAC,EAAAC,EAAA74B,GAEA+4B,EAAAJ,EAAAC,EAAAC,EAAA74B,KAGA,QAAA84B,GAAAH,EAAAC,EAAAC,EAAA74B,GACA,GAAA1mB,GAAA,CACA,KAAAA,EAAA,EAAuBA,EAAAs/C,EAAat/C,IACpCy+C,EAAAz+C,GAAAkoB,EAAAm3B,EAAAr/C,EAEA,IAAA0/C,GAAA,EACAC,EAAAJ,EACAK,EAAAP,CAEA,IADAn3B,EAAA03B,KAAA13B,EAAAy3B,KACA,MAAAj5B,EAAA,CAMA,OAAA44B,EAAA,CACA,IAAAt/C,EAAA,EAA2BA,EAAA0mB,EAAa1mB,IACxCkoB,EAAA03B,EAAA5/C,GAAAkoB,EAAAy3B,EAAA3/C,EAGA,aADAkoB,EAAA03B,EAAAl5B,GAAA+3B,EAAAiB,IAKA,IAFA,GACAG,GAAAC,EAAAC,EADAC,EAAAC,IAEA,CACAJ,EAAA,EACAC,EAAA,EACAC,GAAA,CACA,GACA,IAAA9V,EAAA/hB,EAAAy3B,GAAAlB,EAAAiB,IAAA,GAIA,GAHAx3B,EAAA03B,KAAA13B,EAAAy3B,KACAG,IACAD,EAAA,EACA,MAAAn5B,EAAA,CACAq5B,GAAA,CACA,YAMA,IAHA73B,EAAA03B,KAAAnB,EAAAiB,KACAG,IACAC,EAAA,EACA,MAAAR,EAAA,CACAS,GAAA,CACA,cAGiBF,EAAAC,GAAAE,EACjB,IAAAD,EACA,KAEA,IAEA,GADAF,EAAAnB,EAAAx2B,EAAAy3B,GAAAlB,EAAAiB,EAAAJ,EAAA,EAAArV,GACA,IAAA4V,EAAA,CACA,IAAA7/C,EAAA,EAAmCA,EAAA6/C,EAAY7/C,IAC/CkoB,EAAA03B,EAAA5/C,GAAAy+C,EAAAiB,EAAA1/C,EAKA,IAHA4/C,GAAAC,EACAH,GAAAG,EACAP,GAAAO,EACAP,GAAA,GACAS,GAAA,CACA,QAIA,GADA73B,EAAA03B,KAAA13B,EAAAy3B,KACA,MAAAj5B,EAAA,CACAq5B,GAAA,CACA,OAGA,GADAD,EAAAzB,EAAAI,EAAAiB,GAAAx3B,EAAAy3B,EAAAj5B,EAAA,EAAAujB,GACA,IAAA6V,EAAA,CACA,IAAA9/C,EAAA,EAAmCA,EAAA8/C,EAAY9/C,IAC/CkoB,EAAA03B,EAAA5/C,GAAAkoB,EAAAy3B,EAAA3/C,EAKA,IAHA4/C,GAAAE,EACAH,GAAAG,EACAp5B,GAAAo5B,EACA,IAAAp5B,EAAA,CACAq5B,GAAA,CACA,QAIA,GADA73B,EAAA03B,KAAAnB,EAAAiB,KACA,MAAAJ,EAAA,CACAS,GAAA,CACA,OAEAC,UACiBH,GAAAK,GAAAJ,GAAAI,EACjB,IAAAH,EACA,KAEAC,GAAA,IACAA,EAAA,GAEAA,GAAA,EAIA,GAFAC,EAAAD,EACAC,EAAA,IAAAA,EAAA,GACA,IAAAX,EAAA,CACA,IAAAt/C,EAAA,EAA2BA,EAAA0mB,EAAa1mB,IACxCkoB,EAAA03B,EAAA5/C,GAAAkoB,EAAAy3B,EAAA3/C,EAEAkoB,GAAA03B,EAAAl5B,GAAA+3B,EAAAiB,OACa,QAAAJ,EACb,SAAAp+C,MAEA,KAAAlB,EAAA,EAA2BA,EAAAs/C,EAAat/C,IACxCkoB,EAAA03B,EAAA5/C,GAAAy+C,EAAAiB,EAAA1/C,QAlGA,KAAAA,EAAA,EAA2BA,EAAAs/C,EAAat/C,IACxCkoB,EAAA03B,EAAA5/C,GAAAy+C,EAAAiB,EAAA1/C,GAqGA,QAAAy/C,GAAAJ,EAAAC,EAAAC,EAAA74B,GACA,GAAA1mB,GAAA,CACA,KAAAA,EAAA,EAAuBA,EAAA0mB,EAAa1mB,IACpCy+C,EAAAz+C,GAAAkoB,EAAAq3B,EAAAv/C,EAEA,IAAA0/C,GAAAL,EAAAC,EAAA,EACAK,EAAAj5B,EAAA,EACAk5B,EAAAL,EAAA74B,EAAA,EACAy5B,EAAA,EACAC,EAAA,CAEA,IADAl4B,EAAA03B,KAAA13B,EAAAw3B,KACA,MAAAJ,EAAA,CAOA,OAAA54B,EAAA,CAKA,IAJAk5B,GAAAN,EACAI,GAAAJ,EACAc,EAAAR,EAAA,EACAO,EAAAT,EAAA,EACA1/C,EAAAs/C,EAAA,EAAqCt/C,GAAA,EAAQA,IAC7CkoB,EAAAk4B,EAAApgD,GAAAkoB,EAAAi4B,EAAAngD,EAGA,aADAkoB,EAAA03B,GAAAnB,EAAAkB,IAIA,IADA,GAAAK,GAAAC,IACA,CACA,GAAAJ,GAAA,EACAC,EAAA,EACAC,GAAA,CACA,GACA,IAAA9V,EAAAwU,EAAAkB,GAAAz3B,EAAAw3B,IAAA,GAIA,GAHAx3B,EAAA03B,KAAA13B,EAAAw3B,KACAG,IACAC,EAAA,EACA,MAAAR,EAAA,CACAS,GAAA,CACA,YAMA,IAHA73B,EAAA03B,KAAAnB,EAAAkB,KACAG,IACAD,EAAA,EACA,MAAAn5B,EAAA,CACAq5B,GAAA,CACA,cAGiBF,EAAAC,GAAAE,EACjB,IAAAD,EACA,KAEA,IAEA,GADAF,EAAAP,EAAAZ,EAAAD,EAAAkB,GAAAz3B,EAAAm3B,EAAAC,IAAA,EAAArV,GACA,IAAA4V,EAAA,CAMA,IALAD,GAAAC,EACAH,GAAAG,EACAP,GAAAO,EACAO,EAAAR,EAAA,EACAO,EAAAT,EAAA,EACA1/C,EAAA6/C,EAAA,EAA4C7/C,GAAA,EAAQA,IACpDkoB,EAAAk4B,EAAApgD,GAAAkoB,EAAAi4B,EAAAngD,EAEA,QAAAs/C,EAAA,CACAS,GAAA,CACA,QAIA,GADA73B,EAAA03B,KAAAnB,EAAAkB,KACA,MAAAj5B,EAAA,CACAq5B,GAAA,CACA,OAGA,GADAD,EAAAp5B,EAAA23B,EAAAn2B,EAAAw3B,GAAAjB,EAAA,EAAA/3B,IAAA,EAAAujB,GACA,IAAA6V,EAAA,CAMA,IALAF,GAAAE,EACAH,GAAAG,EACAp5B,GAAAo5B,EACAM,EAAAR,EAAA,EACAO,EAAAR,EAAA,EACA3/C,EAAA,EAAmCA,EAAA8/C,EAAY9/C,IAC/CkoB,EAAAk4B,EAAApgD,GAAAy+C,EAAA0B,EAAAngD,EAEA,IAAA0mB,GAAA,GACAq5B,GAAA,CACA,QAIA,GADA73B,EAAA03B,KAAA13B,EAAAw3B,KACA,MAAAJ,EAAA,CACAS,GAAA,CACA,OAEAC,UACiBH,GAAAK,GAAAJ,GAAAI,EACjB,IAAAH,EACA,KAEAC,GAAA,IACAA,EAAA,GAEAA,GAAA,EAMA,GAJAC,EAAAD,EACAC,EAAA,IACAA,EAAA,GAEA,IAAAv5B,EAAA,CAKA,IAJAk5B,GAAAN,EACAI,GAAAJ,EACAc,EAAAR,EAAA,EACAO,EAAAT,EAAA,EACA1/C,EAAAs/C,EAAA,EAAqCt/C,GAAA,EAAQA,IAC7CkoB,EAAAk4B,EAAApgD,GAAAkoB,EAAAi4B,EAAAngD,EAEAkoB,GAAA03B,GAAAnB,EAAAkB,OACa,QAAAj5B,EACb,SAAAxlB,MAGA,KADAi/C,EAAAP,GAAAl5B,EAAA,GACA1mB,EAAA,EAA2BA,EAAA0mB,EAAa1mB,IACxCkoB,EAAAi4B,EAAAngD,GAAAy+C,EAAAz+C,QAhHA,KADAmgD,EAAAP,GAAAl5B,EAAA,GACA1mB,EAAA,EAA2BA,EAAA0mB,EAAa1mB,IACxCkoB,EAAAi4B,EAAAngD,GAAAy+C,EAAAz+C,GAnMA,GAIA++C,GACAE,EALAgB,EAAAC,EACAvgD,EAAA,EACA0gD,EAAAC,EACAC,EAAA,EAGAvB,EAAA,CACAr/C,GAAAuoB,EAAAvoB,OACAA,EAAA,EAAA2gD,IACAD,EAAA1gD,IAAA,EAEA,IAAA8+C,KACA8B,GAAA5gD,EAAA,MAAAA,EAAA,QAAAA,EAAA,aACAo/C,KACAE,KAwSA3jD,KAAA4jD,YACA5jD,KAAA8jD,iBACA9jD,KAAAsjD,UAEA,QAAApf,GAAAtX,EAAA+hB,EAAAhiC,EAAAC,GACAD,IACAA,EAAA,GAEAC,IACAA,EAAAggB,EAAAvoB,OAEA,IAAA6gD,GAAAt4C,EAAAD,CACA,MAAAu4C,EAAA,IAGA,GAAAvB,GAAA,CACA,IAAAuB,EAAA1C,EAGA,MAFAmB,GAAAlB,EAAA71B,EAAAjgB,EAAAC,EAAA+hC,OACAkU,GAAAj2B,EAAAjgB,EAAAC,EAAAD,EAAAg3C,EAAAhV,EAGA,IAAAwW,GAAA,GAAA9B,GAAAz2B,EAAA+hB,GACAyW,EAAA7C,EAAA2C,EACA,IAEA,GADAvB,EAAAlB,EAAA71B,EAAAjgB,EAAAC,EAAA+hC,GACAgV,EAAAyB,EAAA,CACA,GAAAC,GAAAH,CACAG,GAAAD,IACAC,EAAAD,GAEAvC,EAAAj2B,EAAAjgB,IAAA04C,EAAA14C,EAAAg3C,EAAAhV,GACAgV,EAAA0B,EAEAF,EAAA7B,QAAA32C,EAAAg3C,GACAwB,EAAAvB,YACAsB,GAAAvB,EACAh3C,GAAAg3C,QACS,IAAAuB,EACTC,GAAArB,kBA9fA,GAAAtB,GAAA,GACAoC,EAAA,EACAI,EAAA,GA8fA,OAAA9gB,KAEArgC,EAAA,6EAAAD,GACA,GAAA0hD,GAAA1hD,EAAA,2BACA,iBAAA4C,GACA,QAAA++C,GAAA7+C,GACA,GAAA8+C,IAAA9+C,EAAAspC,uBAAA,0BAAA9rC,MAAA,KACArF,EAAA6H,EAAAC,UACAuB,EAAAxB,EAAAgC,IAAA88C,IAAA9+C,EAAAipB,oBAAAjpB,EAAAgC,IAAA,QAGA7J,GAAA+H,UAAA,QAAAsB,GAEA1B,EAAA6oB,iBAAA3oB,KACA,kBAAAwB,gBAAAo9C,IACAzmD,EAAAqQ,KAAA,SAAAR,GACA7P,EAAA6wB,cAAAhhB,EAAA,QAAAxG,EAAAxB,EAAAmX,cAAAnP,OAIA7P,EAAAqQ,KAAA,SAAAR,GACA,GAAAgX,GAAA7mB,EAAA8mB,aAAAjX,GACAxG,EAAAwd,EAAAhd,IAAA88C,GAAA,EACA,OAAAt9C,GACArJ,EAAA6wB,cAAAhhB,EAAA,QAAAxG,MAKA1B,EAAAomC,cAAA2Y,MAGA1hD,EAAA,sGAAAD,GAGA,QAAA8E,GAAA45B,EAAA7E,GACAA,IAAAv5B,MAAA,IAEA,QADA7F,GAAAikC,EACA59B,EAAA,EAAuBA,EAAA+4B,EAAAp5B,SACvBhG,OAAAo/B,EAAA/4B,IACA,MAAArG,GAFwCqG,KAMxC,MAAArG,GAEA,QAAAonD,GAAAnjB,EAAA7E,EAAAxwB,EAAAif,GACAuR,IAAAv5B,MAAA,IAGA,QADAib,GADA9gB,EAAAikC,EAEA59B,EAAA,EAAuBA,EAAA+4B,EAAAp5B,OAAA,EAAqBK,IAC5Cya,EAAAse,EAAA/4B,GACA,MAAArG,EAAA8gB,KACA9gB,EAAA8gB,OAEA9gB,IAAA8gB,IAEA+M,GAAA,MAAA7tB,EAAAo/B,EAAA/4B,OACArG,EAAAo/B,EAAA/4B,IAAAuI,GAGA,QAAAy4C,GAAArkD,GACA6N,EAAAy2C,EAAA,SAAA14B,GACAA,EAAA,IAAA5rB,MAAA4rB,EAAA,IAAA5rB,MACAA,EAAA4rB,EAAA,IAAA5rB,EAAA4rB,EAAA,OA/BA,GAAAjnB,GAAApC,EAAA,qBACAgiD,EAAAhiD,EAAA,wBAkCA+hD,IAEA,IACA,SAGA,IACA,QAGA,KACA,UAGA,KACA,WAGAE,GACA,OACA,MACA,WACA,SACA,UACA,QACA,YACA,WACA,YAEAC,GACA,MACA,UACA,cACA,QACA,gBACA,SACA,QACA,QACA,QACA,UACA,OACA,MACA,WACA,MACA,QACA,SACA,UACA,WAEA52C,EAAAlJ,EAAAkJ,IACA,iBAAA7N,GACA6N,EAAA7N,EAAAc,OAAA,SAAA4jD,GACA,GAAA//C,EAAAqW,SAAA0pC,GAAA,CAGA,GAAAv6B,GAAAu6B,EAAAzkD,IAOA,IANAskD,EAAAG,GACA,QAAAv6B,GAAA,UAAAA,GACA,MAAAu6B,EAAAC,YACAD,EAAAj9B,UAAAi9B,EAAAC,WAGA,UAAAx6B,EAAA,CACA,GAAAy6B,GAAAv9C,EAAAq9C,EAAA,gBACA,OAAAE,GAAAR,EAAAM,EAAA,yBAAAE,GAEA,OAAAvhD,GAAA,EAA2BA,EAAAohD,EAAAzhD,OAAgCK,IAC3D,GAAAohD,EAAAphD,KAAAqhD,EAAAzkD,KAAA,CACAokD,EAAAK,EACA,WAKA1kD,EAAA6kD,YACA7kD,EAAA8kD,UAAA9kD,EAAA6kD,WAEAh3C,EAAA22C,EAAA,SAAAO,GACA,GAAAtjD,GAAAzB,EAAA+kD,EACAtjD,KACAkD,EAAAgZ,QAAAlc,KACAA,OAEAoM,EAAApM,EAAA,SAAAzB,GACAqkD,EAAArkD,WAMAwC,EAAA,qFAAAD,GACA,GAAAiD,GAAAjD,EAAA,mBACAoC,EAAApC,EAAA,qBACAulB,EAAA1nB,KAAA0nB,EASA,iBAAA5gB,EAAAyH,GACAA,QACAhK,EAAA0F,SAAAsE,GACAjO,KAAA,UACAmG,MAAA,UACAm+C,UAAA,OACAC,UAAA,2BACAn/C,OAAA,GAEA,IAAAo/C,GAAA,GAAA1/C,GAAAuE,MACAnC,OAAwBG,KAAA4G,EAAAs2C,WACxBn/C,OAAA6I,EAAA7I,OACAC,EAAA,MAEAo/C,EAAA,GAAA3/C,GAAAk2B,KACA1xB,OACAkY,YAAA4F,EAAA,EACA3F,UAAA2F,EAAA,KACA3D,EAAA,IAEAvc,OACAme,OAAApX,EAAA9H,MACAu+C,QAAA,QACAvwB,UAAA,GAEA/uB,OAAA6I,EAAA7I,OACAC,EAAA,QAEAs/C,EAAA,GAAA7/C,GAAAuE,MACAnC,OACAG,KAAA,OACArH,KAAAiO,EAAAjO,KACAu1B,aAAA,QACA0H,aAAA,GACAC,SAAAjvB,EAAAq2C,WAEAl/C,OAAA6I,EAAA7I,OACAC,EAAA,OAEAo/C,GAAAG,cAAA,GAAA3iC,KAAA,KAA2CR,SAAA,EAAA2F,EAAA,IAAuB/G,MAAA,iBAClEokC,EAAAG,cAAA,GAAA3iC,KAAA,KAA2CT,WAAA,EAAA4F,EAAA,IAAyBy9B,MAAA,KAAAxkC,MAAA,gBACpE,IAAA5Z,GAAA,GAAA3B,GAAA0d,KA2BA,OA1BA/b,GAAA2B,IAAAq8C,GACAh+C,EAAA2B,IAAAu8C,GACAl+C,EAAA2B,IAAAo8C,GAEA/9C,EAAA8I,OAAA,WACA,GAAAsX,GAAArgB,EAAAmC,WAAA,EACAme,EAAAtgB,EAAAoC,YAAA,CACA67C,GAAA1gC,UACA8C,KACAC,MAEA,IAAArD,GAAAghC,EAAAn7C,MAAAma,CACAkhC,GAAA5gC,UACAlb,EAAAge,EAAApD,EACA7b,EAAAkf,EAAArD,EACAjb,MAAA,EAAAib,EACA5b,OAAA,EAAA4b,IAEA+gC,EAAAzgC,UACAlb,EAAA,EACAjB,EAAA,EACAY,MAAAhC,EAAAmC,WACAd,OAAArB,EAAAoC,eAGAnC,EAAA8I,SACA9I,KAGA3E,EAAA,oCACA,GAAAgjD,GAAA,mBAAAC,cAAA3hD,MAAA2hD,aAKAjmC,GACAxR,OAAA,WACA,GAAAmpC,GAAA,GAAAqO,GAAA,EAEA,OADAhmC,GAAAwe,SAAAmZ,GACAA,GAEAnZ,SAAA,SAAAmZ,GAOA,MANAA,GAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,GAEA1V,KAAA,SAAA0V,EAAAxa,GAOA,MANAwa,GAAA,GAAAxa,EAAA,GACAwa,EAAA,GAAAxa,EAAA,GACAwa,EAAA,GAAAxa,EAAA,GACAwa,EAAA,GAAAxa,EAAA,GACAwa,EAAA,GAAAxa,EAAA,GACAwa,EAAA,GAAAxa,EAAA,GACAwa,GAEAlZ,IAAA,SAAAkZ,EAAA/B,EAAAC,GAIA,GAAAqQ,GAAAtQ,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GACAsQ,EAAAvQ,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GACAuQ,EAAAxQ,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GACAwQ,EAAAzQ,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GACAyQ,EAAA1Q,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,GACA2Q,EAAA3Q,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,EAOA,OANA+B,GAAA,GAAAuO,EACAvO,EAAA,GAAAwO,EACAxO,EAAA,GAAAyO,EACAzO,EAAA,GAAA0O,EACA1O,EAAA,GAAA2O,EACA3O,EAAA,GAAA4O,EACA5O,GAEA6O,UAAA,SAAA7O,EAAA9rC,EAAA46C,GAOA,MANA9O,GAAA,GAAA9rC,EAAA,GACA8rC,EAAA,GAAA9rC,EAAA,GACA8rC,EAAA,GAAA9rC,EAAA,GACA8rC,EAAA,GAAA9rC,EAAA,GACA8rC,EAAA,GAAA9rC,EAAA,GAAA46C,EAAA,GACA9O,EAAA,GAAA9rC,EAAA,GAAA46C,EAAA,GACA9O,GAEArtB,OAAA,SAAAqtB,EAAA9rC,EAAA66C,GACA,GAAAC,GAAA96C,EAAA,GACA+6C,EAAA/6C,EAAA,GACAg7C,EAAAh7C,EAAA,GACAi7C,EAAAj7C,EAAA,GACAk7C,EAAAl7C,EAAA,GACAm7C,EAAAn7C,EAAA,GACAo7C,EAAArmD,KAAAmiB,IAAA2jC,GACAQ,EAAAtmD,KAAAiiB,IAAA6jC,EAOA,OANA/O,GAAA,GAAAgP,EAAAO,EAAAJ,EAAAG,EACAtP,EAAA,IAAAgP,EAAAM,EAAAH,EAAAI,EACAvP,EAAA,GAAAiP,EAAAM,EAAAH,EAAAE,EACAtP,EAAA,IAAAiP,EAAAK,EAAAC,EAAAH,EACApP,EAAA,GAAAuP,EAAAL,EAAAI,EAAAD,EACArP,EAAA,GAAAuP,EAAAF,EAAAC,EAAAJ,EACAlP,GAEAt2B,MAAA,SAAAs2B,EAAA9rC,EAAA46C,GACA,GAAAU,GAAAV,EAAA,GACAW,EAAAX,EAAA,EAOA,OANA9O,GAAA,GAAA9rC,EAAA,GAAAs7C,EACAxP,EAAA,GAAA9rC,EAAA,GAAAu7C,EACAzP,EAAA,GAAA9rC,EAAA,GAAAs7C,EACAxP,EAAA,GAAA9rC,EAAA,GAAAu7C,EACAzP,EAAA,GAAA9rC,EAAA,GAAAs7C,EACAxP,EAAA,GAAA9rC,EAAA,GAAAu7C,EACAzP,GAEA7Y,OAAA,SAAA6Y,EAAA9rC,GACA,GAAA86C,GAAA96C,EAAA,GACA+6C,EAAA/6C,EAAA,GACAg7C,EAAAh7C,EAAA,GACAi7C,EAAAj7C,EAAA,GACAk7C,EAAAl7C,EAAA,GACAm7C,EAAAn7C,EAAA,GACAw7C,EAAAV,EAAAI,EAAAD,EAAAF,CACA,OAAAS,IAGAA,EAAA,EAAAA,EACA1P,EAAA,GAAAoP,EAAAM,EACA1P,EAAA,IAAAmP,EAAAO,EACA1P,EAAA,IAAAiP,EAAAS,EACA1P,EAAA,GAAAgP,EAAAU,EACA1P,EAAA,IAAAiP,EAAAI,EAAAD,EAAAF,GAAAQ,EACA1P,EAAA,IAAAmP,EAAAD,EAAAF,EAAAK,GAAAK,EACA1P,GATA,MAYA,OAAA33B,KAEAhd,EAAA,+JAAAD,GAUA,QAAA8c,GAAArf,EAAA+oC,EAAA5jC,GAKAxG,KAAAoqC,cAKApqC,KAAAwG,UAKAxG,KAAAqB,SAxBA,GAAA2E,GAAApC,EAAA,qBACA+tC,EAAA/tC,EAAA,gBAiCA8c,GAAA1U,WACAkhB,YAAAxM,EACA3f,KAAA,KACA+oB,YAAA,SAAAzoB,GACA2E,EAAAimB,MAAAjsB,KAAAqB,UAAA,IAEAqH,IAAA,SAAA+0B,EAAA0qB,GACA,IAAA1qB,EACA,MAAAz9B,MAAAqB,MAEA,iBAAAo8B,KACAA,IAAAv5B,MAAA,KAIA,QAFA7F,GAAA2B,KAAAqB,OACA+oC,EAAApqC,KAAAoqC,YACA1lC,EAAA,EAA2BA,EAAA+4B,EAAAp5B,UAE3Bo5B,EAAA/4B,KAIArG,KAAA,gBAAAA,KAAAo/B,EAAA/4B,IAAA,KACA,MAAArG,IAP4CqG,KAc5C,MAHA,OAAArG,GAAA+rC,IAAA+d,IACA9pD,EAAA+rC,EAAA1hC,IAAA+0B,IAEAp/B,GAEA+9B,WAAA,SAAAjd,EAAAgpC,GACA,GAAA9mD,GAAArB,KAAAqB,OACA4L,EAAA,MAAA5L,MAAA8d,GACAirB,EAAApqC,KAAAoqC,WAIA,OAHA,OAAAn9B,GAAAm9B,IAAA+d,IACAl7C,EAAAm9B,EAAAhO,WAAAjd,IAEAlS,GAEArE,SAAA,SAAA60B,EAAA2M,GACA,GAAA/rC,GAAA2B,KAAA0I,IAAA+0B,GAAA,GACA2qB,EAAApoD,KAAAoqC,YACA92B,EAAA,GAAAoN,GAAAriB,EAAA+rC,GAAAge,KAAAx/C,SAAA60B,GAAAz9B,KAAAwG,QACA,OAAA8M,IAEA+0C,QAAA,WACA,aAAAroD,KAAAqB,QAEA6Z,YAAA,aAEAvK,MAAA,WACA,GAAAkjC,GAAA7zC,KAAAktB,WACA,WAAA2mB,GAAA7tC,EAAA2K,MAAA3Q,KAAAqB,UAEAinD,YAAA,SAAAC,GACA5W,EAAA2W,YAAAtoD,KAAAuoD,KAIA5W,EAAAgB,kBAAAjyB,EACA,IAAApI,GAAAtS,EAAAsS,KAKA,OAJAA,GAAAoI,EAAA9c,EAAA,sBACA0U,EAAAoI,EAAA9c,EAAA,sBACA0U,EAAAoI,EAAA9c,EAAA,sBACA0U,EAAAoI,EAAA9c,EAAA,sBACA8c,IAEA7c,EAAA,6GAAAD,GAygBA,QAAA4kD,GAAAt+B,GAIA,MAHAlkB,GAAAgZ,QAAAkL,KACAA,OAEAA,EA8GA,QAAAu+B,GAAAC,EAAAC,GACA,GAAAC,GAAAF,EAAAx+B,WACA1Q,EAAA,GAAAiH,GAAAza,EAAA+W,IAAA6rC,EAAAF,EAAA1X,iBAAA0X,KAAAvjC,UAEA0jC,GAAArvC,EAAAkvC,EAIA,QAHAtzC,GAAAoE,EAAAsvC,YACAC,EAAAL,EAAAI,SAEApkD,EAAA,EAAuBA,EAAAkkD,EAAAvkD,OAA0BK,IAAA,CACjD,GAAA2tB,GAAAu2B,EAAAlkD,GACAskD,EAAAD,EAAA12B,EACArsB,GAAAhC,QAAA2kD,EAAAt2B,IAAA,EACAjd,EAAAid,GAAA,GAAA22B,GAAA97B,YAAA67B,EAAA12B,GAAAhuB,QAGA+Q,EAAAid,GAAA02B,EAAA12B,GAGA,MAAA7Y,GA5oBA,GAAAyvC,GAAA,YACAC,EAAA,mBAAAj/C,QAAA1G,EAAA0G,OACAk/C,QAAAD,GAAAC,eAAAF,EAAA9jD,MAAA+jD,EAAAC,aACAC,QAAAF,GAAAE,aAAAH,EAAA9jD,MAAA+jD,EAAAE,WACAC,GACAC,QAAAH,EACAI,MAAAH,EACAI,QAAArkD,MACAwb,OAAAxb,MACAskD,KAAAtkD,OAEAub,EAAA9c,EAAA,kBACA8lD,EAAA9lD,EAAA,gBACAoC,EAAApC,EAAA,qBACAwlB,EAAAxlB,EAAA,iBACAyY,EAAArW,EAAAqW,SACAstC,GACA,YACA,gBACA,YACA,UACA,YAEAd,EAAA,SAAAn8C,EAAAwD;AACAlK,EAAAkJ,KAAAy6C,EAAA/kD,OAAAsL,EAAA05C,sBAAA,SAAAC,GACA35C,EAAA8b,eAAA69B,KACAn9C,EAAAm9C,GAAA35C,EAAA25C,MAGAn9C,EAAAk9C,iBAAA15C,EAAA05C,kBAUAnpC,EAAA,SAAAyJ,EAAA/E,GACA+E,MACA,IACA,IAIA,QAFA4/B,MACAC,KACArlD,EAAA,EAAuBA,EAAAwlB,EAAA7lB,OAAuBK,IAAA,CAC9C,GAAAslD,GACAC,IACA,iBAAA//B,GAAAxlB,IACAslD,EAAA9/B,EAAAxlB,GACAulD,GACA5nD,KAAA2nD,EACAE,WAAA,EACA5oD,KAAA,YAGA2oD,EAAA//B,EAAAxlB,GACAslD,EAAAC,EAAA5nD,KACA4nD,EAAA3oD,KAAA2oD,EAAA3oD,MAAA,UAEAyoD,EAAAvoD,KAAAwoD,GACAF,EAAAE,GAAAC,EAMAjqD,KAAAkqB,WAAA6/B,EAKA/pD,KAAAmqD,gBAAAL,EAIA9pD,KAAAmlB,YAIAnlB,KAAA8d,SAOA9d,KAAA0vC,WAMA1vC,KAAA8oD,YAIA9oD,KAAAoqD,aAIApqD,KAAAqqD,WAMArqD,KAAAsqD,iBAIAtqD,KAAA4U,UAAA,KAMA5U,KAAAuqD,WAMAvqD,KAAAwqD,WAMAxqD,KAAAyqD,gBAMAzqD,KAAA0qD,gBAMA1qD,KAAA2qD,eAKA3qD,KAAA4qD,SAKA5qD,KAAA4N,SAEAi9C,EAAApqC,EAAAzU,SACA6+C,GAAAvpD,KAAA,OAKAupD,EAAAC,eAAA,EAQAD,EAAAE,aAAA,SAAA14B,GAIA,MAHA3S,OAAA2S,KACAA,EAAAryB,KAAAkqB,WAAAmI,OAEAA,GAQAw4B,EAAA7Z,iBAAA,SAAA3e,GACA,MAAArsB,GAAA2K,MAAA3Q,KAAAmqD,gBAAAnqD,KAAA+qD,aAAA14B,MAQAw4B,EAAA1gC,SAAA,SAAAtrB,EAAAmsD,EAAAC,GAGA,GAFApsD,SAEAmH,EAAAgZ,QAAAngB,GACA,SAAA+G,OAAA,gBAGA5F,MAAA4qD,SAAA/rD,CAEA,IAAAuW,GAAApV,KAAA8oD,YACApZ,EAAA1vC,KAAA0vC,WACAxlB,EAAAlqB,KAAAkqB,WACA6F,EAAAlxB,EAAAwF,OACA6mD,EAAAlrD,KAAAmqD,gBACAgB,KACAC,IACAJ,QAEA,QAAAtmD,GAAA,EAAuBA,EAAAwlB,EAAA7lB,OAAuBK,IAAA,CAC9C,GAAAqsC,GAAAma,EAAAhhC,EAAAxlB,IACA2mD,EAAAhC,EAAAtY,EAAAzvC,KACA8T,GAAA8U,EAAAxlB,IAAA,GAAA2mD,GAAAt7B,GAEA,GAAApvB,GAAAX,IACAirD,KACAtqD,EAAAmqD,eAAA,GAGAG,KAAA,SAAAK,EAAAC,EAAA9tC,EAAA+tC,GACA,GAAA9sD,GAAA0qB,EAAAqiC,iBAAAH,EAKA,OAHAliC,GAAAsiC,iBAAAJ,KACA3qD,EAAAmqD,eAAA,GAEA1hC,EAAAuiC,gBAAAjtD,YAAAyG,OAAAzG,EAAA8sD,GAAA9sD,EAAAwsD,EAAAK,IAEA,QAAA78C,GAAA,EAAyBA,EAAA7P,EAAAwF,OAAmBqK,IAAA,CAS5C,OARA48C,GAAAzsD,EAAA6P,GAQA03B,EAAA,EAA2BA,EAAAlc,EAAA7lB,OAAuB+hC,IAAA,CAClD,GAAA/T,GAAAnI,EAAAkc,GACAwlB,EAAAx2C,EAAAid,EAEAu5B,GAAAl9C,GAAAu8C,EAAAK,EAAAj5B,EAAA3jB,EAAA03B,GAEAsJ,EAAAluC,KAAAkN,GAGA,OAAAhK,GAAA,EAAuBA,EAAA7F,EAAAwF,OAAiBK,IAAA,CACxCsmD,EAAAtmD,IACA7F,EAAA6F,IAAA,MAAA7F,EAAA6F,GAAArC,OACA2oD,EAAAtmD,GAAA7F,EAAA6F,GAAArC,KAGA,IAAAA,GAAA2oD,EAAAtmD,IAAA,GAEAvE,EAAAtB,EAAA6F,IAAA7F,EAAA6F,GAAAvE,IACAA,GAAAkC,IAEA+oD,EAAA/oD,GAAA+oD,EAAA/oD,IAAA,EACAlC,EAAAkC,EACA+oD,EAAA/oD,GAAA,IACAlC,GAAA,SAAAirD,EAAA/oD,IAEA+oD,EAAA/oD,MAEAlC,IAAAgrD,EAAAzmD,GAAAvE,GAEAH,KAAAoqD,UAAAY,EACAhrD,KAAAqqD,QAAAc,GAKAN,EAAAriC,MAAA,WACA,MAAAxoB,MAAA0vC,QAAArrC,QASAwmD,EAAAniD,IAAA,SAAA2pB,EAAA3jB,EAAAgG,GACA,GAAAU,GAAApV,KAAA8oD,SACArrC,EAAAzd,KAAA0vC,QAAAhhC,EAEA,UAAA+O,EACA,MAAAqY,IAEA,IAAAp3B,GAAA0W,EAAAid,IAAAjd,EAAAid,GAAA5U,EAEA,IAAA/I,EAAA,CACA,GAAAu1C,GAAAjqD,KAAAmqD,gBAAA93B,EACA,IAAA43B,KAAAC,UAEA,IADA,GAAAt1C,GAAA5U,KAAA4U,UACAA,GAAA,CAEA,GAAAi3C,GAAAj3C,EAAAlM,IAAA2pB,EAAA3jB,IAEAhQ,GAAA,GAAAmtD,EAAA,GAAAntD,GAAA,GAAAmtD,EAAA,KACAntD,GAAAmtD,GAEAj3C,eAIA,MAAAlW,IASAmsD,EAAAiB,UAAA,SAAA5hC,EAAAxb,EAAAgG,GACA,GAAAyZ,KACAnoB,GAAAgZ,QAAAkL,KACAxV,EAAAhG,EACAA,EAAAwb,EACAA,EAAAlqB,KAAAkqB,WAEA,QAAAxlB,GAAA,EAAAonB,EAAA5B,EAAA7lB,OAAgDK,EAAAonB,EAASpnB,IACzDypB,EAAA3sB,KAAAxB,KAAA0I,IAAAwhB,EAAAxlB,GAAAgK,EAAAgG,GAEA,OAAAyZ,IAQA08B,EAAA9zB,SAAA,SAAAroB,GAGA,OAFAwb,GAAAlqB,KAAAkqB,WACA4/B,EAAA9pD,KAAAmqD,gBACAzlD,EAAA,EAAAonB,EAAA5B,EAAA7lB,OAAgDK,EAAAonB,EAASpnB,IACzD,eAAAolD,EAAA5/B,EAAAxlB,IAAApD,MAAAoe,MAAA1f,KAAA0I,IAAAwhB,EAAAxlB,GAAAgK,IACA,QAGA,WAOAm8C,EAAA36B,cAAA,SAAAmC,EAAA3d,GACA2d,EAAAryB,KAAA+qD,aAAA14B,EACA,IAAA05B,GAAA/rD,KAAA8oD,SAAAz2B,GACA0e,EAAA/wC,KAAAgxC,iBAAA3e,EACA3d,GAAAq8B,KAAAmZ,WAAAx1C,CACA,IACAhW,GADAstD,GAAAhsD,KAAA4N,UAAA5N,KAAA4N,aAA2DykB,IAAA3d,EAE3D,IAAAs3C,EACA,MAAAA,EAGA,IAAAD,EAAA,CAIA,OAHArmD,GAAAmI,IACAuM,IAAAvM,KAEAnJ,EAAA,EAAAonB,EAAA9rB,KAAAwoB,QAA+C9jB,EAAAonB,EAASpnB,IACxDhG,EAAAsB,KAAA0I,IAAA2pB,EAAA3tB,EAAAgQ,GAKAhW,EAAAgH,MAAAhH,GACAA,EAAA0b,MAAA1b,EAEA,OAAAsB,MAAA4N,QAAAykB,IAAA3d,IACAhP,EACA0U,GAGA,OACAvM,MACAA,OASAg9C,EAAAxgC,OAAA,SAAAgI,EAAA3d,GACA,GAAAq3C,GAAA/rD,KAAA8oD,SAAAz2B,GACAjI,EAAA,CACA,IAAA2hC,EACA,OAAArnD,GAAA,EAAAonB,EAAA9rB,KAAAwoB,QAA+C9jB,EAAAonB,EAASpnB,IAAA,CACxD,GAAAhG,GAAAsB,KAAA0I,IAAA2pB,EAAA3tB,EAAAgQ,EACAgL,OAAAhhB,KACA0rB,GAAA1rB,GAIA,MAAA0rB,IASAygC,EAAA7mD,QAAA,SAAAquB,EAAA3zB,GACA,GAAA0W,GAAApV,KAAA8oD,SACAiD,EAAA32C,EAAAid,GACAqd,EAAA1vC,KAAA0vC,OACA,IAAAqc,EACA,OAAArnD,GAAA,EAAAonB,EAAA4jB,EAAArrC,OAAiDK,EAAAonB,EAASpnB,IAAA,CAC1D,GAAAunD,GAAAvc,EAAAhrC,EACA,IAAAqnD,EAAAE,KAAAvtD,EACA,MAAAgG,GAIA,UAQAmmD,EAAA7X,YAAA,SAAA3wC,GAGA,OAFAqtC,GAAA1vC,KAAA0vC,QACAsb,EAAAhrD,KAAAoqD,UACA1lD,EAAA,EAAAonB,EAAA4jB,EAAArrC,OAA6CK,EAAAonB,EAASpnB,IAAA,CACtD,GAAAunD,GAAAvc,EAAAhrC,EACA,IAAAsmD,EAAAiB,KAAA5pD,EACA,MAAAqC,GAGA,UAQAmmD,EAAAqB,gBAAA,SAAAD,GAKA,IAHA,GAAAvc,GAAA1vC,KAAA0vC,QACAjoC,EAAA,EACA6S,EAAAo1B,EAAArrC,OAAA,EACAoD,GAAA6S,GAAA,CACA,GAAAzN,IAAApF,EAAA6S,GAAA,GACA,IAAAo1B,EAAA7iC,GAAAo/C,EACAxkD,EAAAoF,EAAA,MACa,MAAA6iC,EAAA7iC,GAAAo/C,GAGb,MAAAp/C,EAFAyN,GAAAzN,EAAA,GAKA,UAUAg+C,EAAAsB,eAAA,SAAA95B,EAAA3zB,EAAAgW,EAAA03C,GACA,GAAAh3C,GAAApV,KAAA8oD,SACAiD,EAAA32C,EAAAid,EACA,OAAA+5B,IACAA,EAAAv+C,IAEA,IAAAw+C,KACA,IAAAN,EAEA,OADAO,GAAAC,OAAAC,UACA9nD,EAAA,EAAAonB,EAAA9rB,KAAAwoB,QAA+C9jB,EAAAonB,EAASpnB,IAAA,CACxD,GAAAsjB,GAAAtpB,EAAAsB,KAAA0I,IAAA2pB,EAAA3tB,EAAAgQ,GACA+3C,EAAAhrD,KAAAihB,IAAAsF,EACAA,IAAAokC,IAAAK,EAAAH,GAAAG,IAAAH,GAAAtkC,EAAA,KACAskC,EAAAG,EACAJ,EAAA3nD,GAIA,MAAA2nD,IAOAxB,EAAAt7B,YAAA,SAAA7gB,GACA,GAAA4gB,GAAAtvB,KAAA0vC,QAAAhhC,EACA,cAAA4gB,QAOAu7B,EAAA6B,eAAA,SAAAh+C,GACA,MAAA1O,MAAA4qD,SAAA5qD,KAAAuvB,YAAA7gB,KAOAm8C,EAAA/nC,QAAA,SAAApU,GACA,MAAA1O,MAAAoqD,UAAApqD,KAAA0vC,QAAAhhC,KAAA,IAOAm8C,EAAAhW,MAAA,SAAAnmC,GACA,MAAA1O,MAAAqqD,QAAArqD,KAAA0vC,QAAAhhC,KAAA1O,KAAAuvB,YAAA7gB,GAAA,IAoBAm8C,EAAA37C,KAAA,SAAAy9C,EAAA5jC,EAAArU,EAAAjF,GACA,kBAAAk9C,KACAl9C,EAAAiF,EACAA,EAAAqU,EACAA,EAAA4jC,EACAA,MAEAA,EAAA3mD,EAAA+W,IAAAyrC,EAAAmE,GAAA3sD,KAAA+qD,aAAA/qD,KACA,IAAAtB,MACAkuD,EAAAD,EAAAtoD,OACAqrC,EAAA1vC,KAAA0vC,OACAjgC,MAAAzP,IACA,QAAA0E,GAAA,EAAuBA,EAAAgrC,EAAArrC,OAAoBK,IAE3C,OAAAkoD,GACA,OACA7jC,EAAA3Z,KAAAK,EAAA/K,EACA,MACA,QACAqkB,EAAA3Z,KAAAK,EAAAzP,KAAA0I,IAAAikD,EAAA,GAAAjoD,EAAAgQ,GAAAhQ,EACA,MACA,QACAqkB,EAAA3Z,KAAAK,EAAAzP,KAAA0I,IAAAikD,EAAA,GAAAjoD,EAAAgQ,GAAA1U,KAAA0I,IAAAikD,EAAA,GAAAjoD,EAAAgQ,GAAAhQ,EACA,MACA,SACA,OAAA0hC,GAAA,EAA+BA,EAAAwmB,EAAaxmB,IAC5C1nC,EAAA0nC,GAAApmC,KAAA0I,IAAAikD,EAAAvmB,GAAA1hC,EAAAgQ,EAGAhW,GAAA0nC,GAAA1hC,EACAqkB,EAAArlB,MAAA+L,EAAA/Q,KAWAmsD,EAAAj6B,WAAA,SAAA1G,EAAAnB,EAAArU,EAAAjF,GACA,kBAAAya,KACAza,EAAAiF,EACAA,EAAAqU,EACAA,EAAAmB,EACAA,MAEAA,EAAAlkB,EAAA+W,IAAAyrC,EAAAt+B,GAAAlqB,KAAA+qD,aAAA/qD,KACA,IAAA6sD,MACAnuD,KACAkuD,EAAA1iC,EAAA7lB,OACAqrC,EAAA1vC,KAAA0vC,OACAjgC,MAAAzP,IACA,QAAA0E,GAAA,EAAuBA,EAAAgrC,EAAArrC,OAAoBK,IAAA,CAC3C,GAAAooD,EAEA,QAAAF,EACAE,EAAA/jC,EAAA3Z,KAAAK,EAAAzP,KAAA0I,IAAAwhB,EAAA,GAAAxlB,EAAAgQ,GAAAhQ,OACa,CACb,OAAA0hC,GAAA,EAA+BA,EAAAwmB,EAAaxmB,IAC5C1nC,EAAA0nC,GAAApmC,KAAA0I,IAAAwhB,EAAAkc,GAAA1hC,EAAAgQ,EAEAhW,GAAA0nC,GAAA1hC,EACAooD,EAAA/jC,EAAArlB,MAAA+L,EAAA/Q,GAEAouD,GACAD,EAAArrD,KAAAkuC,EAAAhrC,IAMA,MAHA1E,MAAA0vC,QAAAmd,EAEA7sD,KAAA4N,WACA5N,MAUA6qD,EAAAkC,SAAA,SAAA7iC,EAAAnB,EAAArU,EAAAjF,GACA,kBAAAya,KACAza,EAAAiF,EACAA,EAAAqU,EACAA,EAAAmB,EACAA,KAEA,IAAA2B,KAIA,OAHA7rB,MAAAkP,KAAAgb,EAAA,WACA2B,EAAArqB,KAAAunB,KAAArlB,MAAA1D,KAAAypB,aACS/U,EAAAjF,GACToc,GA8BAg/B,EAAA9tC,IAAA,SAAAmN,EAAAnB,EAAArU,EAAAjF,GACAya,EAAAlkB,EAAA+W,IAAAyrC,EAAAt+B,GAAAlqB,KAAA+qD,aAAA/qD,KACA,IAAAwZ,GAAAivC,EAAAzoD,KAAAkqB,GAGAwlB,EAAAl2B,EAAAk2B,QAAA1vC,KAAA0vC,QACAt6B,EAAAoE,EAAAsvC,SACAkE,IAoBA,OAnBAhtD,MAAAkP,KAAAgb,EAAA,WACA,GAAAxb,GAAA+a,oBAAAplB,OAAA,GACA4oD,EAAAlkC,KAAArlB,MAAA1D,KAAAypB,UACA,UAAAwjC,EAAA,CAEA,gBAAAA,KACAD,EAAA,GAAAC,EACAA,EAAAD,EAEA,QAAAtoD,GAAA,EAA+BA,EAAAuoD,EAAA5oD,OAAqBK,IAAA,CACpD,GAAA2tB,GAAAnI,EAAAxlB,GACAskD,EAAA5zC,EAAAid,GACA/C,EAAAogB,EAAAhhC,EACAs6C,KACAA,EAAA15B,GAAA29B,EAAAvoD,OAISgQ,EAAAjF,GACT+J,GASAqxC,EAAAqC,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,GAYA,OAXA9zC,GAAAivC,EAAAzoD,MAAAmtD,IACA/3C,EAAApV,KAAA8oD,SACAyE,EAAA/zC,EAAAsvC,SACA0E,EAAAxtD,KAAA0vC,QACAA,EAAAl2B,EAAAk2B,WACA+d,KACAC,KACAC,EAAAlsD,KAAA2K,MAAA,EAAAghD,GACApE,EAAAuE,EAAAJ,GACArhC,EAAA9rB,KAAAwoB,QAEA9jB,EAAA,EAAuBA,EAAA0Q,EAAA+3C,GAAA9oD,OAA+BK,IACtD6oD,EAAAJ,GAAAzoD,GAAA0Q,EAAA+3C,GAAAzoD,EAEA,QAAAA,GAAA,EAAuBA,EAAAonB,EAASpnB,GAAAipD,EAAA,CAEhCA,EAAA7hC,EAAApnB,IACAipD,EAAA7hC,EAAApnB,EACA+oD,EAAAppD,OAAAspD,EAEA,QAAAvnB,GAAA,EAA2BA,EAAAunB,EAAevnB,IAAA,CAC1C,GAAA13B,GAAA8+C,EAAA9oD,EAAA0hC,EACAqnB,GAAArnB,GAAA4iB,EAAAt6C,GACAg/C,EAAAtnB,GAAA13B,EAEA,GAAAhQ,GAAA2uD,EAAAI,GACA/+C,EAAAg/C,EAAAJ,EAAAG,EAAA/uD,IAAA,EAEAsqD,GAAAt6C,GAAAhQ,EACAgxC,EAAAluC,KAAAkN,GAEA,MAAA8K,IAQAqxC,EAAAllC,aAAA,SAAAjX,GACA,GAAAyW,GAAAnlB,KAAAmlB,SAEA,OADAzW,GAAA1O,KAAA0vC,QAAAhhC,GACA,GAAAgS,GAAA1gB,KAAA4qD,SAAAl8C,GAAAyW,OAAA3e,UAOAqkD,EAAA7iC,KAAA,SAAA4lC,GACA,GAAAzC,GAAAnrD,KAAAqqD,QACAwD,EAAAD,KAAAvD,OACA,WAAAX,GAAAkE,IAAAle,WAAA1vC,KAAA0vC,QAAA,SAAAhhC,GACA,MAAAm/C,GAAAn/C,MAAA,IACS,SAAAA,GACT,MAAAy8C,GAAAz8C,MAAA,MAOAm8C,EAAAiD,UAAA,SAAA3uC,GACA,GAAArK,GAAA9U,KAAAuqD,OACA,OAAAz1C,MAAAqK,IAaA0rC,EAAAjkD,UAAA,SAAAuY,EAAAlS,GACA,GAAAoP,EAAA8C,GACA,OAAA9c,KAAA8c,GACAA,EAAA6M,eAAA3pB,IACArC,KAAA4G,UAAAvE,EAAA8c,EAAA9c,QAKArC,MAAAuqD,QAAAvqD,KAAAuqD,YACAvqD,KAAAuqD,QAAAprC,GAAAlS,GAOA49C,EAAA3wB,UAAA,SAAA/a,EAAAlS,GACA,GAAAoP,EAAA8C,GACA,OAAA9c,KAAA8c,GACAA,EAAA6M,eAAA3pB,IACArC,KAAAk6B,UAAA73B,EAAA8c,EAAA9c,QAKArC,MAAAwqD,QAAArrC,GAAAlS,GAOA49C,EAAAl1B,UAAA,SAAAxW,GACA,MAAAnf,MAAAwqD,QAAArrC,IAMA0rC,EAAAznC,cAAA,SAAA1U,GACA,MAAA1O,MAAA0qD,aAAAh8C,IAQAm8C,EAAAr6B,cAAA,SAAA9hB,EAAA5H,EAAAmlB,GACAjsB,KAAA0qD,aAAAh8C,GAAAud,EAAAjmB,EAAA+G,OAAA/M,KAAA0qD,aAAAh8C,OAAmF5H,MAKnF+jD,EAAAkD,iBAAA,WACA/tD,KAAA0qD,aAAArmD,OAAA,GAQAwmD,EAAA7lC,cAAA,SAAAtW,EAAAyQ,EAAAgpC,GACA,GAAA6F,GAAAhuD,KAAAyqD,aAAA/7C,GACAzB,EAAA+gD,KAAA7uC,EACA,cAAAlS,GAAAk7C,EAIAl7C,EAFAjN,KAAA8tD,UAAA3uC,IAiBA0rC,EAAAn7B,cAAA,SAAAhhB,EAAAyQ,EAAAzgB,GACA,GAAAsvD,GAAAhuD,KAAAyqD,aAAA/7C,MAEA,IADA1O,KAAAyqD,aAAA/7C,GAAAs/C,EACA3xC,EAAA8C,GACA,OAAA9c,KAAA8c,GACAA,EAAA6M,eAAA3pB,KACA2rD,EAAA3rD,GAAA8c,EAAA9c,QAKA2rD,GAAA7uC,GAAAzgB,GAKAmsD,EAAAlvC,eAAA,WACA3b,KAAAuqD,WACAvqD,KAAAyqD,gBAEA,IAAAwD,GAAA,SAAA9lC,GACAA,EAAAvK,YAAA5d,KAAA4d,YACAuK,EAAA1K,UAAAzd,KAAAyd,UACA0K,EAAArK,SAAA9d,KAAA8d,SAkFA,OA3EA+sC,GAAAziC,iBAAA,SAAA1Z,EAAA1N,GACA,GAAAmkB,GAAAnlB,KAAAmlB,SACAnkB,KAGAA,EAAAyc,UAAA/O,EACA1N,EAAA8c,SAAA9d,KAAA8d,SACA9c,EAAA4c,YAAAuH,KAAAvH,YACA,UAAA5c,EAAAM,MACAN,EAAAsU,SAAA24C,EAAAjtD,IAGAhB,KAAA2qD,YAAAj8C,GAAA1N,GAMA6pD,EAAA1nC,iBAAA,SAAAzU,GACA,MAAA1O,MAAA2qD,YAAAj8C,IAMAm8C,EAAAtzB,kBAAA,SAAAxO,EAAAtZ,GACAzJ,EAAAkJ,KAAAlP,KAAA2qD,YAAA,SAAA3pD,EAAA0N,GACA1N,GACA+nB,KAAA3Z,KAAAK,EAAAzO,EAAA0N,MAQAm8C,EAAA3a,aAAA,WACA,GAAAge,GAAAloD,EAAA+W,IAAA/c,KAAAkqB,WAAAlqB,KAAAgxC,iBAAAhxC,MACAwZ,EAAA,GAAAiH,GAAAytC,EAAAluD,KAAAmlB,UASA,OAPA3L,GAAAsvC,SAAA9oD,KAAA8oD,SACAD,EAAArvC,EAAAxZ,MAEAwZ,EAAAk2B,QAAA1vC,KAAA0vC,QAAA/qC,QACA3E,KAAA4N,UACA4L,EAAA5L,QAAA5H,EAAA+G,UAA2C/M,KAAA4N,UAE3C4L,GAOAqxC,EAAAsD,WAAA,SAAAh/C,EAAAi/C,GACA,GAAAC,GAAAruD,KAAAmP,EACA,mBAAAk/C,KAGAruD,KAAA4pD,iBAAA5pD,KAAA4pD,qBACA5pD,KAAA4pD,iBAAApoD,KAAA2N,GACAnP,KAAAmP,GAAA,WACA,GAAAk9B,GAAAgiB,EAAA3qD,MAAA1D,KAAAypB,UACA,OAAA2kC,GAAA1qD,MAAA1D,MAAAqsC,GAAAznC,OAAAoB,EAAArB,MAAA8kB,gBAKAohC,EAAAyD,sBACA,eACA,aACA,OAGAzD,EAAA0D,mBAAA,cACA9tC,IAEA5c,EAAA,oCACA,GAAAgjD,GAAA,mBAAAC,cAAA3hD,MAAA2hD,aAQAhmC,GACAzR,OAAA,SAAAzE,EAAAjB,GACA,GAAA6uC,GAAA,GAAAqO,GAAA,EASA,OARA,OAAAj8C,IACAA,EAAA,GAEA,MAAAjB,IACAA,EAAA,GAEA6uC,EAAA,GAAA5tC,EACA4tC,EAAA,GAAA7uC,EACA6uC,GAEA1V,KAAA,SAAA0V,EAAA8O,GAGA,MAFA9O,GAAA,GAAA8O,EAAA,GACA9O,EAAA,GAAA8O,EAAA,GACA9O,GAEA7nC,MAAA,SAAA22C,GACA,GAAA9O,GAAA,GAAAqO,GAAA,EAGA,OAFArO,GAAA,GAAA8O,EAAA,GACA9O,EAAA,GAAA8O,EAAA,GACA9O,GAEAiN,IAAA,SAAAjN,EAAA9rC,EAAAwD,GAGA,MAFAsoC,GAAA,GAAA9rC,EACA8rC,EAAA,GAAAtoC,EACAsoC,GAEAruC,IAAA,SAAAquC,EAAAgW,EAAAC,GAGA,MAFAjW,GAAA,GAAAgW,EAAA,GAAAC,EAAA,GACAjW,EAAA,GAAAgW,EAAA,GAAAC,EAAA,GACAjW,GAEAkW,YAAA,SAAAlW,EAAAgW,EAAAC,EAAA/hD,GAGA,MAFA8rC,GAAA,GAAAgW,EAAA,GAAAC,EAAA,GAAA/hD,EACA8rC,EAAA,GAAAgW,EAAA,GAAAC,EAAA,GAAA/hD,EACA8rC,GAEAxkC,IAAA,SAAAwkC,EAAAgW,EAAAC,GAGA,MAFAjW,GAAA,GAAAgW,EAAA,GAAAC,EAAA,GACAjW,EAAA,GAAAgW,EAAA,GAAAC,EAAA,GACAjW,GAEA1sB,IAAA,SAAAw7B,GACA,MAAA7lD,MAAAktD,KAAA3uD,KAAA4uD,UAAAtH,KAEAsH,UAAA,SAAAtH,GACA,MAAAA,GAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAEAhoB,IAAA,SAAAkZ,EAAAgW,EAAAC,GAGA,MAFAjW,GAAA,GAAAgW,EAAA,GAAAC,EAAA,GACAjW,EAAA,GAAAgW,EAAA,GAAAC,EAAA,GACAjW,GAEAqW,IAAA,SAAArW,EAAAgW,EAAAC,GAGA,MAFAjW,GAAA,GAAAgW,EAAA,GAAAC,EAAA,GACAjW,EAAA,GAAAgW,EAAA,GAAAC,EAAA,GACAjW,GAEAsW,IAAA,SAAAN,EAAAC,GACA,MAAAD,GAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,IAEAvsC,MAAA,SAAAs2B,EAAA8O,EAAA5gB,GAGA,MAFA8R,GAAA,GAAA8O,EAAA,GAAA5gB,EACA8R,EAAA,GAAA8O,EAAA,GAAA5gB,EACA8R,GAEA10C,UAAA,SAAA00C,EAAA8O,GACA,GAAAx5C,GAAAgT,EAAAgL,IAAAw7B,EAQA,OAPA,KAAAx5C,GACA0qC,EAAA,KACAA,EAAA,OAEAA,EAAA,GAAA8O,EAAA,GAAAx5C,EACA0qC,EAAA,GAAA8O,EAAA,GAAAx5C,GAEA0qC,GAEAuW,SAAA,SAAAP,EAAAC,GACA,MAAAhtD,MAAAktD,MAAAH,EAAA,GAAAC,EAAA,KAAAD,EAAA,GAAAC,EAAA,KAAAD,EAAA,GAAAC,EAAA,KAAAD,EAAA,GAAAC,EAAA,MAEAO,eAAA,SAAAR,EAAAC,GACA,OAAAD,EAAA,GAAAC,EAAA,KAAAD,EAAA,GAAAC,EAAA,KAAAD,EAAA,GAAAC,EAAA,KAAAD,EAAA,GAAAC,EAAA,KAEAQ,OAAA,SAAAzW,EAAA8O,GAGA,MAFA9O,GAAA,IAAA8O,EAAA,GACA9O,EAAA,IAAA8O,EAAA,GACA9O,GAEA7B,KAAA,SAAA6B,EAAAgW,EAAAC,EAAA7L,GAGA,MAFApK,GAAA,GAAAgW,EAAA,GAAA5L,GAAA6L,EAAA,GAAAD,EAAA,IACAhW,EAAA,GAAAgW,EAAA,GAAA5L,GAAA6L,EAAA,GAAAD,EAAA,IACAhW,GAEA1a,eAAA,SAAA0a,EAAA8O,EAAAtpB,GACA,GAAApzB,GAAA08C,EAAA,GACA39C,EAAA29C,EAAA,EAGA,OAFA9O,GAAA,GAAAxa,EAAA,GAAApzB,EAAAozB,EAAA,GAAAr0B,EAAAq0B,EAAA,GACAwa,EAAA,GAAAxa,EAAA,GAAApzB,EAAAozB,EAAA,GAAAr0B,EAAAq0B,EAAA,GACAwa,GAEA9yC,IAAA,SAAA8yC,EAAAgW,EAAAC,GAGA,MAFAjW,GAAA,GAAA/2C,KAAAiE,IAAA8oD,EAAA,GAAAC,EAAA,IACAjW,EAAA,GAAA/2C,KAAAiE,IAAA8oD,EAAA,GAAAC,EAAA,IACAjW,GAEAp+B,IAAA,SAAAo+B,EAAAgW,EAAAC,GAGA,MAFAjW,GAAA,GAAA/2C,KAAA2Y,IAAAo0C,EAAA,GAAAC,EAAA,IACAjW,EAAA,GAAA/2C,KAAA2Y,IAAAo0C,EAAA,GAAAC,EAAA,IACAjW,GAOA,OAJA13B,GAAAzc,OAAAyc,EAAAgL,IACAhL,EAAAouC,aAAApuC,EAAA8tC,UACA9tC,EAAA2rC,KAAA3rC,EAAAiuC,SACAjuC,EAAAquC,WAAAruC,EAAAkuC,eACAluC,IAEAjd,EAAA,2DAAAD,GAEA,QAAA8d,KAMA1hB,KAAA4N,SACAC,MACAA,MAOA7N,KAAAoO,UAAA,EACApO,KAAAe,MAAAf,KAAAe,KAAA2C,MAAA1D,KAAAypB,WAjBA,GAAAkoB,GAAA/tC,EAAA,iBAmBA+d,EAAAD,EAAA1V,SAkFA,OA5EA2V,GAAA3S,MAAA,SAAA/B,GAKA,MAAAA,IAEA0U,EAAAytC,QAAA,SAAAniD,GACA,GAAAU,GAAA3N,KAAA4N,OACA,OAAAX,IAAAU,EAAA,IAAAV,GAAAU,EAAA,IAOAgU,EAAA7d,UAAA,SAAAmJ,GACA,GAAAU,GAAA3N,KAAA4N,OACA,OAAAD,GAAA,KAAAA,EAAA,GACA,IAEAV,EAAAU,EAAA,KAAAA,EAAA,GAAAA,EAAA,KAOAgU,EAAAO,MAAA,SAAAjV,GACA,GAAAU,GAAA3N,KAAA4N,OACA,OAAAX,IAAAU,EAAA,GAAAA,EAAA,IAAAA,EAAA,IAMAgU,EAAAY,YAAA,SAAA2kB,GACA,GAAAv5B,GAAA3N,KAAA4N,OACAs5B,GAAA,GAAAv5B,EAAA,KAAAA,EAAA,GAAAu5B,EAAA,IACAA,EAAA,GAAAv5B,EAAA,KAAAA,EAAA,GAAAu5B,EAAA,KAOAvlB,EAAAW,UAAA,WACA,MAAAtiB,MAAA4N,QAAAjJ,SAOAgd,EAAAQ,UAAA,SAAAC,EAAAC,GACA,GAAA4kB,GAAAjnC,KAAA4N,OACA8R,OAAA0C,KACA6kB,EAAA,GAAA7kB,GAEA1C,MAAA2C,KACA4kB,EAAA,GAAA5kB,IAMAV,EAAA6lB,eAAA,WAGA,OAFAtW,MACAmW,EAAArnC,KAAAiiB,WACAvd,EAAA,EAAuBA,EAAA2iC,EAAAhjC,OAAkBK,IACzCwsB,EAAA1vB,KAAAxB,KAAAgN,SAAAq6B,EAAA3iC,IAEA,OAAAwsB,IAEAygB,EAAAgB,kBAAAjxB,GACAiwB,EAAAU,sBAAA3wB,GAA4C4wB,oBAAA,IAC5C5wB,IAEA7d,EAAA,mMAAAD,GACA,GAAAyrD,GAAAzrD,EAAA,oBACAkI,EAAAlI,EAAA,oBACAA,GAAA,iBACAA,EAAA,eACA,IAAA8d,GAAA9d,EAAA,kBACAgI,EAAAhI,EAAA,kBACAoC,EAAApC,EAAA,qBACAyhC,EAAAzhC,EAAA,wBACAivB,IAyMA,OArMAA,GAAAy8B,eAAA,SAAAr+B,EAAA3d,GACA,GAAA4O,GAAA+O,EAAA/O,MACAqtC,EAAArtC,EAAAI,YACAhU,EAAAihD,EAAA,GAAAA,EAAA,EACA,gBAAArtC,EAAA5gB,KAEA,MAAAomC,UAAAp5B,GAMAihD,GAJA,EACA,EAMA,IAAA7pD,GAAA4N,EAAAk8C,OAAAl8C,EAAAk8C,SAAAl8C,EAAA5K,IAAA,OACA0R,EAAA9G,EAAAm8C,OAAAn8C,EAAAm8C,SAAAn8C,EAAA5K,IAAA,OACAgnD,EAAAp8C,EAAAq8C,iBAAAr8C,EAAAq8C,oBAAAr8C,EAAA5K,IAAA,SACAknD,EAAAt8C,EAAA5K,IAAA,cACA1C,GAAAgZ,QAAA4wC,KACAA,GACAA,GAAA,EACAA,GAAA,IAGAA,EAAA,GAAAhkD,EAAAgkB,aAAAggC,EAAA,MACAA,EAAA,GAAAhkD,EAAAgkB,aAAAggC,EAAA,KACA,IAAAniD,IAAA,EACAC,GAAA,CA2BA,OAzBA,OAAAhI,IACAA,EAAA6pD,EAAA,GAAAK,EAAA,GAAAthD,EACAb,GAAA,GAEA,MAAA2M,IACAA,EAAAm1C,EAAA,GAAAK,EAAA,GAAAthD,EACAZ,GAAA,GAEA,YAAAhI,IACAA,EAAA6pD,EAAA,IAEA,YAAAn1C,IACAA,EAAAm1C,EAAA,IAGAG,IAEAhqD,EAAA,GAAA0U,EAAA,IAAA3M,IACA/H,EAAA,GAGAA,EAAA,GAAA0U,EAAA,IAAA1M,IACA0M,EAAA,KAIA1U,EACA0U,IAGAyY,EAAAI,gBAAA,SAAAhC,EAAA3d,GACA,GAAA4O,GAAA+O,EAAA/O,MACAvU,EAAAklB,EAAAy8B,eAAAr+B,EAAA3d,GACA7F,EAAA,OAAA6F,EAAAk8C,OAAAl8C,EAAAk8C,SAAAl8C,EAAA5K,IAAA,QACAgF,EAAA,OAAA4F,EAAAm8C,OAAAn8C,EAAAm8C,SAAAn8C,EAAA5K,IAAA,QACA++B,EAAAn0B,EAAA5K,IAAA,cACA,SAAAwZ,EAAA5gB,OACA4gB,EAAAF,KAAA1O,EAAA5K,IAAA,YAEAwZ,EAAAC,UAAAxU,EAAA,GAAAA,EAAA,IACAuU,EAAA3U,WAAAk6B,EAAAh6B,EAAAC,EAOA,IAAAmiD,GAAAv8C,EAAA5K,IAAA,cACA,IAAAg/B,SAAAmoB,KAAApiD,IAAAC,GAAA,aAAAwU,EAAA5gB,KAAA,CACA,GAAA6M,GAAA+T,EAAAilB,cACA2oB,EAAAruD,KAAA2Y,IAAA3Y,KAAAihB,IAAAvU,GAAA0hD,GAAA1hD,CAMAR,GAAAuU,EAAAI,YACAJ,EAAAC,UAAA2tC,EAAAniD,EAAA,GAAAA,EAAA,GAAAmiD,GACA5tC,EAAA3U,WAAAk6B,GAOA,GAAAt5B,GAAAmF,EAAA5K,IAAA,WACA,OAAAyF,GACA+T,EAAAklB,aAAAllB,EAAAklB,YAAAj5B,IAQA0kB,EAAA6B,mBAAA,SAAAphB,EAAAof,GAEA,GADAA,KAAApf,EAAA5K,IAAA,QAEA,OAAAgqB,GAEA,eACA,UAAA28B,GAAA/7C,EAAAy8C,iBACAliD,MACAA,MAEA,aACA,UAAA/B,EAEA,SACA,OAAA4V,EAAA5N,SAAA4e,IAAA5mB,GAAAuD,OAAAiE,KAOAuf,EAAAG,gBAAA,SAAA/B,GACA,GAAAsT,GAAAtT,EAAA/O,MAAAI,YACA5c,EAAA6+B,EAAA,GACAnqB,EAAAmqB,EAAA,EACA,SAAA7+B,EAAA,GAAA0U,EAAA,GAAA1U,EAAA,GAAA0U,EAAA,IASAyY,EAAAm9B,qBAAA,SAAAC,EAAA/+B,EAAApK,EAAAopC,GAGA,GAAAC,GACAC,EAAA,EACAC,EAAA,EACAj/B,EAAA,CACAF,GAAA7sB,OAAA,KAEA+sB,EAAA3vB,KAAA2K,MAAA8kB,EAAA7sB,OAAA,IAEA,QAAAK,GAAA,EAAuBA,EAAAurD,EAAA5rD,OAAuBK,GAAA0sB,EAAA,CAC9C,GAAAk/B,GAAAL,EAAAvrD,GACAyG,EAAAk6B,EAAA77B,gBAAA0nB,EAAAxsB,GAAAoiB,EAAA,eACA3b,GAAA+kD,EAAA,UAAAI,EAEAnlD,EAAA+kD,EAAA,uBACAC,EAGAA,EAAAI,UAAAplD,IACAklD,IACAD,EAAA3uD,KAAA2Y,IAAAg2C,EAAAC,KAEAF,EAAA1+B,MAAAtmB,GAEAklD,EAAA,GARAF,EAAAhlD,EAAAwF,QAWA,WAAAy/C,GAAAh/B,EAAA,EACAA,GAEAg/B,EAAA,GAAAh/B,EAAA,GAOAyB,EAAA1B,mBAAA,SAAAF,EAAAu/B,GACA,GAAAtuC,GAAA+O,EAAA/O,MACAgP,EAAAhP,EAAAslB,iBACAH,EAAAnlB,EAAAD,UACA,uBAAAuuC,IACAA,EAAA,SAAAxqB,GACA,gBAAA/4B,GACA,MAAA+4B,GAAAxnB,QAAA,UAA+CvR,KAElCujD,GACbxqD,EAAA+W,IAAAmU,EAAAs/B,IACS,kBAAAA,GACTxqD,EAAA+W,IAAAsqB,EAAA,SAAAE,EAAA74B,GACA,MAAA8hD,GAAA,aAAAv/B,EAAA3vB,KAAA4gB,EAAAlV,SAAAu6B,KAAA74B,IACa1O,MAEbkxB,GAGA2B,IAEAhvB,EAAA,6FAAAD,GACA,YAGA,SAAAkvB,GAAAzwB,GACAouD,EAAArhD,KAAApP,KAAAqC,GAHA,GAAA2D,GAAApC,EAAA,qBACA6sD,EAAA7sD,EAAA,cAsDA,OAlDAkvB,GAAA9mB,WACAkhB,YAAA4F,EACAxxB,KAAA,cACA4oB,YACA,IACA,KAEA2L,YAAA,WACA,MAAA71B,MAAA0wD,eAAA,eAAA1wD,KAAA0wD,eAAA,YAAA1wD,KAAAg0B,QAAA,MAEA28B,aAAA,SAAAC,GACA,GAAAC,GAAA7wD,KAAAg0B,QAAA,KACA88B,EAAA9wD,KAAAg0B,QAAA,IACA,OAAA68B,GAAAzB,QAAAyB,EAAAt+B,aAAAq+B,EAAA,MAAAE,EAAA1B,QAAA0B,EAAAv+B,aAAAq+B,EAAA,MAEAG,YAAA,SAAAlyD,GACA,MAAAmB,MAAAg0B,QAAA,KAAA+8B,YAAAlyD,EAAA,KAAAmB,KAAAg0B,QAAA,KAAA+8B,YAAAlyD,EAAA,KAEAo7B,aAAA,SAAAp7B,EAAA6V,GACA,MAAA7V,GAAAkuD,UACA,IACA,KACA,SAAAniD,EAAAjB,GACA,MAAA3J,MAAA01B,aACA9qB,EACAjB,KAEa+K,EAAA1U,OAEb01B,YAAA,SAAA72B,EAAA6kC,GACA,GAAAxhC,GAAAlC,KAAAg0B,QAAA,KACA/xB,EAAAjC,KAAAg0B,QAAA,IACA,QACA9xB,EAAAkwB,cAAAlwB,EAAA43B,YAAAj7B,EAAA,GAAA6kC,IACAzhC,EAAAmwB,cAAAnwB,EAAA63B,YAAAj7B,EAAA,GAAA6kC,MAGAstB,YAAA,SAAAJ,EAAAltB,GACA,GAAAxhC,GAAAlC,KAAAg0B,QAAA,KACA/xB,EAAAjC,KAAAg0B,QAAA,IACA,QACA9xB,EAAA+uD,YAAA/uD,EAAAqwB,aAAAq+B,EAAA,IAAAltB,GACAzhC,EAAAgvD,YAAAhvD,EAAAswB,aAAAq+B,EAAA,IAAAltB,KAGA9J,aAAA,SAAA3I,GACA,MAAAjxB,MAAAg0B,QAAA,MAAA/C,EAAAoB,IAAA,WAGArsB,EAAAuhB,SAAAuL,EAAA29B,GACA39B,IAEAjvB,EAAA,0GAAAD,GACA,GAAAoC,GAAApC,EAAA,qBACAstD,EAAAttD,EAAA,WACAutD,EAAAvtD,EAAA,uBAWAmvB,EAAA,SAAAV,EAAAnQ,EAAAkvC,EAAA1+B,EAAA5O,GACAotC,EAAA9hD,KAAApP,KAAAqyB,EAAAnQ,EAAAkvC,GASApxD,KAAAsB,KAAAoxB,GAAA,QAQA1yB,KAAA8jB,YAAA,SAkCA,OAhCAiP,GAAA/mB,WACAkhB,YAAA6F,EACA5gB,MAAA,EACAshB,QAAA,EACAngB,MAAA,KACAsgB,aAAA,WACA,GAAA9P,GAAA9jB,KAAA8jB,QACA,eAAAA,GAAA,WAAAA,GAEAiW,gBAAA,WACA,GAAAkL,GAAAjlC,KAAAsiB,WAGA,OAFA2iB,GAAA,GAAAjlC,KAAAoyB,cAAA6S,EAAA,IACAA,EAAA,GAAAjlC,KAAAoyB,cAAA6S,EAAA,IACAA,GAEAosB,iBAAA,WACA,GAAAC,GAAAtxD,KAAAuxD,cAIA,OAHAD,KACAA,EAAAtxD,KAAAuxD,eAAAJ,EAAAnxD,OAEAsxD,GAEAhgC,eAAA,SAAA5iB,GACA,gBAAA1O,KAAAsB,KAAA,CACA,GAAAgwD,GAAAtxD,KAAAqxD,kBACA,yBAAAC,OAAA5iD,EAAA1O,KAAAkiB,MAAAlV,SAAA0B,QAAA4iD,EAAA,KAGA/+B,aAAA,KACAH,cAAA,MAEApsB,EAAAuhB,SAAAwL,EAAAm+B,GACAn+B,IAEAlvB,EAAA,+FAAAD,GACA,YACAA,GAAA,cACA,IAAA8P,GAAA9P,EAAA,wBACA,OAAA8P,GAAA3G,QACAzL,KAAA,OACAid,cACA,QACA,SAEAvX,WAAA,MACAwE,iBAAA,KACAtE,eACAG,MAAA,EACAF,OAAA,EACAC,EAAA,EACAK,KAAA,MACA7F,IAAA,GACA0Y,MAAA,MACAzY,OAAA,GACA2vD,cAAA,EACA9pD,gBAAA,gBACAE,YAAA,EACAD,YAAA,YAIA9D,EAAA,kHAAAD,GAyCA,QAAA6tD,GAAApzB,EAAAE,EAAAD,EAAAE,EAAAkzB,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAt0B,GACA,GAAAu0B,GAAAF,GAAA3oC,EAAA,KACA8oC,EAAAC,EAAAF,IAAA3zB,EAAAC,GAAA,EAAA6zB,EAAAH,IAAAzzB,EAAAC,GAAA,EACA4zB,KAAAD,EAAAH,IAAA3zB,EAAAC,GAAA,EAAA4zB,EAAAF,IAAAzzB,EAAAC,GAAA,EACA6zB,EAAAJ,KAAAL,KAAAQ,KAAAP,IACAQ,GAAA,IACAT,GAAAU,EAAAD,GACAR,GAAAS,EAAAD,GAEA,IAAAjtB,IAAAssB,IAAAC,KAAA,GAAAW,GAAAV,KAAAC,KAAAD,KAAAQ,KAAAP,KAAAI,OAAAL,KAAAQ,KAAAP,KAAAI,QAAA,EACAM,EAAAntB,EAAAwsB,EAAAQ,EAAAP,EACAW,EAAAptB,GAAAysB,EAAAI,EAAAL,EACAhpC,GAAAyV,EAAAC,GAAA,EAAA4zB,EAAAF,GAAAO,EAAAJ,EAAAH,GAAAQ,EACA3pC,GAAA0V,EAAAC,GAAA,EAAA2zB,EAAAH,GAAAO,EAAAL,EAAAF,GAAAQ,EACAC,EAAAC,GACA,EACA,KAEAT,EAAAM,GAAAX,GACAQ,EAAAI,GAAAX,IAEAc,IACAV,EAAAM,GAAAX,GACAQ,EAAAI,GAAAX,GAEAvK,OACA2K,EAAAM,GAAAX,MACAQ,EAAAI,GAAAX,GAEAe,EAAAF,EAAAC,EAAArL,EACAuL,GAAAF,EAAArL,SACAsL,EAAAzpC,GAEA0pC,EAAAF,EAAArL,IAAA,IACAsL,EAAA,GAEA,IAAAjB,GAAAiB,EAAA,IACAA,GAAA,EAAAzpC,GAEA,IAAAwoC,GAAAiB,EAAA,IACAA,GAAA,EAAAzpC,GAEAsU,EAAAq1B,QAAAf,EAAAnpC,EAAAC,EAAA+oC,EAAAC,EAAAY,EAAAG,EAAAZ,EAAAL,GAEA,QAAAoB,GAAAl0D,GACA,IAAAA,EACA,QAGA,IACAu7B,GADA44B,EAAAn0D,EAAA2f,QAAA,WAAAA,QAAA,WAAAA,QAAA,UAAAA,QAAA,UAGA,KAAA4b,EAAA,EAAmBA,EAAA64B,EAAA5uD,OAAe+1B,IAClC44B,IAAAx0C,QAAA,GAAA00C,QAAAD,EAAA74B,GAAA,SAAA64B,EAAA74B,GAGA,IAMA+4B,GANAlvB,EAAA+uB,EAAA9uD,MAAA,KAEAkvD,EAAA,EACAC,EAAA,EACA51B,EAAA,GAAA61B,GACAC,EAAAD,EAAAC,GAEA,KAAAn5B,EAAA,EAAmBA,EAAA6J,EAAA5/B,OAAgB+1B,IAAA,CACnC,GAIA23B,GAJAzuB,EAAAW,EAAA7J,GACAo5B,EAAAlwB,EAAAuD,OAAA,GACAzuB,EAAA,EACA+hB,EAAAmJ,EAAA3+B,MAAA,GAAA6Z,QAAA,aAAAta,MAAA,IAEAi2B,GAAA91B,OAAA,QAAA81B,EAAA,IACAA,EAAA9c,OAEA,QAAA3Y,GAAA,EAA2BA,EAAAy1B,EAAA91B,OAAcK,IACzCy1B,EAAAz1B,GAAAq9B,WAAA5H,EAAAz1B,GAEA,MAAA0T,EAAA+hB,EAAA91B,SAAAqb,MAAAya,EAAA/hB,MACAsH,MAAAya,EAAA,KADA,CAIA,GAAAs5B,GACAC,EACA9B,EACAC,EACAG,EACAN,EACAC,EACAtzB,EAAA+0B,EACA70B,EAAA80B,CAEA,QAAAG,GACA,QACAJ,GAAAj5B,EAAA/hB,KACAi7C,GAAAl5B,EAAA/hB,KACA25C,EAAAwB,EAAAvb,EACAva,EAAAq1B,QAAAf,EAAAqB,EAAAC,EACA,MACA,SACAD,EAAAj5B,EAAA/hB,KACAi7C,EAAAl5B,EAAA/hB,KACA25C,EAAAwB,EAAAvb,EACAva,EAAAq1B,QAAAf,EAAAqB,EAAAC,EACA,MACA,SACAD,GAAAj5B,EAAA/hB,KACAi7C,GAAAl5B,EAAA/hB,KACA25C,EAAAwB,EAAAjtB,EACA7I,EAAAq1B,QAAAf,EAAAqB,EAAAC,GACAG,EAAA,GACA,MACA,SACAJ,EAAAj5B,EAAA/hB,KACAi7C,EAAAl5B,EAAA/hB,KACA25C,EAAAwB,EAAAjtB,EACA7I,EAAAq1B,QAAAf,EAAAqB,EAAAC,GACAG,EAAA,GACA,MACA,SACAJ,GAAAj5B,EAAA/hB,KACA25C,EAAAwB,EAAAvb,EACAva,EAAAq1B,QAAAf,EAAAqB,EAAAC,EACA,MACA,SACAD,EAAAj5B,EAAA/hB,KACA25C,EAAAwB,EAAAvb,EACAva,EAAAq1B,QAAAf,EAAAqB,EAAAC,EACA,MACA,SACAA,GAAAl5B,EAAA/hB,KACA25C,EAAAwB,EAAAvb,EACAva,EAAAq1B,QAAAf,EAAAqB,EAAAC,EACA,MACA,SACAA,EAAAl5B,EAAA/hB,KACA25C,EAAAwB,EAAAvb,EACAva,EAAAq1B,QAAAf,EAAAqB,EAAAC,EACA,MACA,SACAtB,EAAAwB,EAAAI,EACAl2B,EAAAq1B,QAAAf,EAAA53B,EAAA/hB,KAAA+hB,EAAA/hB,KAAA+hB,EAAA/hB,KAAA+hB,EAAA/hB,KAAA+hB,EAAA/hB,KAAA+hB,EAAA/hB,MACAg7C,EAAAj5B,EAAA/hB,EAAA,GACAi7C,EAAAl5B,EAAA/hB,EAAA,EACA,MACA,SACA25C,EAAAwB,EAAAI,EACAl2B,EAAAq1B,QAAAf,EAAA53B,EAAA/hB,KAAAg7C,EAAAj5B,EAAA/hB,KAAAi7C,EAAAl5B,EAAA/hB,KAAAg7C,EAAAj5B,EAAA/hB,KAAAi7C,EAAAl5B,EAAA/hB,KAAAg7C,EAAAj5B,EAAA/hB,KAAAi7C,GACAD,GAAAj5B,EAAA/hB,EAAA,GACAi7C,GAAAl5B,EAAA/hB,EAAA,EACA,MACA,SACAq7C,EAAAL,EACAM,EAAAL,CACA,IAAAvnC,GAAA2R,EAAA3R,MACAwR,EAAAG,EAAA5+B,IACAs0D,KAAAI,EAAAI,IACAF,GAAAL,EAAA91B,EAAAxR,EAAA,GACA4nC,GAAAL,EAAA/1B,EAAAxR,EAAA,IAEAimC,EAAAwB,EAAAI,EACAt1B,EAAAlE,EAAA/hB,KACAmmB,EAAApE,EAAA/hB,KACAg7C,EAAAj5B,EAAA/hB,KACAi7C,EAAAl5B,EAAA/hB,KACAqlB,EAAAq1B,QAAAf,EAAA0B,EAAAC,EAAAr1B,EAAAE,EAAA60B,EAAAC,EACA,MACA,SACAI,EAAAL,EACAM,EAAAL,CACA,IAAAvnC,GAAA2R,EAAA3R,MACAwR,EAAAG,EAAA5+B,IACAs0D,KAAAI,EAAAI,IACAF,GAAAL,EAAA91B,EAAAxR,EAAA,GACA4nC,GAAAL,EAAA/1B,EAAAxR,EAAA,IAEAimC,EAAAwB,EAAAI,EACAt1B,EAAA+0B,EAAAj5B,EAAA/hB,KACAmmB,EAAA80B,EAAAl5B,EAAA/hB,KACAg7C,GAAAj5B,EAAA/hB,KACAi7C,GAAAl5B,EAAA/hB,KACAqlB,EAAAq1B,QAAAf,EAAA0B,EAAAC,EAAAr1B,EAAAE,EAAA60B,EAAAC,EACA,MACA,SACAh1B,EAAAlE,EAAA/hB,KACAmmB,EAAApE,EAAA/hB,KACAg7C,EAAAj5B,EAAA/hB,KACAi7C,EAAAl5B,EAAA/hB,KACA25C,EAAAwB,EAAAK,EACAn2B,EAAAq1B,QAAAf,EAAA1zB,EAAAE,EAAA60B,EAAAC,EACA,MACA,SACAh1B,EAAAlE,EAAA/hB,KAAAg7C,EACA70B,EAAApE,EAAA/hB,KAAAi7C,EACAD,GAAAj5B,EAAA/hB,KACAi7C,GAAAl5B,EAAA/hB,KACA25C,EAAAwB,EAAAK,EACAn2B,EAAAq1B,QAAAf,EAAA1zB,EAAAE,EAAA60B,EAAAC,EACA,MACA,SACAI,EAAAL,EACAM,EAAAL,CACA,IAAAvnC,GAAA2R,EAAA3R,MACAwR,EAAAG,EAAA5+B,IACAs0D,KAAAI,EAAAK,IACAH,GAAAL,EAAA91B,EAAAxR,EAAA,GACA4nC,GAAAL,EAAA/1B,EAAAxR,EAAA,IAEAsnC,EAAAj5B,EAAA/hB,KACAi7C,EAAAl5B,EAAA/hB,KACA25C,EAAAwB,EAAAK,EACAn2B,EAAAq1B,QAAAf,EAAA0B,EAAAC,EAAAN,EAAAC,EACA,MACA,SACAI,EAAAL,EACAM,EAAAL,CACA,IAAAvnC,GAAA2R,EAAA3R,MACAwR,EAAAG,EAAA5+B,IACAs0D,KAAAI,EAAAK,IACAH,GAAAL,EAAA91B,EAAAxR,EAAA,GACA4nC,GAAAL,EAAA/1B,EAAAxR,EAAA,IAEAsnC,GAAAj5B,EAAA/hB,KACAi7C,GAAAl5B,EAAA/hB,KACA25C,EAAAwB,EAAAK,EACAn2B,EAAAq1B,QAAAf,EAAA0B,EAAAC,EAAAN,EAAAC,EACA,MACA,SACAzB,EAAAz3B,EAAA/hB,KACAy5C,EAAA13B,EAAA/hB,KACA45C,EAAA73B,EAAA/hB,KACAs5C,EAAAv3B,EAAA/hB,KACAu5C,EAAAx3B,EAAA/hB,KACAimB,EAAA+0B,EAAA70B,EAAA80B,EACAD,EAAAj5B,EAAA/hB,KACAi7C,EAAAl5B,EAAA/hB,KACA25C,EAAAwB,EAAAM,EACApC,EAAApzB,EAAAE,EAAA60B,EAAAC,EAAA3B,EAAAC,EAAAC,EAAAC,EAAAG,EAAAD,EAAAt0B,EACA,MACA,SACAm0B,EAAAz3B,EAAA/hB,KACAy5C,EAAA13B,EAAA/hB,KACA45C,EAAA73B,EAAA/hB,KACAs5C,EAAAv3B,EAAA/hB,KACAu5C,EAAAx3B,EAAA/hB,KACAimB,EAAA+0B,EAAA70B,EAAA80B,EACAD,GAAAj5B,EAAA/hB,KACAi7C,GAAAl5B,EAAA/hB,KACA25C,EAAAwB,EAAAM,EACApC,EAAApzB,EAAAE,EAAA60B,EAAAC,EAAA3B,EAAAC,EAAAC,EAAAC,EAAAG,EAAAD,EAAAt0B,IAIA,MAAA+1B,GAAA,MAAAA,IACAzB,EAAAwB,EAAAO,EACAr2B,EAAAq1B,QAAAf,IAEAoB,EAAApB,EAGA,MADAt0B,GAAAs2B,WACAt2B,EAGA,QAAAu2B,GAAA1wB,EAAAtzB,GACA,GACA0vB,GADAu0B,EAAAlB,EAAAzvB,EAmBA,OAjBAtzB,SACAA,EAAAkkD,UAAA,SAAAz2B,GACAA,EAAA+S,QAAAyjB,EAAAp1D,MACA6gC,GAAAy0B,EAAA12B,EAAAiC,EAEA,IAAAoW,GAAArY,EAAA/Q,YACAopB,IACArY,EAAA22B,YAAAte,IAGA9lC,EAAA8tB,eAAA,SAAAE,GACA0B,IACAA,EAAA7e,EAAAxR,UAEAwR,EAAAye,IAAAI,EAAA1B,EAAA0B,GACA1/B,KAAAq0D,OAAA,IAEArkD,EAhUA,GAAAysB,GAAA74B,EAAA,mBACA0vD,EAAA1vD,EAAA,qBACAuwD,EAAAvwD,EAAA,mBACAid,EAAAjd,EAAA,kBAEAqvD,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KAEAX,EAAA7wD,KAAAktD,KACAwD,EAAA1wD,KAAAmiB,IACAsuC,EAAAzwD,KAAAiiB,IACAyF,EAAA1nB,KAAA0nB,GACAmrC,EAAA,SAAAhN,GACA,MAAA7lD,MAAAktD,KAAArH,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAEAuL,EAAA,SAAAF,EAAArL,GACA,OAAAqL,EAAA,GAAArL,EAAA,GAAAqL,EAAA,GAAArL,EAAA,KAAAgN,EAAA3B,GAAA2B,EAAAhN,KAEAoL,EAAA,SAAAC,EAAArL,GACA,OAAAqL,EAAA,GAAArL,EAAA,GAAAqL,EAAA,GAAArL,EAAA,SAAA7lD,KAAA8yD,KAAA1B,EAAAF,EAAArL,IA4RA,QACA5pB,iBAAA,SAAA4F,EAAAtzB,GACA,UAAAysB,GAAAu3B,EAAA1wB,EAAAtzB,KAEAutB,iBAAA,SAAA+F,EAAAtzB,GACA,MAAAysB,GAAA1vB,OAAAinD,EAAA1wB,EAAAtzB,KAEA6tB,UAAA,SAAA22B,EAAAxkD,GAGA,OAFAykD,MACA3oC,EAAA0oC,EAAAnwD,OACAK,EAAA,EAA2BA,EAAAonB,EAASpnB,IAAA,CACpC,GAAAgwD,GAAAF,EAAA9vD,EACAgwD,GAAAC,SACAD,EAAAR,UAAAQ,EAAAj3B,KAAAi3B,EAAArpD,OAAA,GAEAopD,EAAAjzD,KAAAkzD,EAAAj3B,MAEA,GAAAm3B,GAAA,GAAAn4B,GAAAzsB,EASA,OARA4kD,GAAAV,UAAA,SAAAz2B,GACAA,EAAAo3B,WAAAJ,EAEA,IAAA3e,GAAArY,EAAA/Q,YACAopB,IACArY,EAAA22B,YAAAte,IAGA8e,MAIA/wD,EAAA,6HAAAD,GAcA,QAAA64B,GAAAzsB,GACA8kD,EAAA1lD,KAAApP,KAAAgQ,GAKAhQ,KAAAy9B,KAAA,GAAA61B,GAnBA,GAAAwB,GAAAlxD,EAAA,iBACAoC,EAAApC,EAAA,gBACA0vD,EAAA1vD,EAAA,qBACAmxD,EAAAnxD,EAAA,mBACAoxD,EAAApxD,EAAA,aACAqxD,EAAAD,EAAAhpD,UAAAipD,iBACAvyC,EAAAjhB,KAAAihB,GAyQA,OA1PA+Z,GAAAzwB,WACAkhB,YAAAuP,EACAn7B,KAAA,OACA4zD,aAAA,EACAC,uBAAA,EACAC,MAAA,SAAAtf,EAAAuf,GACA,GAAApsD,GAAAjJ,KAAAiJ,MACAw0B,EAAAz9B,KAAAy9B,KACA63B,EAAArsD,EAAAqsD,YACAC,EAAAtsD,EAAAssD,UACAnsD,EAAAH,EAAAG,KACAge,EAAAne,EAAAme,OACAouC,EAAAD,KAAAnsD,EAAAoS,WACAi6C,EAAAH,KAAAluC,EAAA5L,WACAk6C,EAAAH,KAAAnsD,EAAA4R,MACA26C,EAAAL,KAAAluC,EAAApM,KAGA,IAFA/R,EAAAvI,KAAAo1C,EAAA91C,KAAAq1D,GACAr1D,KAAA41D,aAAA9f,GACA91C,KAAA20D,QAAA,CACA,GAAAxpD,GAAAnL,KAAAwJ,iBAEAgsD,KACAx1D,KAAA61D,cAAA5sD,EAAA6sD,YAAAhgB,EAAA1sC,EAAA+B,IAEAsqD,IACAz1D,KAAA+1D,gBAAA9sD,EAAA6sD,YAAAhgB,EAAA1uB,EAAAjc,IAIAqqD,EAEA1f,EAAAkgB,UAAAh2D,KAAA61D,cACaH,IACb5f,EAAAkgB,UAAAf,EAAA7lD,KAAAhG,EAAA0sC,IAEA2f,EACA3f,EAAAmgB,YAAAj2D,KAAA+1D,gBACaJ,IACb7f,EAAAmgB,YAAAhB,EAAA7lD,KAAAgY,EAAA0uB,GAEA,IAAAogB,GAAAjtD,EAAAitD,SACAC,EAAAltD,EAAAktD,eACAC,IAAAtgB,EAAAugB,YAEAn0C,EAAAliB,KAAAs2D,gBACA74B,GAAA84B,SAAAr0C,EAAA,GAAAA,EAAA,IAMAliB,KAAAk1D,aAAAgB,IAAAE,GAAAd,GACA73B,EAAAz9B,KAAAy9B,KAAA+4B,UAAA1gB,GAEAogB,IAAAE,IACA34B,EAAA44B,YAAAH,GACAz4B,EAAAg5B,kBAAAN,IAEAn2D,KAAAk0D,UAAAz2B,EAAAz9B,KAAAqL,OAAA,GAEArL,KAAAk1D,aAAA,IAGApf,EAAA0gB,YACAx2D,KAAAy9B,KAAA22B,YAAAte,IAEAyf,GAAA93B,EAAAr0B,KAAA0sC,GACAogB,GAAAE,IACAtgB,EAAAugB,YAAAH,GACApgB,EAAAqgB,kBAEAb,GAAA73B,EAAArW,OAAA0uB,GACAogB,GAAAE,GAGAtgB,EAAAugB,gBAEAr2D,KAAA02D,iBAAA5gB,IAEA7sC,EAAAlH,MAAA,IAAAkH,EAAAlH,OAEA/B,KAAA22D,aAAA7gB,EAAA91C,KAAAwJ,oBAGA0qD,UAAA,SAAApe,EAAA8gB,EAAAC,KAEArtD,gBAAA,WACA,GAAA2B,GAAAnL,KAAAmzB,MACAlqB,EAAAjJ,KAAAiJ,MACA6tD,GAAA3rD,CACA,IAAA2rD,EAAA,CACA,GAAAr5B,GAAAz9B,KAAAy9B,IACAz9B,MAAAk1D,cACAz3B,EAAA+4B,YACAx2D,KAAAk0D,UAAAz2B,EAAAz9B,KAAAqL,OAAA,IAEAF,EAAAsyB,EAAAj0B,kBAGA,GADAxJ,KAAAmzB,MAAAhoB,EACAlC,EAAAqsD,YAAA,CAIA,GAAAyB,GAAA/2D,KAAAg3D,kBAAAh3D,KAAAg3D,gBAAA7rD,EAAAwF,QACA,IAAA3Q,KAAA20D,SAAAmC,EAAA,CACAC,EAAAj0B,KAAA33B,EAEA,IAAA8rD,GAAAhuD,EAAAitB,UAEAghC,EAAAjuD,EAAAkuD,cAAAn3D,KAAAo3D,eAAA,CAEAnuD,GAAAssD,YACA0B,EAAAx1D,KAAA2Y,IAAA68C,EAAAj3D,KAAAm1D,wBAAA,IAIA+B,EAAA,QACAH,EAAAxsD,OAAA0sD,EAAAC,EACAH,EAAAntD,QAAAqtD,EAAAC,EACAH,EAAAnsD,GAAAqsD,EAAAC,EAAA,EACAH,EAAAptD,GAAAstD,EAAAC,EAAA,GAIA,MAAAH,GAEA,MAAA5rD,IAEAikD,QAAA,SAAAxkD,EAAAjB,GACA,GAAA0tD,GAAAr3D,KAAAs3D,sBAAA1sD,EAAAjB,GACAwB,EAAAnL,KAAAwJ,kBACAP,EAAAjJ,KAAAiJ,KAGA,IAFA2B,EAAAysD,EAAA,GACA1tD,EAAA0tD,EAAA,GACAlsD,EAAAikD,QAAAxkD,EAAAjB,GAAA,CACA,GAAA2zB,GAAAt9B,KAAAy9B,KAAA5+B,IACA,IAAAoK,EAAAqsD,YAAA,CACA,GAAAp/B,GAAAjtB,EAAAitB,UACAghC,EAAAjuD,EAAAkuD,cAAAn3D,KAAAo3D,eAAA,CAEA,IAAAF,EAAA,QAEAjuD,EAAAssD,YACAr/B,EAAAz0B,KAAA2Y,IAAA8b,EAAAl2B,KAAAm1D,yBAEAJ,EAAAwC,cAAAj6B,EAAApH,EAAAghC,EAAAtsD,EAAAjB,IACA,SAIA,GAAAV,EAAAssD,UACA,MAAAR,GAAA3F,QAAA9xB,EAAA1yB,EAAAjB,GAGA,UAEA0qD,MAAA,SAAAmD,GACA,MAAAA,IACAA,GAAA,GAGAA,IACAx3D,KAAAk1D,YAAAsC,EACAx3D,KAAAmzB,MAAA,MAEAnzB,KAAA20D,SAAA,EACA30D,KAAAk7B,MAAAl7B,KAAAk7B,KAAAga,UAEAl1C,KAAAy3D,cACAz3D,KAAAy3D,aAAApD,SAGA1N,aAAA,SAAA+Q,GACA,MAAA13D,MAAA+jB,QAAA,QAAA2zC,IAEAC,OAAA,SAAAx4C,EAAAzgB,GAEA,UAAAygB,GACAnf,KAAA8lB,SAAApnB,GACAsB,KAAAk1D,aAAA,EACAl1D,KAAAmzB,MAAA,MAEA2hC,EAAA9oD,UAAA2rD,OAAAvoD,KAAApP,KAAAmf,EAAAzgB,IAGAonB,SAAA,SAAA3G,EAAAzgB,GACA,GAAA2M,GAAArL,KAAAqL,KAEA,IAAAA,EAAA,CACA,GAAArF,EAAAqW,SAAA8C,GACA,OAAA9c,KAAA8c,GACA9T,EAAAhJ,GAAA8c,EAAA9c,OAGAgJ,GAAA8T,GAAAzgB,CAEAsB,MAAAq0D,OAAA,GAEA,MAAAr0D,OAEAo3D,aAAA,WACA,GAAAp5B,GAAAh+B,KAAA0/B,SAKA,OAAA1B,IAAAtb,EAAAsb,EAAA,aAAAtb,EAAAsb,EAAA,YAAAv8B,KAAAktD,KAAAjsC,EAAAsb,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,SAaAvB,EAAA1vB,OAAA,SAAArB,GACA,GAAAksD,GAAA,SAAA5nD,GACAysB,EAAArtB,KAAApP,KAAAgQ,GACAtE,EAAAzC,OAEAjJ,KAAAiJ,MAAA4uD,WAAAnsD,EAAAzC,OAAA,EAGA,IAAA6uD,GAAApsD,EAAAL,KACA,IAAAysD,EAAA,CACA93D,KAAAqL,MAAArL,KAAAqL,SACA,IAAA0sD,GAAA/3D,KAAAqL,KACA,QAAAhJ,KAAAy1D,IACAC,EAAA/rC,eAAA3pB,IAAAy1D,EAAA9rC,eAAA3pB,KACA01D,EAAA11D,GAAAy1D,EAAAz1D,IAIAqJ,EAAA3K,MAAA2K,EAAA3K,KAAAqO,KAAApP,KAAAgQ,GAEAhK,GAAAuhB,SAAAqwC,EAAAn7B,EAEA,QAAAp6B,KAAAqJ,GAEA,UAAArJ,GAAA,UAAAA,IACAu1D,EAAA5rD,UAAA3J,GAAAqJ,EAAArJ,GAGA,OAAAu1D,IAEA5xD,EAAAuhB,SAAAkV,EAAAq4B,GACAr4B,IAEA54B,EAAA,gDAAAD,GAIA,GAAA0hD,GAAA,SAAA9pC,GACAxb,KAAAwb,iBAWA,OATA8pC,GAAAt5C,WACAkhB,YAAAo4B,EACA0S,aAAA,SAAAn0C,EAAA3b,GACAlI,KAAAwb,WAAAha,MACAqiB,SACA3b,YAIAo9C,IAEAzhD,EAAA,kGAAAD,GACA,GAAAoC,GAAApC,EAAA,gBACAq0D,EAAAr0D,EAAA,cACAu5B,EAAAv5B,EAAA,wBAOA2gB,EAAA,SAAAvU,GACAA,QACAioD,EAAA7oD,KAAApP,KAAAgQ,EACA,QAAAmP,KAAAnP,GACAhQ,KAAAmf,GAAAnP,EAAAmP,EAEAnf,MAAAk4D,aACAl4D,KAAAm4D,UAAA,KACAn4D,KAAA20D,SAAA,EAmKA,OAjKApwC,GAAAvY,WACAkhB,YAAA3I,EACAhP,SAAA,EACAjU,KAAA,QACAyI,QAAA,EACAquD,SAAA,WACA,MAAAp4D,MAAAk4D,UAAAvzD,SAEA8gB,QAAA,SAAA/W,GACA,MAAA1O,MAAAk4D,UAAAxpD,IAEA2pD,YAAA,SAAAh2D,GAEA,OADA+1D,GAAAp4D,KAAAk4D,UACAxzD,EAAA,EAA2BA,EAAA0zD,EAAA/zD,OAAqBK,IAChD,GAAA0zD,EAAA1zD,GAAArC,SACA,MAAA+1D,GAAA1zD,IAIAouC,WAAA,WACA,MAAA9yC,MAAAk4D,UAAA7zD,QAEA8F,IAAA,SAAAge,GAKA,MAJAA,QAAAnoB,MAAAmoB,EAAAqX,SAAAx/B,OACAA,KAAAk4D,UAAA12D,KAAA2mB,GACAnoB,KAAAs4D,OAAAnwC,IAEAnoB,MAEAu4D,UAAA,SAAApwC,EAAAqwC,GACA,GAAArwC,OAAAnoB,MAAAmoB,EAAAqX,SAAAx/B,MAAAw4D,KAAAh5B,SAAAx/B,KAAA,CACA,GAAAo4D,GAAAp4D,KAAAk4D,UACAxpD,EAAA0pD,EAAAp0D,QAAAw0D,EACA9pD,IAAA,IACA0pD,EAAAhkD,OAAA1F,EAAA,EAAAyZ,GACAnoB,KAAAs4D,OAAAnwC,IAGA,MAAAnoB,OAEAs4D,OAAA,SAAAnwC,GACAA,EAAAqX,QACArX,EAAAqX,OAAArrB,OAAAgU,GAEAA,EAAAqX,OAAAx/B,IACA,IAAAoV,GAAApV,KAAAm4D,UACA/kD,EAAApT,KAAAk7B,IACA9lB,QAAA+S,EAAAgwC,YACA/iD,EAAAq/B,SAAAtsB,GACAA,YAAA5D,IACA4D,EAAAswC,qBAAArjD,IAGAhC,KAAA8hC,WAEA/gC,OAAA,SAAAgU,GACA,GAAA/U,GAAApT,KAAAk7B,KACA9lB,EAAApV,KAAAm4D,UACAC,EAAAp4D,KAAAk4D,UACAxpD,EAAA1I,EAAAhC,QAAAo0D,EAAAjwC,EACA,OAAAzZ,GAAA,EACA1O,MAEAo4D,EAAAhkD,OAAA1F,EAAA,GACAyZ,EAAAqX,OAAA,KACApqB,IACAA,EAAAm/B,WAAApsB,EAAAhoB,IACAgoB,YAAA5D,IACA4D,EAAAuwC,uBAAAtjD,IAGAhC,KAAA8hC,UACAl1C,OAEAyI,UAAA,WACA,GAEA0f,GACAzjB,EAHA0zD,EAAAp4D,KAAAk4D,UACA9iD,EAAApV,KAAAm4D,SAGA,KAAAzzD,EAAA,EAAuBA,EAAA0zD,EAAA/zD,OAAqBK,IAC5CyjB,EAAAiwC,EAAA1zD,GACA0Q,IACAA,EAAAm/B,WAAApsB,EAAAhoB,IACAgoB,YAAA5D,IACA4D,EAAAuwC,uBAAAtjD,IAGA+S,EAAAqX,OAAA,IAGA,OADA44B,GAAA/zD,OAAA,EACArE,MAEAkoB,UAAA,SAAAa,EAAAtZ,GAEA,OADA2oD,GAAAp4D,KAAAk4D,UACAxzD,EAAA,EAA2BA,EAAA0zD,EAAA/zD,OAAqBK,IAAA,CAChD,GAAAyjB,GAAAiwC,EAAA1zD,EACAqkB,GAAA3Z,KAAAK,EAAA0Y,EAAAzjB,GAEA,MAAA1E,OAEAsV,SAAA,SAAAyT,EAAAtZ,GACA,OAAA/K,GAAA,EAA2BA,EAAA1E,KAAAk4D,UAAA7zD,OAA2BK,IAAA,CACtD,GAAAyjB,GAAAnoB,KAAAk4D,UAAAxzD,EACAqkB,GAAA3Z,KAAAK,EAAA0Y,GACA,UAAAA,EAAA7mB,MACA6mB,EAAA7S,SAAAyT,EAAAtZ,GAGA,MAAAzP,OAEAy4D,qBAAA,SAAArjD,GACA,OAAA1Q,GAAA,EAA2BA,EAAA1E,KAAAk4D,UAAA7zD,OAA2BK,IAAA,CACtD,GAAAyjB,GAAAnoB,KAAAk4D,UAAAxzD,EACA0Q,GAAAq/B,SAAAtsB,GACAA,YAAA5D,IACA4D,EAAAswC,qBAAArjD,KAIAsjD,uBAAA,SAAAtjD,GACA,OAAA1Q,GAAA,EAA2BA,EAAA1E,KAAAk4D,UAAA7zD,OAA2BK,IAAA,CACtD,GAAAyjB,GAAAnoB,KAAAk4D,UAAAxzD,EACA0Q,GAAAm/B,WAAApsB,EAAAhoB,IACAgoB,YAAA5D,IACA4D,EAAAuwC,uBAAAtjD,KAIAi/C,MAAA,WAGA,MAFAr0D,MAAA20D,SAAA,EACA30D,KAAAk7B,MAAAl7B,KAAAk7B,KAAAga,UACAl1C,MAEAwJ,gBAAA,SAAAmvD,GAOA,OAJAxtD,GAAA,KACAytD,EAAA,GAAAz7B,GAAA,SACAi7B,EAAAO,GAAA34D,KAAAk4D,UACAW,KACAn0D,EAAA,EAA2BA,EAAA0zD,EAAA/zD,OAAqBK,IAAA,CAChD,GAAAyjB,GAAAiwC,EAAA1zD,EACA,KAAAyjB,EAAAxS,SAAAwS,EAAA2wC,UAAA,CAGA,GAAAC,GAAA5wC,EAAA3e,kBACAk2B,EAAAvX,EAAAoX,kBAAAs5B,EACAn5B,IACAk5B,EAAA91B,KAAAi2B,GACAH,EAAA96B,eAAA4B,GACAv0B,KAAAytD,EAAAjoD,QACAxF,EAAAsmB,MAAAmnC,KAEAztD,KAAA4tD,EAAApoD,QACAxF,EAAAsmB,MAAAsnC,KAGA,MAAA5tD,IAAAytD,IAGA5yD,EAAAuhB,SAAAhD,EAAA0zC,GACA1zC,IAEA1gB,EAAA,6FAAAD,GACA,GAAAkxD,GAAAlxD,EAAA,iBACAoC,EAAApC,EAAA,gBACAyhC,EAAAzhC,EAAA,mBAOAoF,EAAA,SAAAgH,GACA8kD,EAAA1lD,KAAApP,KAAAgQ,GAgFA,OA9EAhH,GAAAgD,WACAkhB,YAAAlkB,EACA1H,KAAA,OACA8zD,MAAA,SAAAtf,EAAAuf,GACA,GAAApsD,GAAAjJ,KAAAiJ,MACA2B,EAAA3B,EAAA2B,GAAA,EACAjB,EAAAV,EAAAU,GAAA,EAEA5H,EAAAkH,EAAAlH,IAKA,IAHA,MAAAA,OAAA,IAEAkH,EAAAvI,KAAAo1C,EAAA91C,KAAAq1D,GACAtzD,EAAA,CACA/B,KAAA41D,aAAA9f,EACA,IAAAhtC,GACA9G,EAAAiH,EAAAjH,UACA8kB,EAAA7d,EAAAC,UAAAD,EAAA6d,IACA,IAAA7d,EAAA8B,kBAAA,CACA,GAAAI,GAAAk6B,EAAA77B,gBAAAzH,EAAA+kB,EAAA7d,EAAAjH,UAAA,MAGA,QADA8G,EAAA,SACAG,EAAA8B,mBACA,aACApB,GAAAwB,EAAAvB,OAAA,EAAAuB,EAAA6tD,WAAA,CACA,MACA,cACArvD,GAAAwB,EAAAvB,OAAAuB,EAAA6tD,WAAA,CACA,MACA,SACArvD,GAAAwB,EAAA6tD,WAAA,OAGAlwD,GAAAG,EAAAH,YAGAgtC,GAAAhvB,QAAA,kBACAgvB,EAAA9zC,aAAA,OAEA8zC,EAAA9zC,gBACA8zC,EAAA9zC,UAAA,QAEA8zC,EAAAhtC,gBAAA,aAEAgtC,EAAAhtC,mBACAgtC,EAAAhtC,aAAA,aAIA,QAFAkwD,GAAA3zB,EAAA4zB,YAAA,IAAAnjB,EAAAhvB,MAAAvc,MACA2uD,EAAAn3D,EAAAmC,MAAA,MACAQ,EAAA,EAA+BA,EAAAw0D,EAAA70D,OAAsBK,IACrDuE,EAAAssD,WAAAzf,EAAAqjB,SAAAD,EAAAx0D,GAAAkG,EAAAjB,GACAV,EAAAqsD,aAAAxf,EAAAsjB,WAAAF,EAAAx0D,GAAAkG,EAAAjB,GACAA,GAAAqvD,CAEAh5D,MAAA02D,iBAAA5gB,KAGAtsC,gBAAA,WACA,IAAAxJ,KAAAmzB,MAAA,CACA,GAAAlqB,GAAAjJ,KAAAiJ,MACA8B,EAAA9B,EAAA8B,kBACAI,EAAAk6B,EAAA77B,gBAAAP,EAAAlH,KAAA,GAAAkH,EAAAC,UAAAD,EAAA6d,KAAA7d,EAAAjH,UAAA+I,EAAA,MAAA9B,EAAAH,aACA,QAAAiC,GACA,aACAI,EAAAxB,GAAAwB,EAAAvB,OAAA,CACA,MACA,cACAuB,EAAAxB,GAAAwB,EAAAvB,OAGAuB,EAAAP,GAAA3B,EAAA2B,GAAA,EACAO,EAAAxB,GAAAV,EAAAU,GAAA,EACA3J,KAAAmzB,MAAAhoB,EAEA,MAAAnL,MAAAmzB,QAGAntB,EAAAuhB,SAAAve,EAAA8rD,GACA9rD,IAEAnF,EAAA,iHAAAD,GAYA,QAAAy1D,GAAArpD,GACA8kD,EAAA1lD,KAAApP,KAAAgQ,GAZA,GAAA8kD,GAAAlxD,EAAA,iBACAu5B,EAAAv5B,EAAA,wBACAoC,EAAApC,EAAA,gBACA01D,EAAA11D,EAAA,eACA21D,EAAA,GAAAD,GAAA,GA+GA,OArGAD,GAAArtD,WACAkhB,YAAAmsC,EACA/3D,KAAA,QACA8zD,MAAA,SAAAtf,EAAAuf,GACA,GAEAr6C,GAFA/R,EAAAjJ,KAAAiJ,MACAuwD,EAAAvwD,EAAA+R,KAYA,IATA/R,EAAAvI,KAAAo1C,EAAA91C,KAAAq1D,GAGAr6C,EADA,gBAAAw+C,GACAx5D,KAAAy5D,OAGAD,GAGAx+C,GAAAw+C,EAAA,CAEA,GAAAE,GAAAH,EAAA7wD,IAAA8wD,EACA,KAAAE,EAgBA,MAdA1+C,GAAA,GAAAD,OACAC,EAAA2+C,OAAA,WACA3+C,EAAA2+C,OAAA,IACA,QAAAj1D,GAAA,EAAuCA,EAAAg1D,EAAAE,QAAAv1D,OAAiCK,IACxEg1D,EAAAE,QAAAl1D,GAAA2vD,SAGAqF,GACA1+C,QACA4+C,SAAA55D,OAEAgb,EAAAw+C,MACAD,EAAAM,IAAAL,EAAAE,QACA15D,KAAAy5D,OAAAz+C,EAMA,IAHAA,EAAA0+C,EAAA1+C,MACAhb,KAAAy5D,OAAAz+C,GAEAA,EAAAzQ,QAAAyQ,EAAApR,OAEA,WADA8vD,GAAAE,QAAAp4D,KAAAxB,MAKA,GAAAgb,EAAA,CAQA,GAAAzQ,GAAAtB,EAAAsB,OAAAyQ,EAAAzQ,MACAX,EAAAX,EAAAW,QAAAoR,EAAApR,OACAgB,EAAA3B,EAAA2B,GAAA,EACAjB,EAAAV,EAAAU,GAAA,CAEA,KAAAqR,EAAAzQ,QAAAyQ,EAAApR,OACA,MAIA,IADA5J,KAAA41D,aAAA9f,GACA7sC,EAAA6wD,QAAA7wD,EAAA8wD,QAAA,CACA,GAAAC,GAAA/wD,EAAA+wD,IAAA,EACAC,EAAAhxD,EAAAgxD,IAAA,CACAnkB,GAAAokB,UAAAl/C,EAAAg/C,EAAAC,EAAAhxD,EAAA6wD,OAAA7wD,EAAA8wD,QAAAnvD,EAAAjB,EAAAY,EAAAX,OACiB,IAAAX,EAAA+wD,IAAA/wD,EAAAgxD,GAAA,CACjB,GAAAD,GAAA/wD,EAAA+wD,GACAC,EAAAhxD,EAAAgxD,GACAH,EAAAvvD,EAAAyvD,EACAD,EAAAnwD,EAAAqwD,CACAnkB,GAAAokB,UAAAl/C,EAAAg/C,EAAAC,EAAAH,EAAAC,EAAAnvD,EAAAjB,EAAAY,EAAAX,OAEAksC,GAAAokB,UAAAl/C,EAAApQ,EAAAjB,EAAAY,EAAAX,EAGA,OAAAX,EAAAsB,QACAtB,EAAAsB,SAEA,MAAAtB,EAAAW,SACAX,EAAAW,UAEA5J,KAAA02D,iBAAA5gB,GAEA,MAAA7sC,EAAAlH,MACA/B,KAAA22D,aAAA7gB,EAAA91C,KAAAwJ,qBAIAA,gBAAA,WACA,GAAAP,GAAAjJ,KAAAiJ,KAIA,OAHAjJ,MAAAmzB,QACAnzB,KAAAmzB,MAAA,GAAAgK,GAAAl0B,EAAA2B,GAAA,EAAA3B,EAAAU,GAAA,EAAAV,EAAAsB,OAAA,EAAAtB,EAAAW,QAAA,IAEA5J,KAAAmzB,QAGAntB,EAAAuhB,SAAA8xC,EAAAvE,GACAuE,IAEAx1D,EAAA,8DAAAD,GACA,YACA,OAAAA,GAAA,WAAAmJ,QACAzL,KAAA,SACA+J,OACAud,GAAA,EACAC,GAAA,EACArD,EAAA,GAEA0uC,UAAA,SAAApe,EAAAzqC,EAAAwrD,GAGAA,GACA/gB,EAAAqkB,OAAA9uD,EAAAud,GAAAvd,EAAAma,EAAAna,EAAAwd,IAIAitB,EAAA0Q,IAAAn7C,EAAAud,GAAAvd,EAAAwd,GAAAxd,EAAAma,EAAA,IAAA/jB,KAAA0nB,IAAA,QAIAtlB,EAAA,4DAAAD,GACA,MAAAA,GAAA,WAAAmJ,QACAzL,KAAA,OACA+J,OACAud,GAAA,EACAC,GAAA,EACArD,EAAA,EACAyD,GAAA,GAEAirC,UAAA,SAAApe,EAAAzqC,GACA,GAAAT,GAAAS,EAAAud,GACAjf,EAAA0B,EAAAwd,GACAgH,EAAA,EAAApuB,KAAA0nB,EACA2sB,GAAAqkB,OAAAvvD,EAAAS,EAAAma,EAAA7b,GACAmsC,EAAA0Q,IAAA57C,EAAAjB,EAAA0B,EAAAma,EAAA,EAAAqK,GAAA,GACAimB,EAAAqkB,OAAAvvD,EAAAS,EAAA4d,GAAAtf,GACAmsC,EAAA0Q,IAAA57C,EAAAjB,EAAA0B,EAAA4d,GAAA,EAAA4G,GAAA,QAIAhsB,EAAA,8DAAAD,GACA,MAAAA,GAAA,WAAAmJ,QACAzL,KAAA,SACA+J,OACAud,GAAA,EACAC,GAAA,EACAI,GAAA,EACAzD,EAAA,EACAjC,WAAA,EACAC,SAAA,EAAA/hB,KAAA0nB,GACAL,WAAA,GAEAorC,UAAA,SAAApe,EAAAzqC,GACA,GAAAT,GAAAS,EAAAud,GACAjf,EAAA0B,EAAAwd,GACAI,EAAAxnB,KAAA2Y,IAAA/O,EAAA4d,IAAA,KACAzD,EAAA/jB,KAAA2Y,IAAA/O,EAAAma,EAAA,GACAjC,EAAAlY,EAAAkY,WACAC,EAAAnY,EAAAmY,SACAsF,EAAAzd,EAAAyd,UACAsxC,EAAA34D,KAAAiiB,IAAAH,GACA82C,EAAA54D,KAAAmiB,IAAAL,EACAuyB,GAAAqkB,OAAAC,EAAAnxC,EAAAre,EAAAyvD,EAAApxC,EAAAtf,GACAmsC,EAAAwkB,OAAAF,EAAA50C,EAAA5a,EAAAyvD,EAAA70C,EAAA7b,GACAmsC,EAAA0Q,IAAA57C,EAAAjB,EAAA6b,EAAAjC,EAAAC,GAAAsF,GACAgtB,EAAAwkB,OAAA74D,KAAAiiB,IAAAF,GAAAyF,EAAAre,EAAAnJ,KAAAmiB,IAAAJ,GAAAyF,EAAAtf,GACA,IAAAsf,GACA6sB,EAAA0Q,IAAA57C,EAAAjB,EAAAsf,EAAAzF,EAAAD,EAAAuF,GAEAgtB,EAAAykB,iBAIA12D,EAAA,kFAAAD,GACA,GAAA42D,GAAA52D,EAAA,sBACA,OAAAA,GAAA,WAAAmJ,QACAzL,KAAA,OACA+J,OACAma,EAAA,EACA5a,EAAA,EACAjB,EAAA,EACAY,MAAA,EACAX,OAAA,GAEAsqD,UAAA,SAAApe,EAAAzqC,GACA,GAAAT,GAAAS,EAAAT,EACAjB,EAAA0B,EAAA1B,EACAY,EAAAc,EAAAd,MACAX,EAAAyB,EAAAzB,MACAyB,GAAAma,EAGAg1C,EAAAtG,UAAApe,EAAAzqC,GAFAyqC,EAAA3qC,KAAAP,EAAAjB,EAAAY,EAAAX,GAIAksC,EAAAykB,iBAKA12D,EAAA,gFAAAD,GACA,GAAA62D,GAAA72D,EAAA,iBACA,OAAAA,GAAA,WAAAmJ,QACAzL,KAAA,UACA+J,OACAsb,OAAA,KACAW,QAAA,EACAozC,iBAAA,MAEAxG,UAAA,SAAApe,EAAAzqC,GACAovD,EAAAvG,UAAApe,EAAAzqC,GAAA,QAIAxH,EAAA,iFAAAD,GACA,GAAA62D,GAAA72D,EAAA,iBACA,OAAAA,GAAA,WAAAmJ,QACAzL,KAAA,WACA+J,OACAsb,OAAA,KACAW,QAAA,EACAozC,iBAAA,MAEAzxD,OACAme,OAAA,OACAhe,KAAA,MAEA8qD,UAAA,SAAApe,EAAAzqC,GACAovD,EAAAvG,UAAApe,EAAAzqC,GAAA,QAIAxH,EAAA,4DAAAD,GACA,MAAAA,GAAA,WAAAmJ,QACAzL,KAAA,OACA+J,OACAgzB,GAAA,EACAE,GAAA,EACAD,GAAA,EACAE,GAAA,EACAlU,QAAA,GAEArhB,OACAme,OAAA,OACAhe,KAAA,MAEA8qD,UAAA,SAAApe,EAAAzqC,GACA,GAAAgzB,GAAAhzB,EAAAgzB,GACAE,EAAAlzB,EAAAkzB,GACAD,EAAAjzB,EAAAizB,GACAE,EAAAnzB,EAAAmzB,GACAlU,EAAAjf,EAAAif,OACA,KAAAA,IAGAwrB,EAAAqkB,OAAA97B,EAAAE,GACAjU,EAAA,IACAgU,EAAAD,GAAA,EAAA/T,GAAAgU,EAAAhU,EACAkU,EAAAD,GAAA,EAAAjU,GAAAkU,EAAAlU,GAEAwrB,EAAAwkB,OAAAh8B,EAAAE,KAEAm8B,QAAA,SAAAxgC,GACA,GAAA9uB,GAAArL,KAAAqL,KACA,QACAA,EAAAgzB,IAAA,EAAAlE,GAAA9uB,EAAAizB,GAAAnE,EACA9uB,EAAAkzB,IAAA,EAAApE,GAAA9uB,EAAAmzB,GAAArE,QAKAt2B,EAAA,0GAAAD,GACA,YAUA,SAAAg3D,GAAAvvD,EAAAu3C,EAAAiY,GACA,GAAAC,GAAAzvD,EAAAyvD,KACAC,EAAA1vD,EAAA0vD,IACA,eAAAD,GAAA,OAAAC,IAEAF,EAAAG,EAAAC,GAAA5vD,EAAAgzB,GAAAhzB,EAAA6vD,KAAA7vD,EAAAyvD,KAAAzvD,EAAAizB,GAAAskB,IACAiY,EAAAG,EAAAC,GAAA5vD,EAAAkzB,GAAAlzB,EAAA8vD,KAAA9vD,EAAA0vD,KAAA1vD,EAAAmzB,GAAAokB,MAIAiY,EAAAO,EAAAC,GAAAhwD,EAAAgzB,GAAAhzB,EAAA6vD,KAAA7vD,EAAAizB,GAAAskB,IACAiY,EAAAO,EAAAC,GAAAhwD,EAAAkzB,GAAAlzB,EAAA8vD,KAAA9vD,EAAAmzB,GAAAokB,IApBA,GAAA0Y,GAAA13D,EAAA,oBACA23D,EAAA33D,EAAA,qBACA43D,EAAAF,EAAAE,mBACAC,EAAAH,EAAAG,eACAJ,EAAAC,EAAAD,YACAJ,EAAAK,EAAAL,QACAG,EAAAE,EAAAF,sBACAJ,EAAAM,EAAAN,kBACAxiB,IAgBA,OAAA50C,GAAA,WAAAmJ,QACAzL,KAAA,eACA+J,OACAgzB,GAAA,EACAE,GAAA,EACAD,GAAA,EACAE,GAAA,EACA08B,KAAA,EACAC,KAAA,EACA7wC,QAAA,GAEArhB,OACAme,OAAA,OACAhe,KAAA,MAEA8qD,UAAA,SAAApe,EAAAzqC,GACA,GAAAgzB,GAAAhzB,EAAAgzB,GACAE,EAAAlzB,EAAAkzB,GACAD,EAAAjzB,EAAAizB,GACAE,EAAAnzB,EAAAmzB,GACA08B,EAAA7vD,EAAA6vD,KACAC,EAAA9vD,EAAA8vD,KACAL,EAAAzvD,EAAAyvD,KACAC,EAAA1vD,EAAA0vD,KACAzwC,EAAAjf,EAAAif,OACA,KAAAA,IAGAwrB,EAAAqkB,OAAA97B,EAAAE,GACA,MAAAu8B,GAAA,MAAAC,GACAzwC,EAAA,IACAkxC,EAAAn9B,EAAA68B,EAAA58B,EAAAhU,EAAAkuB,GACA0iB,EAAA1iB,EAAA,GACAla,EAAAka,EAAA,GACAgjB,EAAAj9B,EAAA48B,EAAA38B,EAAAlU,EAAAkuB,GACA2iB,EAAA3iB,EAAA,GACAha,EAAAga,EAAA,IAEA1C,EAAA4lB,iBAAAR,EAAAC,EAAA78B,EAAAE,KAEAlU,EAAA,IACAmxC,EAAAp9B,EAAA68B,EAAAJ,EAAAx8B,EAAAhU,EAAAkuB,GACA0iB,EAAA1iB,EAAA,GACAsiB,EAAAtiB,EAAA,GACAla,EAAAka,EAAA,GACAijB,EAAAl9B,EAAA48B,EAAAJ,EAAAv8B,EAAAlU,EAAAkuB,GACA2iB,EAAA3iB,EAAA,GACAuiB,EAAAviB,EAAA,GACAha,EAAAga,EAAA,IAEA1C,EAAA6lB,cAAAT,EAAAC,EAAAL,EAAAC,EAAAz8B,EAAAE,MAGAm8B,QAAA,SAAA/X,GACA,MAAAgY,GAAA56D,KAAAqL,MAAAu3C,GAAA,IAEAgZ,UAAA,SAAAhZ,GACA,GAAAzoB,GAAAygC,EAAA56D,KAAAqL,MAAAu3C,GAAA,EACA,OAAA2Y,GAAAz3D,UAAAq2B,UAIAt2B,EAAA,2DAAAD,GACA,MAAAA,GAAA,WAAAmJ,QACAzL,KAAA,MACA+J,OACAud,GAAA,EACAC,GAAA,EACArD,EAAA,EACAjC,WAAA,EACAC,SAAA,EAAA/hB,KAAA0nB,GACAL,WAAA,GAEA7f,OACAme,OAAA,OACAhe,KAAA,MAEA8qD,UAAA,SAAApe,EAAAzqC,GACA,GAAAT,GAAAS,EAAAud,GACAjf,EAAA0B,EAAAwd,GACArD,EAAA/jB,KAAA2Y,IAAA/O,EAAAma,EAAA,GACAjC,EAAAlY,EAAAkY,WACAC,EAAAnY,EAAAmY,SACAsF,EAAAzd,EAAAyd,UACAsxC,EAAA34D,KAAAiiB,IAAAH,GACA82C,EAAA54D,KAAAmiB,IAAAL,EACAuyB,GAAAqkB,OAAAC,EAAA50C,EAAA5a,EAAAyvD,EAAA70C,EAAA7b,GACAmsC,EAAA0Q,IAAA57C,EAAAjB,EAAA6b,EAAAjC,EAAAC,GAAAsF,QAIAjlB,EAAA,kFAAAD,GACA,YACA,IAAAoC,GAAApC,EAAA,gBACA0hD,EAAA1hD,EAAA,cASAs5B,EAAA,SAAAtyB,EAAAjB,EAAA6b,EAAAhK,EAAAqgD,GACA77D,KAAA4K,EAAA,MAAAA,EAAA,GAAAA,EACA5K,KAAA2J,EAAA,MAAAA,EAAA,GAAAA,EACA3J,KAAAwlB,EAAA,MAAAA,EAAA,GAAAA,EAEAxlB,KAAAsB,KAAA,SAEAtB,KAAAuD,OAAAs4D,IAAA,EACAvW,EAAAl2C,KAAApP,KAAAwb,GAIA,OAFA0hB,GAAAlxB,WAAgCkhB,YAAAgQ,GAChCl3B,EAAAuhB,SAAA2V,EAAAooB,GACApoB,IAEAr5B,EAAA,kFAAAD,GACA,YACA,IAAAoC,GAAApC,EAAA,gBACA0hD,EAAA1hD,EAAA,cAUAq5B,EAAA,SAAAryB,EAAAjB,EAAA20B,EAAAE,EAAAhjB,EAAAqgD,GACA77D,KAAA4K,EAAA,MAAAA,EAAA,EAAAA,EACA5K,KAAA2J,EAAA,MAAAA,EAAA,EAAAA,EACA3J,KAAAs+B,GAAA,MAAAA,EAAA,EAAAA,EACAt+B,KAAAw+B,GAAA,MAAAA,EAAA,EAAAA,EAEAx+B,KAAAsB,KAAA,SAEAtB,KAAAuD,OAAAs4D,IAAA,EACAvW,EAAAl2C,KAAApP,KAAAwb,GAIA,OAFAyhB,GAAAjxB,WAAgCkhB,YAAA+P,GAChCj3B,EAAAuhB,SAAA0V,EAAAqoB,GACAroB,IAEAp5B,EAAA,6DAAAD,GACA,GAAA64B,GAAA74B,EAAA,SACA,OAAA64B,GAAA1vB,QACAzL,KAAA,WACA+J,OAAgBywD,MAAA,MAChBC,iBAAA,WAGA,OAFAvE,GAAAx3D,KAAAk1D,YACA4G,EAAA97D,KAAAqL,MAAAywD,MACAp3D,EAAA,EAA2BA,EAAAo3D,EAAAz3D,OAAkBK,IAE7C8yD,KAAAsE,EAAAp3D,GAAAwwD,WAEAl1D,MAAAk1D,YAAAsC,EACAx3D,KAAA20D,QAAA30D,KAAA20D,SAAA6C,GAEAwE,YAAA,WACAh8D,KAAA+7D,kBAIA,QAHAD,GAAA97D,KAAAqL,MAAAywD,UACA55C,EAAAliB,KAAAs2D,iBAEA5xD,EAAA,EAA2BA,EAAAo3D,EAAAz3D,OAAkBK,IAC7Co3D,EAAAp3D,GAAA+4B,KAAA84B,SAAAr0C,EAAA,GAAAA,EAAA,KAGAgyC,UAAA,SAAApe,EAAAzqC,GAEA,OADAywD,GAAAzwD,EAAAywD,UACAp3D,EAAA,EAA2BA,EAAAo3D,EAAAz3D,OAAkBK,IAC7Co3D,EAAAp3D,GAAAwvD,UAAApe,EAAAgmB,EAAAp3D,GAAA2G,OAAA,IAGA4wD,WAAA,WAEA,OADAH,GAAA97D,KAAAqL,MAAAywD,MACAp3D,EAAA,EAA2BA,EAAAo3D,EAAAz3D,OAAkBK,IAC7Co3D,EAAAp3D,GAAAwwD,aAAA;EAGA1rD,gBAAA,WAEA,MADAxJ,MAAA+7D,mBACAt/B,EAAAzwB,UAAAxC,gBAAA4F,KAAApP,WAIA6D,EAAA,uEAAAD,GACA,YAUA,SAAAu5B,GAAAvyB,EAAAjB,EAAAY,EAAAX,GAIA5J,KAAA4K,IAIA5K,KAAA2J,IAIA3J,KAAAuK,QAIAvK,KAAA4J,SAzBA,GAAA2xD,GAAA33D,EAAA,YACAid,EAAAjd,EAAA,YACAs4D,EAAAX,EAAAz9B,eACA5jB,EAAAzY,KAAAiE,IACAy2D,EAAA16D,KAAAihB,IACAvI,EAAA1Y,KAAA2Y,GAoGA,OA9EA+iB,GAAAnxB,WACAkhB,YAAAiQ,EACA1L,MAAA,SAAAyV,GACA,GAAAt8B,GAAAsP,EAAAgtB,EAAAt8B,EAAA5K,KAAA4K,GACAjB,EAAAuQ,EAAAgtB,EAAAv9B,EAAA3J,KAAA2J,EACA3J,MAAAuK,MAAA4P,EAAA+sB,EAAAt8B,EAAAs8B,EAAA38B,MAAAvK,KAAA4K,EAAA5K,KAAAuK,OAAAK,EACA5K,KAAA4J,OAAAuQ,EAAA+sB,EAAAv9B,EAAAu9B,EAAAt9B,OAAA5J,KAAA2J,EAAA3J,KAAA4J,QAAAD,EACA3J,KAAA4K,IACA5K,KAAA2J,KAEAm0B,eAAA,WACA,GAAAp4B,MACA0U,IACA,iBAAA4jB,GAIAA,IAGAt4B,EAAA,GAAA1F,KAAA4K,EACAlF,EAAA,GAAA1F,KAAA2J,EACAyQ,EAAA,GAAApa,KAAA4K,EAAA5K,KAAAuK,MACA6P,EAAA,GAAApa,KAAA2J,EAAA3J,KAAA4J,OACAsyD,EAAAx2D,IAAAs4B,GACAk+B,EAAA9hD,IAAA4jB,GACAh+B,KAAA4K,EAAAsP,EAAAxU,EAAA,GAAA0U,EAAA,IACApa,KAAA2J,EAAAuQ,EAAAxU,EAAA,GAAA0U,EAAA,IACApa,KAAAuK,MAAA4xD,EAAA/hD,EAAA,GAAA1U,EAAA,IACA1F,KAAA4J,OAAAuyD,EAAA/hD,EAAA,GAAA1U,EAAA,SAGAu4B,mBAAA,SAAA/tB,GACA,GAAAxD,GAAA1M,KACAg6D,EAAA9pD,EAAA3F,MAAAmC,EAAAnC,MACA0vD,EAAA/pD,EAAAtG,OAAA8C,EAAA9C,OACAo0B,EAAAnd,EAAAxR,QAcA,OAZAwR,GAAAwmC,UAAArpB,MACAtxB,EAAA9B,GACA8B,EAAA/C,IAEAkX,EAAAqB,MAAA8b,KACAg8B,EACAC,IAEAp5C,EAAAwmC,UAAArpB,KACA9tB,EAAAtF,EACAsF,EAAAvG,IAEAq0B,GAEAuyB,UAAA,SAAArgD,GACA,GAAAxD,GAAA1M,KACAo8D,EAAA1vD,EAAA9B,EACAyxD,EAAA3vD,EAAA9B,EAAA8B,EAAAnC,MACA+xD,EAAA5vD,EAAA/C,EACA4yD,EAAA7vD,EAAA/C,EAAA+C,EAAA9C,OACA4yD,EAAAtsD,EAAAtF,EACA6xD,EAAAvsD,EAAAtF,EAAAsF,EAAA3F,MACAmyD,EAAAxsD,EAAAvG,EACAgzD,EAAAzsD,EAAAvG,EAAAuG,EAAAtG,MACA,SAAAyyD,EAAAG,GAAAC,EAAAL,GAAAG,EAAAG,GAAAC,EAAAL,IAEAlN,QAAA,SAAAxkD,EAAAjB,GACA,GAAAwB,GAAAnL,IACA,OAAA4K,IAAAO,EAAAP,MAAAO,EAAAP,EAAAO,EAAAZ,OAAAZ,GAAAwB,EAAAxB,MAAAwB,EAAAxB,EAAAwB,EAAAvB,QAEA+G,MAAA,WACA,UAAAwsB,GAAAn9B,KAAA4K,EAAA5K,KAAA2J,EAAA3J,KAAAuK,MAAAvK,KAAA4J,SAEAk5B,KAAA,SAAAoE,GACAlnC,KAAA4K,EAAAs8B,EAAAt8B,EACA5K,KAAA2J,EAAAu9B,EAAAv9B,EACA3J,KAAAuK,MAAA28B,EAAA38B,MACAvK,KAAA4J,OAAAs9B,EAAAt9B,SAGAuzB,IAEAt5B,EAAA,kFAAAD,GAOA,QAAAg5D,GAAA76D,EAAAmH,GACA,GAAAiW,GAAApd,EAAA,IAAAmH,CACA,IAAA2zD,EAAA19C,GACA,MAAA09C,GAAA19C,EAIA,QAFA+5C,IAAAn3D,EAAA,IAAAmC,MAAA,MACAqG,EAAA,EACA7F,EAAA,EAAAe,EAAAyzD,EAAA70D,OAA6CK,EAAAe,EAAOf,IAEpD6F,EAAA9I,KAAA2Y,IAAAirB,EAAA4zB,YAAAC,EAAAx0D,GAAAwE,GAAAqB,QAQA,OANAuyD,GAAAC,IACAD,EAAA,EACAD,MAEAC,IACAD,EAAA19C,GAAA5U,EACAA,EAEA,QAAAinB,GAAAzvB,EAAAmH,EAAAlH,EAAA8G,GACA,GAAAk0D,KAAAj7D,GAAA,QAAAmC,MAAA,MAAAG,OACAkG,EAAAqyD,EAAA76D,EAAAmH,GAEA8vD,EAAA4D,EAAA,IAAA1zD,GACAU,EAAAozD,EAAAhE,EACA7tD,EAAA,GAAAgyB,GAAA,IAAA5yB,EAAAX,EAGA,QADAuB,EAAA6tD,aACAlwD,GACA,aACA,iBACAqC,EAAAxB,GAAAqvD,CACA,MACA,cACA7tD,EAAAxB,GAAAqvD,EAAA,EAKA,OAAAh3D,GACA,UACA,YACAmJ,EAAAP,GAAAO,EAAAZ,KACA,MACA,cACAY,EAAAP,GAAAO,EAAAZ,MAAA,EAIA,MAAAY,GAEA,QAAA8xD,GAAA3lC,EAAAnsB,EAAA5B,EAAAwlD,GACA,GAAAnkD,GAAAO,EAAAP,EACAjB,EAAAwB,EAAAxB,EACAC,EAAAuB,EAAAvB,OACAW,EAAAY,EAAAZ,MACA2yD,EAAA3zD,EAAAK,OACAuzD,EAAAvzD,EAAA,EAAAszD,EAAA,EACAl7D,EAAA,MACA,QAAAs1B,GACA,WACA1sB,GAAAmkD,EACAplD,GAAAwzD,EACAn7D,EAAA,OACA,MACA,aACA4I,GAAAmkD,EAAAxkD,EACAZ,GAAAwzD,EACAn7D,EAAA,MACA,MACA,WACA4I,GAAAL,EAAA,EACAZ,GAAAolD,EAAAmO,EACAl7D,EAAA,QACA,MACA,cACA4I,GAAAL,EAAA,EACAZ,GAAAC,EAAAmlD,EACA/sD,EAAA,QACA,MACA,cACA4I,GAAAL,EAAA,EACAZ,GAAAwzD,EACAn7D,EAAA,QACA,MACA,kBACA4I,GAAAmkD,EACAplD,GAAAwzD,EACAn7D,EAAA,MACA,MACA,mBACA4I,GAAAL,EAAAwkD,EACAplD,GAAAwzD,EACAn7D,EAAA,OACA,MACA,iBACA4I,GAAAL,EAAA,EACAZ,GAAAolD,EACA/sD,EAAA,QACA,MACA,oBACA4I,GAAAL,EAAA,EACAZ,GAAAC,EAAAszD,EAAAnO,EACA/sD,EAAA,QACA,MACA,qBACA4I,GAAAmkD,EACAplD,GAAAolD,EACA/sD,EAAA,MACA,MACA,sBACA4I,GAAAL,EAAAwkD,EACAplD,GAAAolD,EACA/sD,EAAA,OACA,MACA,wBACA4I,GAAAmkD,EACAplD,GAAAC,EAAAszD,EAAAnO,CACA,MACA,yBACAnkD,GAAAL,EAAAwkD,EACAplD,GAAAC,EAAAszD,EAAAnO,EACA/sD,EAAA,QAGA,OACA4I,IACAjB,IACA3H,YACA8G,aAAA,OAkBA,QAAAi+B,GAAAhlC,EAAA8/B,EAAA34B,EAAAk0D,EAAAt6D,GACA,IAAA++B,EACA,QAEA/+B,SACAs6D,EAAAl4C,EAAAk4C,EAAA,MAcA,QAbAC,GAAAn4C,EAAApiB,EAAAu6D,cAAA,GACAC,EAAAp4C,EAAApiB,EAAAw6D,QAAA,GAGAC,EAAAX,EAAA,IAAA1zD,GAGAs0D,EAAAZ,EAAA,IAAA1zD,GACAu0D,EAAAv4C,EAAApiB,EAAA26D,YAAA,IAGAC,EAAA77B,EAAApgC,KAAA2Y,IAAA,EAAAynB,EAAA,GAEAn9B,EAAA,EAAuBA,EAAA44D,GAAAI,GAAAF,EAA6C94D,IACpEg5D,GAAAF,CAEA,IAAAG,GAAAf,EAAAQ,EACAO,GAAAD,IACAN,EAAA,GACAO,EAAA,GAEAD,EAAA77B,EAAA87B,CAEA,QADAzE,IAAAn3D,EAAA,IAAAmC,MAAA,MACAQ,EAAA,EAAAonB,EAAAotC,EAAA70D,OAA+CK,EAAAonB,EAASpnB,IAAA,CACxD,GAAAk5D,GAAA1E,EAAAx0D,GACAwxB,EAAA0mC,EAAAgB,EAAA10D,EACA,MAAAgtB,GAAA2L,GAAA,CAGA,OAAAg8B,GAAA,GAA4BA,IAAA,CAC5B,GAAA3nC,GAAAwnC,GAAAG,GAAAR,EAAA,CACAO,GAAAR,CACA,OAEA,GAAAU,GAAA,IAAAD,EAAAE,EAAAH,EAAAF,EAAAF,EAAAD,GAAArnC,EAAA,EAAAz0B,KAAA2K,MAAAwxD,EAAAv5D,OAAAq5D,EAAAxnC,GAAA,CACA0nC,KAAA92B,OAAA,EAAAg3B,GACA5nC,EAAA0mC,EAAAgB,EAAA10D,GAEA,KAAA00D,IACAA,EAAAH,GAEAvE,EAAAx0D,GAAAk5D,GAEA,MAAA1E,GAAAr0D,KAAA,MAEA,QAAAk5D,GAAAh8D,EAAA27D,EAAAF,EAAAD,GAGA,OAFAhzD,GAAA,EACA7F,EAAA,EACAonB,EAAA/pB,EAAAsC,OAAmCK,EAAAonB,GAAAvhB,EAAAmzD,EAAiCh5D,IAAA,CACpE,GAAAs5D,GAAAj8D,EAAAk8D,WAAAv5D,EACA6F,IAAA,GAAAyzD,MAAA,IAAAR,EAAAD,EAEA,MAAA74D,GAnNA,GAAAm4D,MACAC,EAAA,EACAC,EAAA,IACAh8C,EAAAnd,EAAA,gBACAu5B,EAAAv5B,EAAA,wBACAshB,EAAAnE,EAAAmE,SAgNAmgB,GACA36B,SAAAkyD,EACApzD,gBAAAgoB,EACAyrC,2BACAl2B,eACAkyB,YAAA,SAAAl3D,EAAAmH,GACA,GAAA4sC,GAAA/0B,EAAA2L,YAEA,OADAopB,GAAAhvB,KAAA5d,GAAA,kBACA4sC,EAAAmjB,YAAAl3D,IAGA,OAAAsjC,KAEAxhC,EAAA,qGAAAD,GACA,GAAAiI,GAAAjI,EAAA,YACAs6D,EAAAt6D,EAAA,YACA8c,EAAA9c,EAAA,kBACAoC,EAAApC,EAAA,qBACAwlB,IA2RA,OArRAA,GAAA0hB,iBAAA,SAAApsC,GACA,MAAAA,aAAAyG,OAAAzG,EAAA,MAAAA,UAoBA0qB,EAAAqB,gBAAA,SAAA6X,EAAA67B,GACA,GAAA77B,EAAA,CACA,GAAA87B,GAAA97B,EAAAzX,SAAAyX,EAAAzX,aACAwzC,EAAA/7B,EAAA3X,OAAA2X,EAAA3X,UAEA3kB,GAAAkJ,KAAAivD,EAAA,SAAAG,GACA,GAAArxD,GAAAjH,EAAAkf,SAAAk5C,EAAAE,GAAAD,EAAAC,GACA,OAAArxD,IACAmxD,EAAAE,GAAArxD,OAKAmc,EAAAgnB,eACA,WACA,OACA,YACA,WACA,aAQAhnB,EAAAqiC,iBAAA,SAAAH,GAEA,MAAAA,KAAA,MAAAA,EAAA5sD,MAAA4sD,IAAA5sD,QAOA0qB,EAAAsiC,iBAAA,SAAAJ,GACA,MAAAtlD,GAAAqW,SAAAivC,kBAAAnmD,SAQAikB,EAAAuiC,gBAAA,SAAAjtD,EAAAqyC,GAEA,GAAAE,GAAAF,KAAAzvC,IACA,mBAAA2vC,EACAvyC,GAEA,SAAAuyC,GAAAvJ,SAAAhpC,IAAA,MAAAA,GAAA,MAAAA,IACAA,GAAAw/D,EAAAjvD,UAAAvQ,IAKA,MAAAA,GAAA,KAAAA,EAAAo3B,KAAAp3B,IAWA0qB,EAAAm1C,sBAAA,SAAA1/D,EAAAyjC,GACA,GAAAhvB,GAAA,GAAAoN,EASA,OARA1a,GAAAsS,MAAAhF,EAAA8V,EAAAmoB,iBACAj+B,EAAAsK,YAAA0kB,EAAA1kB,YACAtK,EAAAjR,KAAAigC,EAAAjgC,MAAA,GACAiR,EAAArB,SAAAqwB,EAAArwB,SACAqB,EAAAqY,QAAA2W,EAAA3W,QACArY,EAAA3M,QAAA,WACA,MAAA9H,IAEAyU,GAGA8V,EAAAmoB,iBACA1zB,cAAA,SAAAJ,EAAAK,GACA,GAAAjf,GAAAmB,KAAA2G,QAAAmX,GACAF,EAAA5d,KAAA4d,YACAwzB,EAAApxC,KAAAqC,KACAm8D,EAAAx+D,KAAA23B,YAAAla,EAAAK,GACA2gD,EAAA5/D,EAAA0wB,YAAA9R,GACApb,EAAAxD,EAAAikB,QAAArF,GAAA,GACAihD,EAAA7/D,EAAA6tD,eAAAjvC,EACA,QACApK,cAAArT,KAAAiS,SACA0sD,iBAAA3+D,KAAA2rB,QACAH,WAAA,WAAAxrB,KAAAiS,SAAAjS,KAAA2rB,QAAA,KACA/N,cACAwzB,aACA/uC,OACAob,UAAAghD,EACA5/D,KAAA6/D,EACA5gD,WACApf,MAAA8/D,EACAt2D,MAAArJ,EAAAmmB,cAAAvH,EAAA,SACA+M,OACA,aACA,OACA,WAIApF,kBAAA,SAAA3H,EAAAlH,EAAAuH,EAAA0tC,GACAj1C,KAAA,QACA,IAAA1X,GAAAmB,KAAA2G,QAAAmX,GACA4H,EAAA7mB,EAAA8mB,aAAAlI,GACArd,EAAAJ,KAAA6d,cAAAJ,EAAAK,EACA,OAAA0tC,GAAAprD,EAAA1B,gBAAAyG,SACA/E,EAAA1B,MAAA0B,EAAA1B,MAAA8sD,GAEA,IAAAoT,GAAAl5C,EAAAhd,KACA,QACA6N,EACA,aAEA,yBAAAqoD,IACAx+D,EAAAmW,SACAqoD,EAAAx+D,IACa,gBAAAw+D,GACb/yD,EAAAk6B,UAAA64B,EAAAx+D,GADa,QAIbu3B,YAAA,SAAAjpB,EAAAoP,GACA,GAAAjf,GAAAmB,KAAA2G,QAAAmX,GACAwtC,EAAAzsD,EAAA6tD,eAAAh+C,EACA,UAAA48C,EACA,OAAAtlD,EAAAqW,SAAAivC,gBAAAnmD,OAAAmmD,IAAA5sD,OAGAkyC,cAAA5qC,EAAAwa,MAWA4I,EAAA2hB,gBAAA,SAAA8zB,EAAAC,GAOAA,UAAAn6D,OACA,IAAAknB,GAAA7lB,EAAA+W,IAAA8hD,MAAA,SAAAxgE,EAAA8T,GACA,OAAwBq3B,MAAAnrC,IAyCxB,OAtCA2H,GAAAkJ,KAAA4vD,EAAA,SAAAC,EAAA5sD,GACA,GAAAnM,EAAAqW,SAAA0iD,GAAA,CAIA,OAAAr6D,GAAA,EAA2BA,EAAAmnB,EAAAxnB,OAAmBK,IAC9C,IAAAmnB,EAAAnnB,GAAArD,QAAA,MAAA09D,EAAA5+D,IAAA0rB,EAAAnnB,GAAA8kC,MAAArpC,KAAA4+D,EAAA5+D,GAAA,GAGA,MAFA0rB,GAAAnnB,GAAArD,OAAA09D,OACAD,EAAA3sD,GAAA,KAIA,QAAAzN,GAAA,EAA2BA,EAAAmnB,EAAAxnB,OAAmBK,IAAA,CAC9C,GAAA8kC,GAAA3d,EAAAnnB,GAAA8kC,KACA,MAAA3d,EAAAnnB,GAAArD,QAAA,MAAAmoC,EAAArpC,IAAA,MAAA4+D,EAAA5+D,IAAA,MAAA4+D,EAAA18D,MAAA+mB,EAAAqiB,UAAAszB,IAAA31C,EAAAqiB,UAAAjC,MAAAnnC,OAAA08D,EAAA18D,KAAA,IAGA,MAFAwpB,GAAAnnB,GAAArD,OAAA09D,OACAD,EAAA3sD,GAAA,UAMAnM,EAAAkJ,KAAA4vD,EAAA,SAAAC,EAAA5sD,GACA,GAAAnM,EAAAqW,SAAA0iD,GAAA,CAIA,IADA,GAAAr6D,GAAA,EACkBA,EAAAmnB,EAAAxnB,OAAmBK,IAAA,CACrC,GAAA8kC,GAAA3d,EAAAnnB,GAAA8kC,KACA,KAAA3d,EAAAnnB,GAAArD,SAAA+nB,EAAAqiB,UAAAjC,IAAA,MAAAu1B,EAAA5+D,GAAA,CACA0rB,EAAAnnB,GAAArD,OAAA09D,CACA,QAGAr6D,GAAAmnB,EAAAxnB,QACAwnB,EAAArqB,MAA6BH,OAAA09D,OAG7BlzC,GAOAzC,EAAAqiB,UAAA,SAAAszB,GACA,MAAA/4D,GAAAqW,SAAA0iD,MAAA5+D,IAAA,KAAA4+D,EAAA5+D,GAAA,IAAA6D,QAAA,aAUAolB,EAAA41C,gBAAA,SAAAC,EAAAC,GASA,QAAAC,GAAAC,EAAAriD,EAAAsiD,GACA,OAAA36D,GAAA,EAAAonB,EAAAszC,EAAA/6D,OAAqDK,EAAAonB,EAASpnB,IAI9D,OAHAue,GAAAm8C,EAAA16D,GAAAue,SACA8vB,EAAA3pB,EAAA0hB,iBAAAs0B,EAAA16D,GAAA+Y,WACA6hD,EAAAD,KAAAp8C,GACA46C,EAAA,EAAA0B,EAAAxsB,EAAA1uC,OAA0Dw5D,EAAA0B,EAAU1B,IAAA,CACpE,GAAApgD,GAAAs1B,EAAA8qB,EACAyB,MAAA7hD,GACA6hD,EAAA7hD,GAAA,MAEAV,EAAAkG,KAAAlG,EAAAkG,QAA6DxF,GAAA,GAK7D,QAAA+hD,GAAAziD,EAAA0iD,GACA,GAAA5zC,KACA,QAAAnnB,KAAAqY,GACA,GAAAA,EAAAiP,eAAAtnB,IAAA,MAAAqY,EAAArY,GACA,GAAA+6D,EACA5zC,EAAArqB,MAAAkD,OACqB,CACrB,GAAAquC,GAAAysB,EAAAziD,EAAArY,IAAA,EACAquC,GAAA1uC,QAAAwnB,EAAArqB,MACAyhB,SAAAve,EACA+Y,UAAAs1B,IAKA,MAAAlnB,GAtCA,GAAA6zC,MACAC,IAGA,OAFAR,GAAAF,MAAAS,GACAP,EAAAD,MAAAS,EAAAD,IAEAF,EAAAE,GACAF,EAAAG,KAmCAv2C,IAEAvlB,EAAA,4CACA,GAAA+7D,GAAA,EAKA,OAHA,mBAAAt3B,aACAs3B,EAAAt3B,UAAAs3B,UAAA,KAGA13D,OACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WAEAH,WACA83D,WAAAD,EAAA97B,MAAA,uCACA97B,SAAA,GACA83D,UAAA,SACA73D,WAAA,UAEA+N,UAAA,KACArE,WAAA,EACAouD,kBAAA,IACAC,wBAAA,IACAz0C,gBAAA,iBACA00C,sBAAA,WACAC,mBAAA,IACAC,qBAAA,IACArqD,YAAA,IACAsqD,oBAAA,OAGAv8D,EAAA,iDACA,OACAoR,kBAAA,WACAjV,KAAAqgE,UAAA,EACArgE,KAAAsgE,kBAEA3wC,oBAAA,SAAAttB,EAAAgvC,GACAA,KAAArxC,IACA,IAAAugE,GAAAlvB,EAAAgvB,WAAA,EACAG,EAAAnvB,EAAAivB,gBAAAjvB,EAAAivB,iBACA,IAAAE,EAAAn+D,GACA,MAAAm+D,GAAAn+D,EAEA,IAAAo+D,GAAAzgE,KAAA0I,IAAA,eACA,IAAA+3D,EAAAp8D,OAAA,CAGA,GAAA6D,GAAAu4D,EAAAF,EAKA,OAJAl+D,KACAm+D,EAAAn+D,GAAA6F,GAEAmpC,EAAAgvB,WAAAE,EAAA,GAAAE,EAAAp8D,OACA6D,OAIArE,EAAA,yGAAAD,GACA,YACA,IAAA88D,GAAA98D,EAAA,WACA23D,EAAA33D,EAAA,YACA+8D,EAAA/8D,EAAA,UACAu5B,EAAAv5B,EAAA,kBACA4W,EAAA5W,EAAA,aAAA6M,iBACA8iD,GACAjtB,EAAA,EACA0R,EAAA,EACA2b,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACApc,EAAA,GAEAhyC,KACA0U,KACAwmD,KACAC,KACA3mD,EAAAzY,KAAAiE,IACAyU,EAAA1Y,KAAA2Y,IACA83C,EAAAzwD,KAAAiiB,IACAyuC,EAAA1wD,KAAAmiB,IACA0uC,EAAA7wD,KAAAktD,KACAwN,EAAA16D,KAAAihB,IACAo+C,EAAA,mBAAAha,cAKAwM,EAAA,WAKAtzD,KAAAnB,QACAmB,KAAA+gE,KAAA,EACA/gE,KAAA2sB,KAAA,KACA3sB,KAAAghE,IAAA,EACAhhE,KAAAihE,IAAA,EACAjhE,KAAAkhE,IAAA,EACAlhE,KAAAmhE,IAAA,EAEAnhE,KAAAohE,IAAA,EACAphE,KAAAqhE,IAAA,EAseA,OAheA/N,GAAAtnD,WACAkhB,YAAAomC,EACAgO,UAAA,KACAC,YAAA,EACAC,SAAA,EACAC,SAAA,EACAlL,SAAA,SAAAyD,EAAAC,GACAj6D,KAAAohE,IAAAjF,EAAA,EAAA3hD,EAAAw/C,IAAA,EACAh6D,KAAAqhE,IAAAlF,EAAA,EAAA3hD,EAAAy/C,IAAA,GAEAvtC,WAAA,WACA,MAAA1sB,MAAA2sB,MAEA6pC,UAAA,SAAA1gB,GAUA,MATA91C,MAAA2sB,KAAAmpB,EACAA,KAAA0gB,YACA1gB,IAAA91C,KAAAwa,IAAAs7B,EAAAt7B,KAEAxa,KAAA+gE,KAAA,EACA/gE,KAAAshE,YACAthE,KAAAshE,UAAA,KACAthE,KAAAuhE,YAAA,GAEAvhE,MAEAm6D,OAAA,SAAAvvD,EAAAjB,GAWA,MAVA3J,MAAA8yD,QAAAS,EAAAjtB,EAAA17B,EAAAjB,GACA3J,KAAA2sB,MAAA3sB,KAAA2sB,KAAAwtC,OAAAvvD,EAAAjB,GAKA3J,KAAAkhE,IAAAt2D,EACA5K,KAAAmhE,IAAAx3D,EACA3J,KAAAghE,IAAAp2D,EACA5K,KAAAihE,IAAAt3D,EACA3J,MAEAs6D,OAAA,SAAA1vD,EAAAjB,GACA,GAAA+3D,GAAAvF,EAAAvxD,EAAA5K,KAAAghE,KAAAhhE,KAAAohE,KAAAjF,EAAAxyD,EAAA3J,KAAAihE,KAAAjhE,KAAAqhE,KAAArhE,KAAA+gE,KAAA,CASA,OARA/gE,MAAA8yD,QAAAS,EAAAvb,EAAAptC,EAAAjB,GACA3J,KAAA2sB,MAAA+0C,IACA1hE,KAAA2hE,aAAA3hE,KAAA4hE,cAAAh3D,EAAAjB,GAAA3J,KAAA2sB,KAAA2tC,OAAA1vD,EAAAjB,IAEA+3D,IACA1hE,KAAAghE,IAAAp2D,EACA5K,KAAAihE,IAAAt3D,GAEA3J,MAEA27D,cAAA,SAAAt9B,EAAAE,EAAAD,EAAAE,EAAAqjC,EAAAC,GAOA,MANA9hE,MAAA8yD,QAAAS,EAAAI,EAAAt1B,EAAAE,EAAAD,EAAAE,EAAAqjC,EAAAC,GACA9hE,KAAA2sB,OACA3sB,KAAA2hE,aAAA3hE,KAAA+hE,gBAAA1jC,EAAAE,EAAAD,EAAAE,EAAAqjC,EAAAC,GAAA9hE,KAAA2sB,KAAAgvC,cAAAt9B,EAAAE,EAAAD,EAAAE,EAAAqjC,EAAAC,IAEA9hE,KAAAghE,IAAAa,EACA7hE,KAAAihE,IAAAa,EACA9hE,MAEA07D,iBAAA,SAAAr9B,EAAAE,EAAAD,EAAAE,GAOA,MANAx+B,MAAA8yD,QAAAS,EAAAK,EAAAv1B,EAAAE,EAAAD,EAAAE,GACAx+B,KAAA2sB,OACA3sB,KAAA2hE,aAAA3hE,KAAAgiE,mBAAA3jC,EAAAE,EAAAD,EAAAE,GAAAx+B,KAAA2sB,KAAA+uC,iBAAAr9B,EAAAE,EAAAD,EAAAE,IAEAx+B,KAAAghE,IAAA1iC,EACAt+B,KAAAihE,IAAAziC,EACAx+B,MAEAwmD,IAAA,SAAA59B,EAAAC,EAAArD,EAAAjC,EAAAC,EAAAy+C,GAKA,MAJAjiE,MAAA8yD,QAAAS,EAAAM,EAAAjrC,EAAAC,EAAArD,IAAAjC,EAAAC,EAAAD,EAAA,EAAA0+C,EAAA,KACAjiE,KAAA2sB,MAAA3sB,KAAA2sB,KAAA65B,IAAA59B,EAAAC,EAAArD,EAAAjC,EAAAC,EAAAy+C,GACAjiE,KAAAghE,IAAA9O,EAAA1uC,GAAAgC,EAAAoD,EACA5oB,KAAAghE,IAAA7O,EAAA3uC,GAAAgC,EAAAoD,EACA5oB,MAEAkiE,MAAA,SAAA7jC,EAAAE,EAAAD,EAAAE,EAAAp8B,GAIA,MAHApC,MAAA2sB,MACA3sB,KAAA2sB,KAAAu1C,MAAA7jC,EAAAE,EAAAD,EAAAE,EAAAp8B,GAEApC,MAEAmL,KAAA,SAAAP,EAAAjB,EAAAstD,EAAA1wB,GAGA,MAFAvmC,MAAA2sB,MAAA3sB,KAAA2sB,KAAAxhB,KAAAP,EAAAjB,EAAAstD,EAAA1wB,GACAvmC,KAAA8yD,QAAAS,EAAA7b,EAAA9sC,EAAAjB,EAAAstD,EAAA1wB,GACAvmC,MAEAu6D,UAAA,WACAv6D,KAAA8yD,QAAAS,EAAAO,EACA,IAAAhe,GAAA91C,KAAA2sB,KACAw1C,EAAAniE,KAAAkhE,IACAkB,EAAApiE,KAAAmhE,GAOA,OANArrB,KACA91C,KAAA2hE,cAAA3hE,KAAA4hE,cAAAO,EAAAC,GACAtsB,EAAAykB,aAEAv6D,KAAAghE,IAAAmB,EACAniE,KAAAihE,IAAAmB,EACApiE,MAEAoJ,KAAA,SAAA0sC,GACAA,KAAA1sC,OACApJ,KAAA+zD,YAEA3sC,OAAA,SAAA0uB,GACAA,KAAA1uB,SACApnB,KAAA+zD,YAEAsC,YAAA,SAAAH,GACA,GAAAA,YAAA/wD,OAAA,CACAnF,KAAAshE,UAAApL,EACAl2D,KAAAwhE,SAAA,CAEA,QADAa,GAAA,EACA39D,EAAA,EAA+BA,EAAAwxD,EAAA7xD,OAAqBK,IACpD29D,GAAAnM,EAAAxxD,EAEA1E,MAAAyhE,SAAAY,EAEA,MAAAriE,OAEAy2D,kBAAA,SAAA5yC,GAEA,MADA7jB,MAAAuhE,YAAA19C,EACA7jB,MAEA8rB,IAAA,WACA,MAAA9rB,MAAA+gE,MAEAvwB,QAAA,SAAA3xC,GACA,GAAAitB,GAAAjtB,EAAAwF,MACArE,MAAAnB,MAAAmB,KAAAnB,KAAAwF,QAAAynB,IAAAg1C,IACA9gE,KAAAnB,KAAA,GAAAioD,cAAAh7B,GAEA,QAAApnB,GAAA,EAA2BA,EAAAonB,EAASpnB,IACpC1E,KAAAnB,KAAA6F,GAAA7F,EAAA6F,EAEA1E,MAAA+gE,KAAAj1C,GAEA+oC,WAAA,SAAAp3B,GACAA,YAAAt4B,SACAs4B,MAKA,QAHA3R,GAAA2R,EAAAp5B,OACAi+D,EAAA,EACAz+C,EAAA7jB,KAAA+gE,KACAr8D,EAAA,EAA2BA,EAAAonB,EAASpnB,IACpC49D,GAAA7kC,EAAA/4B,GAAAonB,KAEAg1C,IAAA9gE,KAAAnB,eAAAioD,gBACA9mD,KAAAnB,KAAA,GAAAioD,cAAAjjC,EAAAy+C,GAEA,QAAA59D,GAAA,EAA2BA,EAAAonB,EAASpnB,IAEpC,OADA69D,GAAA9kC,EAAA/4B,GAAA7F,KACAunC,EAAA,EAA+BA,EAAAm8B,EAAAl+D,OAA2B+hC,IAC1DpmC,KAAAnB,KAAAglB,KAAA0+C,EAAAn8B,EAGApmC,MAAA+gE,KAAAl9C,GAEAivC,QAAA,SAAAf,GACA,GAAAlzD,GAAAmB,KAAAnB,IACAmB,MAAA+gE,KAAAt3C,UAAAplB,OAAAxF,EAAAwF,SAGArE,KAAAwiE,cACA3jE,EAAAmB,KAAAnB,KAEA,QAAA6F,GAAA,EAA2BA,EAAA+kB,UAAAplB,OAAsBK,IACjD7F,EAAAmB,KAAA+gE,QAAAt3C,UAAA/kB,EAEA1E,MAAAyiE,SAAA1Q,GAEAyQ,YAAA,WAEA,KAAAxiE,KAAAnB,eAAAsG,QAAA,CAEA,OADAu9D,MACAh+D,EAAA,EAA+BA,EAAA1E,KAAA+gE,KAAer8D,IAC9Cg+D,EAAAh+D,GAAA1E,KAAAnB,KAAA6F,EAEA1E,MAAAnB,KAAA6jE,IAGAf,WAAA,WACA,MAAA3hE,MAAAshE,WAEAM,cAAA,SAAAvjC,EAAAE,GACA,GAWAokC,GAEAj0D,EAbAk0D,EAAA5iE,KAAAyhE,SACA59C,EAAA7jB,KAAAuhE,YACArL,EAAAl2D,KAAAshE,UACAxrB,EAAA91C,KAAA2sB,KACAw1C,EAAAniE,KAAAghE,IACAoB,EAAApiE,KAAAihE,IACAx9C,EAAA4a,EAAA8jC,EACAx+C,EAAA4a,EAAA6jC,EACA3V,EAAA6F,EAAA7uC,IAAAE,KACA/Y,EAAAu3D,EACAx4D,EAAAy4D,EAEAS,EAAA3M,EAAA7xD,MAWA,KATAof,GAAAgpC,EACA9oC,GAAA8oC,EACA5oC,EAAA,IAEAA,EAAA++C,EAAA/+C,GAEAA,GAAA++C,EACAh4D,GAAAiZ,EAAAJ,EACA9Z,GAAAka,EAAAF,EACAF,EAAA,GAAA7Y,GAAAyzB,GAAA5a,EAAA,GAAA7Y,GAAAyzB,GAAA,GAAA5a,IAAAE,EAAA,GAAAha,GAAA40B,GAAA5a,EAAA,GAAAha,GAAA40B,IACA7vB,EAAA1O,KAAAwhE,SACAmB,EAAAzM,EAAAxnD,GACA9D,GAAA6Y,EAAAk/C,EACAh5D,GAAAga,EAAAg/C,EACA3iE,KAAAwhE,UAAA9yD,EAAA,GAAAm0D,EAEAp/C,EAAA,GAAA7Y,EAAAu3D,GAAA1+C,EAAA,GAAA7Y,EAAAu3D,GAAAx+C,EAAA,GAAAha,EAAAy4D,GAAAz+C,EAAA,GAAAha,EAAAy4D,GAGAtsB,EAAApnC,EAAA,qBAAA+U,GAAA,EAAAvJ,EAAAtP,EAAAyzB,GAAAlkB,EAAAvP,EAAAyzB,GAAA1a,GAAA,EAAAzJ,EAAAvQ,EAAA40B,GAAApkB,EAAAxQ,EAAA40B,GAGA9a,GAAA7Y,EAAAyzB,EACA1a,EAAAha,EAAA40B,EACAv+B,KAAAuhE,aAAAjP,EAAA7uC,IAAAE,MAEAo+C,gBAAA,SAAA1jC,EAAAE,EAAAD,EAAAE,EAAAqjC,EAAAC,GACA,GAMAlf,GACAn/B,EACAE,EAKA/Y,EACAjB,EAdAi5D,EAAA5iE,KAAAyhE,SACA59C,EAAA7jB,KAAAuhE,YACArL,EAAAl2D,KAAAshE,UACAxrB,EAAA91C,KAAA2sB,KACAw1C,EAAAniE,KAAAghE,IACAoB,EAAApiE,KAAAihE,IAIAhG,EAAAyF,EAAAzF,QACA6H,EAAA,EACAp0D,EAAA1O,KAAAwhE,SACAqB,EAAA3M,EAAA7xD,OAGA0+D,EAAA,CAOA,KANAl/C,EAAA,IAEAA,EAAA++C,EAAA/+C,GAEAA,GAAA++C,EAEAhgB,EAAA,EAAuBA,EAAA,EAAOA,GAAA,GAC9Bn/B,EAAAw3C,EAAAkH,EAAA9jC,EAAAC,EAAAujC,EAAAjf,EAAA,IAAAqY,EAAAkH,EAAA9jC,EAAAC,EAAAujC,EAAAjf,GACAj/B,EAAAs3C,EAAAmH,EAAA7jC,EAAAC,EAAAsjC,EAAAlf,EAAA,IAAAqY,EAAAmH,EAAA7jC,EAAAC,EAAAsjC,EAAAlf,GACAkgB,GAAAxQ,EAAA7uC,IAAAE,IAGA,MAAkBjV,EAAAm0D,IAClBE,GAAA7M,EAAAxnD,KACAq0D,EAAAl/C,IAF+BnV,KAO/B,IADAk0C,GAAAmgB,EAAAl/C,GAAAi/C,EACAlgB,GAAA,GACAh4C,EAAAqwD,EAAAkH,EAAA9jC,EAAAC,EAAAujC,EAAAjf,GACAj5C,EAAAsxD,EAAAmH,EAAA7jC,EAAAC,EAAAsjC,EAAAlf,GAGAl0C,EAAA,EAAAonC,EAAAqkB,OAAAvvD,EAAAjB,GAAAmsC,EAAAwkB,OAAA1vD,EAAAjB,GACAi5C,GAAAsT,EAAAxnD,GAAAo0D,EACAp0D,KAAA,GAAAm0D,CAGAn0D,GAAA,OAAAonC,EAAAwkB,OAAAuH,EAAAC,GACAr+C,EAAAo+C,EAAAj3D,EACA+Y,EAAAm+C,EAAAn4D,EACA3J,KAAAuhE,aAAAjP,EAAA7uC,IAAAE,MAEAq+C,mBAAA,SAAA3jC,EAAAE,EAAAD,EAAAE,GAEA,GAAAqjC,GAAAvjC,EACAwjC,EAAAtjC,CACAF,MAAA,EAAAD,GAAA,EACAG,KAAA,EAAAD,GAAA,EACAF,GAAAr+B,KAAAghE,IAAA,EAAA3iC,GAAA,EACAE,GAAAv+B,KAAAihE,IAAA,EAAA1iC,GAAA,EACAv+B,KAAA+hE,gBAAA1jC,EAAAE,EAAAD,EAAAE,EAAAqjC,EAAAC,IAEA/N,SAAA,WACA,GAAAl1D,GAAAmB,KAAAnB,IACAA,aAAAsG,SACAtG,EAAAwF,OAAArE,KAAA+gE,KACAD,IACA9gE,KAAAnB,KAAA,GAAAioD,cAAAjoD,MAIA2K,gBAAA,WACA9D,EAAA,GAAAA,EAAA,GAAAk7D,EAAA,GAAAA,EAAA,GAAArU,OAAAC,UACApyC,EAAA,GAAAA,EAAA,GAAAymD,EAAA,GAAAA,EAAA,IAAAtU,OAAAC,SAMA,QALA3tD,GAAAmB,KAAAnB,KACAmkE,EAAA,EACAC,EAAA,EACAd,EAAA,EACAC,EAAA,EACA19D,EAAA,EAA2BA,EAAA7F,EAAAwF,QAAiB,CAC5C,GAAA0tD,GAAAlzD,EAAA6F,IAWA,QAVA,GAAAA,IAKAs+D,EAAAnkE,EAAA6F,GACAu+D,EAAApkE,EAAA6F,EAAA,GACAy9D,EAAAa,EACAZ,EAAAa,GAEAlR,GACA,IAAAwB,GAAAjtB,EAGA67B,EAAAtjE,EAAA6F,KACA09D,EAAAvjE,EAAA6F,KACAs+D,EAAAb,EACAc,EAAAb,EACAxB,EAAA,GAAAuB,EACAvB,EAAA,GAAAwB,EACAvB,EAAA,GAAAsB,EACAtB,EAAA,GAAAuB,CACA,MACA,KAAA7O,GAAAvb,EACA2oB,EAAAuC,SAAAF,EAAAC,EAAApkE,EAAA6F,GAAA7F,EAAA6F,EAAA,GAAAk8D,EAAAC,GACAmC,EAAAnkE,EAAA6F,KACAu+D,EAAApkE,EAAA6F,IACA,MACA,KAAA6uD,GAAAI,EACAgN,EAAAwC,UAAAH,EAAAC,EAAApkE,EAAA6F,KAAA7F,EAAA6F,KAAA7F,EAAA6F,KAAA7F,EAAA6F,KAAA7F,EAAA6F,GAAA7F,EAAA6F,EAAA,GAAAk8D,EAAAC,GACAmC,EAAAnkE,EAAA6F,KACAu+D,EAAApkE,EAAA6F,IACA,MACA,KAAA6uD,GAAAK,EACA+M,EAAAyC,cAAAJ,EAAAC,EAAApkE,EAAA6F,KAAA7F,EAAA6F,KAAA7F,EAAA6F,GAAA7F,EAAA6F,EAAA,GAAAk8D,EAAAC,GACAmC,EAAAnkE,EAAA6F,KACAu+D,EAAApkE,EAAA6F,IACA,MACA,KAAA6uD,GAAAM,EAEA,GAAAjrC,GAAA/pB,EAAA6F,KACAmkB,EAAAhqB,EAAA6F,KACAktD,EAAA/yD,EAAA6F,KACAmtD,EAAAhzD,EAAA6F,KACA6e,EAAA1kB,EAAA6F,KACA8e,EAAA3kB,EAAA6F,KAAA6e,EAGA0+C,GADApjE,EAAA6F,KACA,EAAA7F,EAAA6F,KACA,IAAAA,IAGAy9D,EAAAjQ,EAAA3uC,GAAAquC,EAAAhpC,EACAw5C,EAAAjQ,EAAA5uC,GAAAsuC,EAAAhpC,GAEA83C,EAAA0C,QAAAz6C,EAAAC,EAAA+oC,EAAAC,EAAAtuC,EAAAC,EAAAy+C,EAAArB,EAAAC,GACAmC,EAAA9Q,EAAA1uC,GAAAouC,EAAAhpC,EACAq6C,EAAA9Q,EAAA3uC,GAAAquC,EAAAhpC,CACA,MACA,KAAA0qC,GAAA7b,EACAyqB,EAAAa,EAAAnkE,EAAA6F,KACA09D,EAAAa,EAAApkE,EAAA6F,IACA,IAAA6F,GAAA1L,EAAA6F,KACAkF,EAAA/K,EAAA6F,IAEAi8D,GAAAuC,SAAAf,EAAAC,EAAAD,EAAA53D,EAAA63D,EAAAx4D,EAAAg3D,EAAAC,EACA,MACA,KAAAtN,GAAAO,EACAkP,EAAAb,EACAc,EAAAb,EAIA7G,EAAA71D,QAAAk7D,GACArF,EAAAnhD,QAAAymD,GAMA,MAHA,KAAAn8D,IACAgB,EAAA,GAAAA,EAAA,GAAA0U,EAAA,GAAAA,EAAA,MAEA,GAAA+iB,GAAAz3B,EAAA,GAAAA,EAAA,GAAA0U,EAAA,GAAA1U,EAAA,GAAA0U,EAAA,GAAA1U,EAAA,KAEA0uD,YAAA,SAAAte,GAQA,OANAqsB,GAAAC,EACAY,EAAAC,EACAr4D,EAAAjB,EAHAmE,EAAA9N,KAAAnB,KAIAykE,EAAAtjE,KAAAohE,IACAmC,EAAAvjE,KAAAqhE,IACAv1C,EAAA9rB,KAAA+gE,KACAr8D,EAAA,EAA2BA,EAAAonB,GAAS,CACpC,GAAAimC,GAAAjkD,EAAApJ,IAWA,QAVA,GAAAA,IAKAs+D,EAAAl1D,EAAApJ,GACAu+D,EAAAn1D,EAAApJ,EAAA,GACAy9D,EAAAa,EACAZ,EAAAa,GAEAlR,GACA,IAAAwB,GAAAjtB,EACA67B,EAAAa,EAAAl1D,EAAApJ,KACA09D,EAAAa,EAAAn1D,EAAApJ,KACAoxC,EAAAqkB,OAAA6I,EAAAC,EACA,MACA,KAAA1P,GAAAvb,EACAptC,EAAAkD,EAAApJ,KACAiF,EAAAmE,EAAApJ,MAEAy3D,EAAAvxD,EAAAo4D,GAAAM,GAAAnH,EAAAxyD,EAAAs5D,GAAAM,GAAA7+D,IAAAonB,EAAA,KACAgqB,EAAAwkB,OAAA1vD,EAAAjB,GACAq5D,EAAAp4D,EACAq4D,EAAAt5D,EAEA,MACA,KAAA4pD,GAAAI,EACA7d,EAAA6lB,cAAA7tD,EAAApJ,KAAAoJ,EAAApJ,KAAAoJ,EAAApJ,KAAAoJ,EAAApJ,KAAAoJ,EAAApJ,KAAAoJ,EAAApJ,MACAs+D,EAAAl1D,EAAApJ,EAAA,GACAu+D,EAAAn1D,EAAApJ,EAAA,EACA,MACA,KAAA6uD,GAAAK,EACA9d,EAAA4lB,iBAAA5tD,EAAApJ,KAAAoJ,EAAApJ,KAAAoJ,EAAApJ,KAAAoJ,EAAApJ,MACAs+D,EAAAl1D,EAAApJ,EAAA,GACAu+D,EAAAn1D,EAAApJ,EAAA,EACA,MACA,KAAA6uD,GAAAM,EACA,GAAAjrC,GAAA9a,EAAApJ,KACAmkB,EAAA/a,EAAApJ,KACAktD,EAAA9jD,EAAApJ,KACAmtD,EAAA/jD,EAAApJ,KACA+tD,EAAA3kD,EAAApJ,KACAkuD,EAAA9kD,EAAApJ,KACAstD,EAAAlkD,EAAApJ,KACAitD,EAAA7jD,EAAApJ,KACA8gB,EAAAosC,EAAAC,EAAAD,EAAAC,EACA2R,EAAA5R,EAAAC,EAAA,EAAAD,EAAAC,EACA4R,EAAA7R,EAAAC,IAAAD,EAAA,EACA8R,EAAAjiE,KAAAihB,IAAAkvC,EAAAC,GAAA,KACAruC,EAAAivC,EAAAG,CACA8Q,IACA5tB,EAAAuR,UAAAz+B,EAAAC,GACAitB,EAAA3qB,OAAA6mC,GACAlc,EAAA5zB,MAAAshD,EAAAC,GACA3tB,EAAA0Q,IAAA,IAAAhhC,EAAAitC,EAAAjvC,EAAA,EAAAmuC,GACA7b,EAAA5zB,MAAA,EAAAshD,EAAA,EAAAC,GACA3tB,EAAA3qB,QAAA6mC,GACAlc,EAAAuR,WAAAz+B,GAAAC,IAEAitB,EAAA0Q,IAAA59B,EAAAC,EAAArD,EAAAitC,EAAAjvC,EAAA,EAAAmuC,GAEA,GAAAjtD,IAGAy9D,EAAAjQ,EAAAO,GAAAb,EAAAhpC,EACAw5C,EAAAjQ,EAAAM,GAAAZ,EAAAhpC,GAEAm6C,EAAA9Q,EAAA1uC,GAAAouC,EAAAhpC,EACAq6C,EAAA9Q,EAAA3uC,GAAAquC,EAAAhpC,CACA,MACA,KAAA0qC,GAAA7b,EACAyqB,EAAAa,EAAAl1D,EAAApJ,GACA09D,EAAAa,EAAAn1D,EAAApJ,EAAA,GACAoxC,EAAA3qC,KAAA2C,EAAApJ,KAAAoJ,EAAApJ,KAAAoJ,EAAApJ,KAAAoJ,EAAApJ,KACA,MACA,KAAA6uD,GAAAO,EACAhe,EAAAykB,YACAyI,EAAAb,EACAc,EAAAb,MAKA9O,EAAAC,MACAD,IAEAzvD,EAAA,uFAAAD,GAWA,QAAAuwD,GAAA12B,EAAAO,GACA,GACA+zB,GACA4R,EACAj/D,EACAm5D,EACAz3B,EACAjM,EANAt7B,EAAA4+B,EAAA5+B,KAOAynC,EAAAitB,EAAAjtB,EACAqtB,EAAAJ,EAAAI,EACA3b,EAAAub,EAAAvb,EACAN,EAAA6b,EAAA7b,EACAmc,EAAAN,EAAAM,EACAD,EAAAL,EAAAK,CACA,KAAAlvD,EAAA,EAAAm5D,EAAA,EAA0Bn5D,EAAA7F,EAAAwF,QAAiB,CAI3C,OAHA0tD,EAAAlzD,EAAA6F,KACAm5D,EAAAn5D,EACAi/D,EAAA,EACA5R,GACA,IAAAzrB,GACAq9B,EAAA,CACA,MACA,KAAA3rB,GACA2rB,EAAA,CACA,MACA,KAAAhQ,GACAgQ,EAAA,CACA,MACA,KAAA/P,GACA+P,EAAA,CACA,MACA,KAAA9P,GACA,GAAAjpD,GAAAozB,EAAA,GACAr0B,EAAAq0B,EAAA,GACAg8B,EAAA1H,EAAAt0B,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAi8B,EAAA3H,EAAAt0B,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAzN,EAAAqzC,GAAA5lC,EAAA,GAAAi8B,EAAAj8B,EAAA,GAAAg8B,EAEAn7D,GAAA6F,MAAAkG,EAEA/L,EAAA6F,MAAAiF,EAGA9K,EAAA6F,MAAAs1D,EACAn7D,EAAA6F,MAAAu1D,EAEAp7D,EAAA6F,MAAA6rB,EAEA1xB,EAAA6F,MAAA6rB,EAEA7rB,GAAA,EACAm5D,EAAAn5D,CACA,MACA,KAAAgzC,GAEAvd,EAAA,GAAAt7B,EAAA6F,KACAy1B,EAAA,GAAAt7B,EAAA6F,KACAw3D,EAAA/hC,IAAA6D,GACAn/B,EAAAg/D,KAAA1jC,EAAA,GACAt7B,EAAAg/D,KAAA1jC,EAAA,GAEAA,EAAA,IAAAt7B,EAAA6F,KACAy1B,EAAA,IAAAt7B,EAAA6F,KACAw3D,EAAA/hC,IAAA6D,GACAn/B,EAAAg/D,KAAA1jC,EAAA,GACAt7B,EAAAg/D,KAAA1jC,EAAA,GAEA,IAAAiM,EAAA,EAAuBA,EAAAu9B,EAAYv9B,IAAA,CACnC,GAAAjM,GAAAxT,EAAAyf,EACAjM,GAAA,GAAAt7B,EAAA6F,KACAy1B,EAAA,GAAAt7B,EAAA6F,KACAw3D,EAAA/hC,IAAA6D,GAEAn/B,EAAAg/D,KAAA1jC,EAAA,GACAt7B,EAAAg/D,KAAA1jC,EAAA,KApFA,GAAAo5B,GAAA3vD,EAAA,qBAAA2vD,IACAgI,EAAA33D,EAAA,kBACAs4D,EAAAX,EAAAz9B,eACAnX,aAKA2rC,EAAA7wD,KAAAktD,KACAiV,EAAAniE,KAAAoiE,KA+EA,OAAA1P,KAEAtwD,EAAA,8DAAAD,GAiDA,QAAAomB,GAAAva,EAAAN,GACA,GAAAye,GAAA5nB,EAAArB,MAAA8kB,UAAA,EACA,OAAAzpB,MAAAmgB,WAAAnU,UAAAmD,GAAAzL,MAAA+L,EAAAme,GAEA,QAAApE,GAAA/Z,EAAAN,EAAAye,GACA,MAAA5tB,MAAAmgB,WAAAnU,UAAAmD,GAAAzL,MAAA+L,EAAAme,GArDA,GAAA5nB,GAAApC,EAAA,qBACAipB,KACAi3C,EAAA,IACAC,EAAA,iCAIApwD,EAAAkZ,EAAAlZ,eAAA,SAAAN,GACA,GAAA4xB,IACAlxB,KAAA,GACAC,IAAA,GAOA,OALAX,KACAA,IAAAnP,MAAA4/D,GACA7+B,EAAAlxB,KAAAV,EAAA,OACA4xB,EAAAjxB,IAAAX,EAAA,QAEA4xB,EAiJA,OA5IApY,GAAA8lB,kBAAA,SAAAqxB,GACAA,EAAAnyB,aAAAmyB,EACAA,EAAAj3D,OAAA,SAAAk3D,GACA,GAAA9jD,GAAAngB,KACAkkE,EAAA,WACAD,EAAApyB,aAGAoyB,EAAApyB,aAAAnuC,MAAA1D,KAAAypB,WAFAtJ,EAAAzc,MAAA1D,KAAAypB,WAWA,OANAzjB,GAAA+G,OAAAm3D,EAAAl4D,UAAAi4D,GACAC,EAAAn3D,OAAA/M,KAAA+M,OACAm3D,EAAAl6C,YACAk6C,EAAA16C,aACAxjB,EAAAuhB,SAAA28C,EAAAlkE,MACAkkE,EAAA/jD,aACA+jD,IAsBAr3C,EAAAwlB,sBAAA,SAAA8xB,EAAArhE,GA6EA,QAAAshE,GAAA/wD,GACA,GAAAgxD,GAAAjvD,EAAA/B,EAAAU,KAKA,OAJAswD,MAAAN,KACAM,EAAAjvD,EAAA/B,EAAAU,SACAswD,EAAAN,IAAA,GAEAM,EAlFAvhE,OASA,IAAAsS,KA2EA,IA1EA+uD,EAAAG,cAAA,SAAA1wD,EAAAP,GACA,GAAAA,EAEA,GADAA,EAAAM,EAAAN,GACAA,EAAAW,KAOiB,GAAAX,EAAAW,MAAA+vD,EAAA,CACjB,GAAAM,GAAAD,EAAA/wD,EACAgxD,GAAAhxD,EAAAW,KAAAJ,OAPAwB,GAAA/B,EAAAU,OACAmC,QAAAC,KAAA9C,EAAAU,KAAA,YAGAqB,EAAA/B,EAAAU,MAAAH,CAMA,OAAAA,IAEAuwD,EAAArwD,SAAA,SAAAywD,EAAA54C,EAAA64C,GACA,GAAA5wD,GAAAwB,EAAAmvD,EAIA,IAHA3wD,KAAAmwD,KACAnwD,EAAA+X,EAAA/X,EAAA+X,GAAA,MAEA64C,IAAA5wD,EACA,SAAAhO,OAAA,aAAA2+D,EAAA,KAAA54C,GAAA,kCAEA,OAAA/X,IAEAuwD,EAAA1yB,qBAAA,SAAAp+B,GACAA,EAAAM,EAAAN,EACA,IAAAwY,MACAxtB,EAAA+W,EAAA/B,EAAAU,KAQA,OAPA1V,MAAA0lE,GACA/9D,EAAAkJ,KAAA7Q,EAAA,SAAAomE,EAAAnjE,GACAA,IAAAyiE,GAAAl4C,EAAArqB,KAAAijE,KAGA54C,EAAArqB,KAAAnD,GAEAwtB,GAEAs4C,EAAAx7B,SAAA,SAAAt1B,GAGA,MADAA,GAAAM,EAAAN,KACA+B,EAAA/B,EAAAU,OAKAowD,EAAA34B,qBAAA,WACA,GAAArC,KAIA,OAHAnjC,GAAAkJ,KAAAkG,EAAA,SAAA/W,EAAAiD,GACA6nC,EAAA3nC,KAAAF,KAEA6nC,GAOAg7B,EAAAO,YAAA,SAAArxD,GACAA,EAAAM,EAAAN,EACA,IAAAhV,GAAA+W,EAAA/B,EAAAU,KACA,OAAA1V,MAAA0lE,IAEAI,EAAAxwD,iBASA7Q,EAAAwvC,mBAAA,CACA,GAAAqyB,GAAAR,EAAAp3D,MACA43D,KACAR,EAAAp3D,OAAA,SAAAk3D,GACA,GAAAC,GAAAS,EAAAv1D,KAAApP,KAAAikE,EACA,OAAAE,GAAAG,cAAAJ,EAAAD,EAAA3iE,QAIA,MAAA6iE,IAKAt3C,EAAAy7B,YAAA,SAAAjqD,EAAAkqD,KAEA17B,IAEAhpB,EAAA,4GAAAD,GAWA,QAAAkxD,GAAA9kD,GACAA,QACAioD,EAAA7oD,KAAApP,KAAAgQ,EAEA,QAAA3N,KAAA2N,GACAA,EAAAgc,eAAA3pB,IAAA,UAAAA,IACArC,KAAAqC,GAAA2N,EAAA3N,GAMArC,MAAAiJ,MAAA,GAAA27D,GAAA50D,EAAA/G,OACAjJ,KAAAmzB,MAAA,KAEAnzB,KAAA6kE,eAzBA,GAAA7+D,GAAApC,EAAA,gBACAghE,EAAAhhE,EAAA,WACAq0D,EAAAr0D,EAAA,cACAkhE,EAAAlhE,EAAA,mBAwFA,OA/DAkxD,GAAA9oD,WACAkhB,YAAA4nC,EACAxzD,KAAA,cACAqzD,SAAA,EACAmE,WAAA,EACA1xD,EAAA,EACAkC,GAAA,EACAnC,OAAA,EACA49D,WAAA,EACAC,UAAA,EACAj7D,QAAA,EACAk7D,SAAA,EACAC,OAAA,UACAC,WAAA,EACArvD,eACAkmD,YAAA,SAAAlmB,KAEAmmB,WAAA,SAAAnmB,KAEAsf,MAAA,SAAAtf,EAAAuf,KAEA7rD,gBAAA,aAEA4lD,QAAA,SAAAxkD,EAAAjB,GACA,MAAA3J,MAAAolE,YAAAx6D,EAAAjB,IAEA2L,SAAA,SAAAyT,EAAAtZ,GACAsZ,EAAA3Z,KAAAK,EAAAzP,OAEAolE,YAAA,SAAAx6D,EAAAjB,GACA,GAAA2oB,GAAAtyB,KAAAs3D,sBAAA1sD,EAAAjB,GACAwB,EAAAnL,KAAAwJ,iBACA,OAAA2B,GAAAikD,QAAA98B,EAAA,GAAAA,EAAA,KAEA+hC,MAAA,WACAr0D,KAAA20D,SAAA,EACA30D,KAAAmzB,MAAA,KACAnzB,KAAAk7B,MAAAl7B,KAAAk7B,KAAAga,WAEAmwB,aAAA,SAAA3N,GACA,MAAA13D,MAAA+jB,QAAA,QAAA2zC,IAEAC,OAAA,SAAAx4C,EAAAzgB,GACA,UAAAygB,EACA84C,EAAAjsD,UAAA2rD,OAAAvoD,KAAApP,KAAAmf,EAAAzgB,GAEAsB,KAAAiJ,MAAAw8C,IAAA/mD,IAGAsM,SAAA,SAAAmU,EAAAzgB,GAGA,MAFAsB,MAAAiJ,MAAAw8C,IAAAtmC,EAAAzgB,GACAsB,KAAAq0D,OAAA,GACAr0D,MAEAkmB,SAAA,SAAA7nB,GAGA,MAFA2B,MAAAiJ,MAAA,GAAA27D,GAAAvmE,GACA2B,KAAAq0D,OAAA,GACAr0D,OAGAgG,EAAAuhB,SAAAutC,EAAAmD,GACAjyD,EAAAsS,MAAAw8C,EAAAgQ,GAEAhQ,IAEAjxD,EAAA,kJAAAD,GACA,YAYA,SAAA0hE,GAAA54D,EAAAwD,GACA,MAAAzO,MAAAihB,IAAAhW,EAAAwD,GAAAq1D,EAYA,QAAAC,KACA,GAAAriB,GAAAsiB,EAAA,EACAA,GAAA,GAAAA,EAAA,GACAA,EAAA,GAAAtiB,EAEA,QAAAuiB,GAAAvD,EAAAC,EAAA/jC,EAAAE,EAAAD,EAAAE,EAAAqjC,EAAAC,EAAAl3D,EAAAjB,GAEA,GAAAA,EAAAy4D,GAAAz4D,EAAA40B,GAAA50B,EAAA60B,GAAA70B,EAAAm4D,GAAAn4D,EAAAy4D,GAAAz4D,EAAA40B,GAAA50B,EAAA60B,GAAA70B,EAAAm4D,EACA,QAEA,IAAA6D,GAAAjF,EAAAkF,YAAAxD,EAAA7jC,EAAAC,EAAAsjC,EAAAn4D,EAAAk8D,EACA,QAAAF,EACA,QAKA,QADAG,GAAAC,EAFA9O,EAAA,EACA+O,KAEAthE,EAAA,EAA2BA,EAAAihE,EAAYjhE,IAAA,CACvC,GAAAk+C,GAAAijB,EAAAnhE,GAEAuhE,EAAA,IAAArjB,GAAA,IAAAA,EAAA,KACAsjB,EAAAxF,EAAAzF,QAAAkH,EAAA9jC,EAAAC,EAAAujC,EAAAjf,EACAsjB,GAAAt7D,IAIAo7D,EAAA,IACAA,EAAAtF,EAAAyF,aAAA/D,EAAA7jC,EAAAC,EAAAsjC,EAAA2D,GACAA,EAAA,GAAAA,EAAA,IAAAO,EAAA,GACAR,IAEAM,EAAApF,EAAAzF,QAAAmH,EAAA7jC,EAAAC,EAAAsjC,EAAA2D,EAAA,IACAO,EAAA,IACAD,EAAArF,EAAAzF,QAAAmH,EAAA7jC,EAAAC,EAAAsjC,EAAA2D,EAAA,MAMAxO,GAHA,GAAA+O,EAEApjB,EAAA6iB,EAAA,GACAK,EAAA1D,EAAA6D,KACqBrjB,EAAA6iB,EAAA,GACrBM,EAAAD,EAAAG,KAEAnE,EAAAiE,EAAAE,KAIArjB,EAAA6iB,EAAA,GACAK,EAAA1D,EAAA6D,KAEAnE,EAAAgE,EAAAG,MAIA,MAAAhP,GAGA,QAAAmP,GAAAjE,EAAAC,EAAA/jC,EAAAE,EAAAD,EAAAE,EAAA5zB,EAAAjB,GAEA,GAAAA,EAAAy4D,GAAAz4D,EAAA40B,GAAA50B,EAAA60B,GAAA70B,EAAAy4D,GAAAz4D,EAAA40B,GAAA50B,EAAA60B,EACA,QAEA,IAAAmnC,GAAAjF,EAAA2F,gBAAAjE,EAAA7jC,EAAAC,EAAA70B,EAAAk8D,EACA,QAAAF,EACA,QAEA,IAAA/iB,GAAA8d,EAAA4F,kBAAAlE,EAAA7jC,EAAAC,EACA,IAAAokB,GAAA,GAAAA,GAAA,GAGA,OAFAqU,GAAA,EACAsP,EAAA7F,EAAArF,YAAA+G,EAAA7jC,EAAAC,EAAAokB,GACAl+C,EAAA,EAA+BA,EAAAihE,EAAYjhE,IAAA,CAE3C,GAAAuhE,GAAA,IAAAJ,EAAAnhE,IAAA,IAAAmhE,EAAAnhE,GAAA,KACAwhE,EAAAxF,EAAArF,YAAA8G,EAAA9jC,EAAAC,EAAAunC,EAAAnhE,GACAwhE,GAAAt7D,IAKAqsD,GADA4O,EAAAnhE,GAAAk+C,EACA2jB,EAAAnE,EAAA6D,KAEAznC,EAAA+nC,EAAAN,MAGA,MAAAhP,GAGA,GAAAgP,GAAA,IAAAJ,EAAA,QAAAA,EAAA,QACAK,EAAAxF,EAAArF,YAAA8G,EAAA9jC,EAAAC,EAAAunC,EAAA,GACA,OAAAK,GAAAt7D,EAEA,EAEA4zB,EAAA4jC,EAAA6D,KAMA,QAAAO,GAAA59C,EAAAC,EAAArD,EAAAjC,EAAAC,EAAAy+C,EAAAr3D,EAAAjB,GAEA,GADAA,GAAAkf,EACAlf,EAAA6b,GAAA7b,GAAA6b,EACA,QAEA,IAAA29B,GAAA1hD,KAAAktD,KAAAnpC,IAAA7b,IACAk8D,GAAA,IAAA1iB,EACA0iB,EAAA,GAAA1iB,CACA,IAAAn7B,GAAAvmB,KAAAihB,IAAAa,EAAAC,EACA,IAAAwE,EAAA,KACA,QAEA,IAAAA,EAAA6H,EAAA,MAEAtM,EAAA,EACAC,EAAAqM,CACA,IAAAS,GAAA2xC,EAAA,IACA,OAAAr3D,IAAAi7D,EAAA,GAAAj9C,GAAAhe,GAAAi7D,EAAA,GAAAj9C,EACA0H,EAEA,EAGA,GAAA2xC,EAAA,CACA,GAAA9e,GAAA5/B,CACAA,GAAAkjD,EAAAjjD,GACAA,EAAAijD,EAAAtjB,OAEA5/B,GAAAkjD,EAAAljD,GACAC,EAAAijD,EAAAjjD,EAEAD,GAAAC,IACAA,GAAAqM,EAGA,QADAonC,GAAA,EACAvyD,EAAA,EAAuBA,EAAA,EAAOA,IAAA,CAC9B,GAAAwhE,GAAAL,EAAAnhE,EACA,IAAAwhE,EAAAt9C,EAAAhe,EAAA,CACA,GAAA2lB,GAAA9uB,KAAAoiE,MAAAl6D,EAAAu8D,GACA51C,EAAA2xC,EAAA,IACA1xC,GAAA,IACAA,EAAAV,EAAAU,IAEAA,GAAAhN,GAAAgN,GAAA/M,GAAA+M,EAAAV,GAAAtM,GAAAgN,EAAAV,GAAArM,KACA+M,EAAA9uB,KAAA0nB,GAAA,GAAAoH,EAAA,IAAA9uB,KAAA0nB,KACAmH,MAEA2mC,GAAA3mC,IAIA,MAAA2mC,GAEA,QAAAyP,GAAA7nE,EAAAq3B,EAAAywC,EAAA/7D,EAAAjB,GAMA,OALAstD,GAAA,EACA+L,EAAA,EACAC,EAAA,EACAd,EAAA,EACAC,EAAA,EACA19D,EAAA,EAAuBA,EAAA7F,EAAAwF,QAAiB,CACxC,GAAA0tD,GAAAlzD,EAAA6F,IAqBA,QAnBAqtD,IAAAwB,EAAAjtB,GAAA5hC,EAAA,IAEAiiE,IACA1P,GAAA2P,EAAA5D,EAAAC,EAAAd,EAAAC,EAAAx3D,EAAAjB,KAMA,GAAAjF,IAKAs+D,EAAAnkE,EAAA6F,GACAu+D,EAAApkE,EAAA6F,EAAA,GACAy9D,EAAAa,EACAZ,EAAAa,GAEAlR,GACA,IAAAwB,GAAAjtB,EAGA67B,EAAAtjE,EAAA6F,KACA09D,EAAAvjE,EAAA6F,KACAs+D,EAAAb,EACAc,EAAAb,CACA,MACA,KAAA7O,GAAAvb,EACA,GAAA2uB,GACA,GAAApP,EAAAyL,EAAAC,EAAApkE,EAAA6F,GAAA7F,EAAA6F,EAAA,GAAAwxB,EAAAtrB,EAAAjB,GACA,aAIAstD,IAAA2P,EAAA5D,EAAAC,EAAApkE,EAAA6F,GAAA7F,EAAA6F,EAAA,GAAAkG,EAAAjB,IAAA,CAEAq5D,GAAAnkE,EAAA6F,KACAu+D,EAAApkE,EAAA6F,IACA,MACA,KAAA6uD,GAAAI,EACA,GAAAgT,GACA,GAAAE,EAAAtP,cAAAyL,EAAAC,EAAApkE,EAAA6F,KAAA7F,EAAA6F,KAAA7F,EAAA6F,KAAA7F,EAAA6F,KAAA7F,EAAA6F,GAAA7F,EAAA6F,EAAA,GAAAwxB,EAAAtrB,EAAAjB,GACA,aAGAstD,IAAAyO,EAAA1C,EAAAC,EAAApkE,EAAA6F,KAAA7F,EAAA6F,KAAA7F,EAAA6F,KAAA7F,EAAA6F,KAAA7F,EAAA6F,GAAA7F,EAAA6F,EAAA,GAAAkG,EAAAjB,IAAA,CAEAq5D,GAAAnkE,EAAA6F,KACAu+D,EAAApkE,EAAA6F,IACA,MACA,KAAA6uD,GAAAK,EACA,GAAA+S,GACA,GAAAG,EAAAvP,cAAAyL,EAAAC,EAAApkE,EAAA6F,KAAA7F,EAAA6F,KAAA7F,EAAA6F,GAAA7F,EAAA6F,EAAA,GAAAwxB,EAAAtrB,EAAAjB,GACA,aAGAstD,IAAAmP,EAAApD,EAAAC,EAAApkE,EAAA6F,KAAA7F,EAAA6F,KAAA7F,EAAA6F,GAAA7F,EAAA6F,EAAA,GAAAkG,EAAAjB,IAAA,CAEAq5D,GAAAnkE,EAAA6F,KACAu+D,EAAApkE,EAAA6F,IACA,MACA,KAAA6uD,GAAAM,EAEA,GAAAjrC,GAAA/pB,EAAA6F,KACAmkB,EAAAhqB,EAAA6F,KACAktD,EAAA/yD,EAAA6F,KACAmtD,EAAAhzD,EAAA6F,KACA+tD,EAAA5zD,EAAA6F,KACAkuD,EAAA/zD,EAAA6F,KAGAu9D,GADApjE,EAAA6F,KACA,EAAA7F,EAAA6F,MACA25B,EAAA58B,KAAAiiB,IAAA+uC,GAAAb,EAAAhpC,EACA2V,EAAA98B,KAAAmiB,IAAA6uC,GAAAZ,EAAAhpC,CAEAnkB,GAAA,EACAuyD,GAAA2P,EAAA5D,EAAAC,EAAA5kC,EAAAE,EAAA3zB,EAAAjB,IAGAw4D,EAAA9jC,EACA+jC,EAAA7jC,EAGA,IAAAwoC,IAAAn8D,EAAAge,GAAAipC,EAAAD,EAAAhpC,CACA,IAAA+9C,GACA,GAAAngB,EAAA+Q,cAAA3uC,EAAAC,EAAAgpC,EAAAY,IAAAG,EAAAqP,EAAA/rC,EAAA6wC,EAAAp9D,GACA,aAGAstD,IAAAuP,EAAA59C,EAAAC,EAAAgpC,EAAAY,IAAAG,EAAAqP,EAAA8E,EAAAp9D,EAEAq5D,GAAAvhE,KAAAiiB,IAAA+uC,EAAAG,GAAAhB,EAAAhpC,EACAq6C,EAAAxhE,KAAAmiB,IAAA6uC,EAAAG,GAAAf,EAAAhpC,CACA,MACA,KAAA0qC,GAAA7b,EACAyqB,EAAAa,EAAAnkE,EAAA6F,KACA09D,EAAAa,EAAApkE,EAAA6F,IACA,IAAA6F,GAAA1L,EAAA6F,KACAkF,EAAA/K,EAAA6F,KACA25B,EAAA8jC,EAAA53D,EACAg0B,EAAA6jC,EAAAx4D,CACA,IAAA+8D,GACA,GAAApP,EAAA4K,EAAAC,EAAA/jC,EAAA+jC,EAAAlsC,EAAAtrB,EAAAjB,IAAA4tD,EAAAl5B,EAAA+jC,EAAA/jC,EAAAE,EAAArI,EAAAtrB,EAAAjB,IAAA4tD,EAAAl5B,EAAAE,EAAA4jC,EAAA5jC,EAAArI,EAAAtrB,EAAAjB,IAAA4tD,EAAA4K,EAAA5jC,EAAA4jC,EAAAC,EAAAlsC,EAAAtrB,EAAAjB,GACA,aAIAstD,IAAA2P,EAAAvoC,EAAA+jC,EAAA/jC,EAAAE,EAAA3zB,EAAAjB,GACAstD,GAAA2P,EAAAzE,EAAA5jC,EAAA4jC,EAAAC,EAAAx3D,EAAAjB,EAEA,MACA,KAAA4pD,GAAAO,EACA,GAAA6S,GACA,GAAApP,EAAAyL,EAAAC,EAAAd,EAAAC,EAAAlsC,EAAAtrB,EAAAjB,GACA,aAIAstD,IAAA2P,EAAA5D,EAAAC,EAAAd,EAAAC,EAAAx3D,EAAAjB,EAMAq5D,GAAAb,EACAc,EAAAb,GAOA,MAHAuE,IAAArB,EAAArC,EAAAb,KACAnL,GAAA2P,EAAA5D,EAAAC,EAAAd,EAAAC,EAAAx3D,EAAAjB,IAAA,GAEA,IAAAstD,EA9TA,GAAA1D,GAAA3vD,EAAA,qBAAA2vD,IACAyT,EAAApjE,EAAA,UACAijE,EAAAjjE,EAAA,WACAkjE,EAAAljE,EAAA,eACA4iD,EAAA5iD,EAAA,SACA6iE,EAAA7iE,EAAA,UAAA6iE,gBACA/F,EAAA98D,EAAA,iBACAgjE,EAAAhjE,EAAA,iBACA2zD,EAAAyP,EAAAzP,cACA1nC,EAAA,EAAApuB,KAAA0nB,GACAo8C,EAAA,KAKAM,aAKAJ,SA4SA,QACArW,QAAA,SAAA9xB,EAAA1yB,EAAAjB,GACA,MAAA+8D,GAAAppC,EAAA,KAAA1yB,EAAAjB,IAEA4tD,cAAA,SAAAj6B,EAAApH,EAAAtrB,EAAAjB,GACA,MAAA+8D,GAAAppC,EAAApH,GAAA,EAAAtrB,EAAAjB,OAIA9F,EAAA,yEAAAD,GACA,GAAAyjB,GAAAzjB,EAAA,uBAEA,YACA,UAGA,SACA,UAEA,YACA,eACA,kBACA,kBACA,gBAEA,QACAyjB,aAAA,SAAA4/C,GACA,GAAAh+D,GAAAoe,EAAAjY,KAAApP,KAAAinE,GACA/Q,EAAAl2D,KAAAknE,aAEA,OADAhR,KAAAjtD,EAAAitD,YACAjtD,GAEAi+D,YAAA,WACA,GAAAC,GAAAnnE,KAAA0I,IAAA,OACA,iBAAAy+D,GAAA,MAAAA,EAAA,gBAAAA,GACA,EACA,IAEA,EACA,OAKAtjE,EAAA,2EAAAD,GACA,GAAAoC,GAAApC,EAAA,qBACA8d,EAAA9d,EAAA,WACA+d,EAAAD,EAAA1V,UACAqjD,EAAA3tC,EAAA3U,QACAzL,KAAA,UACAP,KAAA,SAAAlC,EAAA8O,GACA3N,KAAA4nB,MAAA/oB,EACAmB,KAAA4N,QAAAD,IACA,EACA9O,EAAAwF,OAAA,IAGA2K,MAAA,SAAA/B,GACA,sBAAAA,GAAAjH,EAAAhC,QAAAhE,KAAA4nB,MAAA3a,GAAAxL,KAAA4M,MAAApB,IAEAmiD,QAAA,SAAAgY,GAEA,MADAA,GAAApnE,KAAAgP,MAAAo4D,GACAzlD,EAAAytC,QAAAhgD,KAAApP,KAAAonE,IAAA,MAAApnE,KAAA4nB,MAAAw/C,IAEAtjE,UAAA,SAAAmJ,GACA,MAAA0U,GAAA7d,UAAAsL,KAAApP,UAAAgP,MAAA/B,KAEAiV,MAAA,SAAAjV,GACA,MAAAxL,MAAA4M,MAAAsT,EAAAO,MAAA9S,KAAApP,KAAAiN,KAEAgV,SAAA,WAIA,IAHA,GAAAolB,MACA15B,EAAA3N,KAAA4N,QACAw5D,EAAAz5D,EAAA,GACAy5D,GAAAz5D,EAAA,IACA05B,EAAA7lC,KAAA4lE,GACAA,GAEA,OAAA//B,IAEAr6B,SAAA,SAAAotB,GACA,MAAAp6B,MAAA4nB,MAAAwS,IAEA5R,MAAA,WACA,MAAAxoB,MAAA4N,QAAA,GAAA5N,KAAA4N,QAAA,MAEAM,UAAAlI,EAAAwa,KACAjT,WAAAvH,EAAAwa,MAQA,OAHA6uC,GAAAhgD,OAAA,WACA,UAAAggD,IAEAA,IAEAxrD,EAAA,+CAAAD,GACA,GAAAoxD,GAAA,SAAAh6C,EAAAqsD,GACArnE,KAAAgb,QACAhb,KAAAqnE,SAEArnE,KAAAsB,KAAA,UAKA,OAHA0zD,GAAAhpD,UAAAipD,iBAAA,SAAAnf,GACA,MAAA91C,MAAAsnE,iBAAAtnE,KAAAsnE,eAAAxxB,EAAAyxB,cAAAvnE,KAAAgb,MAAAhb,KAAAqnE,UAEArS,IAEAnxD,EAAA,yEAAAD,GACA,OACA4jE,aAAA5jE,EAAA,uBAEA,OACA,UAEA,eACA,kBACA,kBACA,YACA,oBAIAC,EAAA,4EAAAD,GAEA,QAAAw4B,GAAA9oB,EAAAmqB,GACA,MAAAnqB,MAAA8oB,WAAAqB,GAFA,GAAA4H,GAAAzhC,EAAA,uBAIA,QACAyF,aAAA,WACA,GAAA7C,GAAAxG,KAAAwG,OACA,OAAAxG,MAAAo8B,WAAA,UAAA51B,KAAAkC,IAAA,oBAEAS,QAAA,WACA,GAAA3C,GAAAxG,KAAAwG,QACAihE,EAAAjhE,KAAAoC,SAAA,YACA,QACA5I,KAAAo8B,WAAA,cAAAA,EAAAqrC,EAAA,aACAznE,KAAAo8B,WAAA,eAAAA,EAAAqrC,EAAA,eACAznE,KAAAo8B,WAAA,aAAAA,EAAAqrC,EAAA,sBACAznE,KAAAo8B,WAAA,eAAAA,EAAAqrC,EAAA,6BACA5iE,KAAA,MAEA2sB,YAAA,SAAAzvB,GACA,GAAAgG,GAAA/H,KAAA0I,IAAA,gBACA,OAAA28B,GAAA77B,gBAAAzH,EAAA/B,KAAAmJ,UAAApB,EAAA2/D,MAAA3/D,EAAA4/D,WAEA5gC,aAAA,SAAAhlC,EAAA8/B,EAAAu7B,EAAAt6D,GACA,MAAAuiC,GAAA0B,aAAAhlC,EAAA8/B,EAAA7hC,KAAAmJ,UAAAi0D,EAAAt6D,OAIAe,EAAA,yEAAAD,GACA,GAAAsH,GAAAtH,EAAA,uBAEA,OACA,UAGA,SACA,gBAGA,YACA,gBAEA,YACA,eACA,kBACA,kBACA,gBAEA,QACAsH,aAAA,SAAA+7D,GACA,GAAAh+D,GAAAiC,EAAAkE,KAAApP,KAAAinE,GACA/Q,EAAAl2D,KAAA4nE,mBAEA,OADA1R,KAAAjtD,EAAAitD,YACAjtD,GAEA2+D,kBAAA,WACA,GAAAT,GAAAnnE,KAAA0I,IAAA,aACA,iBAAAy+D,GAAA,MAAAA,EAAA,gBAAAA,GACA,EACA,IAEA,EACA,OAKAtjE,EAAA,6CAAAD,GAoCA,QAAAikE,GAAA/xB,EAAAz3C,EAAA8M,GAEA,GAAAP,GAAAvM,EAAAuM,EACA0zB,EAAAjgC,EAAAigC,GACA30B,EAAAtL,EAAAsL,EACA60B,EAAAngC,EAAAmgC,EACAngC,GAAAkF,SACAqH,IAAAO,EAAAZ,MAAAY,EAAAP,EACA0zB,IAAAnzB,EAAAZ,MAAAY,EAAAP,EACAjB,IAAAwB,EAAAvB,OAAAuB,EAAAxB,EACA60B,IAAArzB,EAAAvB,OAAAuB,EAAAxB,EAEA,IAAAm+D,GAAAhyB,EAAA+xB,qBAAAj9D,EAAAjB,EAAA20B,EAAAE,EACA,OAAAspC,GAEA,QAAAC,GAAAjyB,EAAAz3C,EAAA8M,GACA,GAAAZ,GAAAY,EAAAZ,MACAX,EAAAuB,EAAAvB,OACAlE,EAAAjE,KAAAiE,IAAA6E,EAAAX,GACAgB,EAAAvM,EAAAuM,EACAjB,EAAAtL,EAAAsL,EACA6b,EAAAnnB,EAAAmnB,CACAnnB,GAAAkF,SACAqH,IAAAL,EAAAY,EAAAP,EACAjB,IAAAC,EAAAuB,EAAAxB,EACA6b,GAAA9f,EAEA,IAAAoiE,GAAAhyB,EAAAiyB,qBAAAn9D,EAAAjB,EAAA,EAAAiB,EAAAjB,EAAA6b,EACA,OAAAsiD,GA/DA,GAAAE,KAEA,aACA,IAGA,gBACA,IAGA,gBACA,IAGA,cACA,SAGA,UACA,SAGA,WACA,UAGA,aACA,KAKApD,EAAA,SAAA50D,GACAhQ,KAAA63D,WAAA7nD,GAgCA40D,GAAA54D,WACAkhB,YAAA03C,EACAx7D,KAAA,UACAge,OAAA,KACAnC,QAAA,EACAixC,SAAA,KACAC,eAAA,EACA8R,WAAA,EACAC,cAAA,EACAC,cAAA,EACAjyC,UAAA,EACAihC,eAAA,EACAp1D,KAAA,KACAk9B,SAAA,OACAmpC,WAAA,KACA9wC,aAAA,SACAxuB,aAAA,KACA9G,UAAA,KACA+I,kBAAA,KACAi0B,aAAA,EACAqpC,eAAA,EACAC,kBAAA,EACAC,kBAAA,EACAC,eAAA,EACAC,aAAA,EACAC,MAAA,KACAhoE,KAAA,SAAAo1C,EAAA90C,EAAAq0D,GAIA,OAHApsD,GAAAjJ,KACA2oE,EAAAtT,KAAApsD,MACA2/D,GAAAD,EACAjkE,EAAA,EAA2BA,EAAAsjE,EAAA3jE,OAA+BK,IAAA,CAC1D,GAAAuoB,GAAA+6C,EAAAtjE,GACAmkE,EAAA57C,EAAA,IACA27C,GAAA3/D,EAAA4/D,KAAAF,EAAAE,MAEA/yB,EAAA+yB,GAAA5/D,EAAA4/D,IAAA57C,EAAA,IAeA,IAZA27C,GAAA3/D,EAAAG,OAAAu/D,EAAAv/D,QACA0sC,EAAAkgB,UAAA/sD,EAAAG,OAEAw/D,GAAA3/D,EAAAme,SAAAuhD,EAAAvhD,UACA0uB,EAAAmgB,YAAAhtD,EAAAme,SAEAwhD,GAAA3/D,EAAAgc,UAAA0jD,EAAA1jD,WACA6wB,EAAAgzB,YAAA,MAAA7/D,EAAAgc,QAAA,EAAAhc,EAAAgc,UAEA2jD,GAAA3/D,EAAAy/D,QAAAC,EAAAD,SACA5yB,EAAAizB,yBAAA9/D,EAAAy/D,OAAA,eAEA1oE,KAAAs1D,YAAA,CACA,GAAAp/B,GAAAjtB,EAAAitB,SACA4f,GAAA5f,aAAAl2B,KAAAm3D,eAAAn2D,KAAAo2D,aAAAp2D,EAAAo2D,eAAA,KAGA7B,QAAA,WACA,GAAAnsD,GAAApJ,KAAAoJ,IACA,cAAAA,GAAA,SAAAA,GAEAksD,UAAA,WACA,GAAAluC,GAAApnB,KAAAonB,MACA,cAAAA,GAAA,SAAAA,GAAApnB,KAAAk2B,UAAA,GAEA2hC,WAAA,SAAAmR,EAAA98C,GACA,GAAA88C,EAAA,CACA,GAAA1hE,GAAAtH,IACA,QAAAqC,KAAA2mE,IACAA,EAAAh9C,eAAA3pB,KAAA6pB,GAAA5kB,EAAA0kB,eAAA3pB,KACAiF,EAAAjF,GAAA2mE,EAAA3mE,MAKAojD,IAAA,SAAApnD,EAAAK,GACA,gBAAAL,GACA2B,KAAA3B,GAAAK,EAEAsB,KAAA63D,WAAAx5D,GAAA,IAGAsS,MAAA,WACA,GAAAs4D,GAAA,GAAAjpE,MAAAktB,WAEA,OADA+7C,GAAApR,WAAA73D,MAAA,GACAipE,GAEAnT,YAAA,SAAAhgB,EAAAz3C,EAAA8M,GAIA,OAHAjF,GAAA,WAAA7H,EAAAiD,KAAAymE,EAAAF,EACAC,EAAA5hE,EAAA4vC,EAAAz3C,EAAA8M,GACAqQ,EAAAnd,EAAAmd,WACA9W,EAAA,EAA2BA,EAAA8W,EAAAnX,OAAuBK,IAClDojE,EAAA9P,aAAAx8C,EAAA9W,GAAAmf,OAAArI,EAAA9W,GAAAwD,MAEA,OAAA4/D,IAIA,QADAoB,GAAAtE,EAAA54D,UACAtH,EAAA,EAAmBA,EAAAsjE,EAAA3jE,OAA+BK,IAAA,CAClD,GAAAuoB,GAAA+6C,EAAAtjE,EACAuoB,GAAA,IAAAi8C,KACAA,EAAAj8C,EAAA,IAAAA,EAAA,IAKA,MADA23C,GAAA9O,YAAAoT,EAAApT,YACA8O,IAEA/gE,EAAA,qGAAAD,GAMA,QAAAgsB,GAAAlxB,EAAAyqE,GACA,sBAAAzqE,GACAA,EAAA0qE,YAAA,QACArnC,WAAArjC,GAAA,IAAAyqE,EAEApnC,WAAArjC,GAEAA,EAZA,GAAA2mC,GAAAzhC,EAAA,sBACAu5B,EAAAv5B,EAAA,2BACAg1D,EAAA,GAAAz7B,GACA2nC,EAAA,YAsGA,OA3FAA,GAAA94D,WACAkhB,YAAA43C,EACAnO,aAAA,SAAA7gB,EAAA3qC,EAAA5B,GACA,GAAAN,GAAAjJ,KAAAiJ,MACAlH,EAAAkH,EAAAlH,IAGA,IADA,MAAAA,OAAA,IACAA,EAAA,CAIA+zC,EAAAuzB,MACA,IAAAz+D,GACAjB,EACA2tB,EAAAruB,EAAAquB,aACAy3B,EAAA9lD,EAAA+1B,aACA0oC,EAAAz+D,EAAAjH,UACA8kB,EAAA7d,EAAAC,UAAAD,EAAA6d,KACA6gD,EAAA1+D,EAAAH,aACA+d,EAAA5d,EAAA8B,iBACAxB,MAAA87B,EAAA77B,gBAAAzH,EAAA+kB,EAAA4gD,EAAAC,EAEA,IAAAjoC,GAAA1/B,KAAA0/B,SAWA,IAVAz2B,EAAAu/D,cAOAxoE,KAAA41D,aAAA9f,GANApW,IACAk5B,EAAA91B,KAAA33B,GACAytD,EAAA96B,eAAA4B,GACAv0B,EAAAytD,GAMAthC,YAAAnyB,QAMA,GAJAyF,EAAAO,EAAAP,EAAAglB,EAAA0H,EAAA,GAAAnsB,EAAAZ,OACAZ,EAAAwB,EAAAxB,EAAAimB,EAAA0H,EAAA,GAAAnsB,EAAAvB,QACA89D,KAAA,OACAC,KAAA,MACA9gD,EAAA,CACA,OAAAA,GACA,aACAld,GAAAJ,EAAAK,OAAA,EAAAL,EAAAyvD,WAAA,CACA,MACA,cACArvD,GAAAJ,EAAAK,OAAAL,EAAAyvD,WAAA,CACA,MACA,SACArvD,GAAAJ,EAAAyvD,WAAA,EAGA2O,EAAA,cAEa,CACb,GAAAt7B,GAAAhH,EAAA43B,yBAAA3lC,EAAAnsB,EAAA5B,EAAAwlD,EACAnkD,GAAAyhC,EAAAzhC,EACAjB,EAAA0iC,EAAA1iC,EAEA+9D,KAAAr7B,EAAArqC,UACA2lE,KAAAt7B,EAAAvjC,aAGAgtC,EAAA9zC,UAAA0lE,GAAA,OAEA5xB,EAAAhtC,aAAA6+D,GAAA,YACA,IAAA1oC,GAAAh2B,EAAAg2B,SACAmpC,EAAAn/D,EAAAm/D,UACAnpC,KAAA6W,EAAAkgB,UAAA/2B,GACAmpC,IAAAtyB,EAAAmgB,YAAAmS,GAEAtyB,EAAAhvB,QAAA,kBAGAgvB,EAAAmyB,WAAAh/D,EAAAo/D,eACAvyB,EAAAwzB,YAAArgE,EAAAsgE,iBAAA,cACAzzB,EAAAoyB,cAAAj/D,EAAAq/D,kBACAxyB,EAAAqyB,cAAAl/D,EAAAs/D,iBACA,IAAArP,GAAAn3D,EAAAmC,MAAA,KACA+E,GAAAw/D,eACA/oC,GAAAoW,EAAAuR,UAAA3nB,EAAA,GAAAA,EAAA,IACAoW,EAAA3qB,OAAAliB,EAAAw/D,cACA/oC,GAAAoW,EAAAuR,WAAA3nB,EAAA,IAAAA,EAAA,IAEA,QAAAh7B,GAAA,EAA2BA,EAAAw0D,EAAA70D,OAAsBK,IACjDu6B,GAAA6W,EAAAqjB,SAAAD,EAAAx0D,GAAAkG,EAAAjB,GACAy+D,GAAAtyB,EAAAsjB,WAAAF,EAAAx0D,GAAAkG,EAAAjB,GACAA,GAAAJ,EAAAyvD,UAEAljB,GAAA0zB,aAGA1E,IAEAjhE,EAAA,mIAAAD,GACA,YACA,IAAAuvC,GAAAvvC,EAAA,eACA+L,EAAA/L,EAAA,oBACA6lE,EAAA7lE,EAAA,yBACA8lE,EAAA9lE,EAAA,sBACAoC,EAAApC,EAAA,eAQAq0D,EAAA,SAAAjoD,GACAy5D,EAAAr6D,KAAApP,KAAAgQ,GACAL,EAAAP,KAAApP,KAAAgQ,GACA05D,EAAAt6D,KAAApP,KAAAgQ,GAKAhQ,KAAAG,GAAA6P,EAAA7P,IAAAgzC,IAsIA,OApIA8kB,GAAAjsD,WACA1K,KAAA,UACAe,KAAA,GACA64B,KAAA,KACAvlB,QAAA,EACAqT,SAAA,KACA2gD,MAAA,SAAAlmD,EAAAE,GACA,OAAA3jB,KAAA+kE,WACA,iBACAphD,EAAA,CACA,MACA,gBACAF,EAAA,EAGA,GAAAua,GAAAh+B,KAAA0/B,SACA1B,KACAA,EAAAh+B,KAAA0/B,WACA,EACA,EACA,EACA,EACA,EACA,IAGA1B,EAAA,IAAAva,EACAua,EAAA,IAAAra,EACA3jB,KAAA4pE,qBACA5pE,KAAAq0D,OAAA,IAEAwV,aAAA,aAEAC,YAAA,aAEA7oE,OAAA,WACAjB,KAAA+pE,mBAEAz0D,SAAA,SAAAyT,EAAAtZ,KAEAkoD,OAAA,SAAAx4C,EAAAzgB,GACA,gBAAAygB,GAAA,UAAAA,GAAA,WAAAA,GAEA,GAAAzgB,EAAA,CACA,GAAA4I,GAAAtH,KAAAmf,EACA7X,KACAA,EAAAtH,KAAAmf,OAEA7X,EAAA,GAAA5I,EAAA,GACA4I,EAAA,GAAA5I,EAAA,QAGAsB,MAAAmf,GAAAzgB,GAGAsrE,KAAA,WACAhqE,KAAA2V,QAAA,EACA3V,KAAAk7B,MAAAl7B,KAAAk7B,KAAAga,WAEA7tC,KAAA,WACArH,KAAA2V,QAAA,EACA3V,KAAAk7B,MAAAl7B,KAAAk7B,KAAAga,WAEArqC,KAAA,SAAAsU,EAAAzgB,GACA,mBAAAygB,GACAnf,KAAA23D,OAAAx4C,EAAAzgB,OACa,IAAAsH,EAAAqW,SAAA8C,GACb,OAAA9c,KAAA8c,GACAA,EAAA6M,eAAA3pB,IACArC,KAAA23D,OAAAt1D,EAAA8c,EAAA9c,GAKA,OADArC,MAAAq0D,OAAA,GACAr0D,MAEA0oB,YAAA,SAAAM,GACA,GAAA5V,GAAApT,KAAAk7B,IACA9nB,IACA4V,EAAA4rB,YAAAxhC,GAGApT,KAAAgpB,UAAAhpB,KAAAgpB,cACAhpB,KAAAyoB,iBAEAzoB,KAAAgpB,WACAA,EAAAkS,KAAA9nB,EACA4V,EAAAyuC,aAAAz3D,KACAA,KAAAq0D,OAAA,IAEA5rC,eAAA,WACA,GAAAO,GAAAhpB,KAAAgpB,QACAA,KACAA,EAAAkS,MACAlS,EAAA2rB,iBAAA3rB,EAAAkS,MAEAlS,EAAAkS,KAAA,KACAlS,EAAAyuC,aAAA,KACAz3D,KAAAgpB,SAAA,KACAhpB,KAAAq0D,OAAA,KAGAzf,YAAA,SAAAxhC,GACApT,KAAAk7B,KAAA9nB,CAEA,IAAA62D,GAAAjqE,KAAAiqE,SACA,IAAAA,EACA,OAAAvlE,GAAA,EAA+BA,EAAAulE,EAAA5lE,OAAsBK,IACrD0O,EAAAzB,UAAAu4D,YAAAD,EAAAvlE,GAGA1E,MAAAgpB,UACAhpB,KAAAgpB,SAAA4rB,YAAAxhC,IAGAuhC,iBAAA,SAAAvhC,GACApT,KAAAk7B,KAAA,IAEA,IAAA+uC,GAAAjqE,KAAAiqE,SACA,IAAAA,EACA,OAAAvlE,GAAA,EAA+BA,EAAAulE,EAAA5lE,OAAsBK,IACrD0O,EAAAzB,UAAAw4D,eAAAF,EAAAvlE,GAGA1E,MAAAgpB,UACAhpB,KAAAgpB,SAAA2rB,iBAAAvhC,KAIApN,EAAAsS,MAAA2/C,EAAAyR,GACA1jE,EAAAsS,MAAA2/C,EAAAwR,GACAzjE,EAAAsS,MAAA2/C,EAAAtoD,GACAsoD,IAEAp0D,EAAA,+EAAAD,GACA,GAAAoC,GAAApC,EAAA,oBACA,iBAAA2kD,GAEA,OAAA7jD,GAAA,EAAuBA,EAAA6jD,EAAAlkD,OAAuBK,IAC9C6jD,EAAA7jD,GAAA,KACA6jD,EAAA7jD,GAAA,GAAA6jD,EAAA7jD,GAAA,GAGA,iBAAAuiE,GAEA,OADAh+D,MACAvE,EAAA,EAA2BA,EAAA6jD,EAAAlkD,OAAuBK,IAAA,CAClD,GAAAmlD,GAAAtB,EAAA7jD,GAAA,EACA,MAAAuiE,GAAAjhE,EAAAhC,QAAAijE,EAAApd,IAAA,IAGA,GAAA58C,GAAAjN,KAAAo8B,WAAAytB,EACA,OAAA58C,IACAhE,EAAAs/C,EAAA7jD,GAAA,IAAAuI,IAGA,MAAAhE,OAIApF,EAAA,6EAAAD,GACA,YAEA,SAAAwmE,GAAA/3C,GACA,MAAAryB,MAAAqqE,MAAAh4C,GAFA,GAAArsB,GAAApC,EAAA,qBAQA6sD,EAAA,SAAApuD,GACArC,KAAAqqE,SACArqE,KAAAsqE,YAIAtqE,KAAAqC,QAAA,GAuCA,OArCAouD,GAAAzkD,WACAkhB,YAAAujC,EACAnvD,KAAA,YACA0yB,QAAA,SAAA3B,GACA,MAAAryB,MAAAqqE,MAAAh4C,IAEAk4C,QAAA,WACA,MAAAvkE,GAAA+W,IAAA/c,KAAAsqE,SAAAF,EAAApqE,OAEA0wD,eAAA,SAAA8Z,GAEA,MADAA,KAAA96D,cACA1J,EAAAynB,OAAAztB,KAAAuqE,UAAA,SAAAt5C,GACA,MAAAA,GAAA/O,MAAA5gB,OAAAkpE,KAGAz1C,QAAA,SAAA9D,GACA,GAAAoB,GAAApB,EAAAoB,GACAryB,MAAAqqE,MAAAh4C,GAAApB,EACAjxB,KAAAsqE,SAAA9oE,KAAA6wB,IAEAyH,YAAA,SAAA7sB,GACA,MAAAjN,MAAAyqE,kBAAAx9D,EAAA,gBAEAgkD,YAAA,SAAAhkD,GACA,MAAAjN,MAAAyqE,kBAAAx9D,EAAA,gBAEAw9D,kBAAA,SAAAC,EAAAxkE,GAGA,OAFAykE,GAAA3qE,KAAAsqE,SACAM,EAAAF,YAAAvlE,aACAT,EAAA,EAA2BA,EAAAimE,EAAAtmE,OAAoBK,IAAA,CAC/C,GAAA2tB,GAAAs4C,EAAAjmE,GACAusB,EAAAjxB,KAAAqqE,MAAAh4C,EACAu4C,GAAAv4C,GAAApB,EAAA/qB,GAAAwkE,EAAAr4C,IAEA,MAAAu4C,KAGAna,IAEA5sD,EAAA,kCACA,GAAAgnE,GAAA,IACA,mBACA,MAAAA,QAGAhnE,EAAA,qFAAAD,GACA,YAKA,SAAAknE,GAAA79D,GACA,MAAAA,GAAAs4D,GAAAt4D,GAAAs4D,EALA,GAAA1kD,GAAAjd,EAAA,kBACAkd,EAAAld,EAAA,kBACAmnE,EAAAlqD,EAAAwe,SACAkmC,EAAA,KAQAkE,EAAA,SAAAz5D,GACAA,QAEAA,EAAA8T,WAMA9jB,KAAA8jB,UACA,EACA,IAGA,MAAA9T,EAAA+W,WAMA/mB,KAAA+mB,SAAA,GAEA/W,EAAAkS,QAMAliB,KAAAkiB,OACA,EACA,IAQAliB,KAAAgnB,OAAAhnB,KAAAgnB,QAAA,MAEAgkD,EAAAvB,EAAAz9D,SACAg/D,GAAAtrC,UAAA,KAKAsrC,EAAAC,mBAAA,WACA,MAAAH,GAAA9qE,KAAA+mB,WAAA+jD,EAAA9qE,KAAA8jB,SAAA,KAAAgnD,EAAA9qE,KAAA8jB,SAAA,KAAAgnD,EAAA9qE,KAAAkiB,MAAA,OAAA4oD,EAAA9qE,KAAAkiB,MAAA,OAEA8oD,EAAAjB,gBAAA,WACA,GAAAvqC,GAAAx/B,KAAAw/B,OACA0rC,EAAA1rC,KAAAE,UACAurC,EAAAjrE,KAAAirE,qBACAjtC,EAAAh+B,KAAA0/B,SACA,OAAAurC,IAAAC,GAIAltC,KAAAnd,EAAAxR,SACA47D,EACAjrE,KAAAu/B,kBAAAvB,GAEA+sC,EAAA/sC,GAGAktC,IACAD,EACApqD,EAAAye,IAAAtB,EAAAwB,EAAAE,UAAA1B,GAEAnd,EAAAiiB,KAAA9E,EAAAwB,EAAAE,YAIA1/B,KAAA0/B,UAAA1B,EACAh+B,KAAAmrE,aAAAnrE,KAAAmrE,cAAAtqD,EAAAxR,aACAwR,GAAA8e,OAAA3/B,KAAAmrE,aAAAntC,SApBAA,GAAA+sC,EAAA/sC,KAsBAgtC,EAAAzrC,kBAAA,SAAAvB,GACAA,QACA+sC,EAAA/sC,EACA,IAAAhX,GAAAhnB,KAAAgnB,OACA9E,EAAAliB,KAAAkiB,MACA6E,EAAA/mB,KAAA+mB,SACAjD,EAAA9jB,KAAA8jB,QAiBA,OAhBAkD,KAEAgX,EAAA,IAAAhX,EAAA,GACAgX,EAAA,IAAAhX,EAAA,IAEAnG,EAAAqB,MAAA8b,IAAA9b,GACA6E,GACAlG,EAAAsK,OAAA6S,IAAAjX,GAEAC,IAEAgX,EAAA,IAAAhX,EAAA,GACAgX,EAAA,IAAAhX,EAAA,IAEAgX,EAAA,IAAAla,EAAA,GACAka,EAAA,IAAAla,EAAA,GACAka,GAMAgtC,EAAApV,aAAA,SAAA9f,GACA,GAAA9X,GAAAh+B,KAAA0/B,UACAllB,EAAAs7B,EAAAt7B,KAAA,CACAwjB,GACA8X,EAAA8f,aAAAp7C,EAAAwjB,EAAA,GAAAxjB,EAAAwjB,EAAA,GAAAxjB,EAAAwjB,EAAA,GAAAxjB,EAAAwjB,EAAA,GAAAxjB,EAAAwjB,EAAA,GAAAxjB,EAAAwjB,EAAA,IAEA8X,EAAA8f,aAAAp7C,EAAA,IAAAA,EAAA,MAGAwwD,EAAAtU,iBAAA,SAAA5gB,GACA,GACAt7B,IADAxa,KAAA0/B,UACAoW,EAAAt7B,KAAA,EACAs7B,GAAA8f,aAAAp7C,EAAA,IAAAA,EAAA,KAEA,IAAA4wD,KAkGA,OA9FAJ,GAAApB,mBAAA,WACA,GAAA5pE,KAAA0/B,UAAA,CAGA,GAAAF,GAAAx/B,KAAAw/B,OACAxB,EAAAh+B,KAAA0/B,SACAF,MAAAE,YAEA7e,EAAAye,IAAA8rC,EAAA5rC,EAAA2rC,aAAAntC,GACAA,EAAAotC,EAEA,IAAApR,GAAAh8B,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACAi8B,EAAAj8B,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACAla,EAAA9jB,KAAA8jB,SACA5B,EAAAliB,KAAAkiB;AACA4oD,EAAA9Q,EAAA,KACAA,EAAAv4D,KAAAktD,KAAAqL,IAEA8Q,EAAA7Q,EAAA,KACAA,EAAAx4D,KAAAktD,KAAAsL,IAEAj8B,EAAA,OACAg8B,MAEAh8B,EAAA,OACAi8B,MAEAn2C,EAAA,GAAAka,EAAA,GACAla,EAAA,GAAAka,EAAA,GACA9b,EAAA,GAAA83C,EACA93C,EAAA,GAAA+3C,EACAj6D,KAAA+mB,SAAAtlB,KAAAoiE,OAAA7lC,EAAA,GAAAi8B,EAAAj8B,EAAA,GAAAg8B,KAMAgR,EAAA1U,eAAA,WACA,GAAAt4B,GAAAh+B,KAAA0/B,SACA,KAAA1B,EACA,OACA,EACA,EAGA,IAAAg8B,GAAAv4D,KAAAktD,KAAA3wB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAi8B,EAAAx4D,KAAAktD,KAAA3wB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAOA,OANAA,GAAA,OACAg8B,MAEAh8B,EAAA,OACAi8B,OAGAD,EACAC,IAUA+Q,EAAA1T,sBAAA,SAAA1sD,EAAAjB,GACA,GAAA8kD,IACA7jD,EACAjB,GAEAwhE,EAAAnrE,KAAAmrE,YAIA,OAHAA,IACArqD,EAAAgd,eAAA2wB,IAAA0c,GAEA1c,GASAuc,EAAAK,uBAAA,SAAAzgE,EAAAjB,GACA,GAAA8kD,IACA7jD,EACAjB,GAEA+1B,EAAA1/B,KAAA0/B,SAIA,OAHAA,IACA5e,EAAAgd,eAAA2wB,IAAA/uB,GAEA+uB,GAEAgb,IAEA5lE,EAAA,qGAAAD,GACA,YACA,IAAA0nE,GAAA1nE,EAAA,yBACAmd,EAAAnd,EAAA,gBACAoqB,EAAAjN,EAAAiN,SACAD,EAAAhN,EAAAgN,WACA1R,EAAA0E,EAAA1E,SACAjD,EAAAxV,EAAA,eAKA8lE,EAAA,WAKA1pE,KAAAiqE,aAoIA,OAlIAP,GAAA19D,WACAkhB,YAAAw8C,EACA3lD,QAAA,SAAA0Z,EAAAi6B,GACA,GAAApwD,GACAikE,GAAA,EACAvqE,EAAAhB,KACAoT,EAAApT,KAAAk7B,IACA,IAAAuC,EAAA,CACA,GAAA+tC,GAAA/tC,EAAAv5B,MAAA,KACA+oB,EAAAjsB,CAEAuqE,GAAA,UAAAC,EAAA,EACA,QAAA9mE,GAAA,EAAAe,EAAA+lE,EAAAnnE,OAAwDK,EAAAe,EAAOf,IAC/DuoB,IAGAA,IAAAu+C,EAAA9mE,IAEAuoB,KACA3lB,EAAA2lB,OAGA3lB,GAAAtG,CAEA,KAAAsG,EAEA,WADA8R,GAAA,aAAAqkB,EAAA,+BAAAz8B,EAAAb,GAGA,IAAA8pE,GAAAjpE,EAAAipE,UACAwB,EAAA,GAAAH,GAAAhkE,EAAAowD,EAYA,OAXA+T,GAAAC,OAAA,SAAApkE,GACAtG,EAAAqzD,MAAAkX,KACaI,KAAA,WAEb1B,EAAA71D,OAAA2M,EAAA/c,QAAAimE,EAAAwB,GAAA,KAEAxB,EAAAzoE,KAAAiqE,GAEAr4D,GACAA,EAAAzB,UAAAu4D,YAAAuB,GAEAA,GAEA11D,cAAA,SAAA61D,GAGA,OAFA3B,GAAAjqE,KAAAiqE,UACAn+C,EAAAm+C,EAAA5lE,OACAK,EAAA,EAA2BA,EAAAonB,EAASpnB,IACpCulE,EAAAvlE,GAAAgxC,KAAAk2B,EAGA,OADA3B,GAAA5lE,OAAA,EACArE,MAEAulB,UAAA,SAAAje,EAAAmiD,EAAA7C,EAAAilB,EAAA7mE,GA8BA,QAAA2mE,KACAnjD,IACAA,GACAxjB,OA/BAgpB,EAAA44B,IACA5hD,EAAA6mE,EACAA,EAAAjlB,EACAA,EAAA,GAEA74B,EAAA89C,IACA7mE,EAAA6mE,EACAA,EAAA,SACAjlB,EAAA,GAEA74B,EAAA64B,IACA5hD,EAAA4hD,EACAA,EAAA,GAEA74B,EAAA07B,IACAzkD,EAAAykD,EACAA,EAAA,KAEAA,IACAA,EAAA,KAGAzpD,KAAA+V,gBACA/V,KAAA8rE,kBAAA,GAAA9rE,KAAAsH,EAAAmiD,EAAA7C,EAAAilB,EAAA7mE,EAGA,IAAAilE,GAAAjqE,KAAAiqE,UAAAtlE,QACA6jB,EAAAyhD,EAAA5lE,MASAmkB,IACAxjB,MAIA,QAAAN,GAAA,EAA2BA,EAAAulE,EAAA5lE,OAAsBK,IACjDulE,EAAAvlE,GAAAinE,QAAAvpD,MAAAypD,IAGAC,kBAAA,SAAAruC,EAAA7R,EAAAtkB,EAAAmiD,EAAA7C,GACA,GAAAmlB,MACAC,EAAA,CACA,QAAA3pE,KAAAiF,GACA,SAAAskB,EAAAvpB,GACAga,EAAA/U,EAAAjF,MAAA0e,EAAAoM,YAAA7lB,EAAAjF,IACArC,KAAA8rE,kBAAAruC,IAAA,IAAAp7B,IAAAupB,EAAAvpB,GAAAiF,EAAAjF,GAAAonD,EAAA7C,IAEAmlB,EAAA1pE,GAAAiF,EAAAjF,GACA2pE,SAEiB,UAAA1kE,EAAAjF,GAGjB,GAAAo7B,EAEqB,CAErB,GAAAxB,KACAA,GAAAwB,MACAxB,EAAAwB,GAAAp7B,GAAAiF,EAAAjF,GACArC,KAAA6K,KAAAoxB,OANAj8B,MAAA6K,KAAAxI,EAAAiF,EAAAjF,GAaA,OAHA2pE,GAAA,GACAhsE,KAAA+jB,QAAA0Z,GAAA,GAAAzZ,KAAA,MAAAylC,EAAA,IAAAA,EAAAsiB,GAAAnlB,SAAA,GAEA5mD,OAGA0pE,IAEA7lE,EAAA,4EAAAD,GACA,GAAAoC,GAAApC,EAAA,qBACAipB,EAAAjpB,EAAA,WACA+P,EAAAkZ,EAAAlZ,eACAqO,EAAA,EACA4vB,KACAq6B,EAAA,GAmJA,OA7IAr6B,GAAAE,OAAA,SAAAxwC,GAGA,OACAA,GAAA,GACA0gB,IACAvgB,KAAAC,UACAmD,KAAAonE,IAKAr6B,EAAAW,uBAAA,SAAA4xB,GACA,GAAA+H,KAeA,OAdA/H,GAAAgI,yBAAA,SAAA94D,EAAA+4D,GACA/4D,EAAAM,EAAAN,GACA64D,EAAA74D,EAAAU,MAAAq4D,GAEAjI,EAAA16B,iBAAA,SAAAp2B,EAAAhS,GACA,GAAAC,GAAAD,EAAAC,IACA,KAAAA,EAAA,CACA,GAAAijE,GAAA5wD,EAAAN,GAAAU,IACAowD,GAAAO,YAAArxD,IAAA64D,EAAA3H,KACAjjE,EAAA4qE,EAAA3H,GAAAljE,IAGA,MAAAC,IAEA6iE,GAWAvyB,EAAAY,wBAAA,SAAA2xB,EAAAkI,GA2DA,QAAAC,GAAAC,GACA,GAAAC,MACAC,IAmBA,OAlBAzmE,GAAAkJ,KAAAq9D,EAAA,SAAAlqE,GACA,GAAAqqE,GAAAC,EAAAH,EAAAnqE,GACAuqE,EAAAF,EAAAE,aAAAP,EAAAhqE,GACAwqE,EAAAC,EAAAF,EAAAL,EACAG,GAAAK,WAAAF,EAAAxoE,OACA,IAAAqoE,EAAAK,YACAN,EAAAjrE,KAAAa,GAEA2D,EAAAkJ,KAAA29D,EAAA,SAAAG,GACAhnE,EAAAhC,QAAA0oE,EAAAO,YAAAD,GAAA,GACAN,EAAAO,YAAAzrE,KAAAwrE,EAEA,IAAAE,GAAAP,EAAAH,EAAAQ,EACAhnE,GAAAhC,QAAAkpE,EAAAC,UAAAH,GAAA,GACAE,EAAAC,UAAA3rE,KAAAa,QAKAmqE,QACAC,eAGA,QAAAE,GAAAH,EAAAnqE,GAOA,MANAmqE,GAAAnqE,KACAmqE,EAAAnqE,IACA4qE,eACAE,eAGAX,EAAAnqE,GAEA,QAAAyqE,GAAAF,EAAAL,GACA,GAAAM,KAIA,OAHA7mE,GAAAkJ,KAAA09D,EAAA,SAAAQ,GACApnE,EAAAhC,QAAAuoE,EAAAa,IAAA,GAAAP,EAAArrE,KAAA4rE,KAEAP,EA1FA1I,EAAA54B,kBAAA,SAAA8hC,EAAAd,EAAAvnE,EAAAyK,GAwBA,QAAA69D,GAAAC,GACAf,EAAAe,GAAAR,aACA,IAAAP,EAAAe,GAAAR,YACAr4D,EAAAlT,KAAA+rE,GASA,QAAAC,GAAAD,GACAE,EAAAF,IAAA,EACAD,EAAAC,GArCA,GAAAF,EAAAhpE,OAAA,CAGA,GAAAwnB,GAAAygD,EAAAC,GACAC,EAAA3gD,EAAA2gD,MACA93D,EAAAmX,EAAA4gD,YACAgB,IAIA,KAHAznE,EAAAkJ,KAAAm+D,EAAA,SAAAhrE,GACAorE,EAAAprE,IAAA,IAEAqS,EAAArQ,QAAA,CACA,GAAAqpE,GAAAh5D,EAAAwiC,MACAy2B,EAAAnB,EAAAkB,GACAE,IAAAH,EAAAC,EACAE,KACA5oE,EAAAoK,KAAAK,EAAAi+D,EAAAC,EAAAf,aAAAjoE,eACA8oE,GAAAC,IAEA1nE,EAAAkJ,KAAAy+D,EAAAR,UAAAS,EAAAJ,EAAAF,GAEAtnE,EAAAkJ,KAAAu+D,EAAA,WACA,SAAA7nE,OAAA,qCAuEAgsC,IAEA/tC,EAAA,qDAAAD,GACA,OACA0G,mBAAA,WACA,OACA7C,KAAAzH,KAAA0I,IAAA,QACA9G,IAAA5B,KAAA0I,IAAA,OACA4R,MAAAta,KAAA0I,IAAA,SACA7G,OAAA7B,KAAA0I,IAAA,UACA6B,MAAAvK,KAAA0I,IAAA,SACAkB,OAAA5J,KAAA0I,IAAA,eAKA7E,EAAA,+EAAAD,GAIA,QAAAiqE,GAAAlgE,EAAAmgE,GACA,GAAA/9C,GAAApiB,EAAA,GAAAA,EAAA,GACAme,EAAAgiD,EACA7iE,EAAA8kB,EAAAjE,EAAA,CACAne,GAAA,IAAA1C,EACA0C,EAAA,IAAA1C,EARA,GAAAW,GAAAhI,EAAA,kBACA6sB,EAAA7kB,EAAA6kB,UACAzqB,EAAApC,EAAA,qBAQAmqE,GACA,EACA,GAMA7c,EAAA,SAAA7+B,EAAAnQ,EAAAvU,GAKA3N,KAAAqyB,MAKAryB,KAAAkiB,QAKAliB,KAAA4N,QAAAD,IACA,EACA,GAKA3N,KAAA8zB,SAAA,EAKA9zB,KAAA40B,QAAA,EAwFA,OAtFAs8B,GAAAllD,WACAkhB,YAAAgkC,EACA9B,QAAA,SAAA98B,GACA,GAAA3kB,GAAA3N,KAAA4N,QACAlI,EAAAjE,KAAAiE,IAAAiI,EAAA,GAAAA,EAAA,IACAyM,EAAA3Y,KAAA2Y,IAAAzM,EAAA,GAAAA,EAAA,GACA,OAAA2kB,IAAA5sB,GAAA4sB,GAAAlY,GAEA22C,YAAA,SAAAlyD,GACA,MAAAmB,MAAAovD,QAAApvD,KAAA85B,YAAAj7B,KAEAyjB,UAAA,WACA,GAAA2iB,GAAAjlC,KAAA4N,QAAAjJ,OACA,OAAAsgC,IAEAX,kBAAA,SAAAC,GACA,MAAA34B,GAAA04B,kBAAAC,GAAAvkC,KAAAkiB,MAAAI,YAAAtiB,KAAA4N,UAEAuU,UAAA,SAAAC,EAAAC,GACA,GAAA1U,GAAA3N,KAAA4N,OACAD,GAAA,GAAAyU,EACAzU,EAAA,GAAA0U,GAEAyX,YAAA,SAAAj7B,EAAA6kC,GACA,GAAA/1B,GAAA3N,KAAA4N,QACAsU,EAAAliB,KAAAkiB,KAMA,OALArjB,GAAAqjB,EAAApe,UAAAjF,GACAmB,KAAA40B,QAAA,YAAA1S,EAAA5gB,OACAqM,IAAAhJ,QACAkpE,EAAAlgE,EAAAuU,EAAAsG,UAEAiI,EAAA5xB,EAAAkvE,EAAApgE,EAAA+1B,IAEAutB,YAAA,SAAA3+B,EAAAoR,GACA,GAAA/1B,GAAA3N,KAAA4N,QACAsU,EAAAliB,KAAAkiB,KACAliB,MAAA40B,QAAA,YAAA1S,EAAA5gB,OACAqM,IAAAhJ,QACAkpE,EAAAlgE,EAAAuU,EAAAsG,SAEA,IAAAo6B,GAAAnyB,EAAA6B,EAAA3kB,EAAAogE,EAAArqC,EACA,OAAA1jC,MAAAkiB,YAAA0gC,IAEAorB,eAAA,SAAAC,GACA,GAAAjuE,KAAA40B,SAAAq5C,EAAA,CAGA,OAFAC,GAAAluE,KAAAmuE,WACAn0C,KACAt1B,EAAA,EAA+BA,EAAAwpE,EAAA7pE,OAAkBK,IACjDs1B,EAAAx4B,KAAA0sE,EAAAxpE,GAAA,GAKA,OAHAwpE,GAAAxpE,EAAA,IACAs1B,EAAAx4B,KAAA0sE,EAAAxpE,EAAA,OAEAs1B,EAEA,MAAAh0B,GAAA+W,IAAA/c,KAAAkiB,MAAAD,WAAAjiB,KAAA85B,YAAA95B,OAGAouE,gBAAA,WACA,MAAApoE,GAAA+W,IAAA/c,KAAAkiB,MAAAD,WAAAjiB,KAAA85B,YAAA95B,OAEAmuE,SAAA,WAOA,OANAxgE,GAAA3N,KAAAsiB,YACA4rD,KACApiD,EAAA9rB,KAAAkiB,MAAAsG,QACApG,EAAAzU,EAAA,GACA0U,EAAA1U,EAAA,GACAW,EAAA+T,EAAAD,EACA1d,EAAA,EAA2BA,EAAAonB,EAASpnB,IACpCwpE,EAAA1sE,MACA8M,EAAA5J,EAAAonB,EAAA1J,EACA9T,GAAA5J,EAAA,GAAAonB,EAAA1J,GAGA,OAAA8rD,IAEAh2C,aAAA,WACA,GAAAhG,GAAAlyB,KAAA4N,QACA22B,EAAAvkC,KAAAkiB,MAAAI,YACAwJ,EAAAyY,EAAA,GAAAA,EAAA,IAAAvkC,KAAA40B,OAAA,IAEA,KAAA9I,MAAA,EACA,IAAAiE,GAAAtuB,KAAAihB,IAAAwP,EAAA,GAAAA,EAAA,GACA,OAAAzwB,MAAAihB,IAAAqN,GAAAjE,IAGAolC,IAEArtD,EAAA,qGAAAD,GACA,YACA,IAAAoC,GAAApC,EAAA,qBACAivB,EAAAjvB,EAAA,gBACA,iBAAAqtB,GACA,GAAAH,GAAAG,EAAA3d,MACAuR,EAAAiM,EAAAloB,SAAA,aACA0oD,EAAAzsC,EAAAnc,IAAA,WACA,oBAAAuoB,EAAA3vB,MAAA,SAAAgwD,EACA,SAAAA,EAAA,EAAAA,EAEAz+B,EAAAm9B,qBAAAhqD,EAAA+W,IAAAkU,EAAA/O,MAAAD,WAAAgP,EAAA6I,YAAA7I,GAAAH,EAAAK,qBAAAtM,EAAAjc,SAAA,aAAAO,UAAA8nB,EAAA2C,mBAGA/vB,EAAA,oDAAAD,GACA,GAAAqxC,GAAArxC,EAAA,YAKA,mBACA,OAAAqxC,EAAAo5B,UAES,MAAAp5B,EAAAo5B,UACT,OAAAjoC,KAAA3c,WACA,SAAA7jB,OAAA6jB,UAAA2c,QAES,IAAA6O,EAAAo5B,UAAA,EACT,OAAAjoC,KAAA3c,WACAvT,QAAAkD,IAAAqQ,UAAA2c,OAYAviC,EAAA,0FAAAD,GAMA,QAAA0qE,GAAAhnE,EAAA6X,GACA,MAAA7X,GAAA6X,GAEA,QAAAovD,GAAAjnE,EAAA6X,EAAAzgB,GACA4I,EAAA6X,GAAAzgB,EAQA,QAAA8vE,GAAAC,EAAAC,EAAApkD,GACA,OAAAokD,EAAAD,GAAAnkD,EAAAmkD,EAQA,QAAAE,GAAAF,EAAAC,EAAApkD,GACA,MAAAA,GAAA,GAAAokD,EAAAD,EASA,QAAAG,GAAAH,EAAAC,EAAApkD,EAAAkuB,EAAAq2B,GACA,GAAA/iD,GAAA2iD,EAAApqE,MACA,OAAAwqE,EACA,OAAAnqE,GAAA,EAA2BA,EAAAonB,EAASpnB,IACpC8zC,EAAA9zC,GAAA8pE,EAAAC,EAAA/pE,GAAAgqE,EAAAhqE,GAAA4lB,OAIA,QADAwkD,GAAAL,EAAA,GAAApqE,OACAK,EAAA,EAA2BA,EAAAonB,EAASpnB,IACpC,OAAAm5D,GAAA,EAA+BA,EAAAiR,EAAUjR,IACzCrlB,EAAA9zC,GAAAm5D,GAAA2Q,EAAAC,EAAA/pE,GAAAm5D,GAAA6Q,EAAAhqE,GAAAm5D,GAAAvzC,GAOA,QAAAykD,GAAAC,EAAAC,EAAAJ,GACA,GAAAK,GAAAF,EAAA3qE,OACA8qE,EAAAF,EAAA5qE,MACA,IAAA6qE,IAAAC,EAAA,CAEA,GAAAC,GAAAF,EAAAC,CACA,IAAAC,EAEAJ,EAAA3qE,OAAA8qE,MAGA,QAAAzqE,GAAAwqE,EAAqCxqE,EAAAyqE,EAAazqE,IAClDsqE,EAAAxtE,KAAA,IAAAqtE,EAAAI,EAAAvqE,GAAA2qE,EAAAjgE,KAAA6/D,EAAAvqE,KAMA,OADAoqE,GAAAE,EAAA,IAAAA,EAAA,GAAA3qE,OACAK,EAAA,EAAuBA,EAAAsqE,EAAA3qE,OAAiBK,IACxC,OAAAmqE,EACAnvD,MAAAsvD,EAAAtqE,MACAsqE,EAAAtqE,GAAAuqE,EAAAvqE,QAGA,QAAAm5D,GAAA,EAA+BA,EAAAiR,EAAUjR,IACzCn+C,MAAAsvD,EAAAtqE,GAAAm5D,MACAmR,EAAAtqE,GAAAm5D,GAAAoR,EAAAvqE,GAAAm5D,IAYA,QAAAyR,GAAAN,EAAAC,EAAAJ,GACA,GAAAG,IAAAC,EACA,QAEA,IAAAnjD,GAAAkjD,EAAA3qE,MACA,IAAAynB,IAAAmjD,EAAA5qE,OACA,QAEA,QAAAwqE,GACA,OAAAnqE,GAAA,EAA2BA,EAAAonB,EAASpnB,IACpC,GAAAsqE,EAAAtqE,KAAAuqE,EAAAvqE,GACA,aAKA,QADAoqE,GAAAE,EAAA,GAAA3qE,OACAK,EAAA,EAA2BA,EAAAonB,EAASpnB,IACpC,OAAAm5D,GAAA,EAA+BA,EAAAiR,EAAUjR,IACzC,GAAAmR,EAAAtqE,GAAAm5D,KAAAoR,EAAAvqE,GAAAm5D,GACA,QAKA,UAcA,QAAA0R,GAAAd,EAAAC,EAAAc,EAAAC,EAAA7sB,EAAA8sB,EAAAC,EAAAn3B,EAAAq2B,GACA,GAAA/iD,GAAA2iD,EAAApqE,MACA,OAAAwqE,EACA,OAAAnqE,GAAA,EAA2BA,EAAAonB,EAASpnB,IACpC8zC,EAAA9zC,GAAAkrE,EAAAnB,EAAA/pE,GAAAgqE,EAAAhqE,GAAA8qE,EAAA9qE,GAAA+qE,EAAA/qE,GAAAk+C,EAAA8sB,EAAAC,OAIA,QADAb,GAAAL,EAAA,GAAApqE,OACAK,EAAA,EAA2BA,EAAAonB,EAASpnB,IACpC,OAAAm5D,GAAA,EAA+BA,EAAAiR,EAAUjR,IACzCrlB,EAAA9zC,GAAAm5D,GAAA+R,EAAAnB,EAAA/pE,GAAAm5D,GAAA6Q,EAAAhqE,GAAAm5D,GAAA2R,EAAA9qE,GAAAm5D,GAAA4R,EAAA/qE,GAAAm5D,GAAAjb,EAAA8sB,EAAAC,GAgBA,QAAAC,GAAAnB,EAAAC,EAAAc,EAAAC,EAAA7sB,EAAA8sB,EAAAC,GACA,GAAAE,GAAA,IAAAL,EAAAf,GACAjgB,EAAA,IAAAihB,EAAAf,EACA,WAAAA,EAAAc,GAAAK,EAAArhB,GAAAmhB,OAAAjB,EAAAc,GAAA,EAAAK,EAAArhB,GAAAkhB,EAAAG,EAAAjtB,EAAA8rB,EAEA,QAAAoB,GAAApxE,GACA,GAAAyuB,EAAAzuB,GAAA,CACA,GAAAotB,GAAAptB,EAAA2F,MACA,IAAA8oB,EAAAzuB,EAAA,KAEA,OADAumC,MACAvgC,EAAA,EAA+BA,EAAAonB,EAASpnB,IACxCugC,EAAAzjC,KAAA6tE,EAAAjgE,KAAA1Q,EAAAgG,IAEA,OAAAugC,GAEA,MAAAoqC,GAAAjgE,KAAA1Q,GAEA,MAAAA,GAEA,QAAAqxE,GAAAz4B,GAIA,MAHAA,GAAA,GAAA71C,KAAA2K,MAAAkrC,EAAA,IACAA,EAAA,GAAA71C,KAAA2K,MAAAkrC,EAAA,IACAA,EAAA,GAAA71C,KAAA2K,MAAAkrC,EAAA,IACA,QAAAA,EAAAzyC,KAAA,SAEA,QAAAmrE,GAAAvE,EAAAI,EAAAoE,EAAAC,EAAArmB,GACA,GAAAsmB,GAAA1E,EAAA2E,QACAC,EAAA5E,EAAA6E,QACAC,EAAA,WAAA1E,EACA2E,EAAAN,EAAA7rE,MACA,IAAAmsE,EAAA,CAIA,GAMAC,GANAC,EAAAR,EAAA,GAAAxxE,MACAiyE,EAAAxjD,EAAAujD,GACAE,GAAA,EACAC,GAAA,EAEAhC,EAAA8B,GAAAxjD,EAAAujD,EAAA,OAGAR,GAAAhsC,KAAA,SAAAx3B,EAAAwD,GACA,MAAAxD,GAAA+8C,KAAAv5C,EAAAu5C,OAEAgnB,EAAAP,EAAAM,EAAA,GAAA/mB,IAOA,QALAqnB,MAEAC,KACAC,EAAAd,EAAA,GAAAxxE,MACAuyE,GAAA,EACAvsE,EAAA,EAAuBA,EAAA8rE,EAAc9rE,IAAA,CACrCosE,EAAAtvE,KAAA0uE,EAAAxrE,GAAA+kD,KAAAgnB,EAEA,IAAA/xE,GAAAwxE,EAAAxrE,GAAAhG,KAOA,IALAiyE,GAAArB,EAAA5wE,EAAAsyE,EAAAnC,KAAA8B,GAAAjyE,IAAAsyE,IACAC,GAAA,GAEAD,EAAAtyE,EAEA,gBAAAA,GAAA,CACA,GAAAwyE,GAAAhpE,EAAA8G,MAAAtQ,EACAwyE,IACAxyE,EAAAwyE,EACAN,GAAA,GAEAC,GAAA,EAGAE,EAAAvvE,KAAA9C,GAEA,IAAAuyE,EAAA,CAKA,OAFAE,GAAAJ,EAAAP,EAAA,GAEA9rE,EAAA,EAAuBA,EAAA8rE,EAAA,EAAkB9rE,IACzCisE,EACA5B,EAAAgC,EAAArsE,GAAAysE,EAAAtC,IAEAnvD,MAAAqxD,EAAArsE,KAAAgb,MAAAyxD,IAAAN,GAAAD,IACAG,EAAArsE,GAAAysE,EAIAR,IAAA5B,EAAAoB,EAAA1E,EAAA2F,QAAAvnB,GAAAsnB,EAAAtC,EAGA,IAEAzsD,GACA60C,EACAwX,EACAC,EACAc,EACAC,EAPA4B,EAAA,EACAC,EAAA,CAOA,IAAAV,EACA,GAAAt5B,IACA,EACA,EACA,EACA,EAGA,IAAAi6B,GAAA,SAAAjqE,EAAAgjB,GAIA,GAAAknD,EAEA,IAAAlnD,EAAA,EACAknD,EAAA,MACa,IAAAlnD,EAAAgnD,EAAA,CAIb,IADAlvD,EAAA3gB,KAAAiE,IAAA2rE,EAAA,EAAAb,EAAA,GACAgB,EAAApvD,EAAmCovD,GAAA,KACnCV,EAAAU,IAAAlnD,GAD+CknD,KAM/CA,EAAA/vE,KAAAiE,IAAA8rE,EAAAhB,EAAA,OACa,CACb,IAAAgB,EAAAH,EAAuCG,EAAAhB,KACvCM,EAAAU,GAAAlnD,GADyDknD,KAKzDA,EAAA/vE,KAAAiE,IAAA8rE,EAAA,EAAAhB,EAAA,GAEAa,EAAAG,EACAF,EAAAhnD,CACA,IAAAmZ,GAAAqtC,EAAAU,EAAA,GAAAV,EAAAU,EACA,QAAA/tC,EAKA,GAFAwzB,GAAA3sC,EAAAwmD,EAAAU,IAAA/tC,EAEA8sC,EAKA,GAJA7B,EAAAqC,EAAAS,GACA/C,EAAAsC,EAAA,IAAAS,MAAA,GACAhC,EAAAuB,EAAAS,EAAAhB,EAAA,EAAAA,EAAA,EAAAgB,EAAA,GACA/B,EAAAsB,EAAAS,EAAAhB,EAAA,EAAAA,EAAA,EAAAgB,EAAA,GACAb,EACApB,EAAAd,EAAAC,EAAAc,EAAAC,EAAAxY,YAAAkZ,EAAA7oE,EAAAuiD,GAAAglB,OACiB,CACjB,GAAAnwE,EACA,IAAAkyE,EACAlyE,EAAA6wE,EAAAd,EAAAC,EAAAc,EAAAC,EAAAxY,YAAA3f,EAAA,GACA54C,EAAAqxE,EAAAz4B,OACqB,IAAAu5B,EAErB,MAAAlC,GAAAD,EAAAc,EAAAvY,EAEAv4D,GAAAkxE,EAAAnB,EAAAC,EAAAc,EAAAC,EAAAxY,aAEAoZ,EAAA/oE,EAAAuiD,EAAAnrD,OAGA,IAAAiyE,EACA/B,EAAAmC,EAAAS,GAAAT,EAAAS,EAAA,GAAAva,EAAAkZ,EAAA7oE,EAAAuiD,GAAAglB,OACiB,CACjB,GAAAnwE,EACA,IAAAkyE,EACAhC,EAAAmC,EAAAS,GAAAT,EAAAS,EAAA,GAAAva,EAAA3f,EAAA,GACA54C,EAAAqxE,EAAAz4B,OACqB,IAAAu5B,EAErB,MAAAlC,GAAAoC,EAAAS,GAAAT,EAAAS,EAAA,GAAAva,EAEAv4D,GAAA8vE,EAAAuC,EAAAS,GAAAT,EAAAS,EAAA,GAAAva,GAEAoZ,EAAA/oE,EAAAuiD,EAAAnrD,KAIA+yE,EAAA,GAAAC,IACApqE,OAAAmkE,EAAA2F,QACAO,KAAAlB,EACA/Y,KAAA+T,EAAAmG,MACAhrB,MAAA6kB,EAAAoG,OACAN,UACAO,UAAA7B,GAKA,OAHApE,IAAA,WAAAA,IACA4F,EAAA5F,UAEA4F,IAzVA,GAAAC,GAAA9tE,EAAA,UACAsE,EAAAtE,EAAA,iBACAmd,EAAAnd,EAAA,gBACAupB,EAAApM,EAAAoM,YACAkiD,EAAAlqE,MAAA6G,UAAArH,MA+VA2mE,EAAA,SAAAhkE,EAAAowD,EAAAyY,EAAAE,GACArwE,KAAA+xE,WACA/xE,KAAAoxE,QAAA9pE,EACAtH,KAAA4xE,MAAAla,IAAA,EACA13D,KAAAowE,QAAAD,GAAA7B,EACAtuE,KAAAswE,QAAAD,GAAA9B,EACAvuE,KAAAgyE,WAAA,EACAhyE,KAAA6xE,OAAA,EACA7xE,KAAAiyE,aACAjyE,KAAAkyE,gBACAlyE,KAAAmyE,aA+GA,OA7GA7G,GAAAt/D,WACAgY,KAAA,SAAAylC,EAAAxtB,GACA,GAAAm2C,GAAApyE,KAAA+xE,OACA,QAAAloB,KAAA5tB,GAAA,CACA,IAAAm2C,EAAAvoB,GAAA,CACAuoB,EAAAvoB,KAEA,IAAAnrD,GAAAsB,KAAAowE,QAAApwE,KAAAoxE,QAAAvnB,EACA,UAAAnrD,EAEA,QAMA,KAAA+qD,GACA2oB,EAAAvoB,GAAAroD,MACAioD,KAAA,EACA/qD,MAAAoxE,EAAApxE,KAIA0zE,EAAAvoB,GAAAroD,MACAioD,OACA/qD,MAAAu9B,EAAA4tB,KAGA,MAAA7pD,OAEA0rE,OAAA,SAAA1mE,GAEA,MADAhF,MAAAkyE,aAAA1wE,KAAAwD,GACAhF,MAEAqyE,cAAA,WAEAryE,KAAA+xE,WAEA/xE,KAAAmyE,UAAA9tE,OAAA,CAGA,QAFAiuE,GAAAtyE,KAAAiyE,UACAnmD,EAAAwmD,EAAAjuE,OACAK,EAAA,EAA2BA,EAAAonB,EAASpnB,IACpC4tE,EAAA5tE,GAAA0K,KAAApP,OAGAoiB,MAAA,SAAAypD,GACA,GAQA0G,GARA5xE,EAAAX,KACAwyE,EAAA,EACAvC,EAAA,WACAuC,IACAA,GACA7xE,EAAA0xE,gBAIA,QAAAxoB,KAAA7pD,MAAA+xE,QAAA,CACA,GAAAN,GAAAzB,EAAAhwE,KAAA6rE,EAAAoE,EAAAjwE,KAAA+xE,QAAAloB,KACA4nB,KACAzxE,KAAAmyE,UAAA3wE,KAAAiwE,GACAe,IAEAxyE,KAAA2R,WACA3R,KAAA2R,UAAA8gE,QAAAhB,GAEAc,EAAAd,GAIA,GAAAc,EAAA,CACA,GAAAG,GAAAH,EAAAhB,OACAgB,GAAAhB,QAAA,SAAAjqE,EAAAgjB,GACAooD,EAAAprE,EAAAgjB,EACA,QAAA5lB,GAAA,EAAmCA,EAAA/D,EAAAuxE,aAAA7tE,OAA8BK,IACjE/D,EAAAuxE,aAAAxtE,GAAA4C,EAAAgjB,IAOA,MAHAkoD,IACAxyE,KAAAqyE,gBAEAryE,MAEA01C,KAAA,SAAAk2B,GAGA,OAFA+G,GAAA3yE,KAAAmyE,UACAxgE,EAAA3R,KAAA2R,UACAjN,EAAA,EAA2BA,EAAAiuE,EAAAtuE,OAAqBK,IAAA,CAChD,GAAA+sE,GAAAkB,EAAAjuE,EACAknE,IAEA6F,EAAAF,QAAAvxE,KAAAoxE,QAAA,GAEAz/D,KAAAihE,WAAAnB,GAEAkB,EAAAtuE,OAAA,GAEAuiD,MAAA,SAAA6C,GAEA,MADAzpD,MAAA6xE,OAAApoB,EACAzpD,MAEA2rE,KAAA,SAAA5iD,GAIA,MAHAA,IACA/oB,KAAAiyE,UAAAzwE,KAAAunB,GAEA/oB,MAEA6yE,SAAA,WACA,MAAA7yE,MAAAmyE,YAGA7G,IAEAznE,EAAA,qJAAAD,GACA,YA+CA,SAAAkvE,GAAAC,EAAA1xE,GAEA,MAAAA,GAAAC,OAAAD,EAAAxC,KAAA,oBAhDA,GAAA6U,GAAA9P,EAAA,yBACAoC,EAAApC,EAAA,qBACAovE,EAAApvE,EAAA,uBACAqvE,EAAAv/D,EAAA3G,QACAzL,KAAA,kBACA2vB,KAAA,KACAlwB,KAAA,WACAkyE,EAAAzpD,WAAAxpB,KAAA,OAAAypB,WACAzpB,KAAAkzE,eAEAppD,YAAA,WACAmpD,EAAAzpD,WAAAxpB,KAAA,cAAAypB,WACAzpB,KAAAkzE,eAEAh4D,YAAA,WACA+3D,EAAAzpD,WAAAxpB,KAAA,cAAAypB,WACAzpB,KAAAkzE,eAEAC,SAAA,SAAAC,EAAAC,GACArzE,KAAAqB,OAAA+xE,aACApzE,KAAAqB,OAAAgyE,YAEA7jB,OAAA,WACA,GAAAnuD,GAAArB,KAAAqB,MACA,cAAAA,EAAA+xE,WAAA/xE,EAAA+xE,WAAA/xE,EAAAqE,KAEA+pD,OAAA,WACA,GAAApuD,GAAArB,KAAAqB,MACA,cAAAA,EAAAgyE,SAAAhyE,EAAAgyE,SAAAhyE,EAAA+Y,KAEAu1C,iBAAA,WACA,GAAAtuD,GAAArB,KAAAqB,MACA,cAAAA,EAAA+xE,YAAA,MAAA/xE,EAAAgyE,WAAAhyE,EAAA6gB,OAEA6O,cAAA,WACA,MAAA/wB,MAAAwG,QAAAmsB,iBACA1gB,SAAA,OACAE,MAAAnS,KAAA0I,IAAA,aACAvI,GAAAH,KAAA0I,IAAA,YACiB,IAEjBwqE,YAAA,WAEAlzE,KAAAqB,OAAA+xE,WAAApzE,KAAAqB,OAAAgyE,SAAA,OAOArtE,GAAAimB,MAAAgnD,EAAAjnE,UAAApI,EAAA,2BACA,IAAA0vE,IAAuBzvD,OAAA,EAGvB,OAFAmvD,GAAA,IAAAC,EAAAH,EAAAQ,GACAN,EAAA,IAAAC,EAAAH,EAAAQ,GACAL,IAEApvE,EAAA,yDAAAD,GAEA,QAAA8tE,GAAA5uE,GACA9C,KAAAoxE,QAAAtuE,EAAAwE,OAEAtH,KAAAuzE,MAAAzwE,EAAA6uE,MAAA,IAEA3xE,KAAA6xE,OAAA/uE,EAAA8jD,OAAA,EAGA5mD,KAAAwzE,cAAA,EAEAxzE,KAAA03D,KAAA,MAAA50D,EAAA40D,MAAA50D,EAAA40D,KACA13D,KAAAu4B,IAAAz1B,EAAAy1B,KAAA,EACAv4B,KAAA6rE,OAAA/oE,EAAA+oE,QAAA,SACA7rE,KAAAuxE,QAAAzuE,EAAAyuE,QACAvxE,KAAA8xE,UAAAhvE,EAAAgvE,UACA9xE,KAAAyzE,UAAA3wE,EAAA2wE,UAhBA,GAAAC,GAAA9vE,EAAA,WAgEA,OA9CA8tE,GAAA1lE,WACAkhB,YAAAwkD,EACAtgD,KAAA,SAAAuiD,GAGA3zE,KAAAwzE,eACAxzE,KAAA4zE,WAAAD,EAAA3zE,KAAA6xE,OACA7xE,KAAAwzE,cAAA,EAEA,IAAAlpD,IAAAqpD,EAAA3zE,KAAA4zE,YAAA5zE,KAAAuzE,KAEA,MAAAjpD,EAAA,IAGAA,EAAA7oB,KAAAiE,IAAA4kB,EAAA,EACA,IAAAuhD,GAAA7rE,KAAA6rE,OACAgI,EAAA,gBAAAhI,GAAA6H,EAAA7H,KACAiI,EAAA,kBAAAD,KAAAvpD,IAGA,OAFAtqB,MAAA+zE,KAAA,QAAAD,GAEA,GAAAxpD,EACAtqB,KAAA03D,MACA13D,KAAAg0E,QAAAL,GAGA,YAIA3zE,KAAAi0E,cAAA,EACA,WAEA,OAEAD,QAAA,SAAAL,GACA,GAAAO,IAAAP,EAAA3zE,KAAA4zE,YAAA5zE,KAAAuzE,KACAvzE,MAAA4zE,WAAAD,EAAAO,EAAAl0E,KAAAu4B,IACAv4B,KAAAi0E,cAAA,GAEAF,KAAA,SAAAh9D,EAAApR,GACAoR,EAAA,KAAAA,EACA/W,KAAA+W,IACA/W,KAAA+W,GAAA/W,KAAAoxE,QAAAzrE,KAIA+rE,IAEA7tE,EAAA,gIAAAD,GACA,GAAAuwE,GAAAvwE,EAAA,iBACAoC,EAAApC,EAAA,qBACA8P,EAAA9P,EAAA,sBACAkD,EAAAlD,EAAA,kBAEAwwE,GACA,QACA,WACA,OACA,MASA,iBAAAC,EAAAC,EAAAC,EAAAC,GACAxuE,EAAAkJ,KAAAklE,EAAA,SAAA1hD,GACA4hD,EAAAvnE,QACAzL,KAAA+yE,EAAA,QAAA3hD,EACAud,qBAAA,SAAA5uC,EAAAmF,GACA,GAAAQ,GAAAhH,KAAAgH,WACA+qC,EAAA/qC,EAAAF,EAAAq8B,gBAAA9hC,MACA2wC,EAAAxrC,EAAAklC,UACA1lC,GAAAimB,MAAA5qB,EAAA2wC,EAAAtpC,IAAAgqB,EAAA,SACA1sB,EAAAimB,MAAA5qB,EAAArB,KAAAmwC,oBACA9uC,EAAAC,KAAAizE,EAAAF,EAAAhzE,GACA2F,GACAF,EAAAs7B,iBAAA/gC,EAAA0wC,EAAA/qC,IAGAE,cAAAlB,EAAAqmB,aAEA8nD,EAAAzhD,EAAA,QACA8hD,IACA,OAGA9gE,EAAAy4D,yBAAAkI,EAAA,OAAAruE,EAAAI,MAAAmuE,EAAAF,OAGAxwE,EAAA,6FAAAD,GAGA,QAAAkf,GAAAzkB,GACA,MAAA2H,GAAAqW,SAAAhe,IAAA,MAAAA,EAAAK,MACAL,EAAAK,MAEAL,EAMA,QAAA0xD,KACA,mBAAA/vD,KAAA0I,IAAA,SAAA1C,EAAA+W,IAAA/c,KAAA0I,IAAA,QAAAoa,GAMA,QAAAqO,KACA,MAAA0B,GAAA1B,mBAAAnxB,KAAAixB,KAAAjxB,KAAA0I,IAAA,wBApBA,GAAA1C,GAAApC,EAAA,qBACAivB,EAAAjvB,EAAA,eAqBA,QACAutB,qBACA4+B,mBAGAlsD,EAAA,yCACA,GAAAgoE,IACA4I,OAAA,SAAAruC,GACA,MAAAA,IAEAsuC,YAAA,SAAAtuC,GACA,MAAAA,MAEAuuC,aAAA,SAAAvuC,GACA,MAAAA,IAAA,EAAAA,IAEAwuC,eAAA,SAAAxuC,GACA,OAAAA,GAAA,KACA,GAAAA,WAEAA,KAAA,OAEAyuC,QAAA,SAAAzuC,GACA,MAAAA,QAEA0uC,SAAA,SAAA1uC,GACA,QAAAA,MAAA,GAEA2uC,WAAA,SAAA3uC,GACA,OAAAA,GAAA,KACA,GAAAA,MAEA,KAAAA,GAAA,GAAAA,IAAA,IAEA4uC,UAAA,SAAA5uC,GACA,MAAAA,UAEA6uC,WAAA,SAAA7uC,GACA,YAAAA,SAEA8uC,aAAA,SAAA9uC,GACA,OAAAA,GAAA,KACA,GAAAA,cAEAA,GAAA,GAAAA,MAAA,IAEA+uC,UAAA,SAAA/uC,GACA,MAAAA,YAEAgvC,WAAA,SAAAhvC,GACA,QAAAA,UAAA,GAEAivC,aAAA,SAAAjvC,GACA,OAAAA,GAAA,KACA,GAAAA,UAEA,KAAAA,GAAA,GAAAA,QAAA,IAEAkvC,aAAA,SAAAlvC,GACA,SAAA3kC,KAAAiiB,IAAA0iB,EAAA3kC,KAAA0nB,GAAA,IAEAosD,cAAA,SAAAnvC,GACA,MAAA3kC,MAAAmiB,IAAAwiB,EAAA3kC,KAAA0nB,GAAA,IAEAqsD,gBAAA,SAAApvC,GACA,YAAA3kC,KAAAiiB,IAAAjiB,KAAA0nB,GAAAid,KAEAqvC,cAAA,SAAArvC,GACA,WAAAA,EAAA,EAAA3kC,KAAAogB,IAAA,KAAAukB,EAAA,IAEAsvC,eAAA,SAAAtvC,GACA,WAAAA,EAAA,IAAA3kC,KAAAogB,IAAA,MAAAukB,IAEAuvC,iBAAA,SAAAvvC,GACA,WAAAA,EACA,EAEA,IAAAA,EACA,GAEAA,GAAA,KACA,GAAA3kC,KAAAogB,IAAA,KAAAukB,EAAA,GAEA,KAAA3kC,KAAAogB,IAAA,OAAAukB,EAAA,QAEAwvC,WAAA,SAAAxvC,GACA,SAAA3kC,KAAAktD,KAAA,EAAAvoB,MAEAyvC,YAAA,SAAAzvC,GACA,MAAA3kC,MAAAktD,KAAA,KAAAvoB,MAEA0vC,cAAA,SAAA1vC,GACA,OAAAA,GAAA,UACA3kC,KAAAktD,KAAA,EAAAvoB,KAAA,GAEA,IAAA3kC,KAAAktD,KAAA,GAAAvoB,GAAA,GAAAA,GAAA,IAEA2vC,UAAA,SAAA3vC,GACA,GAAAM,GACAh6B,EAAA,GACAytB,EAAA,EACA,YAAAiM,EACA,EAEA,IAAAA,EACA,IAEA15B,KAAA,GACAA,EAAA,EACAg6B,EAAAvM,EAAA,GAEAuM,EAAAvM,EAAA14B,KAAAu0E,KAAA,EAAAtpE,IAAA,EAAAjL,KAAA0nB,MAEAzc,EAAAjL,KAAAogB,IAAA,MAAAukB,GAAA,IAAA3kC,KAAAmiB,KAAAwiB,EAAAM,IAAA,EAAAjlC,KAAA0nB,IAAAgR,MAEA87C,WAAA,SAAA7vC,GACA,GAAAM,GACAh6B,EAAA,GACAytB,EAAA,EACA,YAAAiM,EACA,EAEA,IAAAA,EACA,IAEA15B,KAAA,GACAA,EAAA,EACAg6B,EAAAvM,EAAA,GAEAuM,EAAAvM,EAAA14B,KAAAu0E,KAAA,EAAAtpE,IAAA,EAAAjL,KAAA0nB,IAEAzc,EAAAjL,KAAAogB,IAAA,MAAAukB,GAAA3kC,KAAAmiB,KAAAwiB,EAAAM,IAAA,EAAAjlC,KAAA0nB,IAAAgR,GAAA,IAEA+7C,aAAA,SAAA9vC,GACA,GAAAM,GACAh6B,EAAA,GACAytB,EAAA,EACA,YAAAiM,EACA,EAEA,IAAAA,EACA,IAEA15B,KAAA,GACAA,EAAA,EACAg6B,EAAAvM,EAAA,GAEAuM,EAAAvM,EAAA14B,KAAAu0E,KAAA,EAAAtpE,IAAA,EAAAjL,KAAA0nB,KAEAid,GAAA,UACA15B,EAAAjL,KAAAogB,IAAA,MAAAukB,GAAA,IAAA3kC,KAAAmiB,KAAAwiB,EAAAM,IAAA,EAAAjlC,KAAA0nB,IAAAgR,IAEAztB,EAAAjL,KAAAogB,IAAA,OAAAukB,GAAA,IAAA3kC,KAAAmiB,KAAAwiB,EAAAM,IAAA,EAAAjlC,KAAA0nB,IAAAgR,GAAA,OAEAg8C,OAAA,SAAA/vC,GACA,GAAAM,GAAA,OACA,OAAAN,OAAAM,EAAA,GAAAN,EAAAM,IAEA0vC,QAAA,SAAAhwC,GACA,GAAAM,GAAA,OACA,SAAAN,MAAAM,EAAA,GAAAN,EAAAM,GAAA,GAEA2vC,UAAA,SAAAjwC,GACA,GAAAM,GAAA,SACA,QAAAN,GAAA,KACA,IAAAA,MAAAM,EAAA,GAAAN,EAAAM,IAEA,KAAAN,GAAA,GAAAA,IAAAM,EAAA,GAAAN,EAAAM,GAAA,IAEA4vC,SAAA,SAAAlwC,GACA,SAAAylC,EAAA0K,UAAA,EAAAnwC,IAEAmwC,UAAA,SAAAnwC,GACA,MAAAA,GAAA,OACA,OAAAA,IACiBA,EAAA,OACjB,QAAAA,GAAA,UAAAA,EAAA,IACiBA,EAAA,SACjB,QAAAA,GAAA,WAAAA,EAAA,MAEA,QAAAA,GAAA,YAAAA,EAAA,SAGAowC,YAAA,SAAApwC,GACA,MAAAA,GAAA,GACA,GAAAylC,EAAAyK,SAAA,EAAAlwC,GAEA,GAAAylC,EAAA0K,UAAA,EAAAnwC,EAAA,OAGA,OAAAylC,KAEAhoE,EAAA,qEAAAD,GACA,GAAAoC,GAAApC,EAAA,qBACAsD,GACAG,MAAA,EACAF,OAAA,EACAC,EAAA,EACA0sB,SAAA,EACAzxB,KAAA,GACAo0E,aAAA,MACAC,WAAA,KACAC,cACAj+C,SAAA,KACA0kC,SAAA,MACAK,YAAA,KAEAmZ,iBACAC,QAAA,GACA9sE,QAAA,EACA+sE,cAAA,EACAC,SAAsB1vE,MAAA,GACtB2vE,UACA3vE,MAAA,EACAosB,QAAA,EACApI,WACAnjB,MAAA,OACAqC,MAAA,EACAjJ,KAAA,UAGA21E,UACA5vE,MAAA,EACA6vE,QAAA,EACA7yE,OAAA,EACAgnB,WAA4B9gB,MAAA,IAE5B4sE,WACA9vE,MAAA,EACA6vE,QAAA,EACA/rD,OAAA,EACAlgB,OAAA,EACAlD,WAA4BC,SAAA,KAE5BovE,WACA/vE,MAAA,EACAgkB,WACAnjB,OAAA,QACAqC,MAAA,EACAjJ,KAAA,UAGA+1E,WACAhwE,MAAA,EACAiwE,WACApvE,OACA,wBACA,4BAKAqvE,EAAAvxE,EAAAimB,OACA2jC,aAAA,EACAwnB,WAAwB/vE,MAAA,GACxB4vE,UACAhJ,gBAAA,EACA9/D,SAAA,QAEAgpE,WAAwBhpE,SAAA,SACfjH,GACTyyB,EAAA3zB,EAAAimB,OACA2jC,aACA,EACA,GAEAnoB,YAAA,GACSvgC,GAETswE,EAAAxxE,EAAA0F,UACAwW,OAAA,EACAxc,IAAA,UACA0U,IAAA,WACSuf,GACT89C,EAAAzxE,EAAA0F,UAAmCgsE,QAAA,IAAc/9C,EAEjD,OADA89C,GAAAv1D,OAAA,GAEAq1D,eACA59C,YACA69C,WACAC,aAGA5zE,EAAA,+BACA,GAAA2W,GAAA,CAEA,oBAAAvQ,UACAuQ,EAAA/Y,KAAA2Y,IAAAnQ,OAAAwG,kBAAA,KAOA,IAAAwkC,IACAo5B,UAAA,EACA59D,iBAAA+J,EAEA,OAAAy6B,KAEApxC,EAAA,yLAAAD,GACA,YAQA,SAAA+zE,GAAA94E,GAEA,IADA,GAAA6F,GAAA,EACAA,EAAA7F,EAAAwF,QAAA,MAAAxF,EAAA6F,IACAA,GAEA,OAAA7F,GAAA6F,GAEA,QAAAkzE,GAAA/4E,GACA,GAAAg5E,GAAAF,EAAA94E,EACA,cAAAg5E,IAAA7xE,EAAAgZ,QAAAysC,EAAAosB,IAKA,QAAAviD,GAAAz2B,EAAA6H,EAAAF,GAIA,GAFA3H,SAEAmH,EAAAgZ,QAAAngB,GACA,SAAA+G,OAAA,gBAGA,IAAAmzB,GAAAryB,EAAAgC,IAAA,oBACA6X,EAAAu3D,EAAA/+C,GACAg/C,EAAAl4D,EAAAnX,IAAAqwB,GAEAi/C,EAAAz3D,KAAA1hB,EAAA6H,EAAAF,GACA0jB,EAAA8tD,KAAA9tD,UACAA,KAEAA,EAAA6tD,KAAA7tD,aACA,IACA,KAEAA,EAAAb,EAAAa,EAAArrB,EAAAqrB,EAAAtlB,QAAA,WAEA,IAAAqzE,GAAAD,IAAAC,iBACAz+D,EAAA,GAAAiH,GAAAyJ,EAAAxjB,GACAskD,EAAAktB,EAAAF,EAAAn5E,GACAs5E,KACAltB,EAAAgtB,GAAA,GAAAL,EAAA/4E,GAAA,SAAA6/D,EAAAnT,EAAA9tC,EAAA+tC,GAMA,MAJApiC,GAAAsiC,iBAAAgT,KACAllD,EAAAsxC,eAAA,GAGAU,IAAAysB,EAAAx6D,EAAAkuC,EAAAF,EAAAiT,GAAAx0C,EAAAshC,KACa,SAAAkT,EAAAnT,EAAA9tC,EAAA+tC,GACb,GAAA9sD,GAAA+sD,EAAAiT,GACAzxD,EAAA0+C,EAAAjtD,KAAA8sD,GAAAthC,EAAAshC,GAEApiC,GAAAsiC,iBAAAgT,KACAllD,EAAAsxC,eAAA,EAEA,IAAAstB,GAAAJ,KAAAI,kBAaA,OAZAA,MAAA7sB,IAEA,gBAAAt+C,KAEAkrE,EAAA5sB,GAAA4sB,EAAA5sB,IAAA6sB,EAAA7sB,GAAAwE,gBACA9iD,EAAAjH,EAAAhC,QAAAm0E,EAAA5sB,GAAAt+C,GACAA,EAAA,IAAAyS,MAAAzS,KAEAA,OAIAA,EAIA,OAFAuM,GAAAsxC,eAAA,EACAtxC,EAAA2Q,SAAAtrB,EAAAmsD,EAAAC,GACAzxC,EAEA,QAAA6+D,GAAA3lD,GACA,mBAAAA,GAAA,SAAAA,EAEA,QAAA4lD,GAAA5lD,GACA,mBAAAA,EAAA,mBAAAA,EAAA,eA8HA,QAAAwlD,GAAArsD,EAAAhtB,GACA,GAEA05E,GAFAvtB,KACAwtB,EAAA3sD,KAAA3B,WAAA2B,EAAAosD,cAKA,IAHAO,IACAD,EAAA1sD,EAAAusD,mBAAAI,EAAAn2E,OAEAk2E,EAAA,CAEA,GAAAJ,GAAAI,EAAAxoB,eACA,IAAAooB,EAAA,CACA,GAAAM,GAAA55E,EAAAwF,MAKA,IAAA2B,EAAAgZ,QAAAngB,EAAA,KAAAA,EAAA,GAAAwF,OAAA,GACA2mD,IACA,QAAAtmD,GAAA,EAAmCA,EAAA+zE,EAAa/zE,IAChDsmD,EAAAtmD,GAAAyzE,EAAAt5E,EAAA6F,GAAAmnB,EAAAosD,eAAA,QAGAjtB,GAAAmtB,EAAAxzE,MAAA,IAIA,MAAAqmD,GA5OA,GAAAvqC,GAAA7c,EAAA,mBACAylB,EAAAzlB,EAAA,wCACAoC,EAAApC,EAAA,qBACAwlB,EAAAxlB,EAAA,oBACAic,EAAAjc,EAAA,0BACA6nD,EAAAriC,EAAAqiC,iBACAE,EAAAviC,EAAAuiC,gBAmFAmsB,GACAY,YAAA,SAAA75E,EAAA6H,EAAAF,GACA,GAAAyuB,GAAAjvB,EAAA+W,KACA,QACA,SACA,SAAA1a,GACA,MAAAmE,GAAAmsB,iBACA1gB,SAAA5P,EACA8P,MAAAzL,EAAAgC,IAAArG,EAAA,SACAlC,GAAAuG,EAAAgC,IAAArG,EAAA,QACyB,KAEzB6yB,EAAAD,EAAA,GACAE,EAAAF,EAAA,EAEA,KAAAC,EACA,SAAAtvB,OAAA,UAAAI,EAAAkf,SAAAxe,EAAAgC,IAAA,cAAAhC,EAAAgC,IAAA,4BAEA,KAAAysB,EACA,SAAAvvB,OAAA,UAAAI,EAAAkf,SAAAxe,EAAAgC,IAAA,cAAAhC,EAAAgC,IAAA,4BAGA,IAAAiwE,GAAAzjD,EAAAxsB,IAAA,QACAkwE,EAAAzjD,EAAAzsB,IAAA,QACAwhB,IAEA7nB,KAAA,IACAf,KAAAg3E,EAAAK,GACAzuB,UAAAmuB,EAAAM,KAGAt2E,KAAA,IACAf,KAAAg3E,EAAAM,GACA1uB,UAAAmuB,EAAAO,KAGAC,EAAA,aAAAF,EACAG,EAAA,aAAAF,CACAvvD,GAAAa,EAAArrB,GACA,IACA,IACA,KAEA,IAAAu5E,KAOA,OANAS,KACAT,EAAAxtE,EAAAsqB,GAEA4jD,IACAV,EAAAzuE,EAAAwrB,IAGAjL,aACA+tD,cAAAY,EAAA,EAAAC,EAAA,KACAV,uBAGAW,MAAA,SAAAl6E,EAAA6H,EAAAF,GACA,GAAAwyE,GAAAxyE,EAAAmsB,iBACA1gB,SAAA,QACAE,MAAAzL,EAAAgC,IAAA,cACAvI,GAAAuG,EAAAgC,IAAA,aACqB,GACrBuwE,EAAAD,EAAAE,cAAA,aACAC,EAAAH,EAAAE,cAAA,aAEA,KAAAD,EACA,SAAArzE,OAAA,6BAEA,KAAAuzE,EACA,SAAAvzE,OAAA,8BAGA,IAAAwzE,GAAAD,EAAAzwE,IAAA,QACA2wE,EAAAJ,EAAAvwE,IAAA,QACAwhB,IAEA7nB,KAAA,SACAf,KAAAg3E,EAAAc,GACAlvB,UAAAmuB,EAAAe,KAGA/2E,KAAA,QACAf,KAAAg3E,EAAAe,GACAnvB,UAAAmuB,EAAAgB,KAGAC,EAAA,aAAAD,EACAE,EAAA,aAAAH,CACA/vD,GAAAa,EAAArrB,GACA,SACA,QACA,SAEA,IAAAu5E,KAOA,OANAmB,KACAnB,EAAAh2E,OAAA+2E,GAEAG,IACAlB,EAAA7nD,MAAA0oD,IAGA/uD,aACA+tD,cAAAqB,EAAA,EAAAC,EAAA,KACAnB,uBAGAoB,IAAA,SAAA36E,EAAA6H,EAAAF,GAGA,OACA0jB,WAAAb,IACyBhnB,KAAA,QACAA,KAAA,QACzBxD,GACA,MACA,MACA,YAiCA,OAAAy2B,KAEAzxB,EAAA,qDAAAD,GACA,YAeA,SAAA61E,GAAAxsE,GACA,MAAAA,IAAAs4D,GAAAt4D,EAAAs4D,EAEA,QAAAuF,GAAA79D,GACA,MAAAA,GAAAs4D,GAAAt4D,GAAAs4D,EAYA,QAAAtK,GAAAwT,EAAAC,EAAAc,EAAAC,EAAA7sB,GACA,GAAA82B,GAAA,EAAA92B,CACA,OAAA82B,QAAAjL,EAAA,EAAA7rB,EAAA8rB,GAAA9rB,OAAA6sB,EAAA,EAAAiK,EAAAlK,GAYA,QAAAxU,GAAAyT,EAAAC,EAAAc,EAAAC,EAAA7sB,GACA,GAAA82B,GAAA,EAAA92B,CACA,aAAA8rB,EAAAD,GAAAiL,EAAA,GAAAlK,EAAAd,GAAA9rB,GAAA82B,GAAAjK,EAAAD,GAAA5sB,KAaA,QAAAgjB,GAAA6I,EAAAC,EAAAc,EAAAC,EAAAxiE,EAAA44D,GAEA,GAAAn5D,GAAA+iE,EAAA,GAAAf,EAAAc,GAAAf,EACAv+D,EAAA,GAAAs/D,EAAA,EAAAd,EAAAD,GACAjb,EAAA,GAAAkb,EAAAD,GACA3gE,EAAA2gE,EAAAxhE,EACA4mD,EAAA3jD,IAAA,EAAAxD,EAAA8mD,EACA5b,EAAA1nC,EAAAsjD,EAAA,EAAA9mD,EAAAoB,EACA6lD,EAAAH,IAAA,EAAAtjD,EAAApC,EACAssB,EAAA,CACA,IAAAq/C,EAAA5lB,IAAA4lB,EAAA7hC,GACA,GAAA6hC,EAAAvpE,GACA21D,EAAA,SACa,CACb,GAAA8T,IAAAnmB,EAAAtjD,CAEAypE,IAAA,GAAAA,GAAA,IACA9T,EAAAzrC,KAAAu/C,OAGS,CACT,GAAAC,GAAAhiC,IAAA,EAAAic,EAAAF,CACA,IAAA8lB,EAAAG,GAAA,CACA,GAAAC,GAAAjiC,EAAAic,EACA8lB,GAAAzpE,EAAAxD,EAAAmtE,EAEAnK,GAAAmK,EAAA,CAEAF,IAAA,GAAAA,GAAA,IACA9T,EAAAzrC,KAAAu/C,GAEAjK,GAAA,GAAAA,GAAA,IACA7J,EAAAzrC,KAAAs1C,OAEa,IAAAkK,EAAA,GACb,GAAAE,GAAAxnB,EAAAsnB,GACAG,EAAAlmB,EAAA3jD,EAAA,IAAAxD,IAAAkrC,EAAAkiC,GACAE,EAAAnmB,EAAA3jD,EAAA,IAAAxD,IAAAkrC,EAAAkiC,EAEAC,GADAA,EAAA,GACAn4D,GAAAm4D,EAAAE,GAEAr4D,EAAAm4D,EAAAE,GAGAD,EADAA,EAAA,GACAp4D,GAAAo4D,EAAAC,GAEAr4D,EAAAo4D,EAAAC,EAEA,IAAAN,KAAAzpE,GAAA6pE,EAAAC,KAAA,EAAAttE,EACAitE,IAAA,GAAAA,GAAA,IACA9T,EAAAzrC,KAAAu/C,OAEa,CACb,GAAAO,IAAA,EAAArmB,EAAA3jD,EAAA,EAAAxD,EAAAkrC,IAAA,EAAA0a,EAAAuB,QACApB,EAAAhxD,KAAA8yD,KAAA2lB,GAAA,EACAC,EAAA7nB,EAAAuB,GACA1Q,EAAA1hD,KAAAiiB,IAAA+uC,GACAknB,IAAAzpE,EAAA,EAAAiqE,EAAAh3B,IAAA,EAAAz2C,GACAgjE,IAAAx/D,EAAAiqE,GAAAh3B,EAAAi3B,EAAA34E,KAAAmiB,IAAA6uC,MAAA,EAAA/lD,GACAijE,IAAAz/D,EAAAiqE,GAAAh3B,EAAAi3B,EAAA34E,KAAAmiB,IAAA6uC,MAAA,EAAA/lD,EACAitE,IAAA,GAAAA,GAAA,IACA9T,EAAAzrC,KAAAu/C,GAEAjK,GAAA,GAAAA,GAAA,IACA7J,EAAAzrC,KAAAs1C,GAEAC,GAAA,GAAAA,GAAA,IACA9J,EAAAzrC,KAAAu1C,IAIA,MAAAv1C,GAYA,QAAA+rC,GAAAsI,EAAAC,EAAAc,EAAAC,EAAAhK,GACA,GAAAv1D,GAAA,EAAAs/D,EAAA,GAAAd,EAAA,EAAAD,EACA/hE,EAAA,EAAAgiE,EAAA,EAAAe,EAAA,EAAAhB,EAAA,EAAAe,EACAhc,EAAA,EAAAkb,EAAA,EAAAD,EACAr0C,EAAA,CACA,IAAAq/C,EAAA/sE,IACA,GAAAo+D,EAAA56D,GAAA,CACA,GAAAypE,IAAAnmB,EAAAtjD,CACAypE,IAAA,GAAAA,GAAA,IACAlU,EAAArrC,KAAAu/C,QAGS,CACT,GAAAC,GAAA1pE,IAAA,EAAAxD,EAAA8mD,CACA,IAAAimB,EAAAG,GACAnU,EAAA,IAAAv1D,GAAA,EAAAxD,OACa,IAAAktE,EAAA,GACb,GAAAE,GAAAxnB,EAAAsnB,GACAD,IAAAzpE,EAAA4pE,IAAA,EAAAptE,GACAgjE,IAAAx/D,EAAA4pE,IAAA,EAAAptE,EACAitE,IAAA,GAAAA,GAAA,IACAlU,EAAArrC,KAAAu/C,GAEAjK,GAAA,GAAAA,GAAA,IACAjK,EAAArrC,KAAAs1C,IAIA,MAAAt1C,GAYA,QAAAqhC,GAAAgT,EAAAC,EAAAc,EAAAC,EAAA7sB,EAAApK,GACA,GAAA6hC,IAAA3L,EAAAD,GAAA7rB,EAAA6rB,EACA6L,GAAA9K,EAAAd,GAAA9rB,EAAA8rB,EACA6L,GAAA9K,EAAAD,GAAA5sB,EAAA4sB,EACAgL,GAAAF,EAAAD,GAAAz3B,EAAAy3B,EACAI,GAAAF,EAAAD,GAAA13B,EAAA03B,EACAI,GAAAD,EAAAD,GAAA53B,EAAA43B,CAEAhiC,GAAA,GAAAi2B,EACAj2B,EAAA,GAAA6hC,EACA7hC,EAAA,GAAAgiC,EACAhiC,EAAA,GAAAkiC,EAEAliC,EAAA,GAAAkiC,EACAliC,EAAA,GAAAiiC,EACAjiC,EAAA,GAAA+hC,EACA/hC,EAAA,GAAAi3B,EAkBA,QAAAkL,GAAAxY,EAAAC,EAAA/jC,EAAAE,EAAAD,EAAAE,EAAAqjC,EAAAC,EAAAl3D,EAAAjB,EAAA6uC,GAEA,GAAAoK,GAGAg4B,EACA16E,EACA26E,EACAC,EALA3sE,EAAA,KACAL,EAAAD,GAKAktE,GAAA,GAAAnwE,EACAmwE,EAAA,GAAApxE,CAGA,QAAAqxE,GAAA,EAAwBA,EAAA,EAAQA,GAAA,IAChCC,EAAA,GAAAhgB,EAAAkH,EAAA9jC,EAAAC,EAAAujC,EAAAmZ,GACAC,EAAA,GAAAhgB,EAAAmH,EAAA7jC,EAAAC,EAAAsjC,EAAAkZ,GACAH,EAAAK,EAAAH,EAAAE,GACAJ,EAAA/sE,IACA80C,EAAAo4B,EACAltE,EAAA+sE,EAGA/sE,GAAAD,GAEA,QAAAnJ,GAAA,EAAuBA,EAAA,MACvByJ,EAAAgtE,GAD+Bz2E,IAI/Bk2E,EAAAh4B,EAAAz0C,EACAjO,EAAA0iD,EAAAz0C,EAEA8sE,EAAA,GAAAhgB,EAAAkH,EAAA9jC,EAAAC,EAAAujC,EAAA+Y,GACAK,EAAA,GAAAhgB,EAAAmH,EAAA7jC,EAAAC,EAAAsjC,EAAA8Y,GACAC,EAAAK,EAAAD,EAAAF,GACAH,GAAA,GAAAC,EAAA/sE,GACA80C,EAAAg4B,EACA9sE,EAAA+sE,IAGAO,EAAA,GAAAngB,EAAAkH,EAAA9jC,EAAAC,EAAAujC,EAAA3hE,GACAk7E,EAAA,GAAAngB,EAAAmH,EAAA7jC,EAAAC,EAAAsjC,EAAA5hE,GACA46E,EAAAI,EAAAE,EAAAL,GACA76E,GAAA,GAAA46E,EAAAhtE,GACA80C,EAAA1iD,EACA4N,EAAAgtE,GAEA3sE,GAAA,GAUA,OALAqqC,KACAA,EAAA,GAAAyiB,EAAAkH,EAAA9jC,EAAAC,EAAAujC,EAAAjf,GACApK,EAAA,GAAAyiB,EAAAmH,EAAA7jC,EAAAC,EAAAsjC,EAAAlf,IAGA0P,EAAAxkD,GAUA,QAAAutD,GAAAoT,EAAAC,EAAAc,EAAA5sB,GACA,GAAA82B,GAAA,EAAA92B,CACA,OAAA82B,MAAAjL,EAAA,EAAA7rB,EAAA8rB,GAAA9rB,IAAA4sB,EAUA,QAAApU,GAAAqT,EAAAC,EAAAc,EAAA5sB,GACA,aAAAA,IAAA8rB,EAAAD,GAAA7rB,GAAA4sB,EAAAd,IAWA,QAAArI,GAAAoI,EAAAC,EAAAc,EAAAviE,EAAA44D,GACA,GAAAn5D,GAAA+hE,EAAA,EAAAC,EAAAc,EACAt/D,EAAA,GAAAw+D,EAAAD,GACAjb,EAAAib,EAAAxhE,EACAmtB,EAAA,CACA,IAAAq/C,EAAA/sE,IACA,GAAAo+D,EAAA56D,GAAA,CACA,GAAAypE,IAAAnmB,EAAAtjD,CACAypE,IAAA,GAAAA,GAAA,IACA9T,EAAAzrC,KAAAu/C,QAGS,CACT,GAAAC,GAAA1pE,IAAA,EAAAxD,EAAA8mD,CACA,IAAAimB,EAAAG,GAAA,CACA,GAAAD,IAAAzpE,GAAA,EAAAxD,EACAitE,IAAA,GAAAA,GAAA,IACA9T,EAAAzrC,KAAAu/C,OAEa,IAAAC,EAAA,GACb,GAAAE,GAAAxnB,EAAAsnB,GACAD,IAAAzpE,EAAA4pE,IAAA,EAAAptE,GACAgjE,IAAAx/D,EAAA4pE,IAAA,EAAAptE,EACAitE,IAAA,GAAAA,GAAA,IACA9T,EAAAzrC,KAAAu/C,GAEAjK,GAAA,GAAAA,GAAA,IACA7J,EAAAzrC,KAAAs1C,IAIA,MAAAt1C,GAUA,QAAAksC,GAAAmI,EAAAC,EAAAc,GACA,GAAA6L,GAAA5M,EAAAe,EAAA,EAAAd,CACA,YAAA2M,EAEA,IAEA5M,EAAAC,GAAA2M,EAYA,QAAA7f,GAAAiT,EAAAC,EAAAc,EAAA5sB,EAAApK,GACA,GAAA6hC,IAAA3L,EAAAD,GAAA7rB,EAAA6rB,EACA6L,GAAA9K,EAAAd,GAAA9rB,EAAA8rB,EACA8L,GAAAF,EAAAD,GAAAz3B,EAAAy3B,CAEA7hC,GAAA,GAAAi2B,EACAj2B,EAAA,GAAA6hC,EACA7hC,EAAA,GAAAgiC,EAEAhiC,EAAA,GAAAgiC,EACAhiC,EAAA,GAAA8hC,EACA9hC,EAAA,GAAAg3B,EAgBA,QAAA8L,GAAAnZ,EAAAC,EAAA/jC,EAAAE,EAAAD,EAAAE,EAAA5zB,EAAAjB,EAAA6uC,GAEA,GAAAoK,GACAz0C,EAAA,KACAL,EAAAD,GACAktE,GAAA,GAAAnwE,EACAmwE,EAAA,GAAApxE,CAGA,QAAAqxE,GAAA,EAAwBA,EAAA,EAAQA,GAAA,KAChCC,EAAA,GAAA5f,EAAA8G,EAAA9jC,EAAAC,EAAA08C,GACAC,EAAA,GAAA5f,EAAA+G,EAAA7jC,EAAAC,EAAAw8C,EACA,IAAAH,GAAAK,EAAAH,EAAAE,EACAJ,GAAA/sE,IACA80C,EAAAo4B,EACAltE,EAAA+sE,GAGA/sE,EAAAD,GAEA,QAAAnJ,GAAA,EAAuBA,EAAA,MACvByJ,EAAAgtE,GAD+Bz2E,IAAA,CAI/B,GAAAk2E,GAAAh4B,EAAAz0C,EACAjO,EAAA0iD,EAAAz0C,CAEA8sE,GAAA,GAAA5f,EAAA8G,EAAA9jC,EAAAC,EAAAs8C,GACAK,EAAA,GAAA5f,EAAA+G,EAAA7jC,EAAAC,EAAAo8C,EACA,IAAAC,GAAAK,EAAAD,EAAAF,EACA,IAAAH,GAAA,GAAAC,EAAA/sE,EACA80C,EAAAg4B,EACA9sE,EAAA+sE,MACa,CAEbO,EAAA,GAAA/f,EAAA8G,EAAA9jC,EAAAC,EAAAp+B,GACAk7E,EAAA,GAAA/f,EAAA+G,EAAA7jC,EAAAC,EAAAt+B,EACA,IAAA46E,GAAAI,EAAAE,EAAAL,EACA76E,IAAA,GAAA46E,EAAAhtE,GACA80C,EAAA1iD,EACA4N,EAAAgtE,GAEA3sE,GAAA,IAUA,MALAqqC,KACAA,EAAA,GAAA6iB,EAAA8G,EAAA9jC,EAAAC,EAAAskB,GACApK,EAAA,GAAA6iB,EAAA+G,EAAA7jC,EAAAC,EAAAokB,IAGA0P,EAAAxkD,GA5bA,GAAAytD,GAAA33D,EAAA,YACA23E,EAAAhgB,EAAAlsD,OACA6rE,EAAA3f,EAAApM,WACAvtC,EAAAngB,KAAAogB,IACAywC,EAAA7wD,KAAAktD,KACA4W,EAAA,KACA4V,EAAA,KACAf,EAAA9nB,EAAA,GACA2nB,EAAA,IAEAc,EAAAQ,IACAN,EAAAM,IACAH,EAAAG,GAkbA,QACAtgB,UACAD,oBACA4K,cACAO,eACA1K,iBACAkf,oBACAtf,cACAD,wBACAiL,kBACAC,oBACA9K,qBACA8f,2BAGAz3E,EAAA,8DAAAD,GACA,GAAA23D,GAAA33D,EAAA,YACA88D,EAAA98D,EAAA,WACA+8D,KACAzmD,EAAAzY,KAAAiE,IACAyU,EAAA1Y,KAAA2Y,IACA+3C,EAAA1wD,KAAAmiB,IACAsuC,EAAAzwD,KAAAiiB,IACAtB,EAAAm5C,EAAAlsD,SACAgT,EAAAk5C,EAAAlsD,SACAmsE,EAAAjgB,EAAAlsD,SACAwgB,EAAA,EAAApuB,KAAA0nB,EAQAw3C,GAAA8a,WAAA,SAAA90D,EAAAjhB,EAAA0U,GACA,OAAAuM,EAAAtiB,OAAA,CAGA,GAKAK,GALAy1B,EAAAxT,EAAA,GACAlf,EAAA0yB,EAAA,GACA7f,EAAA6f,EAAA,GACAv4B,EAAAu4B,EAAA,GACAt4B,EAAAs4B,EAAA,EAEA,KAAAz1B,EAAA,EAAmBA,EAAAiiB,EAAAtiB,OAAmBK,IACtCy1B,EAAAxT,EAAAjiB,GACA+C,EAAAyS,EAAAzS,EAAA0yB,EAAA,IACA7f,EAAAH,EAAAG,EAAA6f,EAAA,IACAv4B,EAAAsY,EAAAtY,EAAAu4B,EAAA,IACAt4B,EAAAsY,EAAAtY,EAAAs4B,EAAA,GAEAz0B,GAAA,GAAA+B,EACA/B,EAAA,GAAA9D,EACAwY,EAAA,GAAAE,EACAF,EAAA,GAAAvY,IAWA8+D,EAAAuC,SAAA,SAAAf,EAAAC,EAAA/jC,EAAAE,EAAA74B,EAAA0U,GACA1U,EAAA,GAAAwU,EAAAioD,EAAA9jC,GACA34B,EAAA,GAAAwU,EAAAkoD,EAAA7jC,GACAnkB,EAAA,GAAAD,EAAAgoD,EAAA9jC,GACAjkB,EAAA,GAAAD,EAAAioD,EAAA7jC,GAEA,IAAAm9C,MACAC,IAmIA,OApHAhb,GAAAwC,UAAA,SAAAhB,EAAAC,EAAA/jC,EAAAE,EAAAD,EAAAE,EAAAqjC,EAAAC,EAAAp8D,EAAA0U,GACA,GAEA1V,GAFAyhE,EAAAzF,EAAAyF,aACAlL,EAAAyF,EAAAzF,QAEA7gC,EAAA+rC,EAAAhE,EAAA9jC,EAAAC,EAAAujC,EAAA6Z,EAKA,KAJAh2E,EAAA,GAAAmI,IACAnI,EAAA,GAAAmI,IACAuM,EAAA,KAAAvM,KACAuM,EAAA,KAAAvM,KACAnJ,EAAA,EAAmBA,EAAA01B,EAAO11B,IAAA,CAC1B,GAAAkG,GAAAqwD,EAAAkH,EAAA9jC,EAAAC,EAAAujC,EAAA6Z,EAAAh3E,GACAgB,GAAA,GAAAwU,EAAAtP,EAAAlF,EAAA,IACA0U,EAAA,GAAAD,EAAAvP,EAAAwP,EAAA,IAGA,IADAggB,EAAA+rC,EAAA/D,EAAA7jC,EAAAC,EAAAsjC,EAAA6Z,GACAj3E,EAAA,EAAmBA,EAAA01B,EAAO11B,IAAA,CAC1B,GAAAiF,GAAAsxD,EAAAmH,EAAA7jC,EAAAC,EAAAsjC,EAAA6Z,EAAAj3E,GACAgB,GAAA,GAAAwU,EAAAvQ,EAAAjE,EAAA,IACA0U,EAAA,GAAAD,EAAAxQ,EAAAyQ,EAAA,IAEA1U,EAAA,GAAAwU,EAAAioD,EAAAz8D,EAAA,IACA0U,EAAA,GAAAD,EAAAgoD,EAAA/nD,EAAA,IACA1U,EAAA,GAAAwU,EAAA2nD,EAAAn8D,EAAA,IACA0U,EAAA,GAAAD,EAAA0nD,EAAAznD,EAAA,IACA1U,EAAA,GAAAwU,EAAAkoD,EAAA18D,EAAA,IACA0U,EAAA,GAAAD,EAAAioD,EAAAhoD,EAAA,IACA1U,EAAA,GAAAwU,EAAA4nD,EAAAp8D,EAAA,IACA0U,EAAA,GAAAD,EAAA2nD,EAAA1nD,EAAA,KAcAumD,EAAAyC,cAAA,SAAAjB,EAAAC,EAAA/jC,EAAAE,EAAAD,EAAAE,EAAA94B,EAAA0U,GACA,GAAAksD,GAAA5F,EAAA4F,kBACAjL,EAAAqF,EAAArF,YAEAugB,EAAAzhE,EAAAD,EAAAosD,EAAAnE,EAAA9jC,EAAAC,GAAA,MACAu9C,EAAA1hE,EAAAD,EAAAosD,EAAAlE,EAAA7jC,EAAAC,GAAA,MACA5zB,EAAAywD,EAAA8G,EAAA9jC,EAAAC,EAAAs9C,GACAjyE,EAAA0xD,EAAA+G,EAAA7jC,EAAAC,EAAAq9C,EACAn2E,GAAA,GAAAwU,EAAAioD,EAAA7jC,EAAA1zB,GACAlF,EAAA,GAAAwU,EAAAkoD,EAAA5jC,EAAA70B,GACAyQ,EAAA,GAAAD,EAAAgoD,EAAA7jC,EAAA1zB,GACAwP,EAAA,GAAAD,EAAAioD,EAAA5jC,EAAA70B,IAgBAg3D,EAAA0C,QAAA,SAAAz4D,EAAAjB,EAAAioD,EAAAC,EAAAtuC,EAAAC,EAAAy+C,EAAAv8D,EAAA0U,GACA,GAAA0hE,GAAAvgB,EAAA71D,IACAq2E,EAAAxgB,EAAAnhD,IACA4N,EAAAvmB,KAAAihB,IAAAa,EAAAC,EACA,IAAAwE,EAAA6H,EAAA,MAAA7H,EAAA,KAMA,MAJAtiB,GAAA,GAAAkF,EAAAgnD,EACAlsD,EAAA,GAAAiE,EAAAkoD,EACAz3C,EAAA,GAAAxP,EAAAgnD,OACAx3C,EAAA,GAAAzQ,EAAAkoD,EAuBA,IApBAzvC,EAAA,GAAA8vC,EAAA3uC,GAAAquC,EAAAhnD,EACAwX,EAAA,GAAA+vC,EAAA5uC,GAAAsuC,EAAAloD,EACA0Y,EAAA,GAAA6vC,EAAA1uC,GAAAouC,EAAAhnD,EACAyX,EAAA,GAAA8vC,EAAA3uC,GAAAquC,EAAAloD,EACAmyE,EAAAp2E,EAAA0c,EAAAC,GACA05D,EAAA3hE,EAAAgI,EAAAC,GAEAkB,GAAAsM,EACAtM,EAAA,IACAA,GAAAsM,GAEArM,GAAAqM,EACArM,EAAA,IACAA,GAAAqM,GAEAtM,EAAAC,IAAAy+C,EACAz+C,GAAAqM,EACStM,EAAAC,GAAAy+C,IACT1+C,GAAAsM,GAEAoyC,EAAA,CACA,GAAA9e,GAAA3/B,CACAA,GAAAD,EACAA,EAAA4/B,EAIA,OAAA5yB,GAAA,EAA2BA,EAAA/M,EAAkB+M,GAAA9uB,KAAA0nB,GAAA,EAC7CoH,EAAAhN,IACAi4D,EAAA,GAAAtpB,EAAA3hC,GAAAqhC,EAAAhnD,EACA4wE,EAAA,GAAArpB,EAAA5hC,GAAAshC,EAAAloD,EACAmyE,EAAAp2E,EAAA81E,EAAA91E,GACAq2E,EAAA3hE,EAAAohE,EAAAphE,KAIAumD,IAEA98D,EAAA,+CAAAD,GACA,YACA,SAAAo4E,GAAAr8E,GACA,MAAAA,GAEA,QAAA+pD,GAAAuyB,EAAAC,EAAAC,EAAAC,GACAp8E,KAAAq8E,KAAAJ,EACAj8E,KAAAs8E,KAAAJ,EACAl8E,KAAAu8E,cAAAJ,GAAAH,EACAh8E,KAAAw8E,cAAAJ,GAAAJ,EAqEA,QAAAS,GAAAx4C,EAAAlnB,EAAA2/D,EAAAC,GACA,OAAAj4E,GAAA,EAAuBA,EAAAu/B,EAAA5/B,OAAgBK,IAAA,CACvC,GAAAya,GAAAw9D,EAAA14C,EAAAv/B,MACAk4E,EAAA7/D,EAAAoC,EACA,OAAAy9D,GACAF,EAAAl7E,KAAA2d,GACApC,EAAAoC,GAAAza,IAEAk4E,EAAAv4E,SACA0Y,EAAAoC,GAAAy9D,OAEAA,EAAAp7E,KAAAkD,KAIA,MAlFAglD,GAAA19C,WACAkhB,YAAAw8B,EACAv/C,IAAA,SAAAoK,GAEA,MADAvU,MAAA68E,KAAAtoE,EACAvU,MAEAiB,OAAA,SAAAsT,GAEA,MADAvU,MAAA88E,QAAAvoE,EACAvU,MAEAmU,OAAA,SAAAI,GAEA,MADAvU,MAAA+8E,QAAAxoE,EACAvU,MAEAuoB,QAAA,WACA,GAQA7jB,GARAu3E,EAAAj8E,KAAAq8E,KACAH,EAAAl8E,KAAAs8E,KACAH,EAAAn8E,KAAAu8E,cACAH,EAAAp8E,KAAAw8E,cACAQ,KACAC,KACAC,KACAC,IAOA,KALAV,EAAAR,EAAAe,EAAAE,EAAAf,GACAM,EAAAP,EAAAe,EAAAE,EAAAf,GAIA13E,EAAA,EAAuBA,EAAAu3E,EAAA53E,OAAmBK,IAAA,CAC1C,GAAAya,GAAA+9D,EAAAx4E,GACAgK,EAAAuuE,EAAA99D,EAEA,UAAAzQ,EAAA,CAGA,GAAAod,GAAApd,EAAArK,MACAynB,IACA,IAAAA,IAAAmxD,EAAA99D,GAAA,MACAzQ,IAAA0uE,WAEAH,EAAA99D,GAAA,KAEAnf,KAAA88E,SAAA98E,KAAA88E,QAAApuE,EAAAhK,OAEA1E,MAAA+8E,SAAA/8E,KAAA+8E,QAAAr4E,GAGA,OAAAA,GAAA,EAA2BA,EAAAy4E,EAAA94E,OAA0BK,IAAA,CACrD,GAAAya,GAAAg+D,EAAAz4E,EACA,IAAAu4E,EAAAjxD,eAAA7M,GAAA,CACA,GAAAzQ,GAAAuuE,EAAA99D,EACA,UAAAzQ,EACA,QAGA,IAAAA,EAAArK,OAGA,OAAAw5D,GAAA,EAAA/xC,EAAApd,EAAArK,OAAyDw5D,EAAA/xC,EAAS+xC,IAClE79D,KAAA68E,MAAA78E,KAAA68E,KAAAnuE,EAAAmvD,QAHA79D,MAAA68E,MAAA78E,KAAA68E,KAAAnuE,OAyBAg7C,IAEA7lD,EAAA,kFAAAD,GAUA,QAAAylB,GAAAa,EAAArrB,EAAAw+E,EAAAC,GACA,IAAAz+E,EACA,MAAAqrB,EAEA,IAAAqzD,GAAAC,EAAA3+E,EAAA,IACA+tD,EAAA5mD,EAAAgZ,QAAAu+D,MAAAl5E,QAAA,CACAg5E,SACAC,KAAA,OACA,QAAA54E,GAAA,EAAuBA,EAAAkoD,EAAaloD,IACpC,IAAAwlB,EAAAxlB,GAAA,CACA,GAAArC,GAAAg7E,EAAA34E,IAAA44E,GAAA54E,EAAA24E,EAAAh5E,OACA6lB,GAAAxlB,GAAA+4E,EAAA5+E,EAAA6F,IACApD,KAAA,UACAe,QACiBA,EAGjB,MAAA6nB,GAmBA,QAAAszD,GAAA/Y,GACA,MAAAz+D,GAAAgZ,QAAAylD,KAAAz+D,EAAAqW,SAAAooD,KAAA/lE,MAAA+lE,EA9CA,GAAAz+D,GAAApC,EAAA,qBA8BA65E,EAAAp0D,EAAAo0D,aAAA,SAAA5+E,EAAA2sD,GACA,OAAA9mD,GAAA,EAAAonB,EAAAjtB,EAAAwF,OAA8CK,EAAAonB,EAASpnB,IAAA,CACvD,GAAAhG,GAAA8+E,EAAA3+E,EAAA6F,GACA,KAAAsB,EAAAgZ,QAAAtgB,GACA,QAEA,IAAAA,KAAA8sD,EACA,UAAA9sD,GAAAgpC,SAAAhpC,GACA,QACiB,IAAAsH,EAAAgoB,SAAAtvB,IAAA,MAAAA,EACjB,SAGA,SAKA,OAAA2qB,KAEAxlB,EAAA,6DAAAD,GACA,GAAA88D,GAAA98D,EAAA,gBACA,QACA2zD,cAAA,SAAA4K,EAAAC,EAAA/jC,EAAAE,EAAAD,EAAAE,EAAAqjC,EAAAC,EAAA5rC,EAAAtrB,EAAAjB,GACA,OAAAusB,EACA,QAEA,IAAAwnD,GAAAxnD,CAEA,IAAAvsB,EAAAy4D,EAAAsb,GAAA/zE,EAAA40B,EAAAm/C,GAAA/zE,EAAA60B,EAAAk/C,GAAA/zE,EAAAm4D,EAAA4b,GAAA/zE,EAAAy4D,EAAAsb,GAAA/zE,EAAA40B,EAAAm/C,GAAA/zE,EAAA60B,EAAAk/C,GAAA/zE,EAAAm4D,EAAA4b,GAAA9yE,EAAAu3D,EAAAub,GAAA9yE,EAAAyzB,EAAAq/C,GAAA9yE,EAAA0zB,EAAAo/C,GAAA9yE,EAAAi3D,EAAA6b,GAAA9yE,EAAAu3D,EAAAub,GAAA9yE,EAAAyzB,EAAAq/C,GAAA9yE,EAAA0zB,EAAAo/C,GAAA9yE,EAAAi3D,EAAA6b,EACA,QAEA,IAAA5vE,GAAA4yD,EAAAia,kBAAAxY,EAAAC,EAAA/jC,EAAAE,EAAAD,EAAAE,EAAAqjC,EAAAC,EAAAl3D,EAAAjB,EAAA,KACA,OAAAmE,IAAA4vE,EAAA,MAIA75E,EAAA,qCACA,OACA0zD,cAAA,SAAA4K,EAAAC,EAAA/jC,EAAAE,EAAArI,EAAAtrB,EAAAjB,GACA,OAAAusB,EACA,QAEA,IAAAwnD,GAAAxnD,EACAynD,EAAA,EACAC,EAAAzb,CAEA,IAAAx4D,EAAAy4D,EAAAsb,GAAA/zE,EAAA40B,EAAAm/C,GAAA/zE,EAAAy4D,EAAAsb,GAAA/zE,EAAA40B,EAAAm/C,GAAA9yE,EAAAu3D,EAAAub,GAAA9yE,EAAAyzB,EAAAq/C,GAAA9yE,EAAAu3D,EAAAub,GAAA9yE,EAAAyzB,EAAAq/C,EACA,QAEA,IAAAvb,IAAA9jC,EAIA,MAAA58B,MAAAihB,IAAA9X,EAAAu3D,IAAAub,EAAA,CAHAC,IAAAvb,EAAA7jC,IAAA4jC,EAAA9jC,GACAu/C,GAAAzb,EAAA5jC,EAAAF,EAAA+jC,IAAAD,EAAA9jC,EAIA,IAAA8kB,GAAAw6B,EAAA/yE,EAAAjB,EAAAi0E,EACAC,EAAA16B,KAAAw6B,IAAA,EACA,OAAAE,IAAAH,EAAA,EAAAA,EAAA,MAIA75E,EAAA,iEAAAD,GACA,GAAA88D,GAAA98D,EAAA,gBACA,QACA2zD,cAAA,SAAA4K,EAAAC,EAAA/jC,EAAAE,EAAAD,EAAAE,EAAAtI,EAAAtrB,EAAAjB,GACA,OAAAusB,EACA,QAEA,IAAAwnD,GAAAxnD,CAEA,IAAAvsB,EAAAy4D,EAAAsb,GAAA/zE,EAAA40B,EAAAm/C,GAAA/zE,EAAA60B,EAAAk/C,GAAA/zE,EAAAy4D,EAAAsb,GAAA/zE,EAAA40B,EAAAm/C,GAAA/zE,EAAA60B,EAAAk/C,GAAA9yE,EAAAu3D,EAAAub,GAAA9yE,EAAAyzB,EAAAq/C,GAAA9yE,EAAA0zB,EAAAo/C,GAAA9yE,EAAAu3D,EAAAub,GAAA9yE,EAAAyzB,EAAAq/C,GAAA9yE,EAAA0zB,EAAAo/C,EACA,QAEA,IAAA5vE,GAAA4yD,EAAA4a,sBAAAnZ,EAAAC,EAAA/jC,EAAAE,EAAAD,EAAAE,EAAA5zB,EAAAjB,EAAA,KACA,OAAAmE,IAAA4vE,EAAA,MAIA75E,EAAA,oDAAAD,GACA,GAAA6iE,GAAA7iE,EAAA,UAAA6iE,gBACA52C,EAAA,EAAApuB,KAAA0nB,EACA,QACAouC,cAAA,SAAA3uC,EAAAC,EAAArD,EAAAjC,EAAAC,EAAAy+C,EAAA/rC,EAAAtrB,EAAAjB,GACA,OAAAusB,EACA,QAEA,IAAAwnD,GAAAxnD,CACAtrB,IAAAge,EACAjf,GAAAkf,CACA,IAAA/a,GAAArM,KAAAktD,KAAA/jD,IAAAjB,IACA,IAAAmE,EAAA4vE,EAAAl4D,GAAA1X,EAAA4vE,EAAAl4D,EACA,QAEA,IAAA/jB,KAAAihB,IAAAa,EAAAC,GAAAqM,EAAA,KAEA,QAEA,IAAAoyC,EAAA,CACA,GAAA9e,GAAA5/B,CACAA,GAAAkjD,EAAAjjD,GACAA,EAAAijD,EAAAtjB,OAEA5/B,GAAAkjD,EAAAljD,GACAC,EAAAijD,EAAAjjD,EAEAD,GAAAC,IACAA,GAAAqM,EAEA,IAAAU,GAAA9uB,KAAAoiE,MAAAl6D,EAAAiB,EAIA,OAHA2lB,GAAA,IACAA,GAAAV,GAEAU,GAAAhN,GAAAgN,GAAA/M,GAAA+M,EAAAV,GAAAtM,GAAAgN,EAAAV,GAAArM,MAIA3f,EAAA,4CAAAD,GACA,GAAAisB,GAAA,EAAApuB,KAAA0nB,EACA,QACAs9C,gBAAA,SAAAl2C,GAKA,MAJAA,IAAAV,EACAU,EAAA,IACAA,GAAAV,GAEAU,MAIA1sB,EAAA,4CACA,gBAAAs+D,EAAAC,EAAA/jC,EAAAE,EAAA3zB,EAAAjB,GACA,GAAAA,EAAAy4D,GAAAz4D,EAAA40B,GAAA50B,EAAAy4D,GAAAz4D,EAAA40B,EACA,QAGA,IAAAA,IAAA6jC,EACA,QAEA,IAAA9xC,GAAAiO,EAAA6jC,EAAA,KACAxf,GAAAj5C,EAAAy4D,IAAA7jC,EAAA6jC,EAEA,KAAAxf,GAAA,IAAAA,IACAtyB,EAAAiO,EAAA6jC,EAAA,OAEA,IAAA8D,GAAAtjB,GAAAvkB,EAAA8jC,IACA,OAAA+D,GAAAt7D,EAAA0lB,EAAA,KAGAzsB,EAAA,0FAAAD,GACA,GAAA4zB,GAAA5zB,EAAA,uCAEA,OACA,UAGA,SACA,gBAGA,YACA,gBAGA,SACA,mBAGA,YACA,mBAEA,YACA,eACA,kBACA,kBACA,gBAEA,QACA4zB,gBAAA,SAAAyvC,GACA,GAAAh+D,GAAAuuB,EAAApoB,KAAApP,KAAAinE,EACA,IAAAjnE,KAAA4nE,kBAAA,CACA,GAAA1R,GAAAl2D,KAAA4nE,mBACA1R,KAAAjtD,EAAAitD,YAEA,MAAAjtD,OAIApF,EAAA,wCAAAD,GAKA,GAAAk6E,GAAA,WAIA99E,KAAA+9E,KAAA,KAIA/9E,KAAAg+E,KAAA,KACAh+E,KAAA+gE,KAAA,GAEAkd,EAAAH,EAAA9xE,SAMAiyE,GAAAC,OAAA,SAAAjxE,GACA,GAAAkxE,GAAA,GAAAC,GAAAnxE,EAEA,OADAjN,MAAAq+E,YAAAF,GACAA,GAMAF,EAAAI,YAAA,SAAAF,GACAn+E,KAAA+9E,MAGA/9E,KAAAg+E,KAAA99E,KAAAi+E,EACAA,EAAAvD,KAAA56E,KAAAg+E,KACAh+E,KAAAg+E,KAAAG,GAJAn+E,KAAA+9E,KAAA/9E,KAAAg+E,KAAAG,EAMAn+E,KAAA+gE,QAMAkd,EAAA9pE,OAAA,SAAAgqE,GACA,GAAAvD,GAAAuD,EAAAvD,KACA16E,EAAAi+E,EAAAj+E,IACA06E,GACAA,EAAA16E,OAGAF,KAAA+9E,KAAA79E,EAEAA,EACAA,EAAA06E,OAGA56E,KAAAg+E,KAAApD,EAEAuD,EAAAj+E,KAAAi+E,EAAAvD,KAAA,KACA56E,KAAA+gE,QAKAkd,EAAAnyD,IAAA,WACA,MAAA9rB,MAAA+gE,KAMA,IAAAqd,GAAA,SAAAnxE,GAIAjN,KAAAtB,MAAAuO,EAIAjN,KAAAE,KAIAF,KAAA46E,MAOAthB,EAAA,SAAAglB,GACAt+E,KAAAu+E,MAAA,GAAAT,GACA99E,KAAAw+E,QACAx+E,KAAAy+E,SAAAH,GAAA,IAEAI,EAAAplB,EAAAttD,SA4CA,OAvCA0yE,GAAA7kB,IAAA,SAAA16C,EAAAzgB,GACA,GAAA8a,GAAAxZ,KAAAu+E,MACAxhE,EAAA/c,KAAAw+E,IACA,UAAAzhE,EAAAoC,GAAA,CACA,GAAA2M,GAAAtS,EAAAsS,KACA,IAAAA,GAAA9rB,KAAAy+E,UAAA3yD,EAAA,GAEA,GAAA6yD,GAAAnlE,EAAAukE,IACAvkE,GAAArF,OAAAwqE,SACA5hE,GAAA4hE,EAAAx/D,KAEA,GAAAg/D,GAAA3kE,EAAA0kE,OAAAx/E,EACAy/E,GAAAh/D,MACApC,EAAAoC,GAAAg/D,IAOAO,EAAAh2E,IAAA,SAAAyW,GACA,GAAAg/D,GAAAn+E,KAAAw+E,KAAAr/D,GACA3F,EAAAxZ,KAAAu+E,KACA,UAAAJ,EAMA,MAJAA,KAAA3kE,EAAAwkE,OACAxkE,EAAArF,OAAAgqE,GACA3kE,EAAA6kE,YAAAF,IAEAA,EAAAz/E,OAMAggF,EAAAxgE,MAAA,WACAle,KAAAu+E,MAAArgE,QACAle,KAAAw+E,SAEAllB,IAEAz1D,EAAA,qFAAAD,GACA,GAAAg7E,GAAAh7E,EAAA,kBACAi7E,EAAAj7E,EAAA,iBACA,QACAswD,UAAA,SAAApe,EAAAzqC,EAAAkvD,GACA,GAAA5zC,GAAAtb,EAAAsb,OACAW,EAAAjc,EAAAic,MACA,IAAAX,KAAAtiB,QAAA,GACA,GAAAijB,GAAA,WAAAA,EAAA,CACA,GAAAw3D,GAAAD,EAAAl4D,EAAAW,EAAAizC,EAAAlvD,EAAAqvD,iBACA5kB,GAAAqkB,OAAAxzC,EAAA,MAAAA,EAAA,MAEA,QADAmF,GAAAnF,EAAAtiB,OACAK,EAAA,EAAmCA,GAAA61D,EAAAzuC,IAAA,GAAiCpnB,IAAA,CACpE,GAAAq6E,GAAAD,EAAA,EAAAp6E,GACAs6E,EAAAF,EAAA,EAAAp6E,EAAA,GACAy1B,EAAAxT,GAAAjiB,EAAA,GAAAonB,EACAgqB,GAAA6lB,cAAAojB,EAAA,GAAAA,EAAA,GAAAC,EAAA,GAAAA,EAAA,GAAA7kD,EAAA,GAAAA,EAAA,SAEiB,CACjB,WAAA7S,IACAX,EAAAi4D,EAAAj4D,EAAA4zC,IAEAzkB,EAAAqkB,OAAAxzC,EAAA,MAAAA,EAAA,MACA,QAAAjiB,GAAA,EAAAe,EAAAkhB,EAAAtiB,OAAsDK,EAAAe,EAAOf,IAC7DoxC,EAAAwkB,OAAA3zC,EAAAjiB,GAAA,GAAAiiB,EAAAjiB,GAAA,IAGA61D,GAAAzkB,EAAAykB,iBAKA12D,EAAA,+EAAAD,GAKA,QAAAq7E,GAAAxQ,EAAAC,EAAAc,EAAAC,EAAA7sB,EAAA8sB,EAAAC,GACA,GAAAE,GAAA,IAAAL,EAAAf,GACAjgB,EAAA,IAAAihB,EAAAf,EACA,WAAAA,EAAAc,GAAAK,EAAArhB,GAAAmhB,OAAAjB,EAAAc,GAAA,EAAAK,EAAArhB,GAAAkhB,EAAAG,EAAAjtB,EAAA8rB,EAPA,GAAAnT,GAAA33D,EAAA,oBAeA,iBAAA+iB,EAAAu4D,GAIA,OAHApzD,GAAAnF,EAAAtiB,OACA4gC,KACA8pB,EAAA,EACArqD,EAAA,EAAuBA,EAAAonB,EAASpnB,IAChCqqD,GAAAwM,EAAAxM,SAAApoC,EAAAjiB,EAAA,GAAAiiB,EAAAjiB,GAEA,IAAAy6E,GAAApwB,EAAA,CACAowB,KAAArzD,IAAAqzD,CACA,QAAAz6E,GAAA,EAAuBA,EAAAy6E,EAAUz6E,IAAA,CACjC,GAGA+pE,GAEAe,EACAC,EANA2P,EAAA16E,GAAAy6E,EAAA,IAAAD,EAAApzD,IAAA,GACApd,EAAAjN,KAAA2K,MAAAgzE,GACAnoB,EAAAmoB,EAAA1wE,EAEAggE,EAAA/nD,EAAAjY,EAAAod,EAGAozD,IAKAzQ,EAAA9nD,GAAAjY,EAAA,EAAAod,MACA0jD,EAAA7oD,GAAAjY,EAAA,GAAAod,GACA2jD,EAAA9oD,GAAAjY,EAAA,GAAAod,KANA2iD,EAAA9nD,EAAA,IAAAjY,MAAA,GACA8gE,EAAA7oD,EAAAjY,EAAAod,EAAA,EAAAA,EAAA,EAAApd,EAAA,GACA+gE,EAAA9oD,EAAAjY,EAAAod,EAAA,EAAAA,EAAA,EAAApd,EAAA,GAMA,IAAA2wE,GAAApoB,IACAqoB,EAAAroB,EAAAooB,CACAp6C,GAAAzjC,MACAy9E,EAAAxQ,EAAA,GAAAC,EAAA,GAAAc,EAAA,GAAAC,EAAA,GAAAxY,EAAAooB,EAAAC,GACAL,EAAAxQ,EAAA,GAAAC,EAAA,GAAAc,EAAA,GAAAC,EAAA,GAAAxY,EAAAooB,EAAAC,KAGA,MAAAr6C,MAGAphC,EAAA,+EAAAD,GACA,GAAA23D,GAAA33D,EAAA,qBACA27E,EAAAhkB,EAAA71D,IACA85E,EAAAjkB,EAAAnhD,IACAqlE,EAAAlkB,EAAAr5C,MACAw9D,EAAAnkB,EAAAxM,SACA4wB,EAAApkB,EAAApxD,GAYA,iBAAAwc,EAAAW,EAAA43D,EAAAU,GACA,GAIAC,GACAC,EACAp6E,EAAA0U,EANA2lE,KACAz4B,KACAkH,KACAC,IAIA,IAAAmxB,EAAA,CACAl6E,GACAmI,IACAA,KAEAuM,KACAvM,OACAA,KAEA,QAAAnJ,GAAA,EAAAonB,EAAAnF,EAAAtiB,OAAgDK,EAAAonB,EAASpnB,IACzD66E,EAAA75E,IAAAihB,EAAAjiB,IACA86E,EAAAplE,IAAAuM,EAAAjiB,GAGA66E,GAAA75E,IAAAk6E,EAAA,IACAJ,EAAAplE,IAAAwlE,EAAA,IAEA,OAAAl7E,GAAA,EAAAonB,EAAAnF,EAAAtiB,OAA4CK,EAAAonB,EAASpnB,IAAA,CACrD,GAAAksD,GAAAjqC,EAAAjiB,EACA,IAAAw6E,EACAW,EAAAl5D,EAAAjiB,IAAA,EAAAonB,EAAA,GACAg0D,EAAAn5D,GAAAjiB,EAAA,GAAAonB,OACa,CACb,OAAApnB,OAAAonB,EAAA,GACAi0D,EAAAv+E,KAAA+5D,EAAA5qD,MAAAgW,EAAAjiB,IACA,UAEAm7E,EAAAl5D,EAAAjiB,EAAA,GACAo7E,EAAAn5D,EAAAjiB,EAAA,GAGA62D,EAAAvnD,IAAAszC,EAAAw4B,EAAAD,GAEAJ,EAAAn4B,IAAAhgC,EACA,IAAA04D,GAAAN,EAAA9uB,EAAAivB,GACAhF,EAAA6E,EAAA9uB,EAAAkvB,GACA11D,EAAA41D,EAAAnF,CACA,KAAAzwD,IACA41D,GAAA51D,EACAywD,GAAAzwD,GAEAq1D,EAAAjxB,EAAAlH,GAAA04B,GACAP,EAAAhxB,EAAAnH,EAAAuzB,EACA,IAAAoF,GAAAN,KAAA/uB,EAAApC,GACAuwB,EAAAY,KAAA/uB,EAAAnC,EACAmxB,KACAJ,EAAAS,IAAAv6E,GACA65E,EAAAU,IAAA7lE,GACAolE,EAAAT,IAAAr5E,GACA65E,EAAAR,IAAA3kE,IAEA2lE,EAAAv+E,KAAAy+E,GACAF,EAAAv+E,KAAAu9E,GAKA,MAHAG,IACAa,EAAAv+E,KAAAu+E,EAAA1iE,SAEA0iE,KAGAl8E,EAAA,wDAAAD,GACA,OACAswD,UAAA,SAAApe,EAAAzqC,GACA,GAKA60E,GACAC,EACAC,EACAC,EARAz1E,EAAAS,EAAAT,EACAjB,EAAA0B,EAAA1B,EACAY,EAAAc,EAAAd,MACAX,EAAAyB,EAAAzB,OACA4b,EAAAna,EAAAma,CAMAjb,GAAA,IACAK,GAAAL,EACAA,MAEAX,EAAA,IACAD,GAAAC,EACAA,MAEA,gBAAA4b,GACA06D,EAAAC,EAAAC,EAAAC,EAAA76D,EACaA,YAAArgB,OACb,IAAAqgB,EAAAnhB,OACA67E,EAAAC,EAAAC,EAAAC,EAAA76D,EAAA,GACiB,IAAAA,EAAAnhB,QACjB67E,EAAAE,EAAA56D,EAAA,GACA26D,EAAAE,EAAA76D,EAAA,IACiB,IAAAA,EAAAnhB,QACjB67E,EAAA16D,EAAA,GACA26D,EAAAE,EAAA76D,EAAA,GACA46D,EAAA56D,EAAA,KAEA06D,EAAA16D,EAAA,GACA26D,EAAA36D,EAAA,GACA46D,EAAA56D,EAAA,GACA66D,EAAA76D,EAAA,IAGA06D,EAAAC,EAAAC,EAAAC,EAAA,CAEA,IAAAC,EACAJ,GAAAC,EAAA51E,IACA+1E,EAAAJ,EAAAC,EACAD,GAAA31E,EAAA+1E,EACAH,GAAA51E,EAAA+1E,GAEAF,EAAAC,EAAA91E,IACA+1E,EAAAF,EAAAC,EACAD,GAAA71E,EAAA+1E,EACAD,GAAA91E,EAAA+1E,GAEAH,EAAAC,EAAAx2E,IACA02E,EAAAH,EAAAC,EACAD,GAAAv2E,EAAA02E,EACAF,GAAAx2E,EAAA02E,GAEAJ,EAAAG,EAAAz2E,IACA02E,EAAAJ,EAAAG,EACAH,GAAAt2E,EAAA02E,EACAD,GAAAz2E,EAAA02E,GAEAxqC,EAAAqkB,OAAAvvD,EAAAs1E,EAAAv2E,GACAmsC,EAAAwkB,OAAA1vD,EAAAL,EAAA41E,EAAAx2E,GACA,IAAAw2E,GAAArqC,EAAA4lB,iBAAA9wD,EAAAL,EAAAZ,EAAAiB,EAAAL,EAAAZ,EAAAw2E,GACArqC,EAAAwkB,OAAA1vD,EAAAL,EAAAZ,EAAAC,EAAAw2E,GACA,IAAAA,GAAAtqC,EAAA4lB,iBAAA9wD,EAAAL,EAAAZ,EAAAC,EAAAgB,EAAAL,EAAA61E,EAAAz2E,EAAAC,GACAksC,EAAAwkB,OAAA1vD,EAAAy1E,EAAA12E,EAAAC,GACA,IAAAy2E,GAAAvqC,EAAA4lB,iBAAA9wD,EAAAjB,EAAAC,EAAAgB,EAAAjB,EAAAC,EAAAy2E,GACAvqC,EAAAwkB,OAAA1vD,EAAAjB,EAAAu2E,GACA,IAAAA,GAAApqC,EAAA4lB,iBAAA9wD,EAAAjB,EAAAiB,EAAAs1E,EAAAv2E,OAIA9F,EAAA,uGAAAD,GACA,YAOA,SAAA28E,GAAA7zE,EAAAwD,GACA,MAAAxD,GAAAvF,SAAA+I,EAAA/I,OACAuF,EAAAtF,IAAA8I,EAAA9I,EAOAsF,EAAApD,GAAA4G,EAAA5G,GAEAoD,EAAAtF,EAAA8I,EAAA9I,EAEAsF,EAAAvF,OAAA+I,EAAA/I,OAnBA,GAAA4Z,GAAAnd,EAAA,eACA4R,EAAA5R,EAAA,cACA2gB,EAAA3gB,EAAA,qBAGA4N,EAAA5N,EAAA,kBAqBAyvC,EAAA,WAEArzC,KAAAwgF,aACAxgF,KAAAygF;AACAzgF,KAAA0gF,gBACA1gF,KAAA2gF,gBAAA,EAgJA,OA9IAttC,GAAArnC,WACAkhB,YAAAmmB,EACA/9B,SAAA,SAAAyT,EAAAtZ,GACA,OAAA/K,GAAA,EAA2BA,EAAA1E,KAAAygF,OAAAp8E,OAAwBK,IACnD1E,KAAAygF,OAAA/7E,GAAA4Q,SAAAyT,EAAAtZ,IAGAgK,eAAA,SAAAxY,EAAA2/E,GAKA,MAJAA,OAAA,EACA3/E,GACAjB,KAAA6gF,kBAAAD,GAEA5gF,KAAA0gF,cAEAG,kBAAA,SAAAD,GACA5gF,KAAA2gF,gBAAA,CAGA,QAFA9a,GAAA7lE,KAAAygF,OACAK,EAAA9gF,KAAA0gF,aACAh8E,EAAA,EAAAonB,EAAA+5C,EAAAxhE,OAA+CK,EAAAonB,EAASpnB,IACxD1E,KAAA+gF,yBAAAlb,EAAAnhE,GAAA,KAAAk8E,EAEAE,GAAAz8E,OAAArE,KAAA2gF,gBAKAnrE,EAAAS,iBAAAzE,EAAAsvE,EAAAP,IAEAQ,yBAAA,SAAA//E,EAAAggF,EAAAJ,GACA,IAAA5/E,EAAA2U,QAAAirE,EAAA,CAGA5/E,EAAA6oE,eACA7oE,EAAA2zD,SACA3zD,EAAAC,SAEAD,EAAA8oE,aACA,IAAA9gD,GAAAhoB,EAAAgoB,QAaA,IAZAA,IAEAA,EAAAwW,OAAAx+B,EACAgoB,EAAA+gD,kBAEAiX,GACAA,IAAAr8E,QACAq8E,EAAAx/E,KAAAwnB,IAEAg4D,GAAAh4D,IAGAhoB,EAAAuU,QAAA,CAEA,OADA6iD,GAAAp3D,EAAAk3D,UACAxzD,EAAA,EAA+BA,EAAA0zD,EAAA/zD,OAAqBK,IAAA,CACpD,GAAAyjB,GAAAiwC,EAAA1zD,EAGA1D,GAAA2zD,UACAxsC,EAAAwsC,SAAA,GAEA30D,KAAA+gF,yBAAA54D,EAAA64D,EAAAJ,GAGA5/E,EAAA2zD,SAAA,MAEA3zD,GAAA6jE,YAAAmc,EACAhhF,KAAA0gF,aAAA1gF,KAAA2gF,mBAAA3/E,IAGA8zC,QAAA,SAAA9zC,GAEAhB,KAAAwgF,UAAAx/E,EAAAb,MAGAa,YAAAujB,IACAvjB,EAAAy3D,qBAAAz4D,MAEAA,KAAAy0C,SAAAzzC,GACAhB,KAAAygF,OAAAj/E,KAAAR,KAEA+zC,QAAA,SAAAL,GACA,SAAAA,EAAA,CAEA,OAAAhwC,GAAA,EAA+BA,EAAA1E,KAAAygF,OAAAp8E,OAAwBK,IAAA,CACvD,GAAAlB,GAAAxD,KAAAygF,OAAA/7E,EACAlB,aAAA+gB,IACA/gB,EAAAk1D,uBAAA14D,MAOA,MAJAA,MAAAwgF,aACAxgF,KAAAygF,UACAzgF,KAAA0gF,qBACA1gF,KAAA2gF,gBAAA,GAGA,GAAAjsC,YAAAvvC,OACA,OAAAT,GAAA,EAAAe,EAAAivC,EAAArwC,OAAgDK,EAAAe,EAAOf,IACvD1E,KAAA+0C,QAAAL,EAAAhwC,QAFA,CAMA,GAAA1D,EAEAA,GADA,gBAAA0zC,GACA10C,KAAAwgF,UAAA9rC,GAEAA,CAEA,IAAAhmC,GAAAqS,EAAA/c,QAAAhE,KAAAygF,OAAAz/E,EACA0N,IAAA,IACA1O,KAAAu0C,WAAAvzC,EAAAb,IACAH,KAAAygF,OAAArsE,OAAA1F,EAAA,GACA1N,YAAAujB,IACAvjB,EAAA03D,uBAAA14D,SAIAy0C,SAAA,SAAAzzC,GAMA,MALAA,aAAAujB,KACAvjB,EAAAm3D,UAAAn4D,MAEAgB,EAAAqzD,OAAA,GACAr0D,KAAAwgF,UAAAx/E,EAAAb,IAAAa,EACAhB,MAEA0I,IAAA,SAAAgsC,GACA,MAAA10C,MAAAwgF,UAAA9rC,IAEAH,WAAA,SAAAG,GACA,GAAAusC,GAAAjhF,KAAAwgF,UACAx/E,EAAAigF,EAAAvsC,EAOA,OANA1zC,WACAigF,GAAAvsC,GACA1zC,YAAAujB,KACAvjB,EAAAm3D,UAAA,OAGAn4D,MAEAwC,QAAA,WACAxC,KAAAwgF,UAAAxgF,KAAAkhF,YAAAlhF,KAAAygF,OAAA,MAEAU,oBAAAZ,GAEAltC,IAEAxvC,EAAA,4FAAAD,GACA,YAIA,SAAAw9E,GAAAC,EAAA/5E,EAAArB,GACA,OACA3E,KAAA+/E,EACAp7E,QACAqB,SACAg6E,cAAA,EACAC,QAAAt7E,EAAAu7E,IACAC,QAAAx7E,EAAAy7E,IACAC,aAAA17E,EAAA07E,aACAC,OAAA37E,EAAA27E,OACAC,OAAA57E,EAAA47E,OACAC,WAAA77E,EAAA67E,WACAC,WAAA97E,EAAA+7E,SAGA,QAAAC,MA8JA,QAAAC,GAAAC,EAAAv3E,EAAAjB,GACA,GAAAw4E,IAAAhd,UAAA,yBAAAv6D,EAAAjB,GAAA,CAEA,IADA,GAAA3I,GAAAmhF,EACAnhF,GAAA,CAEA,GAAAA,EAAA+I,QAAA/I,EAAAgoB,WAAAhoB,EAAAgoB,SAAAomC,QAAAxkD,EAAAjB,GACA,QAEA3I,KAAAw+B,OAEA,SAEA,SA5LA,GAAAze,GAAAnd,EAAA,eACAw+E,EAAAx+E,EAAA,qBACA+L,EAAA/L,EAAA,mBAkBAq+E,GAAAj2E,UAAAxJ,QAAA,YAEA,IAAA6/E,IACA,QACA,WACA,aACA,WACA,UACA,YACA,aAUAjvC,EAAA,SAAAh+B,EAAAsE,EAAA4oE,GACA3yE,EAAAP,KAAApP,MACAA,KAAAoV,UACApV,KAAA0Z,UACA4oE,KAAA,GAAAL,GAIAjiF,KAAAsiF,QAEAA,EAAA9yE,QAAAxP,KAKAA,KAAAuiF,SAKAviF,KAAAwiF,iBAKAxiF,KAAAyiF,OAKAziF,KAAA0iF,OACAN,EAAAhzE,KAAApP,MACA+gB,EAAA7R,KAAAmzE,EAAA,SAAAhgF,GACAigF,EAAAt4E,IAAAs4E,EAAAt4E,GAAA3H,EAAArC,KAAAqC,GAAArC,OACSA,MAuHT,OArHAozC,GAAApnC,WACAkhB,YAAAkmB,EACAuvC,UAAA,SAAA18E,GACA,GAAA2E,GAAA3E,EAAAu7E,IACA73E,EAAA1D,EAAAy7E,IACAkB,EAAA5iF,KAAA6iF,UAAAj4E,EAAAjB,EAAA,MACAm5E,EAAA9iF,KAAAuiF,SACAD,EAAAtiF,KAAAsiF,KACAtiF,MAAAuiF,SAAAK,EACAN,EAAAS,WAAAT,EAAAS,UAAAH,IAAA1d,OAAA,WAEA4d,GAAAF,IAAAE,KAAA5nD,MACAl7B,KAAAgjF,kBAAAF,EAAA,WAAA78E,GAGAjG,KAAAgjF,kBAAAJ,EAAA,YAAA38E,GAEA28E,OAAAE,GACA9iF,KAAAgjF,kBAAAJ,EAAA,YAAA38E,IAGAg9E,SAAA,SAAAh9E,GACAjG,KAAAgjF,kBAAAhjF,KAAAuiF,SAAA,WAAAt8E,GACAjG,KAAAmd,QAAA,aAAuClX,WAEvCqL,OAAA,SAAArL,GACAjG,KAAAuiF,SAAA,MAEA3iF,SAAA,SAAA2P,EAAA2zE,GACA,GAAA1zE,GAAAxP,KAAAuP,EACAC,MAAAJ,KAAApP,KAAAkjF,IAEA1gF,QAAA,WACAxC,KAAAsiF,MAAA9/E,UACAxC,KAAAoV,QAAApV,KAAAsiF,MAAAtiF,KAAA0Z,QAAA,MAEA67B,eAAA,SAAAC,GACA,GAAA8sC,GAAAtiF,KAAAsiF,KACAA,GAAAS,WAAAT,EAAAS,UAAAvtC,IAEAwtC,kBAAA,SAAAG,EAAA5zE,EAAAtJ,GAIA,IAHA,GAAAwvC,GAAA,KAAAlmC,EACA6zE,EAAAhC,EAAA7xE,EAAA4zE,EAAAl9E,GACAjF,EAAAmiF,EACAniF,IACAA,EAAAy0C,KAAA2tC,EAAA9B,aAAAtgF,EAAAy0C,GAAArmC,KAAApO,EAAAoiF,IACApiF,EAAAmc,QAAA5N,EAAA6zE,GACApiF,IAAAw+B,QACA4jD,EAAA9B,gBAIA8B,EAAA9B,eAEAthF,KAAAmd,QAAA5N,EAAA6zE,GAGApjF,KAAA0Z,SAAA1Z,KAAA0Z,QAAA2pE,eAAA,SAAAC,GACA,kBAAAA,GAAA7tC,IACA6tC,EAAA7tC,GAAArmC,KAAAk0E,EAAAF,GAEAE,EAAAnmE,SACAmmE,EAAAnmE,QAAA5N,EAAA6zE,OAKAP,UAAA,SAAAj4E,EAAAjB,EAAA45E,GAEA,OADA/pE,GAAAxZ,KAAAoV,QAAAqE,iBACA/U,EAAA8U,EAAAnV,OAAA,EAAyCK,GAAA,EAAQA,IACjD,IAAA8U,EAAA9U,GAAAqF,QAAAyP,EAAA9U,KAAA6+E,IAAA/pE,EAAA9U,GAAAiR,QAAAusE,EAAA1oE,EAAA9U,GAAAkG,EAAAjB,GACA,MAAA6P,GAAA9U,KAMAqc,EAAA7R,MACA,QACA,YACA,UACA,aACA,YACA,SAAA7M,GACA+wC,EAAApnC,UAAA3J,GAAA,SAAA4D,GAEA,GAAA28E,GAAA5iF,KAAA6iF,UAAA58E,EAAAu7E,IAAAv7E,EAAAy7E,IAAA,KACA,kBAAAr/E,EACArC,KAAAwjF,QAAAZ,EAEA5iF,KAAAyjF,MAAAb,MACa,gBAAAvgF,EACbrC,KAAAyjF,MAAAb,MACa,cAAAvgF,GACbrC,KAAAwjF,UAAAxjF,KAAAyjF,MACA,MAGAzjF,MAAAgjF,kBAAAJ,EAAAvgF,EAAA4D,MAiBA8a,EAAAzI,MAAA86B,EAAAzjC,GACAoR,EAAAzI,MAAA86B,EAAAgvC,GACAhvC,IAEAvvC,EAAA,yHAAAD,GACA,YACA,IAAAmd,GAAAnd,EAAA,gBACA8/E,EAAA9/E,EAAA,iBAAA8/E,WACAC,EAAA//E,EAAA,2BACA0nE,EAAA1nE,EAAA,cA4BA0vC,EAAA,SAAAxwC,GACAA,QACA9C,KAAAk0C,MAAApxC,EAAAoxC,UACAl0C,KAAAuxE,QAAAzuE,EAAAyuE,SAAA,aAGAvxE,KAAA4jF,UACA5jF,KAAA6jF,UAAA,EACA7jF,KAAA8jF,MACA9jF,KAAA+jF,YACA/jF,KAAAgkF,YACAhkF,KAAAikF,SAAA,EACAP,EAAAt0E,KAAApP,MA0GA,OAxGAszC,GAAAtnC,WACAkhB,YAAAomB,EACAm/B,QAAA,SAAAhB,GACAzxE,KAAA4jF,OAAApiF,KAAAiwE,IAEAvH,YAAA,SAAAuB,GACAA,EAAA95D,UAAA3R,IAEA,QADAkkF,GAAAzY,EAAAoH,WACAnuE,EAAA,EAA2BA,EAAAw/E,EAAA7/E,OAAkBK,IAC7C1E,KAAAyyE,QAAAyR,EAAAx/E,KAGAkuE,WAAA,SAAAnB,GACA,GAAA/iE,GAAAqS,EAAA/c,QAAAhE,KAAA4jF,OAAAnS,EACA/iE,IAAA,GACA1O,KAAA4jF,OAAAxvE,OAAA1F,EAAA,IAGAy7D,eAAA,SAAAsB,GAEA,OADAyY,GAAAzY,EAAAoH,WACAnuE,EAAA,EAA2BA,EAAAw/E,EAAA7/E,OAAkBK,IAC7C1E,KAAA4yE,WAAAsR,EAAAx/E,GAEA+mE,GAAA95D,UAAA,MAEAmrE,QAAA,WAOA,OANArzB,IAAA,GAAAp8C,OAAA82E,UAAAnkF,KAAA+jF,YACAhsC,EAAA0R,EAAAzpD,KAAA8jF,MACAI,EAAAlkF,KAAA4jF,OACA93D,EAAAo4D,EAAA7/E,OACA+/E,KACAC,KACA3/E,EAAA,EAA2BA,EAAAonB,EAASpnB,IAAA,CACpC,GAAA+sE,GAAAyS,EAAAx/E,GACA8Y,EAAAi0D,EAAArgD,KAAAq4B,EAGAjsC,KACA4mE,EAAA5iF,KAAAgc,GACA6mE,EAAA7iF,KAAAiwE,IAIA,OAAA/sE,GAAA,EAA2BA,EAAAonB,GAC3Bo4D,EAAAx/E,GAAAuvE,cACAiQ,EAAAx/E,GAAAw/E,EAAAp4D,EAAA,GACAo4D,EAAAhtC,MACAprB,KAEApnB,GAGAonB,GAAAs4D,EAAA//E,MACA,QAAAK,GAAA,EAA2BA,EAAAonB,EAASpnB,IACpC2/E,EAAA3/E,GAAAqvE,KAAAqQ,EAAA1/E,GAEA1E,MAAA8jF,MAAAr6B,EACAzpD,KAAAuxE,QAAAx5B,GACA/3C,KAAAmd,QAAA,QAAA46B,GACA/3C,KAAAk0C,MAAAjzC,QACAjB,KAAAk0C,MAAAjzC,UAGAqjF,WAAA,WAGA,QAAAlzD,KACAzwB,EAAAkjF,WACAF,EAAAvyD,IACAzwB,EAAAsjF,SAAAtjF,EAAAm8E,WALA,GAAAn8E,GAAAX,IACAA,MAAA6jF,UAAA,EAOAF,EAAAvyD,IAEAhP,MAAA,WACApiB,KAAA8jF,OAAA,GAAAz2E,OAAA82E,UACAnkF,KAAA+jF,YAAA,EACA/jF,KAAAskF,cAEA5uC,KAAA,WACA11C,KAAA6jF,UAAA,GAEAU,MAAA,WACAvkF,KAAAikF,UACAjkF,KAAAgkF,aAAA,GAAA32E,OAAA82E,UACAnkF,KAAAikF,SAAA,IAGAO,OAAA,WACAxkF,KAAAikF,UACAjkF,KAAA+jF,cAAA,GAAA12E,OAAA82E,UAAAnkF,KAAAgkF,YACAhkF,KAAAikF,SAAA,IAGA/lE,MAAA,WACAle,KAAA4jF,WAEA7/D,QAAA,SAAAzc,EAAAxE,GACAA,OACA,IAAA2oE,GAAA,GAAAH,GAAAhkE,EAAAxE,EAAA40D,KAAA50D,EAAAqtE,OAAArtE,EAAAutE,OACA,OAAA5E,KAGA1qD,EAAAzI,MAAAg7B,EAAAowC,GACApwC,IAEAzvC,EAAA,sIAAAD,GAwBA,QAAA6gF,GAAApiF,GACA,qBAAAA,GAAAmT,EAAAwyB,QAAAC,QAAA,iBAAA5lC,EAEA,QAAAqiF,GAAApC,EAAAr8E,EAAAiuC,GACA,GAAAywC,GAAArC,EAAAsC,WACA,WAAA1wC,GAAAywC,EAAAzmE,OACA,IAAA2mE,GAAAF,EAAAG,UAAA7+E,EAAAq8E,EAAA9yE,QAAAqzE,UAAA58E,EAAAu7E,IAAAv7E,EAAAy7E,IAAA,MAAAY,EAAAxyE,IAEA,IADA,QAAAokC,GAAAywC,EAAAzmE,QACA2mE,EAAA,CAEA,GAAAvjF,GAAAujF,EAAAvjF,IACA2E,GAAA07E,aAAArgF,EACAghF,EAAA9yE,QAAAwzE,kBAAA6B,EAAAv9E,OAAAhG,EAAAujF,EAAA5+E,QAUA,QAAA8+E,GAAAjkF,GACAA,EAAAkkF,WAAA,EACAC,aAAAnkF,EAAAokF,aACApkF,EAAAokF,YAAAC,WAAA,WACArkF,EAAAkkF,WAAA,GACS,KAET,QAAAI,KACA,MAAA5vE,GAAA4yB,qBA0EA,QAAAi9C,GAAAvkF,GASA,QAAAwkF,GAAAC,EAAAzkF,GACA,kBACA,IAAAA,EAAAkkF,UAGA,MAAAO,GAAA7hF,MAAA5C,EAAA2oB,YAbA,OAAA/kB,GAAA,EAAuBA,EAAA8gF,EAAAnhF,OAA8BK,IAAA,CACrD,GAAArC,GAAAmjF,EAAA9gF,EACA5D,GAAA2kF,UAAApjF,GAAA2D,EAAAtF,KAAAglF,EAAArjF,GAAAvB,GAEA,OAAA4D,GAAA,EAAuBA,EAAAihF,EAAAthF,OAA8BK,IAAA,CACrD,GAAArC,GAAAsjF,EAAAjhF,EACA5D,GAAA2kF,UAAApjF,GAAAijF,EAAAI,EAAArjF,GAAAvB,IAWA,QAAA8kF,GAAA91E,GA4BA,QAAA+1E,GAAAxD,EAAAvhF,GACAkF,EAAAkJ,KAAAmzE,EAAA,SAAAhgF,GACAyjF,EAAAh2E,EAAA20E,EAAApiF,GAAAvB,EAAA2kF,UAAApjF,KACavB,GA9Bb6O,EAAAP,KAAApP,MACAA,KAAA8P,MAKA9P,KAAAglF,WAAA,EAKAhlF,KAAAklF,YAKAllF,KAAA4kF,YAAA,GAAAmB,GACA/lF,KAAAylF,aACAJ,EAAArlF,MACAolF,KACAS,EAAAL,EAAAxlF,MAMA6lF,EAAAF,EAAA3lF,MA5KA,GAAAgmF,GAAApiF,EAAA,iBACAoC,EAAApC,EAAA,gBACA+L,EAAA/L,EAAA,qBACA4R,EAAA5R,EAAA,eACAmiF,EAAAniF,EAAA,sBACAkiF,EAAAE,EAAAF,iBACAG,EAAAD,EAAAC,oBACAC,EAAAF,EAAAE,eACAC,EAAA,IACAR,GACA,QACA,WACA,aACA,WACA,UACA,YACA,aAEAH,GACA,aACA,WACA,aAkCAE,GACA/C,UAAA,SAAA18E,GACAA,EAAAigF,EAAAlmF,KAAA8P,IAAA7J,GACAjG,KAAAmd,QAAA,YAAAlX,IAEAg9E,SAAA,SAAAh9E,GACAA,EAAAigF,EAAAlmF,KAAA8P,IAAA7J,EACA,IAAAmgF,GAAAngF,EAAAogF,WAAApgF,EAAAqgF,aACA,IAAAF,GAAApmF,KAAA8P,IACA,KAAAs2E,GAAA,GAAAA,EAAAl4D,UAAA,CAEA,GAAAk4D,IAAApmF,KAAA8P,IACA,MAEAs2E,KAAAG,WAGAvmF,KAAAmd,QAAA,WAAAlX,IAEAugF,WAAA,SAAAvgF,GAGAA,EAAAigF,EAAAlmF,KAAA8P,IAAA7J,GACAjG,KAAAwiF,iBAAA,GAAAn1E,MACAq3E,EAAA1kF,KAAAiG,EAAA,SAIAy/E,EAAA/C,UAAAvzE,KAAApP,KAAAiG,GACAy/E,EAAAe,UAAAr3E,KAAApP,KAAAiG,GACA8+E,EAAA/kF,OAEA0mF,UAAA,SAAAzgF,GACAA,EAAAigF,EAAAlmF,KAAA8P,IAAA7J,GACAy+E,EAAA1kF,KAAAiG,EAAA,UAIAy/E,EAAA/C,UAAAvzE,KAAApP,KAAAiG,GACA8+E,EAAA/kF,OAEA2mF,SAAA,SAAA1gF,GACAA,EAAAigF,EAAAlmF,KAAA8P,IAAA7J,GACAy+E,EAAA1kF,KAAAiG,EAAA,OACAy/E,EAAAkB,QAAAx3E,KAAApP,KAAAiG,IAGA,GAAAoH,MAAArN,KAAAwiF,iBAAA2D,GACAT,EAAAmB,MAAAz3E,KAAApP,KAAAiG,GAEA8+E,EAAA/kF,OAIAgG,GAAAkJ,MACA,QACA,YACA,UACA,aACA,YACA,SAAA7M,GACAqjF,EAAArjF,GAAA,SAAA4D,GACAA,EAAAigF,EAAAlmF,KAAA8P,IAAA7J,GACAjG,KAAAmd,QAAA9a,EAAA4D,KA6DA,IAAA6gF,GAAAlB,EAAA55E,SAYA,OAXA86E,GAAAtkF,QAAA,WAEA,OADA6/E,GAAAsD,EAAA/gF,OAAA4gF,GACA9gF,EAAA,EAAuBA,EAAA29E,EAAAh+E,OAAyBK,IAAA,CAChD,GAAArC,GAAAggF,EAAA39E,EACAuhF,GAAAjmF,KAAA8P,IAAA20E,EAAApiF,GAAArC,KAAAylF,UAAApjF,MAGAykF,EAAA/D,UAAA,SAAAvtC,GACAx1C,KAAA8P,IAAA7G,MAAAi8D,OAAA1vB,GAAA,WAEAxvC,EAAAsS,MAAAstE,EAAAj2E,GACAi2E,IAEA/hF,EAAA,oLAAAD,GACA,YAaA,SAAAmjF,GAAA95E,GACA,MAAA1M,UAAA0M,EAAA,IAEA,QAAA+5E,GAAA1D,GACA,QAAAA,MAGAA,EAAA2D,WAGA,kBAAA3D,GAAAhyE,QAAA,kBAAAgyE,GAAApuC,SAKA,QAAAgyC,GAAA5D,GACAA,EAAA6D,gBAEA,QAAAC,GAAA9D,GACA,GAAAA,EAAA6D,eACA7D,EAAAplE,QAKA,QAAAmpE,GAAArmF,EAAAuJ,EAAAX,GAOA,MANAgvD,GAAA91B,KAAA9hC,EAAAwI,mBACAxI,EAAA0+B,WACAk5B,EAAA96B,eAAA98B,EAAA0+B,WAEA4nD,EAAA/8E,QACA+8E,EAAA19E,UACAgvD,EAAArI,UAAA+2B,GAEA,QAAAC,GAAAvG,EAAAwG,GACA,GAAAxG,GAAAwG,EAEA,QAEA,KAAAxG,IAAAwG,GAAAxG,EAAA38E,SAAAmjF,EAAAnjF,OACA,QAEA,QAAAK,GAAA,EAAuBA,EAAAs8E,EAAA38E,OAAsBK,IAC7C,GAAAs8E,EAAAt8E,KAAA8iF,EAAA9iF,GACA,SAIA,QAAA+iF,GAAAzG,EAAAlrC,GACA,OAAApxC,GAAA,EAAuBA,EAAAs8E,EAAA38E,OAAsBK,IAAA,CAC7C,GAAAskB,GAAAg4D,EAAAt8E,GACA+4B,EAAAzU,EAAAyU,IACAzU,GAAA4sC,aAAA9f,GACArY,EAAA+4B,UAAA1gB,GACA9sB,EAAAkrC,UAAAz2B,EAAAzU,EAAA3d,OACAyqC,EAAA27B,OAEAzoD,EAAA0tC,iBAAA5gB,IAGA,QAAA4xC,GAAAn9E,EAAAX,GACA,GAAA+9E,GAAAn7D,SAAAC,cAAA,OACAm7D,EAAAD,EAAA1+E,KAMA,OAJA2+E,GAAA9jE,SAAA,WACA8jE,EAAAC,SAAA,SACAD,EAAAr9E,QAAA,KACAq9E,EAAAh+E,SAAA,KACA+9E,EAhFA,GAAA1yC,GAAArxC,EAAA,YACAmd,EAAAnd,EAAA,eACAwV,EAAAxV,EAAA,cACAu5B,EAAAv5B,EAAA,uBACA4N,EAAA5N,EAAA,kBACAkkF,EAAAlkF,EAAA,WACA+/E,EAAA//E,EAAA,qCAKAmkF,EAAA,EAwBAnvB,EAAA,GAAAz7B,GAAA,SACAmqD,EAAA,GAAAnqD,GAAA,SAqDA6qD,EAAA,SAAAxkF,EAAA4R,EAAApF,GAEA,GAAAi4E,IAAAzkF,EAAAkb,UAAA,WAAAlb,EAAAkb,SAAAC,aACA3O,SAIAhQ,KAAAwa,IAAAxK,EAAAS,kBAAAwkC,EAAAxkC,iBAKAzQ,KAAAkoF,cAAAD,EAKAjoF,KAAAwD,MACA,IAAA2kF,GAAA3kF,EAAAyF,KACAk/E,KACAA,EAAA,6CACAA,EAAA,uBAAAA,EAAA,eAAAA,EAAA,gCACA3kF,EAAA4kF,UAAA,IAKApoF,KAAAoV,SAKA,IAAAizE,GAAAroF,KAAAsoF,eAKAC,EAAAvoF,KAAAwoF,UAMA,IADAxoF,KAAAyoF,gBACAR,EAKS,CAET,GAAA19E,GAAA/G,EAAA+G,MACAX,EAAApG,EAAAoG,MACA5J,MAAA0oF,OAAAn+E,EACAvK,KAAA2oF,QAAA/+E,CAGA,IAAAg/E,GAAA,GAAAd,GAAAtkF,EAAAxD,KAAA,EACA4oF,GAAAC,cAGAN,EAAA,GAAAK,EACAP,EAAA7mF,KAAA,OAlBA,CACAxB,KAAA0oF,OAAA1oF,KAAA8oF,YACA9oF,KAAA2oF,QAAA3oF,KAAA+oF,YACA,IAAApB,GAAA3nF,KAAAgpF,SAAAtB,EAAA1nF,KAAA0oF,OAAA1oF,KAAA2oF,QACAnlF,GAAAylF,YAAAtB,GAgBA3nF,KAAAs1C,YAAAt1C,KAAAkpF,qBAEAlpF,KAAAmpF,sBAKAnpF,KAAAopF,YACAppF,KAAAqpF,kBAolBA,OAllBArB,GAAAh8E,WACAkhB,YAAA86D,EACA7sE,eAAA,WACA,MAAAnb,MAAAkoF,eAEAj0C,gBAAA,WACA,MAAAj0C,MAAAkoF,cAAAloF,KAAAwoF,QAAA,GAAA14E,IAAA9P,KAAAgpF,UAEA9zC,QAAA,SAAAo0C,GACA,GAAA9vE,GAAAxZ,KAAAoV,QAAAqE,gBAAA,GACA4uE,EAAAroF,KAAAsoF,WACAtoF,MAAAupF,WAAA/vE,EAAA8vE,EAEA,QAAA5kF,GAAA,EAA2BA,EAAA2jF,EAAAhkF,OAAuBK,IAAA,CAClD,GAAA0C,GAAAihF,EAAA3jF,GACA4+E,EAAAtjF,KAAAwoF,QAAAphF,IACAk8E,EAAA2D,WAAA3D,EAAApuC,SACAouC,EAAApuC,UAOA,MAJAl1C,MAAAm1C,eACAn1C,KAAAmpF,mBAAA9kF,QACArE,KAAAwpF,mBAEAxpF,MAEAm7B,SAAA,SAAAn6B,EAAAolB,GACA,IAAAplB,EAAAyoF,WAAA,CAGA,GAAAC,GAAA,GAAA1oF,GAAAksB,aACAjkB,MAAAjI,EAAAiI,MACAoC,MAAArK,EAAAqK,OAEAq+E,GAAAC,OAAA3oF,EACAA,EAAAyoF,WAAAC,EACAA,EAAA1+E,SAAAob,GACApmB,KAAAqpF,eAAA7nF,KAAAkoF,KAEApuD,YAAA,SAAAt6B,GACA,GAAA0oF,GAAA1oF,EAAAyoF,WACAG,EAAA5pF,KAAAqpF,eACA36E,EAAAqS,EAAA/c,QAAA4lF,EAAAF,EACAh7E,IAAA,GACAk7E,EAAAx1E,OAAA1F,EAAA,GAEA1N,EAAAyoF,WAAA,MAEAr0C,WAAA,SAAAp0C,GAEA,OADA4oF,GAAA5pF,KAAAqpF,eACA3kF,EAAA,EAA2BA,EAAAklF,EAAAvlF,OAA0BK,IAAA,CACrD,GAAAse,GAAA4mE,EAAAllF,GAAAilF,MACA3mE,KACAA,EAAAymE,WAAA,MAGAG,EAAAvlF,OAAA,GAEA8wC,aAAA,WACA,GAAAy0C,GAAA5pF,KAAAqpF,eACAv9D,EAAA89D,EAAAvlF,OACAwlF,EAAA7pF,KAAAopF,WAEA,IADAS,KAAA3rE,QACA4N,EAAA,CAGAta,EAAAo4E,EAAA5pF,KAAAoV,QAAA+rE,qBAGA0I,IACAA,EAAA7pF,KAAAopF,YAAAppF,KAAA8pF,SAAA,KAEA,IAAAz4C,KACAw4C,GAAA/zC,IAAAuzB,MACA,QAAA3kE,GAAA,EAA2BA,EAAAonB,GAAS,CACpC,GAAA9qB,GAAA4oF,EAAAllF,GACAqlF,EAAA/oF,EAAA2oF,MAGAI,MAAA7uD,MAMAx2B,IAGAqlF,EAAAjxB,YACA93D,EAAA0+B,UAAAqqD,EAAArqD,UACA1+B,EAAAmqE,aAAA4e,EAAA5e,aACAnqE,EAAA6jE,YAAAklB,EAAAllB,YAEA7kE,KAAAgqF,WAAAhpF,EAAA6oF,GAAA,EAAAx4C,MAbAu4C,EAAAx1E,OAAA1P,EAAA,GACAqlF,EAAAN,WAAA,KACA39D,KAcA+9D,EAAA/zC,IAAA0zB,YAEAggB,iBAAA,WAUA,QAAAp4D,KAEA64D,IAAAtpF,EAAAupF,mBAAAvpF,EAAAyU,UACAzU,EAAAwpF,aAAAxpF,EAAAyU,QAAAqE,kBACA9Y,EAAAypF,qBACAzpF,EAAA0pF,YACA1G,EAAAvyD,IAEAzwB,EAAAupF,sBAjBA,GAAAvpF,GAAAX,IACA,IAAAW,EAAAypF,oBAAA,CAKA,GAAAH,GAAAtpF,EAAAupF,mBAAA,GAAA78E,KACA1M,GAAA0pF,YACA1G,EAAAvyD,KAcAk5D,kBAAA,WACAtqF,KAAAkqF,qBACAlqF,KAAAqqF,UAAA,EACAtpE,EAAA7R,KAAAlP,KAAAmpF,mBAAA,SAAA7F,GACAA,EAAA3uB,SAAA2uB,EAAAplE,WAGAqrE,WAAA,SAAA/vE,EAAA8vE,GACA,MAAAA,IACAA,GAAA,GAEAtpF,KAAAuqF,mBAAA/wE,GACAxZ,KAAAsqF,oBACAtqF,KAAAwqF,iBAAAtD,GACAlnF,KAAAmqF,aAAA3wE,EAAA8vE,GACAtpF,KAAAwqF,iBAAApD,IAEA+C,aAAA,SAAA3wE,EAAA8vE,GAYA,QAAAmB,GAAAnH,GACA,GAAA9oE,GAAAs7B,EAAAt7B,KAAA,CACAs7B,GAAAuzB,OACAvzB,EAAAgzB,YAAA,EACAhzB,EAAAmyB,WAAA,EAEAyiB,EAAA/1B,SAAA,EACA7e,EAAA8f,aAAA,aACA9f,EAAAokB,UAAAopB,EAAAxzE,IAAA,IAAAvF,EAAAiQ,EAAA5Q,EAAA4Q,GACAs7B,EAAA0zB,UAEA,OAtBAkhB,GACAC,EACA70C,EAEAzE,EAEAu5C,EAGAC,EAJAC,EAAA,EAEAvgF,EAAAvK,KAAA0oF,OACA9+E,EAAA5J,KAAA2oF,QAEAnX,EAAAxxE,KAAAqqF,UAYA3lF,EAAA,EAAAe,EAAA+T,EAAAnV,OAA4CK,EAAAe,EAAOf,IAAA,CACnD,GAAA1D,GAAAwY,EAAA9U,GACAqmF,EAAA/qF,KAAAkoF,cAAA,EAAAlnF,EAAAmG,OACA6jF,EAAAhqF,EAAAiqF,OA4BA,IAzBAD,EAAA,GAAAJ,IACAH,EAAAG,GACAA,EAAA,MAGAD,IAAAI,IACAj1C,GACAA,EAAA0zB,UAGAn4B,KAEAs5C,EAAAI,EACAL,EAAA1qF,KAAA8pF,SAAAa,GACAD,EAAAzD,WACA7tE,EAAA,UAAAuxE,EAAA,kCAAAD,EAAAvqF,IAEA21C,EAAA40C,EAAA50C,IACAA,EAAAuzB,OAEAqhB,EAAAvD,cAAA,GACAuD,EAAA/1B,SAAA20B,IACAoB,EAAAxsE,SAGAwsE,EAAA/1B,SAAA20B,EAAA,CAGA,GAAA0B,GAAA,GAEA,IAAAJ,EAAA,CAIA,GAHAA,EAAA5qF,KAAAmpF,mBAAA1nF,KAAAiE,IAAAolF,IAAA/C,EAAA,IACA6C,EAAA90C,IAAAuzB,OACAuhB,EAAAM,eACAN,KAAAO,WAAAP,EAAAQ,cAAA,CAIA1mF,EAAAkmF,EAAAS,iBAAA,CAEA,UAEAR,EAAAD,EAAAO,WACAP,EAAAj2B,UAEA6c,EAAAqZ,GAEAD,EAAAO,WAAA3Z,EAAA,EAEAwZ,IAAAxZ,GACAxxE,KAAAgqF,WAAAhpF,EAAA4pF,GAAA,EAAAA,EAAAM,iBAGAlrF,MAAAgqF,WAAAhpF,EAAA0pF,EAAApB,EAAAj4C,EAEArwC,GAAA2zD,SAAA,GAEAi2B,GACAH,EAAAG,GAGA90C,KAAA0zB,UAKAxpE,KAAAoqF,qBAAA,EACArpE,EAAA7R,KAAAlP,KAAAmpF,mBAAA,SAAA7F,GACAA,EAAA8H,eAAA9H,EAAA6H,aACAnrF,KAAAoqF,qBAAA,IAEapqF,OAEbgqF,WAAA,SAAAhpF,EAAA0pF,EAAAY,EAAAj6C,GACA,GAAAyE,GAAA40C,EAAA50C,IACA9X,EAAAh9B,EAAA0+B,SACA,KAAAgrD,EAAA/1B,SAAA22B,KAAAtqF,EAAA83D,WAAA,IAAA93D,EAAAiI,MAAAgc,WAAA+Y,KAAA,IAAAA,EAAA,OAAAh9B,EAAAikE,UAAAoiB,EAAArmF,EAAAhB,KAAA0oF,OAAA1oF,KAAA2oF,UAAA,CACA,GAAA3H,GAAAhgF,EAAA6jE,aAEAxzB,EAAAk6C,gBAAAb,GAAAnD,EAAAvG,EAAA3vC,EAAAm6C,oBAEAn6C,EAAAm6C,kBACAn6C,EAAAk6C,cAAAz1C,IAAA0zB,UACAn4B,EAAAk6C,cAAAl6C,EAAAm6C,gBAAA,KAEAn6C,EAAAgkB,OAAA,MAGA2rB,IACAlrC,EAAAuzB,OACAoe,EAAAzG,EAAAlrC,GACAzE,EAAAk6C,cAAAb,EACAr5C,EAAAm6C,gBAAAxK,IAGAhgF,EAAAg7D,aAAAh7D,EAAAg7D,YAAAlmB,GACA90C,EAAAo0D,MAAAtf,EAAAzE,EAAAgkB,QAAA,MACAhkB,EAAAgkB,OAAAr0D,EACAA,EAAAi7D,YAAAj7D,EAAAi7D,WAAAnmB,KAGAg0C,SAAA,SAAA3iF,GACA,GAAAnH,KAAAkoF,cACA,MAAAloF,MAAAwoF,QAAA,EAEA,IAAAlF,GAAAtjF,KAAAwoF,QAAArhF,EAaA,OAZAm8E,KAEAA,EAAA,GAAAwE,GAAA,MAAA3gF,EAAAnH,UAAAwa,KACA8oE,EAAA2D,WAAA,EACAjnF,KAAAyoF,aAAAthF,IACA4Z,EAAAkL,MAAAq3D,EAAAtjF,KAAAyoF,aAAAthF,IAAA,GAEAnH,KAAAyrF,YAAAtkF,EAAAm8E,GAGAA,EAAAuF,eAEAvF,GAEAmI,YAAA,SAAAtkF,EAAAm8E,GACA,GAAAoI,GAAA1rF,KAAAwoF,QACAH,EAAAroF,KAAAsoF,YACAx8D,EAAAu8D,EAAAhkF,OACAsnF,EAAA,KACAjnF,KACAijF,EAAA3nF,KAAAgpF,QACA,IAAA0C,EAAAvkF,GAEA,WADAiS,GAAA,UAAAjS,EAAA,yBAIA,KAAA6/E,EAAA1D,GAEA,WADAlqE,GAAA,mBAAAjS,EAAA,gBAGA,IAAA2kB,EAAA,GAAA3kB,EAAAkhF,EAAA,IACA,IAAA3jF,EAAA,EAA2BA,EAAAonB,EAAA,KAC3Bu8D,EAAA3jF,GAAAyC,GAAAkhF,EAAA3jF,EAAA,GAAAyC,GADwCzC,KAKxCinF,EAAAD,EAAArD,EAAA3jF,IAGA,GADA2jF,EAAAj0E,OAAA1P,EAAA,IAAAyC,GACAwkF,EAAA,CACA,GAAAC,GAAAD,EAAA77E,GACA87E,GAAApzB,YACAmvB,EAAAkE,aAAAvI,EAAAxzE,IAAA87E,EAAApzB,aAEAmvB,EAAAsB,YAAA3F,EAAAxzE,SAGA63E,GAAAmE,WACAnE,EAAAkE,aAAAvI,EAAAxzE,IAAA63E,EAAAmE,YAEAnE,EAAAsB,YAAA3F,EAAAxzE,IAGA47E,GAAAvkF,GAAAm8E,GAEAyI,UAAA,SAAAhjE,EAAAtZ,GACA,GACArI,GACA1C,EAFA2jF,EAAAroF,KAAAsoF,WAGA,KAAA5jF,EAAA,EAAuBA,EAAA2jF,EAAAhkF,OAAuBK,IAC9C0C,EAAAihF,EAAA3jF,GACAqkB,EAAA3Z,KAAAK,EAAAzP,KAAAwoF,QAAAphF,OAGAojF,iBAAA,SAAAzhE,EAAAtZ,GACA,GACA6zE,GACAl8E,EACA1C,EAHA2jF,EAAAroF,KAAAsoF,WAIA,KAAA5jF,EAAA,EAAuBA,EAAA2jF,EAAAhkF,OAAuBK,IAC9C0C,EAAAihF,EAAA3jF,GACA4+E,EAAAtjF,KAAAwoF,QAAAphF,GACAk8E,EAAA2D,WACAl+D,EAAA3Z,KAAAK,EAAA6zE,EAAAl8E,IAIAi8E,eAAA,SAAAt6D,EAAAtZ,GACA,GACA6zE,GACAl8E,EACA1C,EAHA2jF,EAAAroF,KAAAsoF,WAIA,KAAA5jF,EAAA,EAAuBA,EAAA2jF,EAAAhkF,OAAuBK,IAC9C0C,EAAAihF,EAAA3jF,GACA4+E,EAAAtjF,KAAAwoF,QAAAphF,GACAk8E,EAAA2D,WACAl+D,EAAA3Z,KAAAK,EAAA6zE,EAAAl8E,IAIA4kF,UAAA,WACA,MAAAhsF,MAAAwoF,SAEA+B,mBAAA,SAAA/wE,GACA,GAAA+uE,GAAAvoF,KAAAwoF,QACAyD,EAAAjsF,KAAAmpF,mBACA+C,KACAC,IACAnsF,MAAAwqF,iBAAA,SAAAlH,EAAAl8E,GACA8kF,EAAA9kF,GAAAk8E,EAAAjuE,QACAiuE,EAAAjuE,QAAA,EACAiuE,EAAA3uB,SAAA,IAEA5zC,EAAA7R,KAAA+8E,EAAA,SAAA3I,EAAA50E,GACAy9E,EAAAz9E,GAAA40E,EAAAjuE,QACAiuE,EAAAjuE,QAAA,EACAiuE,EAAA3uB,SAAA,GAMA,QAHAi2B,GACAwB,EAFAC,EAAA,EAGAC,EAAA,EACA5nF,EAAA,EAAAe,EAAA+T,EAAAnV,OAA4CK,EAAAe,EAAOf,IAAA,CACnD,GAAA1D,GAAAwY,EAAA9U,GACAyC,EAAAnH,KAAAkoF,cAAA,EAAAlnF,EAAAmG,OACAm8E,EAAAiF,EAAAphF,GACAolF,EAAAvrF,EAAA8U,WAMA,IALAwtE,IACAA,EAAAjuE,UACAiuE,EAAA3uB,QAAA2uB,EAAA3uB,SAAA3zD,EAAA2zD,SAGA43B,GAAA,GAEAH,IAAAG,IACAH,EAAAG,EACAD,IAEA,IAAAtB,GAAAhqF,EAAAiqF,QAAAqB,EAAA,CACA,KAAA1B,EAAA,CACA,GAAAl8E,GAAAjN,KAAAiE,IAAA2mF,EAAAtE,EAAA,EACA6C,GAAAqB,EAAAv9E,GACAk8E,IACAA,EAAAqB,EAAAv9E,GAAA,GAAAo5E,GAAA,cAAA9nF,UAAAwa,KACAowE,EAAA/B,eAEA+B,EAAAQ,cAAA,EAEAR,EAAAj2B,QAAAi2B,EAAAj2B,SAAA3zD,EAAA2zD,QACAi2B,EAAAv1E,UACAu1E,EAAAQ,cAAA3pF,KAAA2Y,IAAAwwE,EAAAQ,cAAAJ,GACAJ,EAAAQ,eAAAR,EAAAO,aAEA7H,EAAA3uB,SAAA,OAGA3zD,GAAAiqF,WACAL,IACAA,EAAAS,iBAAA3mF,EACA2nF,IACAzB,EAAA,MAIAA,IACAyB,IACAzB,EAAAS,iBAAA3mF,GAGA1E,KAAAwqF,iBAAA,SAAAlH,EAAAl8E,GACA8kF,EAAA9kF,KAAAk8E,EAAAjuE,UACAiuE,EAAA3uB,SAAA,KAGAs3B,EAAA5nF,OAAA5C,KAAAiE,IAAA2mF,EAAAtE,GACAhnE,EAAA7R,KAAA+8E,EAAA,SAAA3I,EAAA50E,GACAy9E,EAAAz9E,KAAA40E,EAAAjuE,UACArU,EAAA2zD,SAAA,GAEA2uB,EAAA3uB,UACA2uB,EAAA6H,WAAA,MAIAjtE,MAAA,WAEA,MADAle,MAAAwqF,iBAAAxqF,KAAAwsF,aACAxsF,MAEAwsF,YAAA,SAAAlJ,GACAA,EAAAplE,SAEA9C,YAAA,SAAAjU,EAAA8tC,GACA,GAAAA,EAAA,CACA,GAAAw3C,GAAAzsF,KAAAyoF,YACAgE,GAAAtlF,GAGA4Z,EAAAkL,MAAAwgE,EAAAtlF,GAAA8tC,GAAA,GAFAw3C,EAAAtlF,GAAA8tC,CAIA,IAAAquC,GAAAtjF,KAAAwoF,QAAArhF,EACAm8E,IACAviE,EAAAkL,MAAAq3D,EAAAmJ,EAAAtlF,IAAA,KAIAulF,SAAA,SAAAvlF,GACA,GAAAohF,GAAAvoF,KAAAwoF,QACAH,EAAAroF,KAAAsoF,YACAhF,EAAAiF,EAAAphF,EACAm8E,KAGAA,EAAAxzE,IAAAy2E,WAAAoG,YAAArJ,EAAAxzE,WACAy4E,GAAAphF,GACAkhF,EAAAj0E,OAAA2M,EAAA/c,QAAAqkF,EAAAlhF,GAAA,KAEAmK,OAAA,SAAA/G,EAAAX,GACA,GAAA+9E,GAAA3nF,KAAAgpF,QAOA,IALArB,EAAA1+E,MAAA2jF,QAAA,OACAriF,KAAAvK,KAAA8oF,YACAl/E,KAAA5J,KAAA+oF,aACApB,EAAA1+E,MAAA2jF,QAAA,GAEA5sF,KAAA0oF,QAAAn+E,GAAAX,GAAA5J,KAAA2oF,QAAA,CACAhB,EAAA1+E,MAAAsB,QAAA,KACAo9E,EAAA1+E,MAAAW,SAAA,IACA,QAAAzJ,KAAAH,MAAAwoF,QACAxoF,KAAAwoF,QAAAroF,GAAAmR,OAAA/G,EAAAX,EAEA5J,MAAAk1C,SAAA,GAIA,MAFAl1C,MAAA0oF,OAAAn+E,EACAvK,KAAA2oF,QAAA/+E,EACA5J,MAEA6sF,WAAA,SAAA1lF,GACA,GAAAm8E,GAAAtjF,KAAAwoF,QAAArhF,EACAm8E,IACAA,EAAAplE,SAGA1b,QAAA,WACAxC,KAAAwD,KAAA4kF,UAAA,GACApoF,KAAAwD,KAAAxD,KAAAoV,QAAApV,KAAAgpF,SAAAhpF,KAAAwoF,QAAA,MAEAlvE,kBAAA,SAAAtJ,GAEA,GADAA,QACAhQ,KAAAkoF,cACA,MAAAloF,MAAAwoF,QAAA,GAAA14E,GAEA,IAAAg9E,GAAA,GAAAhF,GAAA,QAAA9nF,KAAAgQ,EAAAuJ,YAAAvZ,KAAAwa,IACAsyE,GAAAjE,cACAiE,EAAAzxE,WAAArL,EAAAtI,gBACAolF,EAAA5uE,OAGA,QAFA4iE,GAAA9gF,KAAAoV,QAAAqE,gBAAA,GACA43B,KACA3sC,EAAA,EAA2BA,EAAAo8E,EAAAz8E,OAAwBK,IAAA,CACnD,GAAA1D,GAAA8/E,EAAAp8E,EACA1E,MAAAgqF,WAAAhpF,EAAA8rF,GAAA,EAAAz7C,GAEA,MAAAy7C,GAAAh9E,KAEApF,SAAA,WACA,MAAA1K,MAAA0oF,QAEA/9E,UAAA,WACA,MAAA3K,MAAA2oF,SAEAG,UAAA,WACA,GAAAtlF,GAAAxD,KAAAwD,KACAupF,EAAAvgE,SAAAwgE,YAAAC,iBAAAzpF,EAEA,QAAAA,EAAAob,aAAAmoE,EAAAgG,EAAAxiF,QAAAw8E,EAAAvjF,EAAAyF,MAAAsB,SAAAw8E,EAAAgG,EAAAG,cAAA,IAAAnG,EAAAgG,EAAAI,eAAA,MAEApE,WAAA,WACA,GAAAvlF,GAAAxD,KAAAwD,KACAupF,EAAAvgE,SAAAwgE,YAAAC,iBAAAzpF,EACA,QAAAA,EAAAqb,cAAAkoE,EAAAgG,EAAAnjF,SAAAm9E,EAAAvjF,EAAAyF,MAAAW,UAAAm9E,EAAAgG,EAAAK,aAAA,IAAArG,EAAAgG,EAAAM,gBAAA,MAEAC,aAAA,SAAAntF,EAAAs9B,EAAAlzB,EAAAX,EAAA4Q,GACA,GAAAC,GAAA+R,SAAAC,cAAA,UACAqpB,EAAAr7B,EAAAiS,WAAA,KACAjS,GAAAlQ,QAAAiQ,EACAC,EAAA7Q,SAAA4Q,EACAs7B,EAAAy3C,UAAA,IAAAhjF,EAAAiQ,EAAA5Q,EAAA4Q,EACA,IAAAgzE,IACA1pE,SAAA2Z,EAAA3Z,SACAiD,SAAA0W,EAAA1W,SACA7E,MAAAub,EAAAvb,MAEAub,GAAA3Z,UACA,EACA,EACA,GAEA2Z,EAAA1W,SAAA,EACA0W,EAAAvb,OACA,EACA,GAEAub,GACAA,EAAA23B,MAAAtf,EAEA,IAAA23C,GAAA7pF,EAAA,mBACA8pF,EAAA,GAAAD,IACAttF,KACA8I,OACA2B,EAAA,EACAjB,EAAA,EACAqR,MAAAP,IAYA,OATA,OAAA+yE,EAAA1pE,WACA4pE,EAAA5pE,SAAA2Z,EAAA3Z,SAAA0pE,EAAA1pE,UAEA,MAAA0pE,EAAAzmE,WACA2mE,EAAA3mE,SAAA0W,EAAA1W,SAAAymE,EAAAzmE,UAEA,MAAAymE,EAAAtrE,QACAwrE,EAAAxrE,MAAAub,EAAAvb,MAAAsrE,EAAAtrE,OAEAwrE,GAEAxE,mBAAA,WACA,GAAAyE,GAAA3tF,IACA,iBAAAG,EAAAqd,EAAAjT,EAAAX,GACA,MAAA+jF,GAAAL,aAAAntF,EAAAqd,EAAAjT,EAAAX,EAAA+jF,EAAAnzE,QAIAwtE,IAEAnkF,EAAA,+CAAAD,GACA,QAAAw+E,KACApiF,KAAAgK,GAAA,YAAAhK,KAAA4tF,WAAA5tF,MACAA,KAAAgK,GAAA,YAAAhK,KAAA6tF,MAAA7tF,MACAA,KAAAgK,GAAA,UAAAhK,KAAA8tF,SAAA9tF,MACAA,KAAAgK,GAAA,YAAAhK,KAAA8tF,SAAA9tF,MAsDA,MAjDAoiF,GAAAp2E,WACAkhB,YAAAk1D,EACAwL,WAAA,SAAApwE,GACA,GAAAuwE,GAAAvwE,EAAAlW,MACAymF,MAAAhpB,YACA/kE,KAAAguF,gBAAAD,EACAA,EAAA/oB,UAAA,EACAhlE,KAAA+mE,GAAAvpD,EAAA+jE,QACAvhF,KAAAiuF,GAAAzwE,EAAAikE,QACAzhF,KAAAgjF,kBAAA+K,EAAA,YAAAvwE,EAAAvX,SAGA4nF,MAAA,SAAArwE,GACA,GAAAuwE,GAAA/tF,KAAAguF,eACA,IAAAD,EAAA,CACA,GAAAnjF,GAAA4S,EAAA+jE,QACA53E,EAAA6T,EAAAikE,QACAh+D,EAAA7Y,EAAA5K,KAAA+mE,GACApjD,EAAAha,EAAA3J,KAAAiuF,EACAjuF,MAAA+mE,GAAAn8D,EACA5K,KAAAiuF,GAAAtkF,EACAokF,EAAApkB,MAAAlmD,EAAAE,EAAAnG,GACAxd,KAAAgjF,kBAAA+K,EAAA,OAAAvwE,EAAAvX,MACA,IAAAioF,GAAAluF,KAAA6iF,UAAAj4E,EAAAjB,EAAAokF,GACAI,EAAAnuF,KAAAouF,WACApuF,MAAAouF,YAAAF,EACAH,IAAAG,IACAC,GAAAD,IAAAC,GACAnuF,KAAAgjF,kBAAAmL,EAAA,YAAA3wE,EAAAvX,OAEAioF,OAAAC,GACAnuF,KAAAgjF,kBAAAkL,EAAA,YAAA1wE,EAAAvX,UAKA6nF,SAAA,SAAAtwE,GACA,GAAAuwE,GAAA/tF,KAAAguF,eACAD,KACAA,EAAA/oB,UAAA,GAEAhlE,KAAAgjF,kBAAA+K,EAAA,UAAAvwE,EAAAvX,OACAjG,KAAAouF,aACApuF,KAAAgjF,kBAAAhjF,KAAAouF,YAAA,OAAA5wE,EAAAvX,OAEAjG,KAAAguF,gBAAA,KACAhuF,KAAAouF,YAAA,OAGAhM,IAEAv+E,EAAA,8DAAAD,GACA,YAGA,SAAA+W,GAAA3Z,GAEA,MAAAA,GAAA2Z,sBAAA3Z,EAAA2Z,yBACAlT,KAAA,EACA7F,IAAA,GAGA,QAAAysF,GAAArtF,EAAAwc,EAAAg7B,GAEA,GAAAjX,GAAA5mB,EAAA3Z,EAIA,OAHAw3C,SACAA,EAAAgpC,IAAAhkE,EAAA8wE,QAAA/sD,EAAA95B,KACA+wC,EAAAkpC,IAAAlkE,EAAA+wE,QAAAhtD,EAAA3/B,IACA42C,EAKA,QAAA0tC,GAAAllF,EAAAwc,GAEA,GADAA,KAAAvT,OAAAhE,MACA,MAAAuX,EAAAgkE,IACA,MAAAhkE,EAEA,IAAAzG,GAAAyG,EAAAlc,KACAktF,EAAAz3E,KAAA/S,QAAA,WACA,IAAAwqF,EAGS,CACT,GAAAC,GAAA,YAAA13E,EAAAyG,EAAAkxE,cAAA,GAAAlxE,EAAAmxE,eAAA,EACAF,IAAAJ,EAAArtF,EAAAytF,EAAAjxE,OAJA6wE,GAAArtF,EAAAwc,KACAA,EAAAwkE,QAAAxkE,EAAAukE,WAAAvkE,EAAAukE,WAAA,MAAAvkE,EAAAoxE,QAAA,IAKA,OAAApxE,GAEA,QAAAsoE,GAAA9kF,EAAAqB,EAAAmN,GACAq/E,EACA7tF,EAAA8kF,iBAAAzjF,EAAAmN,GAEAxO,EAAA8tF,YAAA,KAAAzsF,EAAAmN,GAGA,QAAAy2E,GAAAjlF,EAAAqB,EAAAmN,GACAq/E,EACA7tF,EAAAilF,oBAAA5jF,EAAAmN,GAEAxO,EAAA+tF,YAAA,KAAA1sF,EAAAmN,GA/CA,GAAAG,GAAA/L,EAAA,qBACAirF,EAAA,mBAAA5kF,kBAAA67E,iBAuDApwC,EAAAm5C,EAAA,SAAArxE,GACAA,EAAAwxE,iBACAxxE,EAAAyxE,kBACAzxE,EAAA8jE,cAAA,GACS,SAAA9jE,GACTA,EAAA0xE,aAAA,EACA1xE,EAAA8jE,cAAA,EAEA,QACA+M,gBACAnI,iBACAJ,mBACAG,sBACAvwC,OACAguC,WAAA/zE,KAGA9L,EAAA,+DAAAD,GACA,yBAAAqG,iBAAA05E,uBAAA15E,OAAAklF,yBAAAllF,OAAAmlF,0BAAAnlF,OAAAolF,8BAAA,SAAA96E,GACA4wE,WAAA5wE,EAAA,OAGA1Q,EAAA,yDAAAD,GACA,YAoDA,SAAA6oD,GAAA6iC,GACA,GAAA7rE,GAAA6rE,EAAA,MAAAA,EAAA,MACA3rE,EAAA2rE,EAAA,MAAAA,EAAA,KACA,OAAA7tF,MAAAktD,KAAAlrC,IAAAE,KAEA,QAAAqH,GAAAskE,GACA,QACAA,EAAA,MAAAA,EAAA,UACAA,EAAA,MAAAA,EAAA,UA3DA,GAAAC,GAAA3rF,EAAA,WACAmiF,EAAA,WAKA/lF,KAAAwvF,UAEAzJ,GAAA/5E,WACAkhB,YAAA64D,EACAjB,UAAA,SAAA7+E,EAAAqB,EAAA9D,GAEA,MADAxD,MAAAyvF,SAAAxpF,EAAAqB,EAAA9D,GACAxD,KAAA0vF,WAAAzpF,IAEAiY,MAAA,WAEA,MADAle,MAAAwvF,OAAAnrF,OAAA,EACArE,MAEAyvF,SAAA,SAAAxpF,EAAAqB,EAAA9D,GACA,GAAAmsF,GAAA1pF,EAAA0pF,OACA,IAAAA,EAAA,CASA,OANAC,IACAjpE,UACAgpE,WACAroF,SACArB,SAEAvB,EAAA,EAAAonB,EAAA6jE,EAAAtrF,OAAiDK,EAAAonB,EAASpnB,IAAA,CAC1D,GAAA+pF,GAAAkB,EAAAjrF,GACA06E,EAAAmQ,EAAAlB,cAAA7qF,EAAAirF,EACAmB,GAAAjpE,OAAAnlB,MACA49E,EAAAoC,IACApC,EAAAsC,MAEAkO,EAAAD,QAAAnuF,KAAAitF,GAEAzuF,KAAAwvF,OAAAhuF,KAAAouF,KAEAF,WAAA,SAAAzpF,GACA,OAAAsJ,KAAAsgF,GACA,GAAAA,EAAA7jE,eAAAzc,GAAA,CACA,GAAAs1E,GAAAgL,EAAAtgF,GAAAvP,KAAAwvF,OAAAvpF,EACA,IAAA4+E,EACA,MAAAA,KAiBA,IAAAgL,IACAC,MAAA,SAAAC,EAAA9pF,GACA,GAAAuqE,GAAAuf,EAAA1rF,MACA,IAAAmsE,EAAA,CAGA,GAAAwf,IAAAD,EAAAvf,EAAA,QAAyD7pD,OACzDspE,GAAAF,EAAAvf,EAAA,QAAyD7pD,QAAAqpE,CACzD,IAAAC,KAAA5rF,OAAA,GAAA2rF,KAAA3rF,OAAA,GACA,GAAAy9E,GAAAr1B,EAAAujC,GAAAvjC,EAAAwjC,IACAvoD,SAAAo6C,OAAA,GACA77E,EAAA67E,YACA,IAAAoO,GAAAllE,EAAAglE,EAGA,OAFA/pF,GAAA27E,OAAAsO,EAAA,GACAjqF,EAAA47E,OAAAqO,EAAA,IAEA5uF,KAAA,QACAgG,OAAAyoF,EAAA,GAAAzoF,OACArB,YAKA,OAAA8/E,KAEAliF,EAAA,oGAAAD,GAKA,QAAAusF,KACA,SAWA,QAAAC,GAAAjwF,EAAAmB,EAAAoY,EAAAc,GACA,GAAA61E,GAAA7jE,SAAAC,cAAAnrB,GACAiJ,EAAAmP,EAAAhP,WACAd,EAAA8P,EAAA/O,YACA2lF,EAAAD,EAAApnF,KAWA,OATAqnF,GAAAxsE,SAAA,WACAwsE,EAAA7oF,KAAA,EACA6oF,EAAA1uF,IAAA,EACA0uF,EAAA/lF,QAAA,KACA+lF,EAAA1mF,SAAA,KACAymF,EAAA9lF,QAAAiQ,EACA61E,EAAAzmF,SAAA4Q,EAEA61E,EAAAvxE,aAAA,iBAAA3e,GACAkwF,EA/BA,GAAAtvE,GAAAnd,EAAA,eACAqxC,EAAArxC,EAAA,YACAghE,EAAAhhE,EAAA,mBACAoxD,EAAApxD,EAAA,qBAsCAkkF,EAAA,SAAA3nF,EAAAuZ,EAAAc,GACA,GAAA1K,EACA0K,MAAAy6B,EAAAxkC,iBACA,gBAAAtQ,GACA2P,EAAAsgF,EAAAjwF,EAAA,SAAAuZ,EAAAc,GAEAuG,EAAA1E,SAAAlc,KACA2P,EAAA3P,EACAA,EAAA2P,EAAA3P,IAEAH,KAAAG,KACAH,KAAA8P,KACA,IAAAygF,GAAAzgF,EAAA7G,KACAsnF,KAEAzgF,EAAA0gF,cAAAL,EAEAI,EAAA,8BACAA,EAAA,sBACAA,EAAA,gCACAA,EAAA,gDAEAvwF,KAAAywF,QAAA,KACAzwF,KAAA0wF,QAAA,KACA1wF,KAAA0Z,UACA1Z,KAAAi1C,OAAA,KAOAj1C,KAAAqb,WAAA,EAMArb,KAAA2wF,YAAA,EAMA3wF,KAAA4wF,eAAA,GAKA5wF,KAAAwa,MAkFA,OAhFAstE,GAAA97E,WACAkhB,YAAA46D,EACAzyE,QAAA,EACAs/C,SAAA,EACAk0B,YAAA,WACA7oF,KAAA81C,IAAA91C,KAAA8P,IAAA4c,WAAA,MACA1sB,KAAA81C,IAAAt7B,IAAAxa,KAAAwa,KAEAq2E,iBAAA,WACA,GAAAr2E,GAAAxa,KAAAwa,GACAxa,MAAAywF,QAAAL,EAAA,QAAApwF,KAAAG,GAAA,SAAAH,KAAA0Z,QAAAc,GACAxa,KAAA0wF,QAAA1wF,KAAAywF,QAAA/jE,WAAA,MACA,GAAAlS,GACAxa,KAAA0wF,QAAAxuE,MAAA1H,MAGAlJ,OAAA,SAAA/G,EAAAX,GACA,GAAA4Q,GAAAxa,KAAAwa,IACA1K,EAAA9P,KAAA8P,IACAygF,EAAAzgF,EAAA7G,MACAwnF,EAAAzwF,KAAAywF,OACAF,GAAAhmF,QAAA,KACAgmF,EAAA3mF,SAAA,KACAkG,EAAAvF,QAAAiQ,EACA1K,EAAAlG,SAAA4Q,EACAi2E,IACAA,EAAAlmF,QAAAiQ,EACAi2E,EAAA7mF,SAAA4Q,EACA,GAAAA,GACAxa,KAAA0wF,QAAAxuE,MAAA1H,OAIA0D,MAAA,SAAA4yE,GACA,GAAAhhF,GAAA9P,KAAA8P,IACAgmC,EAAA91C,KAAA81C,IACAvrC,EAAAuF,EAAAvF,MACAX,EAAAkG,EAAAlG,OACAyR,EAAArb,KAAAqb,WACA01E,EAAA/wF,KAAA2wF,aAAAG,EACAF,EAAA5wF,KAAA4wF,eACAp2E,EAAAxa,KAAAwa,GASA,IARAu2E,IACA/wF,KAAAywF,SACAzwF,KAAA6wF,mBAEA7wF,KAAA0wF,QAAA3nB,yBAAA,OACA/oE,KAAA0wF,QAAAx2B,UAAApqD,EAAA,IAAAvF,EAAAiQ,EAAA5Q,EAAA4Q,IAEAs7B,EAAAy3C,UAAA,IAAAhjF,EAAAX,GACAyR,EAAA,CACA,GAAA21E,EAEA31E,GAAAG,YAEAw1E,EAAA31E,EAAA41E,kBAAArsB,EAAA9O,YAAAhgB,EAAAz6B,GACAzQ,EAAA,EACAjB,EAAA,EACAY,QACAX,WAEAyR,EAAA41E,iBAAAD,GAEA31E,EAAAL,QACAg2E,EAAAh8B,EAAAhpD,UAAAipD,iBAAA7lD,KAAAiM,EAAAy6B,IAEAA,EAAAuzB,OACAvzB,EAAAkgB,UAAAg7B,GAAA31E,EACAy6B,EAAAo7C,SAAA,IAAA3mF,EAAAX,GACAksC,EAAA0zB,UAEA,GAAAunB,EAAA,CACA,GAAAN,GAAAzwF,KAAAywF,OACA36C,GAAAuzB,OACAvzB,EAAAgzB,YAAA8nB,EACA96C,EAAAokB,UAAAu2B,EAAA,IAAAlmF,EAAAX,GACAksC,EAAA0zB,aAIAse,IAEAjkF,EAAA,mFAAAD,GAWA,QAAAutF,GAAA7uD,GACA,GAAA8uD,GAAA9uD,KAAAhX,SACA8lE,IACAprF,EAAAkJ,KAAAmiF,EAAA,SAAAxoB,GACA,GAAAyoB,GAAAF,EAAAzmE,OACA4mE,EAAAH,EAAAvmE,QACAymE,MAAAzoB,KACAvmC,EAAAumC,GAAAvmC,EAAAumC,OACAvmC,EAAAumC,GAAAl+C,OAGA3kB,EAAAimB,MAAAqW,EAAAumC,GAAAl+C,OAAA2mE,EAAAzoB,IAFAvmC,EAAAumC,GAAAl+C,OAAA2mE,EAAAzoB,GAIAyoB,EAAAzoB,GAAA,MAEA0oB,KAAA1oB,KACAvmC,EAAAumC,GAAAvmC,EAAAumC,OACAvmC,EAAAumC,GAAAh+C,SAGA7kB,EAAAimB,MAAAqW,EAAAumC,GAAAh+C,SAAA0mE,EAAA1oB,IAFAvmC,EAAAumC,GAAAh+C,SAAA0mE,EAAA1oB,GAIA0oB,EAAA1oB,GAAA,QAhCA,GAAA7iE,GAAApC,EAAA,qBACAytF,GACA,YACA,YACA,YACA,YACA,aACA,QACA,YA6BA,iBAAAtrC,GACA,GAAAA,EAAA,CAGAorC,EAAAprC,GACAorC,EAAAprC,EAAAyrC,WACAL,EAAAprC,EAAA0rC,SACA,IAAA5yF,GAAAknD,EAAAlnD,IACA,IAAAA,EAAA,CACA,OAAA6F,GAAA,EAA2BA,EAAA7F,EAAAwF,OAAiBK,IAC5CysF,EAAAtyF,EAAA6F,GAGA,IAAA8sF,GAAAzrC,EAAAyrC,SACA,IAAAA,KAAA3yF,KAEA,OADA6yF,GAAAF,EAAA3yF,KACA6F,EAAA,EAA+BA,EAAAgtF,EAAArtF,OAAmBK,IAClDysF,EAAAO,EAAAhtF,GAIA,IAAA+sF,GAAA1rC,EAAA0rC,QACA,IAAAA,KAAA5yF,KAEA,OADA8yF,GAAAF,EAAA5yF,KACA6F,EAAA,EAA+BA,EAAAitF,EAAAttF,OAAmBK,IAClDsB,EAAAgZ,QAAA2yE,EAAAjtF,KACAysF,EAAAQ,EAAAjtF,GAAA,IACAysF,EAAAQ,EAAAjtF,GAAA,KAEAysF,EAAAQ,EAAAjtF,SAOAb,EAAA,oFAAAD,GACA,GAAAoC,GAAApC,EAAA,oBACA,QACAgmB,kBAAA,SAAAgoE,GACA5xF,KAAA6xF,iBAAA7rF,EAAAsnB,OAAAskE,MAAA,SAAAE,EAAAxqF,GAEA,MADAwqF,GAAAxqF,EAAAjF,MAAAiF,EACAwqF,QAGAC,OAAA,SAAA1vF,GACA,GAAAyvF,GAAA9xF,KAAA6xF,iBACAvqF,EAAAwqF,EAAAzvF,GACA0lB,EAAA/nB,KAAA0I,IAAA,eACA,YAAAqf,GACA/hB,EAAAkJ,KAAA4iF,EAAA,SAAAxqF,GACAA,EAAAokB,UAAA,IAGApkB,MAAAokB,UAAA,IAEAsmE,SAAA,SAAA3vF,GACA,GAAAiF,GAAAtH,KAAA6xF,iBAAAxvF,EAGAiF,OAAAokB,UAAA,IAEAumE,eAAA,SAAA5vF,GACA,GAAAiF,GAAAtH,KAAA6xF,iBAAAxvF,EACA,UAAAiF,EAEA,MADAtH,MAAAsH,EAAAokB,SAAA,qBAAArpB,GACAiF,EAAAokB,UAGArI,WAAA,SAAAhhB,GACA,GAAAiF,GAAAtH,KAAA6xF,iBAAAxvF,EACA,OAAAiF,MAAAokB,aAIA7nB,EAAA,gIAAAD,GAoJA,QAAAsuF,GAAA3mF,EAAAulB,GA4BA,QAAAqhE,GAAA9/D,EAAAplB,GACA,GAAAmlF,GAAAzwF,EAAAqyB,QAAA3B,EACA,OAAA+/D,GAAAhgE,cAAAggE,EAAAt4D,YAAA,IA7BA,GAAAn4B,GAAA4J,EAAAC,iBACAylB,EAAAH,EAAAG,KACAnqB,KACAurF,EAAAphE,EAAAnN,SACA0Q,EAAAvD,EAAAwC,OAAA,SAAA4+D,EACAtf,EAAA9hD,EAAAoB,IAEAlnB,EAAAxJ,EAAA8J,UACA6mF,GACAnnF,EAAAP,EACAO,EAAAP,EAAAO,EAAAZ,MACAY,EAAAxB,EACAwB,EAAAxB,EAAAwB,EAAAvB,QAEA2oF,EAAAzhE,EAAApoB,IAAA,aACA8pF,GACA5nF,GACAhJ,IAAA0wF,EAAA,GAAAC,EACA1wF,OAAAywF,EAAA,GAAAC,GAEA5oF,GACAlC,KAAA6qF,EAAA,GAAAC,EACAj4E,MAAAg4E,EAAA,GAAAC,GAGAC,GAAA5nF,EAAA6oB,OAAAhyB,KAAA2Y,IAAA3Y,KAAAiE,IAAAysF,EAAA,KAAAK,EAAA5nF,EAAA/I,QAAA2wF,EAAA5nF,EAAAhJ,KACA4wF,EAAA7oF,EAAA8pB,OAAAhyB,KAAA2Y,IAAA3Y,KAAAiE,IAAAysF,EAAA,KAAAK,EAAA7oF,EAAA2Q,OAAAk4E,EAAA7oF,EAAAlC,MAMAX,EAAAgd,UACA,MAAAivD,EAAAyf,EAAA7oF,EAAA6qB,GAAA89D,EAAA,GACA,MAAAvf,EAAAyf,EAAA5nF,EAAA4pB,GAAA89D,EAAA,IAGAxrF,EAAAigB,SAAAtlB,KAAA0nB,GAAA,SAAA4pD,EAAA,IAEA,IAAA0f,IACA7wF,OACAC,OAAA,EACA4F,QACA6S,MAAA,EAEAxT,GAAA4rF,eAAA5rF,EAAA6rF,cAAA7rF,EAAA8rF,cAAAH,EAAAJ,GACAphE,EAAAwC,SACA3sB,EAAA+rF,YAAAL,EAAAzf,GAAAsf,GAAAG,EAAAzf,GAAAt/C,QAEA3C,EAAAloB,SAAA,YAAAF,IAAA,YACA5B,EAAA6rF,eAAA7rF,EAAA6rF,eAEA7hE,EAAAloB,SAAA,aAAAF,IAAA,YACA5B,EAAA4rF,gBAAA5rF,EAAA4rF,eAGA,IAAAI,GAAAhiE,EAAAloB,SAAA,aAAAF,IAAA,SAMA,OALA5B,GAAAgsF,cAAA,QAAAt+D,GAAAs+D,IAEAhsF,EAAAwqD,cAAArgC,EAAAogC,mBAEAvqD,EAAAwC,GAAA,EACAxC,EAlNA,GAAAd,GAAApC,EAAA,qBACAiD,EAAAjD,EAAA,sBACAmvF,EAAAnvF,EAAA,iBACAovF,EAAAD,EAAAC,eACA7rD,EAAA4rD,EAAA5rD,YACA8rD,GACA,WACA,YACA,WACA,YAEAC,GACA,YACA,aASAC,EAAAvvF,EAAA,iBAAAwE,qBACA9G,KAAA,OACA+G,OAAA,SAAAyoB,EAAAtqB,GACAxG,KAAAwI,MAAAC,WACA,IAAA2qF,GAAApzF,KAAAqzF,UAGA,IAFArzF,KAAAqzF,WAAA,GAAAxsF,GAAA0d,MACAvkB,KAAAwI,MAAA2B,IAAAnK,KAAAqzF,YACAviE,EAAApoB,IAAA,SAGA,GAAA6C,GAAAulB,EAAAC,gBACAjqB,EAAAorF,EAAA3mF,EAAAulB,GACAwiE,EAAA,GAAAP,GAAAjiE,EAAAhqB,EACAd,GAAAkJ,KAAA+jF,EAAAK,EAAAnpF,IAAAmpF,GACAtzF,KAAAqzF,WAAAlpF,IAAAmpF,EAAAC,YACAvtF,EAAAkJ,KAAAgkF,EAAA,SAAA7wF,GACAyuB,EAAApoB,IAAArG,EAAA,UACArC,KAAA,IAAAqC,GAAAyuB,EAAAvlB,EAAAzE,EAAAwqD,gBAEiBtxD,MACjB6G,EAAAm5B,gBAAAozD,EAAApzF,KAAAqzF,WAAAviE,KAEA0iE,WAAA,SAAA1iE,EAAAvlB,EAAA+lD,GACA,GAAArgC,GAAAH,EAAAG,KACAwiE,EAAA3iE,EAAAloB,SAAA,aACA8qF,EAAAD,EAAA7qF,SAAA,aACA+qF,EAAAD,EAAAhrF,IAAA,SACAkrF,EAAAzsD,EAAAssD,EAAAniC,EACAqiC,GAAA3tF,EAAAgZ,QAAA20E,QAWA,QAVA9/D,GAAAtoB,EAAAC,iBAAAC,UACAmoB,EAAA3C,EAAA2C,eACAigE,EAAA,EACAC,EAAA7iE,EAAA+8C,iBACA3mC,EAAApW,EAAA/O,MAAAD,WACAysD,KACAc,KAGAnkD,EAAAqoE,EAAArsE,eACA3iB,EAAA,EAA+BA,EAAAovF,EAAAzvF,OAAwBK,IACvD,IAAAsuF,EAAA/hE,EAAAvsB,EAAAkvF,GAAA,CAGA,GAAAtjC,GAAAr/B,EAAAmB,cAAA0hE,EAAApvF,GACAkvB,IACA86C,EAAA,GAAApe,EACAoe,EAAA,GAAA76C,EAAAlqB,EACA6lE,EAAA,GAAAlf,EACAkf,EAAA,GAAA37C,EAAAlqB,EAAAkqB,EAAAjqB,SAEA8kE,EAAA,GAAA76C,EAAAjpB,EACA8jE,EAAA,GAAApe,EACAkf,EAAA,GAAA37C,EAAAjpB,EAAAipB,EAAAtpB,MACAilE,EAAA,GAAAlf,EAEA,IAAAyjC,GAAAF,IAAAF,EAAAtvF,MACArE,MAAAqzF,WAAAlpF,IAAA,GAAAtD,GAAAg2B,KAAAh2B,EAAAq3B,sBACAoC,KAAA,QAAA+G,EAAA3iC,GACA2G,OACAgzB,GAAAqwC,EAAA,GACAnwC,GAAAmwC,EAAA,GACApwC,GAAAkxC,EAAA,GACAhxC,GAAAgxC,EAAA,IAEAvmE,MAAAjD,EAAA0F,UAAgD0b,OAAAusE,EAAAI,IAAiC1oE,GACjFthB,QAAA,QAIAiqF,WAAA,SAAAljE,EAAAvlB,EAAA+lD,GACA,GAAArgC,GAAAH,EAAAG,KACAgjE,EAAAnjE,EAAAloB,SAAA,aACAsrF,EAAAD,EAAArrF,SAAA,aACAurF,EAAAD,EAAAxrF,IAAA,SACAmrB,EAAAtoB,EAAAC,iBAAAC,UACAqoF,EAAA7iE,EAAA+8C,iBACA3mC,EAAApW,EAAA/O,MAAAD,WACAmyE,EAAAnjE,EAAAmB,cAAA0hE,EAAA,IACAO,EAAApjE,EAAAmB,cAAA0hE,EAAA,IACAtrE,EAAA,EACA8rE,EAAAntD,EAAA8sD,EAAA3iC,GACAgmB,EAAA4c,EAAA1sB,cACA2sB,GAAAnuF,EAAAgZ,QAAAm1E,QACA,QAAAzvF,GAAA,EAA+BA,EAAAovF,EAAAzvF,OAAwBK,IACvD,IAAAsuF,EAAA/hE,EAAAvsB,EAAA4vF,GAAA,CAGA,GACA1pF,GACAjB,EACAY,EACAX,EAJA0mD,EAAAr/B,EAAAmB,cAAA0hE,EAAApvF,GAKAusB,GAAA2C,gBACAhpB,EAAAwpF,EACAzqF,EAAAkqB,EAAAlqB,EACAY,EAAA+lD,EAAA1lD,EACAhB,EAAAiqB,EAAAjqB,SAEAgB,EAAAipB,EAAAjpB,EACAjB,EAAA0qF,EACA9pF,EAAAspB,EAAAtpB,MACAX,EAAA0mD,EAAA3mD,EAEA,IAAAoqF,GAAAvrE,IAAA2rE,EAAA9vF,MACArE,MAAAqzF,WAAAlpF,IAAA,GAAAtD,GAAAuE,MACAk1B,KAAA,QAAA+G,EAAA3iC,GACA2G,OACAT,IACAjB,IACAY,QACAX,UAEAX,MAAAjD,EAAA0F,UAAgDtC,KAAA+qF,EAAAJ,IAA+Bzc,GAC/EvtE,QAAA,KAEAqqF,EAAAxpF,EAAAL,EACA8pF,EAAA1qF,EAAAC,KAIAupF,GAAApmF,QAAqBzL,KAAA,UACrB6xF,EAAApmF,QAAqBzL,KAAA,YAsErBuC,EAAA,4EAAAD,GACA,YAEA,SAAA2wF,GAAA/6E,EAAAoP,EAAAC,EAAArD,EAAA8K,EAAAkkE,EAAAC,GAKA,QAAAC,GAAAtyE,EAAAC,EAAA01B,EAAAznB,GACA,OAAAutC,GAAAz7C,EAA+By7C,EAAAx7C,EAASw7C,IAExC,GADArkD,EAAAqkD,GAAAl0D,GAAAouC,EACA8lB,EAAAz7C,GAAAy7C,EAAA,EAAAx7C,GAAA7I,EAAAqkD,EAAA,GAAAl0D,EAAA6P,EAAAqkD,GAAAl0D,EAAA6P,EAAAqkD,GAAAj0D,OAEA,WADA+qF,GAAA92B,EAAA9lB,EAAA,EAIA48C,GAAAtyE,EAAA,EAAA01B,EAAA,GAGA,QAAA48C,GAAAtyE,EAAA01B,GACA,OAAA8lB,GAAAx7C,EAA6Bw7C,GAAA,IAC7BrkD,EAAAqkD,GAAAl0D,GAAAouC,IACA8lB,EAAA,GAAArkD,EAAAqkD,GAAAl0D,EAAA6P,EAAAqkD,EAAA,GAAAl0D,EAAA6P,EAAAqkD,EAAA,GAAAj0D,SAFqCi0D,MAOrC,QAAA+2B,GAAAp7E,EAAAq7E,EAAAjsE,EAAAC,EAAArD,EAAA8K,GAGA,OAFAwkE,GAAAxkE,EAAA,EAAAukE,EAAAtoC,OAAAC,UAAA,EAAAqoC,EAAAtoC,OAAAC,UAAA,EAEA9nD,EAAA,EAAAe,EAAA+T,EAAAnV,OAA4CK,EAAAe,EAAOf,IAEnD,cAAA8U,EAAA9U,GAAAof,SAAA,CAGA,GAAAixE,GAAAtzF,KAAAihB,IAAAlJ,EAAA9U,GAAAiF,EAAAkf,GACAxkB,EAAAmV,EAAA9U,GAAAonB,IACAV,EAAA5R,EAAA9U,GAAAoqE,KACAkmB,EAAAD,EAAAvvE,EAAAnhB,EAAA5C,KAAAktD,MAAAnpC,EAAAnhB,EAAA+mB,IAAA5F,EAAAnhB,EAAA+mB,GAAA2pE,KAAAtzF,KAAAihB,IAAAlJ,EAAA9U,GAAAkG,EAAAge,EACAisE,IAAAG,GAAAF,IAEAE,EAAAF,EAAA,KAEAD,GAAAG,GAAAF,IAEAE,EAAAF,EAAA,IAEAt7E,EAAA9U,GAAAkG,EAAAge,EAAAosE,EAAA1kE,EACAwkE,EAAAE,GA5CAx7E,EAAA0qB,KAAA,SAAAx3B,EAAAwD,GACA,MAAAxD,GAAA/C,EAAAuG,EAAAvG,GAmDA,QAJAouC,GADAk9C,EAAA,EAEAnpE,EAAAtS,EAAAnV,OACA6wF,KACAC,KACAzwF,EAAA,EAAuBA,EAAAonB,EAASpnB,IAChCqzC,EAAAv+B,EAAA9U,GAAAiF,EAAAsrF,EACAl9C,EAAA,GACA28C,EAAAhwF,EAAAonB,GAAAisB,EAAAznB,GAEA2kE,EAAAz7E,EAAA9U,GAAAiF,EAAA6P,EAAA9U,GAAAkF,MAEA6qF,GAAAQ,EAAA,GACAN,EAAA7oE,EAAA,EAAAmpE,EAAAR,EAEA,QAAA/vF,GAAA,EAAuBA,EAAAonB,EAASpnB,IAChC8U,EAAA9U,GAAAiF,GAAAkf,EACAssE,EAAA3zF,KAAAgY,EAAA9U,IAEAwwF,EAAA1zF,KAAAgY,EAAA9U,GAGAkwF,GAAAM,GAAA,EAAAtsE,EAAAC,EAAArD,EAAA8K,GACAskE,EAAAO,GAAA,EAAAvsE,EAAAC,EAAArD,EAAA8K,GAEA,QAAA8kE,GAAAC,EAAAzsE,EAAAC,EAAArD,EAAAgvE,EAAAC,GAGA,OAFAa,MACAC,KACA7wF,EAAA,EAAuBA,EAAA2wF,EAAAhxF,OAA4BK,IACnD2wF,EAAA3wF,GAAAkG,EAAAge,EACA0sE,EAAA9zF,KAAA6zF,EAAA3wF,IAEA6wF,EAAA/zF,KAAA6zF,EAAA3wF,GAGA6vF,GAAAgB,EAAA3sE,EAAAC,EAAArD,EAAA,EAAAgvE,EAAAC,GACAF,EAAAe,EAAA1sE,EAAAC,EAAArD,KAAAgvE,EAAAC,EACA,QAAA/vF,GAAA,EAAuBA,EAAA2wF,EAAAhxF,OAA4BK,IAAA,CACnD,GAAAkiB,GAAAyuE,EAAA3wF,GAAAkiB,UACA,IAAAA,EAAA,CACA,GAAA6lC,GAAA7lC,EAAA,MAAAA,EAAA,KACAyuE,GAAA3wF,GAAAkG,EAAAge,EACAhC,EAAA,MAAAyuE,EAAA3wF,GAAAkG,EAAA,EAEAgc,EAAA,MAAAyuE,EAAA3wF,GAAAkG,EAAA,EAEAgc,EAAA,MAAAA,EAAA,MAAAyuE,EAAA3wF,GAAAiF,EACAid,EAAA,MAAAA,EAAA,MAAA6lC,IAhGA,GAAApnB,GAAAzhC,EAAA,uBAoGA,iBAAA8C,EAAA8e,EAAAgvE,EAAAC,GACA,GAEA7rE,GACAC,EAHAhqB,EAAA6H,EAAAC,UACA0uF,KAGAG,GAAA,CACA32F,GAAAqQ,KAAA,SAAAR,GACA,GAWA+mF,GACAC,EACA9uE,EACA5kB,EAdA8E,EAAAjI,EAAAukB,cAAA1U,GACAgX,EAAA7mB,EAAA8mB,aAAAjX,GACAmW,EAAAa,EAAA9c,SAAA,gBAEAkc,EAAAD,EAAAnc,IAAA,aAAAgd,EAAAhd,IAAA,2BACAwe,EAAAxB,EAAA9c,SAAA,oBACA+sF,EAAAzuE,EAAAxe,IAAA,UACAktF,EAAA1uE,EAAAxe,IAAA,WACA4a,GAAAxc,EAAAyc,WAAAzc,EAAA0c,UAAA,EACAC,EAAAhiB,KAAAiiB,IAAAJ,GACAK,EAAAliB,KAAAmiB,IAAAN,EAKAsF,GAAA9hB,EAAA8hB,GACAC,EAAA/hB,EAAA+hB,EACA,IAAA9D,GAAA,WAAAD,GAAA,UAAAA,CACA,eAAAA,EACA2wE,EAAA3uF,EAAA8hB,GACA8sE,EAAA5uF,EAAA+hB,GACA7mB,EAAA,aACa,CACb,GAAAq8B,IAAAtZ,GAAAje,EAAA0e,EAAA1e,EAAAmiB,IAAA,EAAAxF,EAAA3c,EAAA0e,EAAA/B,GAAAmF,EACA2V,GAAAxZ,GAAAje,EAAA0e,EAAA1e,EAAAmiB,IAAA,EAAAtF,EAAA7c,EAAA0e,EAAA7B,GAAAkF,CAGA,IAFA4sE,EAAAp3D,EAAA,EAAA5a,EACAiyE,EAAAn3D,EAAA,EAAA5a,GACAoB,EAAA,CAEA,GAAAuZ,GAAAD,EAAA5a,GAAAkyE,EAAAnwE,EAAA1e,EAAA0e,GACAgZ,EAAAD,EAAA5a,GAAAgyE,EAAAnwE,EAAA1e,EAAA0e,GACAq8C,EAAAvjC,GAAA7a,EAAA,QAAAmyE,EACA9zB,EAAAtjC,CACAi3D,GAAA5zB,GAAAp+C,EAAA,QACAiyE,EAAA5zB,EACAl7C,IAEAyX,EACAE,IAGAD,EACAE,IAGAqjC,EACAC,IAIA9/D,EAAA+iB,EAAA,SAAAtB,EAAA,iBAEA,GAAAqD,GAAAjC,EAAAjc,SAAA,aAAAO,UACA0sF,EAAAhxE,EAAAnc,IAAA,UAAA+a,EAAA,GAAAH,EAAA7hB,KAAA0nB,IAAA7F,EAAA,EACAvhB,EAAA2E,EAAA0e,kBAAA1W,EAAA,WAAA7P,EAAAikB,QAAApU,GACAnF,EAAA87B,EAAA77B,gBAAAzH,EAAA+kB,EAAA9kB,EAAA,MACAwzF,KAAAK,EACA/uF,EAAA+e,OACAjb,EAAA6qF,EACA9rF,EAAA+rF,EACA5xE,SAAAgB,EACAlb,OAAAL,EAAAK,OACAkiB,IAAA6pE,EACA7mB,KAAA8mB,EACAhvE,aACA5kB,YACA6kB,cAAA,SACAC,OACAC,SAAA8uE,GAGA9wE,GACAswE,EAAA7zF,KAAAsF,EAAA+e,UAGA2vE,GAAA9uF,EAAAgC,IAAA,sBACA0sF,EAAAC,EAAAzsE,EAAAC,EAAArD,EAAAgvE,EAAAC,MAIA5wF,EAAA,qLAAAD,GAYA,QAAAkyF,GAAAhlE,GACA,GAAA/S,IAAyB1K,cAAAyd,EAAA7e,SAEzB,OADA8L,GAAA+S,EAAA7e,SAAA,SAAA6e,EAAAsE,eACArX,EAyVA,QAAAg4E,GAAAzzD,EAAAmmC,EAAA5oC,GACA,GACA79B,GACA6kB,EAFAmvE,EAAAnxD,EAAA4jC,EAAAnmC,EAAAvb,SAmBA,OAhBAie,GAAAgxD,IAEAnvE,EAAAgZ,EAAA,iBACA79B,EAAA,UACSgjC,EAAAgxD,EAAA7sE,IAETtC,EAAAgZ,EAAA,iBACA79B,EAAA,WAEA6kB,EAAA,SAEA7kB,EADAg0F,EAAA,GAAAA,EAAA7sE,EACA0W,EAAA,iBAEAA,EAAA,mBAIA9Y,SAAAivE,EACAh0F,YACA6kB,iBAMA,QAAAovE,GAAA3zD,EAAAhL,EAAA4+D,EAAAvoF,GACA,GACA3L,GACA6kB,EAFAmvE,EAAAnxD,EAAAqxD,EAAA5zD,EAAAvb,UAGA+M,EAAAnmB,EAAA,GAAAA,EAAA,GACAwoF,EAAA,UAAA7+D,IAAAxD,GAAA,UAAAwD,GAAAxD,CAeA,OAdAkR,GAAAgxD,EAAA7sE,EAAA,IACAtC,EAAAsvE,EAAA,eACAn0F,EAAA,UACSgjC,EAAAgxD,EAAA,IAAA7sE,IACTtC,EAAAsvE,EAAA,eACAn0F,EAAA,WAEA6kB,EAAA,SAEA7kB,EADAg0F,EAAA,IAAA7sE,GAAA6sE,EAAA7sE,EAAA,EACAgtE,EAAA,eAEAA,EAAA,iBAIApvE,SAAAivE,EACAh0F,YACA6kB,iBAMA,QAAAkvB,GAAAjlB,GACA,GAAAslE,GAAAtlE,EAAApoB,IAAA,UACA,OAAAooB,GAAApoB,IAAA,aAAAooB,EAAApoB,IAAA,iBAAA0tF,KAAA/uF,MAnaA,GAAArB,GAAApC,EAAA,qBACAiI,EAAAjI,EAAA,qBACAiD,EAAAjD,EAAA,sBACA8c,EAAA9c,EAAA,qBACAgI,EAAAhI,EAAA,qBACAihC,EAAAj5B,EAAAi5B,UACAG,EAAAp5B,EAAAo5B,mBACAu2B,EAAA33D,EAAA,uBACAs4D,EAAAX,EAAAz9B,eACA5Y,EAAAlf,EAAAkf,SACAiE,EAAA1nB,KAAA0nB,GA6CA4pE,EAAA,SAAAjiE,EAAAwR,GAIAtiC,KAAAsiC,MAIAtiC,KAAA8wB,YAEA9qB,EAAA0F,SAAA42B,GACAuwD,YAAA,EACAD,cAAA,EACAD,cAAA,EACAD,eAAA,EACA3oF,QAAA,IAKA/J,KAAAwI,MAAA,GAAA3B,GAAA0d,KAEA,IAAA8xE,GAAA,GAAAxvF,GAAA0d,OACAT,SAAAwe,EAAAxe,SAAAnf,QACAoiB,SAAAub,EAAAvb,UAIAsvE,GAAAtsB,kBACA/pE,KAAAs2F,WAAAD,EAAA32D,UACA1/B,KAAAu2F,WAAAF,EAEAtD,GAAA/mF,WACAkhB,YAAA6lE,EACAyD,WAAA,SAAAn0F,GACA,QAAAo0F,EAAAp0F,IAEA8H,IAAA,SAAA9H,GACAo0F,EAAAp0F,GAAA+M,KAAApP,OAEAuzF,SAAA,WACA,MAAAvzF,MAAAwI,OAGA,IAAAiuF,IACAzf,SAAA,WACA,GAAA10C,GAAAtiC,KAAAsiC,IACAxR,EAAA9wB,KAAA8wB,SACA,IAAAA,EAAApoB,IAAA,kBAGA,GAAAiF,GAAA3N,KAAA8wB,UAAAG,KAAA3O,YACAzB,EAAA7gB,KAAAs2F,WACAI,GACA/oF,EAAA,GACA,GAEAgpF,GACAhpF,EAAA,GACA,EAEAkT,KACAq7C,EAAAw6B,IAAA71E,GACAq7C,EAAAy6B,IAAA91E,IAEA7gB,KAAAwI,MAAA2B,IAAA,GAAAtD,GAAAg2B,KAAAh2B,EAAAq3B,sBACAoC,KAAA,OACAj1B,OACAgzB,GAAAq4D,EAAA,GACAn4D,GAAAm4D,EAAA,GACAp4D,GAAAq4D,EAAA,GACAn4D,GAAAm4D,EAAA,IAEA1tF,MAAAjD,EAAA+G,QAA0C05C,QAAA,SAAmB31B,EAAAloB,SAAA,sBAAAye,gBAC7D8tC,uBAAA7yB,EAAA6yB,wBAAA,EACAprD,QAAA,EACAT,GAAA,QAGA2tE,SAAA,WACA,GAAAnmD,GAAA9wB,KAAA8wB,SACA,IAAAA,EAAApoB,IAAA,iBAcA,OAXAuoB,GAAAH,EAAAG,KACA2lE,EAAA9lE,EAAAloB,SAAA,YACA05B,EAAAtiC,KAAAsiC,IACAoxD,EAAAkD,EAAAhuF,SAAA,aACAiuF,EAAAD,EAAAluF,IAAA,UACAouF,EAAA3vD,EAAAyvD,EAAAt0D,EAAAgvB,eACAwiC,EAAA7iE,EAAA+8C,eAAA4oB,EAAAluF,IAAA,mBACA2+B,EAAApW,EAAA/O,MAAAD,WACAy0E,KACAC,KACA91E,EAAA7gB,KAAAs2F,WACA5xF,EAAA,EAA+BA,EAAAovF,EAAAzvF,OAAwBK,IAEvD,IAAAsuF,EAAA/hE,EAAAvsB,EAAAoyF,GAAA;AAGA,GAAAxmC,GAAAwjC,EAAApvF,EACAgyF,GAAA,GAAApmC,EACAomC,EAAA,KACAC,EAAA,GAAArmC,EACAqmC,EAAA,GAAAr0D,EAAAqwD,cAAAkE,EACAh2E,IACAq7C,EAAAw6B,IAAA71E,GACAq7C,EAAAy6B,IAAA91E,IAGA7gB,KAAAwI,MAAA2B,IAAA,GAAAtD,GAAAg2B,KAAAh2B,EAAAq3B,sBACAoC,KAAA,QAAA+G,EAAA3iC,GACA2G,OACAgzB,GAAAq4D,EAAA,GACAn4D,GAAAm4D,EAAA,GACAp4D,GAAAq4D,EAAA,GACAn4D,GAAAm4D,EAAA,IAEA1tF,MAAAjD,EAAA0F,SAAAgoF,EAAArsE,gBAA+ED,OAAA0J,EAAApoB,IAAA,8BAC/EY,GAAA,EACAS,QAAA,QAIAotE,UAAA,WAgEA,QAAA4f,GAAAC,EAAA92F,GACA,GAAA+2F,GAAAD,KAAAxtF,kBAAAmH,QACAumF,EAAAh3F,KAAAsJ,kBAAAmH,OACA,IAAAsmF,GAAAC,EAGA,MAFAD,GAAAn5D,eAAAk5D,EAAAz3D,qBACA23D,EAAAp5D,eAAA59B,EAAAq/B,qBACA03D,EAAA1mC,UAAA2mC,GArEA,GAAA50D,GAAAtiC,KAAAsiC,IACAxR,EAAA9wB,KAAA8wB,UACAzpB,EAAA6d,EAAAod,EAAA60D,cAAArmE,EAAApoB,IAAA,kBACA,IAAArB,EAAA,CAGA,GAAA4pB,GAAAH,EAAAG,KACApM,EAAAiM,EAAAloB,SAAA,aACAD,EAAAkc,EAAAjc,SAAA,aACAwuF,EAAAvyE,EAAAnc,IAAA,UACA2+B,EAAApW,EAAA/O,MAAAD,WACAiP,EAAAJ,EAAAK,qBAEA2hE,EAAA5tE,EAAAod,EAAAwwD,cAAAjuE,EAAAnc,IAAA,aAEAoqF,KAAA3pE,EAAA,GAMA,QALAzC,GAAAqvE,EAAAzzD,EAAAwwD,EAAAxwD,EAAAowD,gBACA2E,EAAAvmE,EAAApoB,IAAA,QACA4uF,KACAvtF,EAAAgsC,EAAAjlB,GACAgmD,EAAAhmD,EAAApoB,IAAA,gBACAhE,EAAA,EAA+BA,EAAA2iC,EAAAhjC,OAAkBK,IACjD,IAAAsuF,EAAA/hE,EAAAvsB,EAAA49B,EAAAgvB,eAAA,CAGA,GAAAimC,GAAA5uF,CACA0uF,MAAA3yF,IAAA2yF,EAAA3yF,GAAAqD,YACAwvF,EAAA,GAAA72E,GAAA22E,EAAA3yF,GAAAqD,UAAAY,EAAAmoB,EAAAtqB,SAEA,IAAA6/C,GAAAkxC,EAAAluF,gBAAAynB,EAAApoB,IAAA,4BACA4nD,EAAAr/B,EAAA6I,YAAAuN,EAAA3iC,IACA06E,GACA9uB,EACAhuB,EAAAuwD,YAAAvwD,EAAAowD,eAAA0E,GAEAI,EAAAvmE,EAAA/O,MAAAlV,SAAAq6B,EAAA3iC,IACAqE,EAAA,GAAAlC,GAAAmC,MACAs3B,KAAA,SAAA+G,EAAA3iC,GACAuE,OACAlH,KAAAmvB,EAAAxsB,GACA1C,UAAAu1F,EAAA7uF,IAAA,aAAAge,EAAA1kB,UACA+I,kBAAAwsF,EAAA7uF,IAAA,gBAAAge,EAAAG,cACA3d,SAAAquF,EAAApuF,UACAC,KAAA,kBAAAi9C,KAAAmxC,GAAAnxC,GAEAviC,SAAAs7D,EACAr4D,SAAAL,EAAAK,SACAhd,SACAT,GAAA,IAGAwtE,KACA/tE,EAAAgV,UAAA+3E,EAAAhlE,GACA/nB,EAAAgV,UAAA05E,WAAA,YACA1uF,EAAAgV,UAAArf,MAAA84F,GAGAx3F,KAAAu2F,WAAApsF,IAAApB,GACAA,EAAAghE,kBACAutB,EAAA91F,KAAAuH,GACA/I,KAAAwI,MAAA2B,IAAApB,GACAA,EAAA6gE,qBAWA,gBAAA34C,EAAA3vB,KAAA,CAIA,GAAAwvB,EAAA0+B,OAAA1+B,EAAA0+B,SAAA1+B,EAAApoB,IAAA,QACA,GAAAgvF,GAAAJ,EAAA,GACAK,EAAAL,EAAA,EACAP,GAAAW,EAAAC,KACAD,EAAA/hF,QAAA,GAGA,GAAAmb,EAAA2+B,OAAA3+B,EAAA2+B,SAAA3+B,EAAApoB,IAAA,QACA,GAAAkvF,GAAAN,IAAAjzF,OAAA,GACAwzF,EAAAP,IAAAjzF,OAAA,EACA0yF,GAAAc,EAAAD,KACAA,EAAAjiF,QAAA,OAKA0+D,SAAA,WACA,GAAA/xC,GAAAtiC,KAAAsiC,IACAxR,EAAA9wB,KAAA8wB,UACAzuB,EAAA6iB,EAAAod,EAAA+xC,SAAAvjD,EAAApoB,IAAA,QACA,IAAArG,EAAA,CAGA,GAUAqkB,GAVA+vD,EAAA3lD,EAAApoB,IAAA,gBACAkqF,EAAAtwD,EAAAswD,cACAjqF,EAAAmoB,EAAAloB,SAAA,iBACA2vB,EAAAzH,EAAApoB,IAAA,cACAiF,EAAA3N,KAAA8wB,UAAAG,KAAA3O,YACAw1E,EAAAnqF,EAAA,GAAAA,EAAA,QACAyxE,GACA,UAAA3I,EAAA9oE,EAAA,GAAAmqF,EAAAv/D,EAAA,QAAAk+C,EAAA9oE,EAAA,GAAAmqF,EAAAv/D,GAAA5qB,EAAA,GAAAA,EAAA,MACA,WAAA8oE,EAAAn0C,EAAAuwD,YAAAD,EAAAr6D,EAAA,GAGAw/D,EAAAjnE,EAAApoB,IAAA,aACA,OAAAqvF,IACAA,IAAA5uE,EAAA,IAEA,IAAA6uE,EACA,YAAAvhB,EACA/vD,EAAAqvE,EAAAzzD,EAAA,MAAAy1D,IAAAz1D,EAAAvb,SAAA6rE,IAEAlsE,EAAAuvE,EAAA3zD,EAAAm0C,EAAAshB,GAAA,EAAApqF,GACAqqF,EAAA11D,EAAA01D,uBACA,MAAAA,IACAA,EAAAv2F,KAAAihB,IAAAs1E,EAAAv2F,KAAAmiB,IAAA8C,EAAAK,YACA2gB,SAAAswD,OAAA,OAGA,IAAA9uF,GAAAP,EAAAQ,UACA8uF,EAAAnnE,EAAApoB,IAAA,uBACA00D,EAAA66B,EAAA76B,SACA1kC,EAAAxT,EAAA+yE,EAAAv/D,SAAAs/D,GACAE,EAAA,MAAA96B,GAAA,MAAA1kC,EAAA7sB,EAAAk7B,aAAA1kC,EAAAq2B,EAAAxvB,EAAAk0D,GACAE,QAAA,EACAG,YAAAw6B,EAAAx6B,cACqBp7D,EACrB+zF,EAAAtlE,EAAApoB,IAAA,cACAuJ,EAAA6e,EAAA7e,SACAkmF,GACA9kF,cAAApB,EACA5P,OACAmoB,OAAA,QAEA2tE,GAAAlmF,EAAA,SAAA6e,EAAAsE,cACA,IAAArsB,GAAA,GAAAlC,GAAAmC,MACAs3B,KAAA,OACA83D,WAAA/1F,EACAg2F,gBAAAH,EACAjvF,OACAlH,KAAAm2F,EACAhvF,WACAE,KAAAT,EAAAU,gBAAAynB,EAAApoB,IAAA,4BACA1G,UAAA0kB,EAAA1kB,UACA+I,kBAAA2b,EAAAG,eAEA/C,SAAAs7D,EACAr4D,SAAAL,EAAAK,SACAhd,OAAAgsC,EAAAjlB,GACAxnB,GAAA,EACAytE,QAAAqf,KAAA/uF,KAAArB,EAAA+G,QACA9J,QAAAZ,EACAu8D,UAAA,WACA,MAAAv8D,IAEA81F,mBACyB/B,GAAA,MAEzBtlE,GAAApoB,IAAA,kBACAK,EAAAgV,UAAA+3E,EAAAhlE,GACA/nB,EAAAgV,UAAA05E,WAAA,WACA1uF,EAAAgV,UAAA1b,QAGArC,KAAAu2F,WAAApsF,IAAApB,GACAA,EAAAghE,kBACA/pE,KAAAwI,MAAA2B,IAAApB,GACAA,EAAA6gE,wBAuEAopB,EAAAD,EAAAC,eAAA,SAAA/hE,EAAAvsB,EAAAyJ,GACA,GAAAmqF,GACAp2E,EAAA+O,EAAA/O,KACA,mBAAAA,EAAA5gB,OAAA,kBAAA6M,IAAAmqF,EAAAp2E,EAAAD,WAAAvd,IAAAyJ,EAAAmqF,EAAAp2E,EAAAlV,SAAAsrF,KAAA5zF,GAAAyJ,EAAA,KAKAg5B,EAAA4rD,EAAA5rD,YAAA,SAAA7zB,EAAAg+C,GACA,GAAAnjD,GAAAmF,EAAA5K,IAAA,WAIA,OAHA,OAAAyF,GAAA,QAAAA,IACAA,EAAAmjD,GAEAnjD,EAEA,OAAA4kF,KAEAlvF,EAAA,uCAAA0M,GAA2D,MAAAA,KAC3D1M,EAAA,uCAAApD,GAA2D,MAAAA,IAC3D,IAAAA,GAAAmD,EAAA,UAmBA,OAjBAnD,GAAAoG,QAAAjD,EAAA,wBACAnD,EAAAkgB,OAAA/c,EAAA,uBACAnD,EAAAmgB,OAAAhd,EAAA,uBAGAA,EAAA,qBAEAA,EAAA,qBAGAA,EAAA,0BAEAA,EAAA,2BAKAnD,MNsM8B2O,KAAKlR,EAAU,WAAa,MAAO8B","file":"2.build.js","sourcesContent":["webpackJsonp([2,4],{\n\n/***/ 16:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _echarts = __webpack_require__(50);\n\t\n\tvar _echarts2 = _interopRequireDefault(_echarts);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t    data: function data() {\n\t        return {\n\t            typeMap: {\n\t                radio: '单选',\n\t                checkbox: '多选',\n\t                textarea: '问答'\n\t            }\n\t        };\n\t    },\n\t\n\t    vuex: {\n\t        getters: {\n\t            questionnaire: function questionnaire(state) {\n\t                return state.currentQuestionnaire;\n\t            },\n\t            questionnaireList: function questionnaireList(state) {\n\t                return state.questionnaireList;\n\t            }\n\t        },\n\t        actions: {\n\t            setCurrentQuest: function setCurrentQuest(_ref, item) {\n\t                var dispatch = _ref.dispatch;\n\t\n\t                dispatch(\"SET_QUEST\", item);\n\t            }\n\t        }\n\t    },\n\t    route: {\n\t        data: function data(_ref2) {\n\t            var _this = this;\n\t\n\t            var to = _ref2.to;\n\t            var next = _ref2.next;\n\t\n\t            var id = to.params.questId;\n\t            if (!this.questionnaire) {\n\t                this.questionnaireList.forEach(function (item) {\n\t                    if (parseInt(item.id) === parseInt(id)) {\n\t                        _this.setCurrentQuest(item);\n\t                        return;\n\t                    }\n\t                });\n\t            }\n\t\n\t            next();\n\t        }\n\t    },\n\t    directives: {\n\t        'echarts': {\n\t            bind: function bind() {\n\t                var self = this;\n\t                this.vm.$nextTick(function () {\n\t                    self.instance = _echarts2.default.init(self.el);\n\t                });\n\t            },\n\t            update: function update(newVal, oldVal) {\n\t                var self = this;\n\t                var seriesData = [];\n\t                var option = {};\n\t\n\t                if (newVal.type !== 'textarea') {\n\t                    newVal.selections.forEach(function (item) {\n\t                        seriesData.push(parseInt(Math.random() * 100));\n\t                    });\n\t                    option = {\n\t                        grid: {\n\t                            top: 40,\n\t                            bottom: 25\n\t                        },\n\t                        title: {\n\t                            text: self.vm.typeMap[newVal.type] + '.' + newVal.title,\n\t                            textAlign: \"left\"\n\t                        },\n\t                        yAxis: {},\n\t                        xAxis: {\n\t                            data: newVal.selections\n\t                        },\n\t                        series: [{\n\t                            type: 'bar',\n\t                            data: seriesData\n\t                        }]\n\t                    };\n\t                } else {\n\t                    seriesData.push(parseInt(Math.random() * 100));\n\t                    seriesData.push(100 - seriesData[0]);\n\t                    option = {\n\t                        title: {\n\t                            text: self.vm.typeMap[newVal.type] + '.' + newVal.title,\n\t                            textAlign: \"left\"\n\t                        },\n\t                        series: [{\n\t                            type: 'pie',\n\t                            radius: \"60%\",\n\t                            data: [{ name: '有效回答', value: seriesData[0] }, { name: '无效回答', value: seriesData[1] }]\n\t                        }]\n\t                    };\n\t                }\n\t                this.vm.$nextTick(function () {\n\t                    self.instance.setOption(option);\n\t                });\n\t            },\n\t            unbind: function unbind() {\n\t                this.instance.dispose();\n\t            }\n\t        }\n\t    }\n\t};\n\n/***/ },\n\n/***/ 24:\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(1)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"#create .preview-deadline{font-size:.14rem;margin-top:.2rem;text-align:center}#create .quest-title_preview{text-align:center;letter-spacing:.05rem;font-size:.28rem;font-weight:700}#create .questItem-data{margin:.1rem 0;border:1px solid #ccc;border-radius:.03rem}#create .chart{min-height:2rem;width:4rem;margin:0 auto}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n\n/***/ 31:\n/***/ function(module, exports) {\n\n\tmodule.exports = \" <div id=create v-if=!$loadingRouteData> <div class=quest> <div class=quest-title> <h2 v-text=questionnaire.title class=quest-title_preview></h2> </div> <div v-for=\\\"questItem in questionnaire.questItemList\\\" class=questItem-data track-by=$index> <div class=chart v-echarts=questItem></div> </div> </div> <p class=preview-deadline>问卷截止日期：{{new Date(questionnaire.deadline).toLocaleDateString()}}</p> </div> \";\n\n/***/ },\n\n/***/ 38:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\t__webpack_require__(44)\n\t__vue_script__ = __webpack_require__(16)\n\t__vue_template__ = __webpack_require__(31)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tif (__vue_template__) {\n\t(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n\t}\n\n\n/***/ },\n\n/***/ 44:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(24);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(2)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Data.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Data.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n\n/***/ 50:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;/* WEBPACK VAR INJECTION */(function(global) {(function (root, factory) {\n\t    if (true) {\n\t        // AMD. Register as an anonymous module.\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof module === 'object' && module.exports) {\n\t        // Node. Does not work with strict CommonJS, but\n\t        // only CommonJS-like environments that support module.exports,\n\t        // like Node.\n\t        module.exports = factory();\n\t    } else {\n\t        // Browser globals (root is window)\n\t        root.echarts = factory();\n\t    }\n\t}(this, function () {var require, define;\n\t(function () {\n\t    var mods = {};\n\t\n\t    define = function (id, deps, factory) {\n\t        mods[id] = {\n\t            id: id,\n\t            deps: deps,\n\t            factory: factory,\n\t            defined: 0,\n\t            exports: {},\n\t            require: createRequire(id)\n\t        };\n\t    };\n\t\n\t    require = createRequire('');\n\t\n\t    function normalize(id, baseId) {\n\t        if (!baseId) {\n\t            return id;\n\t        }\n\t\n\t        if (id.indexOf('.') === 0) {\n\t            var basePath = baseId.split('/');\n\t            var namePath = id.split('/');\n\t            var baseLen = basePath.length - 1;\n\t            var nameLen = namePath.length;\n\t            var cutBaseTerms = 0;\n\t            var cutNameTerms = 0;\n\t\n\t            pathLoop: for (var i = 0; i < nameLen; i++) {\n\t                switch (namePath[i]) {\n\t                    case '..':\n\t                        if (cutBaseTerms < baseLen) {\n\t                            cutBaseTerms++;\n\t                            cutNameTerms++;\n\t                        }\n\t                        else {\n\t                            break pathLoop;\n\t                        }\n\t                        break;\n\t                    case '.':\n\t                        cutNameTerms++;\n\t                        break;\n\t                    default:\n\t                        break pathLoop;\n\t                }\n\t            }\n\t\n\t            basePath.length = baseLen - cutBaseTerms;\n\t            namePath = namePath.slice(cutNameTerms);\n\t\n\t            return basePath.concat(namePath).join('/');\n\t        }\n\t\n\t        return id;\n\t    }\n\t\n\t    function createRequire(baseId) {\n\t        var cacheMods = {};\n\t\n\t        function localRequire(id, callback) {\n\t            if (typeof id === 'string') {\n\t                var exports = cacheMods[id];\n\t                if (!exports) {\n\t                    exports = getModExports(normalize(id, baseId));\n\t                    cacheMods[id] = exports;\n\t                }\n\t\n\t                return exports;\n\t            }\n\t            else if (id instanceof Array) {\n\t                callback = callback || function () {};\n\t                callback.apply(this, getModsExports(id, callback, baseId));\n\t            }\n\t        };\n\t\n\t        return localRequire;\n\t    }\n\t\n\t    function getModsExports(ids, factory, baseId) {\n\t        var es = [];\n\t        var mod = mods[baseId];\n\t\n\t        for (var i = 0, l = Math.min(ids.length, factory.length); i < l; i++) {\n\t            var id = normalize(ids[i], baseId);\n\t            var arg;\n\t            switch (id) {\n\t                case 'require':\n\t                    arg = (mod && mod.require) || require;\n\t                    break;\n\t                case 'exports':\n\t                    arg = mod.exports;\n\t                    break;\n\t                case 'module':\n\t                    arg = mod;\n\t                    break;\n\t                default:\n\t                    arg = getModExports(id);\n\t            }\n\t            es.push(arg);\n\t        }\n\t\n\t        return es;\n\t    }\n\t\n\t    function getModExports(id) {\n\t        var mod = mods[id];\n\t        if (!mod) {\n\t            throw new Error('No ' + id);\n\t        }\n\t\n\t        if (!mod.defined) {\n\t            var factory = mod.factory;\n\t            var factoryReturn = factory.apply(\n\t                this,\n\t                getModsExports(mod.deps || [], factory, id)\n\t            );\n\t            if (typeof factoryReturn !== 'undefined') {\n\t                mod.exports = factoryReturn;\n\t            }\n\t            mod.defined = 1;\n\t        }\n\t\n\t        return mod.exports;\n\t    }\n\t}());\n\tdefine('echarts/chart/pie', ['require', 'zrender/core/util', '../echarts', './pie/PieSeries', './pie/PieView', '../action/createDataSelectAction', '../visual/dataColor', './pie/pieLayout', '../processor/dataFilter'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var echarts = require('../echarts');\n\t    require('./pie/PieSeries');\n\t    require('./pie/PieView');\n\t    require('../action/createDataSelectAction')('pie', [\n\t        {\n\t            type: 'pieToggleSelect',\n\t            event: 'pieselectchanged',\n\t            method: 'toggleSelected'\n\t        },\n\t        {\n\t            type: 'pieSelect',\n\t            event: 'pieselected',\n\t            method: 'select'\n\t        },\n\t        {\n\t            type: 'pieUnSelect',\n\t            event: 'pieunselected',\n\t            method: 'unSelect'\n\t        }\n\t    ]);\n\t    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'pie'));\n\t    echarts.registerLayout(zrUtil.curry(require('./pie/pieLayout'), 'pie'));\n\t    echarts.registerProcessor(zrUtil.curry(require('../processor/dataFilter'), 'pie'));\n\t});\n\tdefine('echarts/chart/bar', ['require', 'zrender/core/util', '../coord/cartesian/Grid', './bar/BarSeries', './bar/BarView', '../layout/barGrid', '../echarts', '../component/grid'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    require('../coord/cartesian/Grid');\n\t    require('./bar/BarSeries');\n\t    require('./bar/BarView');\n\t    var barLayoutGrid = require('../layout/barGrid');\n\t    var echarts = require('../echarts');\n\t    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n\t    // Visual coding for legend\n\t    echarts.registerVisual(function (ecModel) {\n\t        ecModel.eachSeriesByType('bar', function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t            data.setVisual('legendSymbol', 'roundRect');\n\t        });\n\t    });\n\t    // In case developer forget to include grid component\n\t    require('../component/grid');\n\t});\n\tdefine('echarts/component/title', ['require', '../echarts', '../util/graphic', '../util/layout'], function (require) {\n\t    'use strict';\n\t    var echarts = require('../echarts');\n\t    var graphic = require('../util/graphic');\n\t    var layout = require('../util/layout');\n\t    // Model\n\t    echarts.extendComponentModel({\n\t        type: 'title',\n\t        layoutMode: {\n\t            type: 'box',\n\t            ignoreSize: true\n\t        },\n\t        defaultOption: {\n\t            zlevel: 0,\n\t            z: 6,\n\t            show: true,\n\t            text: '',\n\t            target: 'blank',\n\t            subtext: '',\n\t            subtarget: 'blank',\n\t            left: 0,\n\t            top: 0,\n\t            backgroundColor: 'rgba(0,0,0,0)',\n\t            borderColor: '#ccc',\n\t            borderWidth: 0,\n\t            padding: 5,\n\t            itemGap: 10,\n\t            textStyle: {\n\t                fontSize: 18,\n\t                fontWeight: 'bolder',\n\t                color: '#333'\n\t            },\n\t            subtextStyle: { color: '#aaa' }\n\t        }\n\t    });\n\t    // View\n\t    echarts.extendComponentView({\n\t        type: 'title',\n\t        render: function (titleModel, ecModel, api) {\n\t            this.group.removeAll();\n\t            if (!titleModel.get('show')) {\n\t                return;\n\t            }\n\t            var group = this.group;\n\t            var textStyleModel = titleModel.getModel('textStyle');\n\t            var subtextStyleModel = titleModel.getModel('subtextStyle');\n\t            var textAlign = titleModel.get('textAlign');\n\t            var textBaseline = titleModel.get('textBaseline');\n\t            var textEl = new graphic.Text({\n\t                    style: {\n\t                        text: titleModel.get('text'),\n\t                        textFont: textStyleModel.getFont(),\n\t                        fill: textStyleModel.getTextColor()\n\t                    },\n\t                    z2: 10\n\t                });\n\t            var textRect = textEl.getBoundingRect();\n\t            var subText = titleModel.get('subtext');\n\t            var subTextEl = new graphic.Text({\n\t                    style: {\n\t                        text: subText,\n\t                        textFont: subtextStyleModel.getFont(),\n\t                        fill: subtextStyleModel.getTextColor(),\n\t                        y: textRect.height + titleModel.get('itemGap'),\n\t                        textBaseline: 'top'\n\t                    },\n\t                    z2: 10\n\t                });\n\t            var link = titleModel.get('link');\n\t            var sublink = titleModel.get('sublink');\n\t            textEl.silent = !link;\n\t            subTextEl.silent = !sublink;\n\t            if (link) {\n\t                textEl.on('click', function () {\n\t                    window.open(link, '_' + titleModel.get('target'));\n\t                });\n\t            }\n\t            if (sublink) {\n\t                subTextEl.on('click', function () {\n\t                    window.open(sublink, '_' + titleModel.get('subtarget'));\n\t                });\n\t            }\n\t            group.add(textEl);\n\t            subText && group.add(subTextEl);\n\t            // If no subText, but add subTextEl, there will be an empty line.\n\t            var groupRect = group.getBoundingRect();\n\t            var layoutOption = titleModel.getBoxLayoutParams();\n\t            layoutOption.width = groupRect.width;\n\t            layoutOption.height = groupRect.height;\n\t            var layoutRect = layout.getLayoutRect(layoutOption, {\n\t                    width: api.getWidth(),\n\t                    height: api.getHeight()\n\t                }, titleModel.get('padding'));\n\t            // Adjust text align based on position\n\t            if (!textAlign) {\n\t                // Align left if title is on the left. center and right is same\n\t                textAlign = titleModel.get('left') || titleModel.get('right');\n\t                if (textAlign === 'middle') {\n\t                    textAlign = 'center';\n\t                }\n\t                // Adjust layout by text align\n\t                if (textAlign === 'right') {\n\t                    layoutRect.x += layoutRect.width;\n\t                } else if (textAlign === 'center') {\n\t                    layoutRect.x += layoutRect.width / 2;\n\t                }\n\t            }\n\t            if (!textBaseline) {\n\t                textBaseline = titleModel.get('top') || titleModel.get('bottom');\n\t                if (textBaseline === 'center') {\n\t                    textBaseline = 'middle';\n\t                }\n\t                if (textBaseline === 'bottom') {\n\t                    layoutRect.y += layoutRect.height;\n\t                } else if (textBaseline === 'middle') {\n\t                    layoutRect.y += layoutRect.height / 2;\n\t                }\n\t                textBaseline = textBaseline || 'top';\n\t            }\n\t            group.attr('position', [\n\t                layoutRect.x,\n\t                layoutRect.y\n\t            ]);\n\t            var alignStyle = {\n\t                    textAlign: textAlign,\n\t                    textVerticalAlign: textBaseline\n\t                };\n\t            textEl.setStyle(alignStyle);\n\t            subTextEl.setStyle(alignStyle);\n\t            // Render background\n\t            // Get groupRect again because textAlign has been changed\n\t            groupRect = group.getBoundingRect();\n\t            var padding = layoutRect.margin;\n\t            var style = titleModel.getItemStyle([\n\t                    'color',\n\t                    'opacity'\n\t                ]);\n\t            style.fill = titleModel.get('backgroundColor');\n\t            var rect = new graphic.Rect({\n\t                    shape: {\n\t                        x: groupRect.x - padding[3],\n\t                        y: groupRect.y - padding[0],\n\t                        width: groupRect.width + padding[1] + padding[3],\n\t                        height: groupRect.height + padding[0] + padding[2]\n\t                    },\n\t                    style: style,\n\t                    silent: true\n\t                });\n\t            graphic.subPixelOptimizeRect(rect);\n\t            group.add(rect);\n\t        }\n\t    });\n\t});\n\tdefine('echarts/component/grid', ['require', '../util/graphic', 'zrender/core/util', '../echarts', '../coord/cartesian/Grid', './axis'], function (require) {\n\t    'use strict';\n\t    var graphic = require('../util/graphic');\n\t    var zrUtil = require('zrender/core/util');\n\t    var echarts = require('../echarts');\n\t    require('../coord/cartesian/Grid');\n\t    require('./axis');\n\t    // Grid view\n\t    echarts.extendComponentView({\n\t        type: 'grid',\n\t        render: function (gridModel, ecModel) {\n\t            this.group.removeAll();\n\t            if (gridModel.get('show')) {\n\t                this.group.add(new graphic.Rect({\n\t                    shape: gridModel.coordinateSystem.getRect(),\n\t                    style: zrUtil.defaults({ fill: gridModel.get('backgroundColor') }, gridModel.getItemStyle()),\n\t                    silent: true\n\t                }));\n\t            }\n\t        }\n\t    });\n\t    echarts.registerPreprocessor(function (option) {\n\t        // Only create grid when need\n\t        if (option.xAxis && option.yAxis && !option.grid) {\n\t            option.grid = {};\n\t        }\n\t    });\n\t});\n\tdefine('echarts/scale/Time', ['require', 'zrender/core/util', '../util/number', '../util/format', './Interval'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var numberUtil = require('../util/number');\n\t    var formatUtil = require('../util/format');\n\t    var IntervalScale = require('./Interval');\n\t    var intervalScaleProto = IntervalScale.prototype;\n\t    var mathCeil = Math.ceil;\n\t    var mathFloor = Math.floor;\n\t    var ONE_SECOND = 1000;\n\t    var ONE_MINUTE = ONE_SECOND * 60;\n\t    var ONE_HOUR = ONE_MINUTE * 60;\n\t    var ONE_DAY = ONE_HOUR * 24;\n\t    // FIXME 公用？\n\t    var bisect = function (a, x, lo, hi) {\n\t        while (lo < hi) {\n\t            var mid = lo + hi >>> 1;\n\t            if (a[mid][2] < x) {\n\t                lo = mid + 1;\n\t            } else {\n\t                hi = mid;\n\t            }\n\t        }\n\t        return lo;\n\t    };\n\t    /**\n\t     * @alias module:echarts/coord/scale/Time\n\t     * @constructor\n\t     */\n\t    var TimeScale = IntervalScale.extend({\n\t            type: 'time',\n\t            getLabel: function (val) {\n\t                var stepLvl = this._stepLvl;\n\t                var date = new Date(val);\n\t                return formatUtil.formatTime(stepLvl[0], date);\n\t            },\n\t            niceExtent: function (approxTickNum, fixMin, fixMax) {\n\t                var extent = this._extent;\n\t                // If extent start and end are same, expand them\n\t                if (extent[0] === extent[1]) {\n\t                    // Expand extent\n\t                    extent[0] -= ONE_DAY;\n\t                    extent[1] += ONE_DAY;\n\t                }\n\t                // If there are no data and extent are [Infinity, -Infinity]\n\t                if (extent[1] === -Infinity && extent[0] === Infinity) {\n\t                    var d = new Date();\n\t                    extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n\t                    extent[0] = extent[1] - ONE_DAY;\n\t                }\n\t                this.niceTicks(approxTickNum);\n\t                // var extent = this._extent;\n\t                var interval = this._interval;\n\t                if (!fixMin) {\n\t                    extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n\t                }\n\t                if (!fixMax) {\n\t                    extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n\t                }\n\t            },\n\t            niceTicks: function (approxTickNum) {\n\t                approxTickNum = approxTickNum || 10;\n\t                var extent = this._extent;\n\t                var span = extent[1] - extent[0];\n\t                var approxInterval = span / approxTickNum;\n\t                var scaleLevelsLen = scaleLevels.length;\n\t                var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\t                var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n\t                var interval = level[2];\n\t                // Same with interval scale if span is much larger than 1 year\n\t                if (level[0] === 'year') {\n\t                    var yearSpan = span / interval;\n\t                    // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t                    // var niceYearSpan = numberUtil.nice(yearSpan, false);\n\t                    var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\t                    interval *= yearStep;\n\t                }\n\t                var niceExtent = [\n\t                        mathCeil(extent[0] / interval) * interval,\n\t                        mathFloor(extent[1] / interval) * interval\n\t                    ];\n\t                this._stepLvl = level;\n\t                // Interval will be used in getTicks\n\t                this._interval = interval;\n\t                this._niceExtent = niceExtent;\n\t            },\n\t            parse: function (val) {\n\t                // val might be float.\n\t                return +numberUtil.parseDate(val);\n\t            }\n\t        });\n\t    zrUtil.each([\n\t        'contain',\n\t        'normalize'\n\t    ], function (methodName) {\n\t        TimeScale.prototype[methodName] = function (val) {\n\t            return intervalScaleProto[methodName].call(this, this.parse(val));\n\t        };\n\t    });\n\t    // Steps from d3\n\t    var scaleLevels = [\n\t            [\n\t                'hh:mm:ss',\n\t                1,\n\t                ONE_SECOND\n\t            ],\n\t            [\n\t                'hh:mm:ss',\n\t                5,\n\t                ONE_SECOND * 5\n\t            ],\n\t            [\n\t                'hh:mm:ss',\n\t                10,\n\t                ONE_SECOND * 10\n\t            ],\n\t            [\n\t                'hh:mm:ss',\n\t                15,\n\t                ONE_SECOND * 15\n\t            ],\n\t            [\n\t                'hh:mm:ss',\n\t                30,\n\t                ONE_SECOND * 30\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                1,\n\t                ONE_MINUTE\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                5,\n\t                ONE_MINUTE * 5\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                10,\n\t                ONE_MINUTE * 10\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                15,\n\t                ONE_MINUTE * 15\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                30,\n\t                ONE_MINUTE * 30\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                1,\n\t                ONE_HOUR\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                2,\n\t                ONE_HOUR * 2\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                6,\n\t                ONE_HOUR * 6\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                12,\n\t                ONE_HOUR * 12\n\t            ],\n\t            [\n\t                'MM-dd\\nyyyy',\n\t                1,\n\t                ONE_DAY\n\t            ],\n\t            [\n\t                'week',\n\t                7,\n\t                ONE_DAY * 7\n\t            ],\n\t            [\n\t                'month',\n\t                1,\n\t                ONE_DAY * 31\n\t            ],\n\t            [\n\t                'quarter',\n\t                3,\n\t                ONE_DAY * 380 / 4\n\t            ],\n\t            [\n\t                'half-year',\n\t                6,\n\t                ONE_DAY * 380 / 2\n\t            ],\n\t            [\n\t                'year',\n\t                1,\n\t                ONE_DAY * 380\n\t            ]\n\t        ];\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    TimeScale.create = function () {\n\t        return new TimeScale();\n\t    };\n\t    return TimeScale;\n\t});\n\tdefine('echarts/echarts', ['require', 'zrender/core/env', './model/Global', './ExtensionAPI', './CoordinateSystem', './model/OptionManager', './model/Component', './model/Series', './view/Component', './view/Chart', './util/graphic', 'zrender', 'zrender/core/util', 'zrender/tool/color', 'zrender/mixin/Eventful', 'zrender/core/timsort', './visual/seriesColor', './preprocessor/backwardCompat', './loading/default', './data/List', './model/Model', './util/number', './util/format', 'zrender/core/matrix', 'zrender/core/vector'], function (require) {\n\t    var env = require('zrender/core/env');\n\t    var GlobalModel = require('./model/Global');\n\t    var ExtensionAPI = require('./ExtensionAPI');\n\t    var CoordinateSystemManager = require('./CoordinateSystem');\n\t    var OptionManager = require('./model/OptionManager');\n\t    var ComponentModel = require('./model/Component');\n\t    var SeriesModel = require('./model/Series');\n\t    var ComponentView = require('./view/Component');\n\t    var ChartView = require('./view/Chart');\n\t    var graphic = require('./util/graphic');\n\t    var zrender = require('zrender');\n\t    var zrUtil = require('zrender/core/util');\n\t    var colorTool = require('zrender/tool/color');\n\t    var Eventful = require('zrender/mixin/Eventful');\n\t    var timsort = require('zrender/core/timsort');\n\t    var each = zrUtil.each;\n\t    var PRIORITY_PROCESSOR_FILTER = 1000;\n\t    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\t    var PRIORITY_VISUAL_LAYOUT = 1000;\n\t    var PRIORITY_VISUAL_GLOBAL = 2000;\n\t    var PRIORITY_VISUAL_CHART = 3000;\n\t    var PRIORITY_VISUAL_COMPONENT = 4000;\n\t    var PRIORITY_VISUAL_BRUSH = 5000;\n\t    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n\t    // where they must not be invoked nestedly, except the only case: invoke\n\t    // dispatchAction with updateMethod \"none\" in main process.\n\t    // This flag is used to carry out this rule.\n\t    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n\t    var IN_MAIN_PROCESS = '__flag_in_main_process';\n\t    var HAS_GRADIENT_OR_PATTERN_BG = '_hasGradientOrPatternBg';\n\t    var OPTION_UPDATED = '_optionUpdated';\n\t    function createRegisterEventWithLowercaseName(method) {\n\t        return function (eventName, handler, context) {\n\t            // Event name is all lowercase\n\t            eventName = eventName && eventName.toLowerCase();\n\t            Eventful.prototype[method].call(this, eventName, handler, context);\n\t        };\n\t    }\n\t    /**\n\t     * @module echarts~MessageCenter\n\t     */\n\t    function MessageCenter() {\n\t        Eventful.call(this);\n\t    }\n\t    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n\t    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n\t    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n\t    zrUtil.mixin(MessageCenter, Eventful);\n\t    /**\n\t     * @module echarts~ECharts\n\t     */\n\t    function ECharts(dom, theme, opts) {\n\t        opts = opts || {};\n\t        // Get theme by name\n\t        if (typeof theme === 'string') {\n\t            theme = themeStorage[theme];\n\t        }\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id;\n\t        /**\n\t         * Group id\n\t         * @type {string}\n\t         */\n\t        this.group;\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         * @private\n\t         */\n\t        this._dom = dom;\n\t        /**\n\t         * @type {module:zrender/ZRender}\n\t         * @private\n\t         */\n\t        this._zr = zrender.init(dom, {\n\t            renderer: opts.renderer || 'canvas',\n\t            devicePixelRatio: opts.devicePixelRatio\n\t        });\n\t        /**\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._theme = zrUtil.clone(theme);\n\t        /**\n\t         * @type {Array.<module:echarts/view/Chart>}\n\t         * @private\n\t         */\n\t        this._chartsViews = [];\n\t        /**\n\t         * @type {Object.<string, module:echarts/view/Chart>}\n\t         * @private\n\t         */\n\t        this._chartsMap = {};\n\t        /**\n\t         * @type {Array.<module:echarts/view/Component>}\n\t         * @private\n\t         */\n\t        this._componentsViews = [];\n\t        /**\n\t         * @type {Object.<string, module:echarts/view/Component>}\n\t         * @private\n\t         */\n\t        this._componentsMap = {};\n\t        /**\n\t         * @type {module:echarts/ExtensionAPI}\n\t         * @private\n\t         */\n\t        this._api = new ExtensionAPI(this);\n\t        /**\n\t         * @type {module:echarts/CoordinateSystem}\n\t         * @private\n\t         */\n\t        this._coordSysMgr = new CoordinateSystemManager();\n\t        Eventful.call(this);\n\t        /**\n\t         * @type {module:echarts~MessageCenter}\n\t         * @private\n\t         */\n\t        this._messageCenter = new MessageCenter();\n\t        // Init mouse events\n\t        this._initEvents();\n\t        // In case some people write `window.onresize = chart.resize`\n\t        this.resize = zrUtil.bind(this.resize, this);\n\t        // Can't dispatch action during rendering procedure\n\t        this._pendingActions = [];\n\t        // Sort on demand\n\t        function prioritySortFunc(a, b) {\n\t            return a.prio - b.prio;\n\t        }\n\t        timsort(visualFuncs, prioritySortFunc);\n\t        timsort(dataProcessorFuncs, prioritySortFunc);\n\t        this._zr.animation.on('frame', this._onframe, this);\n\t    }\n\t    var echartsProto = ECharts.prototype;\n\t    echartsProto._onframe = function () {\n\t        // Lazy update\n\t        if (this[OPTION_UPDATED]) {\n\t            this[IN_MAIN_PROCESS] = true;\n\t            updateMethods.prepareAndUpdate.call(this);\n\t            this[IN_MAIN_PROCESS] = false;\n\t            this[OPTION_UPDATED] = false;\n\t        }\n\t    };\n\t    /**\n\t     * @return {HTMLDomElement}\n\t     */\n\t    echartsProto.getDom = function () {\n\t        return this._dom;\n\t    };\n\t    /**\n\t     * @return {module:zrender~ZRender}\n\t     */\n\t    echartsProto.getZr = function () {\n\t        return this._zr;\n\t    };\n\t    /**\n\t     * @param {Object} option\n\t     * @param {boolean} notMerge\n\t     * @param {boolean} [lazyUpdate=false] Useful when setOption frequently.\n\t     */\n\t    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n\t        if (true) {\n\t            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n\t        }\n\t        this[IN_MAIN_PROCESS] = true;\n\t        if (!this._model || notMerge) {\n\t            var optionManager = new OptionManager(this._api);\n\t            var theme = this._theme;\n\t            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n\t            ecModel.init(null, null, theme, optionManager);\n\t        }\n\t        this._model.setOption(option, optionPreprocessorFuncs);\n\t        if (lazyUpdate) {\n\t            this[OPTION_UPDATED] = true;\n\t        } else {\n\t            updateMethods.prepareAndUpdate.call(this);\n\t            this._zr.refreshImmediately();\n\t            this[OPTION_UPDATED] = false;\n\t        }\n\t        this[IN_MAIN_PROCESS] = false;\n\t        this._flushPendingActions();\n\t    };\n\t    /**\n\t     * @DEPRECATED\n\t     */\n\t    echartsProto.setTheme = function () {\n\t        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n\t    };\n\t    /**\n\t     * @return {module:echarts/model/Global}\n\t     */\n\t    echartsProto.getModel = function () {\n\t        return this._model;\n\t    };\n\t    /**\n\t     * @return {Object}\n\t     */\n\t    echartsProto.getOption = function () {\n\t        return this._model && this._model.getOption();\n\t    };\n\t    /**\n\t     * @return {number}\n\t     */\n\t    echartsProto.getWidth = function () {\n\t        return this._zr.getWidth();\n\t    };\n\t    /**\n\t     * @return {number}\n\t     */\n\t    echartsProto.getHeight = function () {\n\t        return this._zr.getHeight();\n\t    };\n\t    /**\n\t     * Get canvas which has all thing rendered\n\t     * @param {Object} opts\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getRenderedCanvas = function (opts) {\n\t        if (!env.canvasSupported) {\n\t            return;\n\t        }\n\t        opts = opts || {};\n\t        opts.pixelRatio = opts.pixelRatio || 1;\n\t        opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');\n\t        var zr = this._zr;\n\t        var list = zr.storage.getDisplayList();\n\t        // Stop animations\n\t        zrUtil.each(list, function (el) {\n\t            el.stopAnimation(true);\n\t        });\n\t        return zr.painter.getRenderedCanvas(opts);\n\t    };\n\t    /**\n\t     * @return {string}\n\t     * @param {Object} opts\n\t     * @param {string} [opts.type='png']\n\t     * @param {string} [opts.pixelRatio=1]\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getDataURL = function (opts) {\n\t        opts = opts || {};\n\t        var excludeComponents = opts.excludeComponents;\n\t        var ecModel = this._model;\n\t        var excludesComponentViews = [];\n\t        var self = this;\n\t        each(excludeComponents, function (componentType) {\n\t            ecModel.eachComponent({ mainType: componentType }, function (component) {\n\t                var view = self._componentsMap[component.__viewId];\n\t                if (!view.group.ignore) {\n\t                    excludesComponentViews.push(view);\n\t                    view.group.ignore = true;\n\t                }\n\t            });\n\t        });\n\t        var url = this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));\n\t        each(excludesComponentViews, function (view) {\n\t            view.group.ignore = false;\n\t        });\n\t        return url;\n\t    };\n\t    /**\n\t     * @return {string}\n\t     * @param {Object} opts\n\t     * @param {string} [opts.type='png']\n\t     * @param {string} [opts.pixelRatio=1]\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getConnectedDataURL = function (opts) {\n\t        if (!env.canvasSupported) {\n\t            return;\n\t        }\n\t        var groupId = this.group;\n\t        var mathMin = Math.min;\n\t        var mathMax = Math.max;\n\t        var MAX_NUMBER = Infinity;\n\t        if (connectedGroups[groupId]) {\n\t            var left = MAX_NUMBER;\n\t            var top = MAX_NUMBER;\n\t            var right = -MAX_NUMBER;\n\t            var bottom = -MAX_NUMBER;\n\t            var canvasList = [];\n\t            var dpr = opts && opts.pixelRatio || 1;\n\t            for (var id in instances) {\n\t                var chart = instances[id];\n\t                if (chart.group === groupId) {\n\t                    var canvas = chart.getRenderedCanvas(zrUtil.clone(opts));\n\t                    var boundingRect = chart.getDom().getBoundingClientRect();\n\t                    left = mathMin(boundingRect.left, left);\n\t                    top = mathMin(boundingRect.top, top);\n\t                    right = mathMax(boundingRect.right, right);\n\t                    bottom = mathMax(boundingRect.bottom, bottom);\n\t                    canvasList.push({\n\t                        dom: canvas,\n\t                        left: boundingRect.left,\n\t                        top: boundingRect.top\n\t                    });\n\t                }\n\t            }\n\t            left *= dpr;\n\t            top *= dpr;\n\t            right *= dpr;\n\t            bottom *= dpr;\n\t            var width = right - left;\n\t            var height = bottom - top;\n\t            var targetCanvas = zrUtil.createCanvas();\n\t            targetCanvas.width = width;\n\t            targetCanvas.height = height;\n\t            var zr = zrender.init(targetCanvas);\n\t            each(canvasList, function (item) {\n\t                var img = new graphic.Image({\n\t                        style: {\n\t                            x: item.left * dpr - left,\n\t                            y: item.top * dpr - top,\n\t                            image: item.dom\n\t                        }\n\t                    });\n\t                zr.add(img);\n\t            });\n\t            zr.refreshImmediately();\n\t            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n\t        } else {\n\t            return this.getDataURL(opts);\n\t        }\n\t    };\n\t    var updateMethods = {\n\t            update: function (payload) {\n\t                // console.time && console.time('update');\n\t                var ecModel = this._model;\n\t                var api = this._api;\n\t                var coordSysMgr = this._coordSysMgr;\n\t                var zr = this._zr;\n\t                // update before setOption\n\t                if (!ecModel) {\n\t                    return;\n\t                }\n\t                // Fixme First time update ?\n\t                ecModel.restoreData();\n\t                // TODO\n\t                // Save total ecModel here for undo/redo (after restoring data and before processing data).\n\t                // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\t                // Create new coordinate system each update\n\t                // In LineView may save the old coordinate system and use it to get the orignal point\n\t                coordSysMgr.create(this._model, this._api);\n\t                processData.call(this, ecModel, api);\n\t                stackSeriesData.call(this, ecModel);\n\t                coordSysMgr.update(ecModel, api);\n\t                doVisualEncoding.call(this, ecModel, payload);\n\t                doRender.call(this, ecModel, payload);\n\t                // Set background\n\t                var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\t                var painter = zr.painter;\n\t                // TODO all use clearColor ?\n\t                if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n\t                    zr.configLayer(0, { clearColor: backgroundColor });\n\t                } else {\n\t                    // In IE8\n\t                    if (!env.canvasSupported) {\n\t                        var colorArr = colorTool.parse(backgroundColor);\n\t                        backgroundColor = colorTool.stringify(colorArr, 'rgb');\n\t                        if (colorArr[3] === 0) {\n\t                            backgroundColor = 'transparent';\n\t                        }\n\t                    }\n\t                    if (backgroundColor.colorStops || backgroundColor.image) {\n\t                        // Gradient background\n\t                        // FIXME Fixed layer？\n\t                        zr.configLayer(0, { clearColor: backgroundColor });\n\t                        this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\t                        this._dom.style.background = 'transparent';\n\t                    } else {\n\t                        if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n\t                            zr.configLayer(0, { clearColor: null });\n\t                        }\n\t                        this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\t                        this._dom.style.background = backgroundColor;\n\t                    }\n\t                }    // console.time && console.timeEnd('update');\n\t            },\n\t            updateView: function (payload) {\n\t                var ecModel = this._model;\n\t                // update before setOption\n\t                if (!ecModel) {\n\t                    return;\n\t                }\n\t                ecModel.eachSeries(function (seriesModel) {\n\t                    seriesModel.getData().clearAllVisual();\n\t                });\n\t                doVisualEncoding.call(this, ecModel, payload);\n\t                invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n\t            },\n\t            updateVisual: function (payload) {\n\t                var ecModel = this._model;\n\t                // update before setOption\n\t                if (!ecModel) {\n\t                    return;\n\t                }\n\t                ecModel.eachSeries(function (seriesModel) {\n\t                    seriesModel.getData().clearAllVisual();\n\t                });\n\t                doVisualEncoding.call(this, ecModel, payload);\n\t                invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n\t            },\n\t            updateLayout: function (payload) {\n\t                var ecModel = this._model;\n\t                // update before setOption\n\t                if (!ecModel) {\n\t                    return;\n\t                }\n\t                doLayout.call(this, ecModel, payload);\n\t                invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n\t            },\n\t            highlight: function (payload) {\n\t                toggleHighlight.call(this, 'highlight', payload);\n\t            },\n\t            downplay: function (payload) {\n\t                toggleHighlight.call(this, 'downplay', payload);\n\t            },\n\t            prepareAndUpdate: function (payload) {\n\t                var ecModel = this._model;\n\t                prepareView.call(this, 'component', ecModel);\n\t                prepareView.call(this, 'chart', ecModel);\n\t                updateMethods.update.call(this, payload);\n\t            }\n\t        };\n\t    /**\n\t     * @param {Object} payload\n\t     * @private\n\t     */\n\t    function toggleHighlight(method, payload) {\n\t        var ecModel = this._model;\n\t        // dispatchAction before setOption\n\t        if (!ecModel) {\n\t            return;\n\t        }\n\t        ecModel.eachComponent({\n\t            mainType: 'series',\n\t            query: payload\n\t        }, function (seriesModel, index) {\n\t            var chartView = this._chartsMap[seriesModel.__viewId];\n\t            if (chartView && chartView.__alive) {\n\t                chartView[method](seriesModel, ecModel, this._api, payload);\n\t            }\n\t        }, this);\n\t    }\n\t    /**\n\t     * Resize the chart\n\t     */\n\t    echartsProto.resize = function () {\n\t        if (true) {\n\t            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n\t        }\n\t        this[IN_MAIN_PROCESS] = true;\n\t        this._zr.resize();\n\t        var optionChanged = this._model && this._model.resetOption('media');\n\t        updateMethods[optionChanged ? 'prepareAndUpdate' : 'update'].call(this);\n\t        // Resize loading effect\n\t        this._loadingFX && this._loadingFX.resize();\n\t        this[IN_MAIN_PROCESS] = false;\n\t        this._flushPendingActions();\n\t    };\n\t    /**\n\t     * Show loading effect\n\t     * @param  {string} [name='default']\n\t     * @param  {Object} [cfg]\n\t     */\n\t    echartsProto.showLoading = function (name, cfg) {\n\t        if (zrUtil.isObject(name)) {\n\t            cfg = name;\n\t            name = '';\n\t        }\n\t        name = name || 'default';\n\t        this.hideLoading();\n\t        if (!loadingEffects[name]) {\n\t            if (true) {\n\t                console.warn('Loading effects ' + name + ' not exists.');\n\t            }\n\t            return;\n\t        }\n\t        var el = loadingEffects[name](this._api, cfg);\n\t        var zr = this._zr;\n\t        this._loadingFX = el;\n\t        zr.add(el);\n\t    };\n\t    /**\n\t     * Hide loading effect\n\t     */\n\t    echartsProto.hideLoading = function () {\n\t        this._loadingFX && this._zr.remove(this._loadingFX);\n\t        this._loadingFX = null;\n\t    };\n\t    /**\n\t     * @param {Object} eventObj\n\t     * @return {Object}\n\t     */\n\t    echartsProto.makeActionFromEvent = function (eventObj) {\n\t        var payload = zrUtil.extend({}, eventObj);\n\t        payload.type = eventActionMap[eventObj.type];\n\t        return payload;\n\t    };\n\t    /**\n\t     * @pubilc\n\t     * @param {Object} payload\n\t     * @param {string} [payload.type] Action type\n\t     * @param {boolean} [silent=false] Whether trigger event.\n\t     */\n\t    echartsProto.dispatchAction = function (payload, silent) {\n\t        var actionWrap = actions[payload.type];\n\t        if (!actionWrap) {\n\t            return;\n\t        }\n\t        var actionInfo = actionWrap.actionInfo;\n\t        var updateMethod = actionInfo.update || 'update';\n\t        // if (__DEV__) {\n\t        //     zrUtil.assert(\n\t        //         !this[IN_MAIN_PROCESS],\n\t        //         '`dispatchAction` should not be called during main process.'\n\t        //         + 'unless updateMathod is \"none\".'\n\t        //     );\n\t        // }\n\t        // May dispatchAction in rendering procedure\n\t        if (this[IN_MAIN_PROCESS]) {\n\t            this._pendingActions.push(payload);\n\t            return;\n\t        }\n\t        this[IN_MAIN_PROCESS] = true;\n\t        var payloads = [payload];\n\t        var batched = false;\n\t        // Batch action\n\t        if (payload.batch) {\n\t            batched = true;\n\t            payloads = zrUtil.map(payload.batch, function (item) {\n\t                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n\t                item.batch = null;\n\t                return item;\n\t            });\n\t        }\n\t        var eventObjBatch = [];\n\t        var eventObj;\n\t        var isHighlightOrDownplay = payload.type === 'highlight' || payload.type === 'downplay';\n\t        for (var i = 0; i < payloads.length; i++) {\n\t            var batchItem = payloads[i];\n\t            // Action can specify the event by return it.\n\t            eventObj = actionWrap.action(batchItem, this._model);\n\t            // Emit event outside\n\t            eventObj = eventObj || zrUtil.extend({}, batchItem);\n\t            // Convert type to eventType\n\t            eventObj.type = actionInfo.event || eventObj.type;\n\t            eventObjBatch.push(eventObj);\n\t            // Highlight and downplay are special.\n\t            isHighlightOrDownplay && updateMethods[updateMethod].call(this, batchItem);\n\t        }\n\t        if (updateMethod !== 'none' && !isHighlightOrDownplay) {\n\t            // Still dirty\n\t            if (this[OPTION_UPDATED]) {\n\t                // FIXME Pass payload ?\n\t                updateMethods.prepareAndUpdate.call(this, payload);\n\t                this[OPTION_UPDATED] = false;\n\t            } else {\n\t                updateMethods[updateMethod].call(this, payload);\n\t            }\n\t        }\n\t        // Follow the rule of action batch\n\t        if (batched) {\n\t            eventObj = {\n\t                type: actionInfo.event || payload.type,\n\t                batch: eventObjBatch\n\t            };\n\t        } else {\n\t            eventObj = eventObjBatch[0];\n\t        }\n\t        this[IN_MAIN_PROCESS] = false;\n\t        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n\t        this._flushPendingActions();\n\t    };\n\t    echartsProto._flushPendingActions = function () {\n\t        var pendingActions = this._pendingActions;\n\t        while (pendingActions.length) {\n\t            var payload = pendingActions.shift();\n\t            this.dispatchAction(payload);\n\t        }\n\t    };\n\t    /**\n\t     * Register event\n\t     * @method\n\t     */\n\t    echartsProto.on = createRegisterEventWithLowercaseName('on');\n\t    echartsProto.off = createRegisterEventWithLowercaseName('off');\n\t    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\t    /**\n\t     * @param {string} methodName\n\t     * @private\n\t     */\n\t    function invokeUpdateMethod(methodName, ecModel, payload) {\n\t        var api = this._api;\n\t        // Update all components\n\t        each(this._componentsViews, function (component) {\n\t            var componentModel = component.__model;\n\t            component[methodName](componentModel, ecModel, api, payload);\n\t            updateZ(componentModel, component);\n\t        }, this);\n\t        // Upate all charts\n\t        ecModel.eachSeries(function (seriesModel, idx) {\n\t            var chart = this._chartsMap[seriesModel.__viewId];\n\t            chart[methodName](seriesModel, ecModel, api, payload);\n\t            updateZ(seriesModel, chart);\n\t            updateProgressiveAndBlend(seriesModel, chart);\n\t        }, this);\n\t        // If use hover layer\n\t        updateHoverLayerStatus(this._zr, ecModel);\n\t    }\n\t    /**\n\t     * Prepare view instances of charts and components\n\t     * @param  {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function prepareView(type, ecModel) {\n\t        var isComponent = type === 'component';\n\t        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n\t        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n\t        var zr = this._zr;\n\t        for (var i = 0; i < viewList.length; i++) {\n\t            viewList[i].__alive = false;\n\t        }\n\t        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n\t            if (isComponent) {\n\t                if (componentType === 'series') {\n\t                    return;\n\t                }\n\t            } else {\n\t                model = componentType;\n\t            }\n\t            // Consider: id same and type changed.\n\t            var viewId = model.id + '_' + model.type;\n\t            var view = viewMap[viewId];\n\t            if (!view) {\n\t                var classType = ComponentModel.parseClassType(model.type);\n\t                var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);\n\t                if (Clazz) {\n\t                    view = new Clazz();\n\t                    view.init(ecModel, this._api);\n\t                    viewMap[viewId] = view;\n\t                    viewList.push(view);\n\t                    zr.add(view.group);\n\t                } else {\n\t                    // Error\n\t                    return;\n\t                }\n\t            }\n\t            model.__viewId = viewId;\n\t            view.__alive = true;\n\t            view.__id = viewId;\n\t            view.__model = model;\n\t        }, this);\n\t        for (var i = 0; i < viewList.length;) {\n\t            var view = viewList[i];\n\t            if (!view.__alive) {\n\t                zr.remove(view.group);\n\t                view.dispose(ecModel, this._api);\n\t                viewList.splice(i, 1);\n\t                delete viewMap[view.__id];\n\t            } else {\n\t                i++;\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * Processor data in each series\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function processData(ecModel, api) {\n\t        each(dataProcessorFuncs, function (process) {\n\t            process.func(ecModel, api);\n\t        });\n\t    }\n\t    /**\n\t     * @private\n\t     */\n\t    function stackSeriesData(ecModel) {\n\t        var stackedDataMap = {};\n\t        ecModel.eachSeries(function (series) {\n\t            var stack = series.get('stack');\n\t            var data = series.getData();\n\t            if (stack && data.type === 'list') {\n\t                var previousStack = stackedDataMap[stack];\n\t                if (previousStack) {\n\t                    data.stackedOn = previousStack;\n\t                }\n\t                stackedDataMap[stack] = data;\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * Layout before each chart render there series, special visual encoding stage\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function doLayout(ecModel, payload) {\n\t        var api = this._api;\n\t        each(visualFuncs, function (visual) {\n\t            if (visual.isLayout) {\n\t                visual.func(ecModel, api, payload);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * Encode visual infomation from data after data processing\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function doVisualEncoding(ecModel, payload) {\n\t        var api = this._api;\n\t        ecModel.clearColorPalette();\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            seriesModel.clearColorPalette();\n\t        });\n\t        each(visualFuncs, function (visual) {\n\t            visual.func(ecModel, api, payload);\n\t        });\n\t    }\n\t    /**\n\t     * Render each chart and component\n\t     * @private\n\t     */\n\t    function doRender(ecModel, payload) {\n\t        var api = this._api;\n\t        // Render all components\n\t        each(this._componentsViews, function (componentView) {\n\t            var componentModel = componentView.__model;\n\t            componentView.render(componentModel, ecModel, api, payload);\n\t            updateZ(componentModel, componentView);\n\t        }, this);\n\t        each(this._chartsViews, function (chart) {\n\t            chart.__alive = false;\n\t        }, this);\n\t        // Render all charts\n\t        ecModel.eachSeries(function (seriesModel, idx) {\n\t            var chartView = this._chartsMap[seriesModel.__viewId];\n\t            chartView.__alive = true;\n\t            chartView.render(seriesModel, ecModel, api, payload);\n\t            chartView.group.silent = !!seriesModel.get('silent');\n\t            updateZ(seriesModel, chartView);\n\t            updateProgressiveAndBlend(seriesModel, chartView);\n\t        }, this);\n\t        // If use hover layer\n\t        updateHoverLayerStatus(this._zr, ecModel);\n\t        // Remove groups of unrendered charts\n\t        each(this._chartsViews, function (chart) {\n\t            if (!chart.__alive) {\n\t                chart.remove(ecModel, api);\n\t            }\n\t        }, this);\n\t    }\n\t    var MOUSE_EVENT_NAMES = [\n\t            'click',\n\t            'dblclick',\n\t            'mouseover',\n\t            'mouseout',\n\t            'mousemove',\n\t            'mousedown',\n\t            'mouseup',\n\t            'globalout'\n\t        ];\n\t    /**\n\t     * @private\n\t     */\n\t    echartsProto._initEvents = function () {\n\t        each(MOUSE_EVENT_NAMES, function (eveName) {\n\t            this._zr.on(eveName, function (e) {\n\t                var ecModel = this.getModel();\n\t                var el = e.target;\n\t                if (el && el.dataIndex != null) {\n\t                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n\t                    var params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n\t                    params.event = e;\n\t                    params.type = eveName;\n\t                    this.trigger(eveName, params);\n\t                }    // If element has custom eventData of components\n\t                else if (el && el.eventData) {\n\t                    this.trigger(eveName, el.eventData);\n\t                }\n\t            }, this);\n\t        }, this);\n\t        each(eventActionMap, function (actionType, eventType) {\n\t            this._messageCenter.on(eventType, function (event) {\n\t                this.trigger(eventType, event);\n\t            }, this);\n\t        }, this);\n\t    };\n\t    /**\n\t     * @return {boolean}\n\t     */\n\t    echartsProto.isDisposed = function () {\n\t        return this._disposed;\n\t    };\n\t    /**\n\t     * Clear\n\t     */\n\t    echartsProto.clear = function () {\n\t        this.setOption({ series: [] }, true);\n\t    };\n\t    /**\n\t     * Dispose instance\n\t     */\n\t    echartsProto.dispose = function () {\n\t        if (this._disposed) {\n\t            if (true) {\n\t                console.warn('Instance ' + this.id + ' has been disposed');\n\t            }\n\t            return;\n\t        }\n\t        this._disposed = true;\n\t        var api = this._api;\n\t        var ecModel = this._model;\n\t        each(this._componentsViews, function (component) {\n\t            component.dispose(ecModel, api);\n\t        });\n\t        each(this._chartsViews, function (chart) {\n\t            chart.dispose(ecModel, api);\n\t        });\n\t        // Dispose after all views disposed\n\t        this._zr.dispose();\n\t        delete instances[this.id];\n\t    };\n\t    zrUtil.mixin(ECharts, Eventful);\n\t    function updateHoverLayerStatus(zr, ecModel) {\n\t        var storage = zr.storage;\n\t        var elCount = 0;\n\t        storage.traverse(function (el) {\n\t            if (!el.isGroup) {\n\t                elCount++;\n\t            }\n\t        });\n\t        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n\t            storage.traverse(function (el) {\n\t                if (!el.isGroup) {\n\t                    el.useHoverLayer = true;\n\t                }\n\t            });\n\t        }\n\t    }\n\t    /**\n\t     * Update chart progressive and blend.\n\t     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n\t     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n\t     */\n\t    function updateProgressiveAndBlend(seriesModel, chartView) {\n\t        // Progressive configuration\n\t        var elCount = 0;\n\t        chartView.group.traverse(function (el) {\n\t            if (el.type !== 'group' && !el.ignore) {\n\t                elCount++;\n\t            }\n\t        });\n\t        var frameDrawNum = +seriesModel.get('progressive');\n\t        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n\t        if (needProgressive) {\n\t            chartView.group.traverse(function (el) {\n\t                // FIXME marker and other components\n\t                if (!el.isGroup) {\n\t                    el.progressive = needProgressive ? Math.floor(elCount++ / frameDrawNum) : -1;\n\t                    if (needProgressive) {\n\t                        el.stopAnimation(true);\n\t                    }\n\t                }\n\t            });\n\t        }\n\t        // Blend configration\n\t        var blendMode = seriesModel.get('blendMode') || null;\n\t        if (true) {\n\t            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n\t                console.warn('Only canvas support blendMode');\n\t            }\n\t        }\n\t        chartView.group.traverse(function (el) {\n\t            // FIXME marker and other components\n\t            if (!el.isGroup) {\n\t                el.setStyle('blend', blendMode);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n\t     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n\t     */\n\t    function updateZ(model, view) {\n\t        var z = model.get('z');\n\t        var zlevel = model.get('zlevel');\n\t        // Set z and zlevel\n\t        view.group.traverse(function (el) {\n\t            if (el.type !== 'group') {\n\t                z != null && (el.z = z);\n\t                zlevel != null && (el.zlevel = zlevel);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * @type {Array.<Function>}\n\t     * @inner\n\t     */\n\t    var actions = [];\n\t    /**\n\t     * Map eventType to actionType\n\t     * @type {Object}\n\t     */\n\t    var eventActionMap = {};\n\t    /**\n\t     * Data processor functions of each stage\n\t     * @type {Array.<Object.<string, Function>>}\n\t     * @inner\n\t     */\n\t    var dataProcessorFuncs = [];\n\t    /**\n\t     * @type {Array.<Function>}\n\t     * @inner\n\t     */\n\t    var optionPreprocessorFuncs = [];\n\t    /**\n\t     * Visual encoding functions of each stage\n\t     * @type {Array.<Object.<string, Function>>}\n\t     * @inner\n\t     */\n\t    var visualFuncs = [];\n\t    /**\n\t     * Theme storage\n\t     * @type {Object.<key, Object>}\n\t     */\n\t    var themeStorage = {};\n\t    /**\n\t     * Loading effects\n\t     */\n\t    var loadingEffects = {};\n\t    var instances = {};\n\t    var connectedGroups = {};\n\t    var idBase = new Date() - 0;\n\t    var groupIdBase = new Date() - 0;\n\t    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n\t    /**\n\t     * @alias module:echarts\n\t     */\n\t    var echarts = {\n\t            version: '3.2.3',\n\t            dependencies: { zrender: '3.1.3' }\n\t        };\n\t    function enableConnect(chart) {\n\t        var STATUS_PENDING = 0;\n\t        var STATUS_UPDATING = 1;\n\t        var STATUS_UPDATED = 2;\n\t        var STATUS_KEY = '__connectUpdateStatus';\n\t        function updateConnectedChartsStatus(charts, status) {\n\t            for (var i = 0; i < charts.length; i++) {\n\t                var otherChart = charts[i];\n\t                otherChart[STATUS_KEY] = status;\n\t            }\n\t        }\n\t        zrUtil.each(eventActionMap, function (actionType, eventType) {\n\t            chart._messageCenter.on(eventType, function (event) {\n\t                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n\t                    var action = chart.makeActionFromEvent(event);\n\t                    var otherCharts = [];\n\t                    for (var id in instances) {\n\t                        var otherChart = instances[id];\n\t                        if (otherChart !== chart && otherChart.group === chart.group) {\n\t                            otherCharts.push(otherChart);\n\t                        }\n\t                    }\n\t                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n\t                    each(otherCharts, function (otherChart) {\n\t                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n\t                            otherChart.dispatchAction(action);\n\t                        }\n\t                    });\n\t                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n\t                }\n\t            });\n\t        });\n\t    }\n\t    /**\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} [theme]\n\t     * @param {Object} opts\n\t     */\n\t    echarts.init = function (dom, theme, opts) {\n\t        if (true) {\n\t            // Check version\n\t            if (zrender.version.replace('.', '') - 0 < echarts.dependencies.zrender.replace('.', '') - 0) {\n\t                throw new Error('ZRender ' + zrender.version + ' is too old for ECharts ' + echarts.version + '. Current version need ZRender ' + echarts.dependencies.zrender + '+');\n\t            }\n\t            if (!dom) {\n\t                throw new Error('Initialize failed: invalid dom.');\n\t            }\n\t            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {\n\t                console.warn('Can\\'t get dom width or height');\n\t            }\n\t        }\n\t        var chart = new ECharts(dom, theme, opts);\n\t        chart.id = 'ec_' + idBase++;\n\t        instances[chart.id] = chart;\n\t        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n\t        enableConnect(chart);\n\t        return chart;\n\t    };\n\t    /**\n\t     * @return {string|Array.<module:echarts~ECharts>} groupId\n\t     */\n\t    echarts.connect = function (groupId) {\n\t        // Is array of charts\n\t        if (zrUtil.isArray(groupId)) {\n\t            var charts = groupId;\n\t            groupId = null;\n\t            // If any chart has group\n\t            zrUtil.each(charts, function (chart) {\n\t                if (chart.group != null) {\n\t                    groupId = chart.group;\n\t                }\n\t            });\n\t            groupId = groupId || 'g_' + groupIdBase++;\n\t            zrUtil.each(charts, function (chart) {\n\t                chart.group = groupId;\n\t            });\n\t        }\n\t        connectedGroups[groupId] = true;\n\t        return groupId;\n\t    };\n\t    /**\n\t     * @return {string} groupId\n\t     */\n\t    echarts.disConnect = function (groupId) {\n\t        connectedGroups[groupId] = false;\n\t    };\n\t    /**\n\t     * Dispose a chart instance\n\t     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n\t     */\n\t    echarts.dispose = function (chart) {\n\t        if (zrUtil.isDom(chart)) {\n\t            chart = echarts.getInstanceByDom(chart);\n\t        } else if (typeof chart === 'string') {\n\t            chart = instances[chart];\n\t        }\n\t        if (chart instanceof ECharts && !chart.isDisposed()) {\n\t            chart.dispose();\n\t        }\n\t    };\n\t    /**\n\t     * @param  {HTMLDomElement} dom\n\t     * @return {echarts~ECharts}\n\t     */\n\t    echarts.getInstanceByDom = function (dom) {\n\t        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n\t        return instances[key];\n\t    };\n\t    /**\n\t     * @param {string} key\n\t     * @return {echarts~ECharts}\n\t     */\n\t    echarts.getInstanceById = function (key) {\n\t        return instances[key];\n\t    };\n\t    /**\n\t     * Register theme\n\t     */\n\t    echarts.registerTheme = function (name, theme) {\n\t        themeStorage[name] = theme;\n\t    };\n\t    /**\n\t     * Register option preprocessor\n\t     * @param {Function} preprocessorFunc\n\t     */\n\t    echarts.registerPreprocessor = function (preprocessorFunc) {\n\t        optionPreprocessorFuncs.push(preprocessorFunc);\n\t    };\n\t    /**\n\t     * @param {number} [priority=1000]\n\t     * @param {Function} processorFunc\n\t     */\n\t    echarts.registerProcessor = function (priority, processorFunc) {\n\t        if (typeof priority === 'function') {\n\t            processorFunc = priority;\n\t            priority = PRIORITY_PROCESSOR_FILTER;\n\t        }\n\t        if (true) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown processor priority');\n\t            }\n\t        }\n\t        dataProcessorFuncs.push({\n\t            prio: priority,\n\t            func: processorFunc\n\t        });\n\t    };\n\t    /**\n\t     * Usage:\n\t     * registerAction('someAction', 'someEvent', function () { ... });\n\t     * registerAction('someAction', function () { ... });\n\t     * registerAction(\n\t     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n\t     *     function () { ... }\n\t     * );\n\t     *\n\t     * @param {(string|Object)} actionInfo\n\t     * @param {string} actionInfo.type\n\t     * @param {string} [actionInfo.event]\n\t     * @param {string} [actionInfo.update]\n\t     * @param {string} [eventName]\n\t     * @param {Function} action\n\t     */\n\t    echarts.registerAction = function (actionInfo, eventName, action) {\n\t        if (typeof eventName === 'function') {\n\t            action = eventName;\n\t            eventName = '';\n\t        }\n\t        var actionType = zrUtil.isObject(actionInfo) ? actionInfo.type : [\n\t                actionInfo,\n\t                actionInfo = { event: eventName }\n\t            ][0];\n\t        // Event name is all lowercase\n\t        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n\t        eventName = actionInfo.event;\n\t        if (!actions[actionType]) {\n\t            actions[actionType] = {\n\t                action: action,\n\t                actionInfo: actionInfo\n\t            };\n\t        }\n\t        eventActionMap[eventName] = actionType;\n\t    };\n\t    /**\n\t     * @param {string} type\n\t     * @param {*} CoordinateSystem\n\t     */\n\t    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n\t        CoordinateSystemManager.register(type, CoordinateSystem);\n\t    };\n\t    /**\n\t     * Layout is a special stage of visual encoding\n\t     * Most visual encoding like color are common for different chart\n\t     * But each chart has it's own layout algorithm\n\t     *\n\t     * @param {number} [priority=1000]\n\t     * @param {Function} layoutFunc\n\t     */\n\t    echarts.registerLayout = function (priority, layoutFunc) {\n\t        if (typeof priority === 'function') {\n\t            layoutFunc = priority;\n\t            priority = PRIORITY_VISUAL_LAYOUT;\n\t        }\n\t        if (true) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown layout priority');\n\t            }\n\t        }\n\t        visualFuncs.push({\n\t            prio: priority,\n\t            func: layoutFunc,\n\t            isLayout: true\n\t        });\n\t    };\n\t    /**\n\t     * @param {number} [priority=3000]\n\t     * @param {Function} visualFunc\n\t     */\n\t    echarts.registerVisual = function (priority, visualFunc) {\n\t        if (typeof priority === 'function') {\n\t            visualFunc = priority;\n\t            priority = PRIORITY_VISUAL_CHART;\n\t        }\n\t        if (true) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown visual priority');\n\t            }\n\t        }\n\t        visualFuncs.push({\n\t            prio: priority,\n\t            func: visualFunc\n\t        });\n\t    };\n\t    /**\n\t     * @param {string} name\n\t     */\n\t    echarts.registerLoading = function (name, loadingFx) {\n\t        loadingEffects[name] = loadingFx;\n\t    };\n\t    var parseClassType = ComponentModel.parseClassType;\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendComponentModel = function (opts, superClass) {\n\t        var Clazz = ComponentModel;\n\t        if (superClass) {\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendComponentView = function (opts, superClass) {\n\t        var Clazz = ComponentView;\n\t        if (superClass) {\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendSeriesModel = function (opts, superClass) {\n\t        var Clazz = SeriesModel;\n\t        if (superClass) {\n\t            superClass = 'series.' + superClass.replace('series.', '');\n\t            var classType = parseClassType(superClass);\n\t            Clazz = SeriesModel.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendChartView = function (opts, superClass) {\n\t        var Clazz = ChartView;\n\t        if (superClass) {\n\t            superClass.replace('series.', '');\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ChartView.getClass(classType.main, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t    /**\n\t     * ZRender need a canvas context to do measureText.\n\t     * But in node environment canvas may be created by node-canvas.\n\t     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n\t     *\n\t     * Be careful of using it in the browser.\n\t     *\n\t     * @param {Function} creator\n\t     * @example\n\t     *     var Canvas = require('canvas');\n\t     *     var echarts = require('echarts');\n\t     *     echarts.setCanvasCreator(function () {\n\t     *         // Small size is enough.\n\t     *         return new Canvas(32, 32);\n\t     *     });\n\t     */\n\t    echarts.setCanvasCreator = function (creator) {\n\t        zrUtil.createCanvas = creator;\n\t    };\n\t    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, require('./visual/seriesColor'));\n\t    echarts.registerPreprocessor(require('./preprocessor/backwardCompat'));\n\t    echarts.registerLoading('default', require('./loading/default'));\n\t    // Default action\n\t    echarts.registerAction({\n\t        type: 'highlight',\n\t        event: 'highlight',\n\t        update: 'highlight'\n\t    }, zrUtil.noop);\n\t    echarts.registerAction({\n\t        type: 'downplay',\n\t        event: 'downplay',\n\t        update: 'downplay'\n\t    }, zrUtil.noop);\n\t    // --------\n\t    // Exports\n\t    // --------\n\t    //\n\t    echarts.List = require('./data/List');\n\t    echarts.Model = require('./model/Model');\n\t    echarts.graphic = require('./util/graphic');\n\t    echarts.number = require('./util/number');\n\t    echarts.format = require('./util/format');\n\t    echarts.matrix = require('zrender/core/matrix');\n\t    echarts.vector = require('zrender/core/vector');\n\t    echarts.color = require('zrender/tool/color');\n\t    echarts.util = {};\n\t    each([\n\t        'map',\n\t        'each',\n\t        'filter',\n\t        'indexOf',\n\t        'inherits',\n\t        'reduce',\n\t        'filter',\n\t        'bind',\n\t        'curry',\n\t        'isArray',\n\t        'isString',\n\t        'isObject',\n\t        'isFunction',\n\t        'extend',\n\t        'defaults'\n\t    ], function (name) {\n\t        echarts.util[name] = zrUtil[name];\n\t    });\n\t    // PRIORITY\n\t    echarts.PRIORITY = {\n\t        PROCESSOR: {\n\t            FILTER: PRIORITY_PROCESSOR_FILTER,\n\t            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n\t        },\n\t        VISUAL: {\n\t            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n\t            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n\t            CHART: PRIORITY_VISUAL_CHART,\n\t            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n\t            BRUSH: PRIORITY_VISUAL_BRUSH\n\t        }\n\t    };\n\t    return echarts;\n\t});\n\tdefine('echarts/scale/Log', ['require', 'zrender/core/util', './Scale', '../util/number', './Interval'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var Scale = require('./Scale');\n\t    var numberUtil = require('../util/number');\n\t    // Use some method of IntervalScale\n\t    var IntervalScale = require('./Interval');\n\t    var scaleProto = Scale.prototype;\n\t    var intervalScaleProto = IntervalScale.prototype;\n\t    var mathFloor = Math.floor;\n\t    var mathCeil = Math.ceil;\n\t    var mathPow = Math.pow;\n\t    var mathLog = Math.log;\n\t    var LogScale = Scale.extend({\n\t            type: 'log',\n\t            base: 10,\n\t            getTicks: function () {\n\t                return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n\t                    return numberUtil.round(mathPow(this.base, val));\n\t                }, this);\n\t            },\n\t            getLabel: intervalScaleProto.getLabel,\n\t            scale: function (val) {\n\t                val = scaleProto.scale.call(this, val);\n\t                return mathPow(this.base, val);\n\t            },\n\t            setExtent: function (start, end) {\n\t                var base = this.base;\n\t                start = mathLog(start) / mathLog(base);\n\t                end = mathLog(end) / mathLog(base);\n\t                intervalScaleProto.setExtent.call(this, start, end);\n\t            },\n\t            getExtent: function () {\n\t                var base = this.base;\n\t                var extent = scaleProto.getExtent.call(this);\n\t                extent[0] = mathPow(base, extent[0]);\n\t                extent[1] = mathPow(base, extent[1]);\n\t                return extent;\n\t            },\n\t            unionExtent: function (extent) {\n\t                var base = this.base;\n\t                extent[0] = mathLog(extent[0]) / mathLog(base);\n\t                extent[1] = mathLog(extent[1]) / mathLog(base);\n\t                scaleProto.unionExtent.call(this, extent);\n\t            },\n\t            niceTicks: function (approxTickNum) {\n\t                approxTickNum = approxTickNum || 10;\n\t                var extent = this._extent;\n\t                var span = extent[1] - extent[0];\n\t                if (span === Infinity || span <= 0) {\n\t                    return;\n\t                }\n\t                var interval = numberUtil.quantity(span);\n\t                var err = approxTickNum / span * interval;\n\t                // Filter ticks to get closer to the desired count.\n\t                if (err <= 0.5) {\n\t                    interval *= 10;\n\t                }\n\t                // Interval should be integer\n\t                while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n\t                    interval *= 10;\n\t                }\n\t                var niceExtent = [\n\t                        numberUtil.round(mathCeil(extent[0] / interval) * interval),\n\t                        numberUtil.round(mathFloor(extent[1] / interval) * interval)\n\t                    ];\n\t                this._interval = interval;\n\t                this._niceExtent = niceExtent;\n\t            },\n\t            niceExtent: intervalScaleProto.niceExtent\n\t        });\n\t    zrUtil.each([\n\t        'contain',\n\t        'normalize'\n\t    ], function (methodName) {\n\t        LogScale.prototype[methodName] = function (val) {\n\t            val = mathLog(val) / mathLog(this.base);\n\t            return scaleProto[methodName].call(this, val);\n\t        };\n\t    });\n\t    LogScale.create = function () {\n\t        return new LogScale();\n\t    };\n\t    return LogScale;\n\t});\n\tdefine('echarts/chart/pie/PieView', ['require', '../../util/graphic', 'zrender/core/util', '../../view/Chart'], function (require) {\n\t    var graphic = require('../../util/graphic');\n\t    var zrUtil = require('zrender/core/util');\n\t    /**\n\t     * @param {module:echarts/model/Series} seriesModel\n\t     * @param {boolean} hasAnimation\n\t     * @inner\n\t     */\n\t    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n\t        var data = seriesModel.getData();\n\t        var dataIndex = this.dataIndex;\n\t        var name = data.getName(dataIndex);\n\t        var selectedOffset = seriesModel.get('selectedOffset');\n\t        api.dispatchAction({\n\t            type: 'pieToggleSelect',\n\t            from: uid,\n\t            name: name,\n\t            seriesId: seriesModel.id\n\t        });\n\t        data.each(function (idx) {\n\t            toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n\t        });\n\t    }\n\t    /**\n\t     * @param {module:zrender/graphic/Sector} el\n\t     * @param {Object} layout\n\t     * @param {boolean} isSelected\n\t     * @param {number} selectedOffset\n\t     * @param {boolean} hasAnimation\n\t     * @inner\n\t     */\n\t    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n\t        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\t        var dx = Math.cos(midAngle);\n\t        var dy = Math.sin(midAngle);\n\t        var offset = isSelected ? selectedOffset : 0;\n\t        var position = [\n\t                dx * offset,\n\t                dy * offset\n\t            ];\n\t        hasAnimation ? el.animate().when(200, { position: position }).start('bounceOut') : el.attr('position', position);\n\t    }\n\t    /**\n\t     * Piece of pie including Sector, Label, LabelLine\n\t     * @constructor\n\t     * @extends {module:zrender/graphic/Group}\n\t     */\n\t    function PiePiece(data, idx) {\n\t        graphic.Group.call(this);\n\t        var sector = new graphic.Sector({ z2: 2 });\n\t        var polyline = new graphic.Polyline();\n\t        var text = new graphic.Text();\n\t        this.add(sector);\n\t        this.add(polyline);\n\t        this.add(text);\n\t        this.updateData(data, idx, true);\n\t        // Hover to change label and labelLine\n\t        function onEmphasis() {\n\t            polyline.ignore = polyline.hoverIgnore;\n\t            text.ignore = text.hoverIgnore;\n\t        }\n\t        function onNormal() {\n\t            polyline.ignore = polyline.normalIgnore;\n\t            text.ignore = text.normalIgnore;\n\t        }\n\t        this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n\t    }\n\t    var piePieceProto = PiePiece.prototype;\n\t    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n\t        var textStyleModel = labelModel.getModel('textStyle');\n\t        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\t        return {\n\t            fill: textStyleModel.getTextColor() || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n\t            opacity: data.getItemVisual(idx, 'opacity'),\n\t            textFont: textStyleModel.getFont(),\n\t            text: zrUtil.retrieve(data.hostModel.getFormattedLabel(idx, state), data.getName(idx))\n\t        };\n\t    }\n\t    piePieceProto.updateData = function (data, idx, firstCreate) {\n\t        var sector = this.childAt(0);\n\t        var seriesModel = data.hostModel;\n\t        var itemModel = data.getItemModel(idx);\n\t        var layout = data.getItemLayout(idx);\n\t        var sectorShape = zrUtil.extend({}, layout);\n\t        sectorShape.label = null;\n\t        if (firstCreate) {\n\t            sector.setShape(sectorShape);\n\t            sector.shape.endAngle = layout.startAngle;\n\t            graphic.updateProps(sector, { shape: { endAngle: layout.endAngle } }, seriesModel, idx);\n\t        } else {\n\t            graphic.updateProps(sector, { shape: sectorShape }, seriesModel, idx);\n\t        }\n\t        // Update common style\n\t        var itemStyleModel = itemModel.getModel('itemStyle');\n\t        var visualColor = data.getItemVisual(idx, 'color');\n\t        sector.useStyle(zrUtil.defaults({\n\t            lineJoin: 'bevel',\n\t            fill: visualColor\n\t        }, itemStyleModel.getModel('normal').getItemStyle()));\n\t        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\t        // Toggle selected\n\t        toggleItemSelected(this, data.getItemLayout(idx), itemModel.get('selected'), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n\t        function onEmphasis() {\n\t            // Sector may has animation of updating data. Force to move to the last frame\n\t            // Or it may stopped on the wrong shape\n\t            sector.stopAnimation(true);\n\t            sector.animateTo({ shape: { r: layout.r + 10 } }, 300, 'elasticOut');\n\t        }\n\t        function onNormal() {\n\t            sector.stopAnimation(true);\n\t            sector.animateTo({ shape: { r: layout.r } }, 300, 'elasticOut');\n\t        }\n\t        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\t        if (itemModel.get('hoverAnimation') && seriesModel.ifEnableAnimation()) {\n\t            sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n\t        }\n\t        this._updateLabel(data, idx);\n\t        graphic.setHoverStyle(this);\n\t    };\n\t    piePieceProto._updateLabel = function (data, idx) {\n\t        var labelLine = this.childAt(1);\n\t        var labelText = this.childAt(2);\n\t        var seriesModel = data.hostModel;\n\t        var itemModel = data.getItemModel(idx);\n\t        var layout = data.getItemLayout(idx);\n\t        var labelLayout = layout.label;\n\t        var visualColor = data.getItemVisual(idx, 'color');\n\t        graphic.updateProps(labelLine, {\n\t            shape: {\n\t                points: labelLayout.linePoints || [\n\t                    [\n\t                        labelLayout.x,\n\t                        labelLayout.y\n\t                    ],\n\t                    [\n\t                        labelLayout.x,\n\t                        labelLayout.y\n\t                    ],\n\t                    [\n\t                        labelLayout.x,\n\t                        labelLayout.y\n\t                    ]\n\t                ]\n\t            }\n\t        }, seriesModel, idx);\n\t        graphic.updateProps(labelText, {\n\t            style: {\n\t                x: labelLayout.x,\n\t                y: labelLayout.y\n\t            }\n\t        }, seriesModel, idx);\n\t        labelText.attr({\n\t            style: {\n\t                textVerticalAlign: labelLayout.verticalAlign,\n\t                textAlign: labelLayout.textAlign,\n\t                textFont: labelLayout.font\n\t            },\n\t            rotation: labelLayout.rotation,\n\t            origin: [\n\t                labelLayout.x,\n\t                labelLayout.y\n\t            ],\n\t            z2: 10\n\t        });\n\t        var labelModel = itemModel.getModel('label.normal');\n\t        var labelHoverModel = itemModel.getModel('label.emphasis');\n\t        var labelLineModel = itemModel.getModel('labelLine.normal');\n\t        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n\t        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n\t        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n\t        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n\t        labelText.hoverIgnore = !labelHoverModel.get('show');\n\t        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n\t        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\t        // Default use item visual color\n\t        labelLine.setStyle({\n\t            stroke: visualColor,\n\t            opacity: data.getItemVisual(idx, 'opacity')\n\t        });\n\t        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\t        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n\t        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\t        var smooth = labelLineModel.get('smooth');\n\t        if (smooth && smooth === true) {\n\t            smooth = 0.4;\n\t        }\n\t        labelLine.setShape({ smooth: smooth });\n\t    };\n\t    zrUtil.inherits(PiePiece, graphic.Group);\n\t    // Pie view\n\t    var Pie = require('../../view/Chart').extend({\n\t            type: 'pie',\n\t            init: function () {\n\t                var sectorGroup = new graphic.Group();\n\t                this._sectorGroup = sectorGroup;\n\t            },\n\t            render: function (seriesModel, ecModel, api, payload) {\n\t                if (payload && payload.from === this.uid) {\n\t                    return;\n\t                }\n\t                var data = seriesModel.getData();\n\t                var oldData = this._data;\n\t                var group = this.group;\n\t                var hasAnimation = ecModel.get('animation');\n\t                var isFirstRender = !oldData;\n\t                var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n\t                var selectedMode = seriesModel.get('selectedMode');\n\t                data.diff(oldData).add(function (idx) {\n\t                    var piePiece = new PiePiece(data, idx);\n\t                    if (isFirstRender) {\n\t                        piePiece.eachChild(function (child) {\n\t                            child.stopAnimation(true);\n\t                        });\n\t                    }\n\t                    selectedMode && piePiece.on('click', onSectorClick);\n\t                    data.setItemGraphicEl(idx, piePiece);\n\t                    group.add(piePiece);\n\t                }).update(function (newIdx, oldIdx) {\n\t                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\t                    piePiece.updateData(data, newIdx);\n\t                    piePiece.off('click');\n\t                    selectedMode && piePiece.on('click', onSectorClick);\n\t                    group.add(piePiece);\n\t                    data.setItemGraphicEl(newIdx, piePiece);\n\t                }).remove(function (idx) {\n\t                    var piePiece = oldData.getItemGraphicEl(idx);\n\t                    group.remove(piePiece);\n\t                }).execute();\n\t                if (hasAnimation && isFirstRender && data.count() > 0) {\n\t                    var shape = data.getItemLayout(0);\n\t                    var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\t                    var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n\t                    group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n\t                }\n\t                this._data = data;\n\t            },\n\t            _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n\t                var clipPath = new graphic.Sector({\n\t                        shape: {\n\t                            cx: cx,\n\t                            cy: cy,\n\t                            r0: 0,\n\t                            r: r,\n\t                            startAngle: startAngle,\n\t                            endAngle: startAngle,\n\t                            clockwise: clockwise\n\t                        }\n\t                    });\n\t                graphic.initProps(clipPath, { shape: { endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2 } }, seriesModel, cb);\n\t                return clipPath;\n\t            }\n\t        });\n\t    return Pie;\n\t});\n\tdefine('echarts/chart/pie/PieSeries', ['require', '../../data/List', 'zrender/core/util', '../../util/model', '../../data/helper/completeDimensions', '../../component/helper/selectableMixin', '../../echarts'], function (require) {\n\t    'use strict';\n\t    var List = require('../../data/List');\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../../util/model');\n\t    var completeDimensions = require('../../data/helper/completeDimensions');\n\t    var dataSelectableMixin = require('../../component/helper/selectableMixin');\n\t    var PieSeries = require('../../echarts').extendSeriesModel({\n\t            type: 'series.pie',\n\t            init: function (option) {\n\t                PieSeries.superApply(this, 'init', arguments);\n\t                // Enable legend selection for each data item\n\t                // Use a function instead of direct access because data reference may changed\n\t                this.legendDataProvider = function () {\n\t                    return this._dataBeforeProcessed;\n\t                };\n\t                this.updateSelectedMap(option.data);\n\t                this._defaultLabelLine(option);\n\t            },\n\t            mergeOption: function (newOption) {\n\t                PieSeries.superCall(this, 'mergeOption', newOption);\n\t                this.updateSelectedMap(this.option.data);\n\t            },\n\t            getInitialData: function (option, ecModel) {\n\t                var dimensions = completeDimensions(['value'], option.data);\n\t                var list = new List(dimensions, this);\n\t                list.initData(option.data);\n\t                return list;\n\t            },\n\t            getDataParams: function (dataIndex) {\n\t                var data = this._data;\n\t                var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n\t                var sum = data.getSum('value');\n\t                // FIXME toFixed?\n\t                //\n\t                // Percent is 0 if sum is 0\n\t                params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\t                params.$vars.push('percent');\n\t                return params;\n\t            },\n\t            _defaultLabelLine: function (option) {\n\t                // Extend labelLine emphasis\n\t                modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\t                var labelLineNormalOpt = option.labelLine.normal;\n\t                var labelLineEmphasisOpt = option.labelLine.emphasis;\n\t                // Not show label line if `label.normal.show = false`\n\t                labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.normal.show;\n\t                labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.label.emphasis.show;\n\t            },\n\t            defaultOption: {\n\t                zlevel: 0,\n\t                z: 2,\n\t                legendHoverLink: true,\n\t                hoverAnimation: true,\n\t                center: [\n\t                    '50%',\n\t                    '50%'\n\t                ],\n\t                radius: [\n\t                    0,\n\t                    '75%'\n\t                ],\n\t                clockwise: true,\n\t                startAngle: 90,\n\t                minAngle: 0,\n\t                selectedOffset: 10,\n\t                avoidLabelOverlap: true,\n\t                label: {\n\t                    normal: {\n\t                        rotate: false,\n\t                        show: true,\n\t                        position: 'outer'\n\t                    },\n\t                    emphasis: {}\n\t                },\n\t                labelLine: {\n\t                    normal: {\n\t                        show: true,\n\t                        length: 15,\n\t                        length2: 15,\n\t                        smooth: false,\n\t                        lineStyle: {\n\t                            width: 1,\n\t                            type: 'solid'\n\t                        }\n\t                    }\n\t                },\n\t                itemStyle: {\n\t                    normal: { borderWidth: 1 },\n\t                    emphasis: {}\n\t                },\n\t                animationEasing: 'cubicOut',\n\t                data: []\n\t            }\n\t        });\n\t    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\t    return PieSeries;\n\t});\n\tdefine('echarts/action/createDataSelectAction', ['require', '../echarts', 'zrender/core/util'], function (require) {\n\t    var echarts = require('../echarts');\n\t    var zrUtil = require('zrender/core/util');\n\t    return function (seriesType, actionInfos) {\n\t        zrUtil.each(actionInfos, function (actionInfo) {\n\t            actionInfo.update = 'updateView';\n\t            /**\n\t             * @payload\n\t             * @property {string} seriesName\n\t             * @property {string} name\n\t             */\n\t            echarts.registerAction(actionInfo, function (payload, ecModel) {\n\t                var selected = {};\n\t                ecModel.eachComponent({\n\t                    mainType: 'series',\n\t                    subType: seriesType,\n\t                    query: payload\n\t                }, function (seriesModel) {\n\t                    if (seriesModel[actionInfo.method]) {\n\t                        seriesModel[actionInfo.method](payload.name);\n\t                    }\n\t                    var data = seriesModel.getData();\n\t                    // Create selected map\n\t                    data.each(function (idx) {\n\t                        var name = data.getName(idx);\n\t                        selected[name] = seriesModel.isSelected(name) || false;\n\t                    });\n\t                });\n\t                return {\n\t                    name: payload.name,\n\t                    selected: selected\n\t                };\n\t            });\n\t        });\n\t    };\n\t});\n\tdefine('zrender/core/util', ['require'], function (require) {\n\t    // 用于处理merge时无法遍历Date等对象的问题\n\t    var BUILTIN_OBJECT = {\n\t            '[object Function]': 1,\n\t            '[object RegExp]': 1,\n\t            '[object Date]': 1,\n\t            '[object Error]': 1,\n\t            '[object CanvasGradient]': 1,\n\t            '[object CanvasPattern]': 1,\n\t            '[object Image]': 1\n\t        };\n\t    var objToString = Object.prototype.toString;\n\t    var arrayProto = Array.prototype;\n\t    var nativeForEach = arrayProto.forEach;\n\t    var nativeFilter = arrayProto.filter;\n\t    var nativeSlice = arrayProto.slice;\n\t    var nativeMap = arrayProto.map;\n\t    var nativeReduce = arrayProto.reduce;\n\t    /**\n\t     * @param {*} source\n\t     * @return {*} 拷贝后的新对象\n\t     */\n\t    function clone(source) {\n\t        if (typeof source == 'object' && source !== null) {\n\t            var result = source;\n\t            if (source instanceof Array) {\n\t                result = [];\n\t                for (var i = 0, len = source.length; i < len; i++) {\n\t                    result[i] = clone(source[i]);\n\t                }\n\t            } else if (!isBuildInObject(source) && !isDom(source)) {\n\t                result = {};\n\t                for (var key in source) {\n\t                    if (source.hasOwnProperty(key)) {\n\t                        result[key] = clone(source[key]);\n\t                    }\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t        return source;\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolean} [overwrite=false]\n\t     */\n\t    function merge(target, source, overwrite) {\n\t        // We should escapse that source is string\n\t        // and enter for ... in ...\n\t        if (!isObject(source) || !isObject(target)) {\n\t            return overwrite ? clone(source) : target;\n\t        }\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                var targetProp = target[key];\n\t                var sourceProp = source[key];\n\t                if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuildInObject(sourceProp) && !isBuildInObject(targetProp)) {\n\t                    // 如果需要递归覆盖，就递归调用merge\n\t                    merge(targetProp, sourceProp, overwrite);\n\t                } else if (overwrite || !(key in target)) {\n\t                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n\t                    // NOTE，在 target[key] 不存在的时候也是直接覆盖\n\t                    target[key] = clone(source[key], true);\n\t                }\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t    /**\n\t     * @param {Array} targetAndSources The first item is target, and the rests are source.\n\t     * @param {boolean} [overwrite=false]\n\t     * @return {*} target\n\t     */\n\t    function mergeAll(targetAndSources, overwrite) {\n\t        var result = targetAndSources[0];\n\t        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n\t            result = merge(result, targetAndSources[i], overwrite);\n\t        }\n\t        return result;\n\t    }\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function extend(target, source) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolen} [overlay=false]\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function defaults(target, source, overlay) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t    function createCanvas() {\n\t        return document.createElement('canvas');\n\t    }\n\t    // FIXME\n\t    var _ctx;\n\t    function getContext() {\n\t        if (!_ctx) {\n\t            // Use util.createCanvas instead of createCanvas\n\t            // because createCanvas may be overwritten in different environment\n\t            _ctx = util.createCanvas().getContext('2d');\n\t        }\n\t        return _ctx;\n\t    }\n\t    /**\n\t     * 查询数组中元素的index\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function indexOf(array, value) {\n\t        if (array) {\n\t            if (array.indexOf) {\n\t                return array.indexOf(value);\n\t            }\n\t            for (var i = 0, len = array.length; i < len; i++) {\n\t                if (array[i] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t    /**\n\t     * 构造类继承关系\n\t     *\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} clazz 源类\n\t     * @param {Function} baseClazz 基类\n\t     */\n\t    function inherits(clazz, baseClazz) {\n\t        var clazzPrototype = clazz.prototype;\n\t        function F() {\n\t        }\n\t        F.prototype = baseClazz.prototype;\n\t        clazz.prototype = new F();\n\t        for (var prop in clazzPrototype) {\n\t            clazz.prototype[prop] = clazzPrototype[prop];\n\t        }\n\t        clazz.prototype.constructor = clazz;\n\t        clazz.superClass = baseClazz;\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Function} target\n\t     * @param {Object|Function} sorce\n\t     * @param {boolean} overlay\n\t     */\n\t    function mixin(target, source, overlay) {\n\t        target = 'prototype' in target ? target.prototype : target;\n\t        source = 'prototype' in source ? source.prototype : source;\n\t        defaults(target, source, overlay);\n\t    }\n\t    /**\n\t     * @param {Array|TypedArray} data\n\t     */\n\t    function isArrayLike(data) {\n\t        if (!data) {\n\t            return;\n\t        }\n\t        if (typeof data == 'string') {\n\t            return false;\n\t        }\n\t        return typeof data.length == 'number';\n\t    }\n\t    /**\n\t     * 数组或对象遍历\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     */\n\t    function each(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.forEach && obj.forEach === nativeForEach) {\n\t            obj.forEach(cb, context);\n\t        } else if (obj.length === +obj.length) {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                cb.call(context, obj[i], i, obj);\n\t            }\n\t        } else {\n\t            for (var key in obj) {\n\t                if (obj.hasOwnProperty(key)) {\n\t                    cb.call(context, obj[key], key, obj);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * 数组映射\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function map(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.map && obj.map === nativeMap) {\n\t            return obj.map(cb, context);\n\t        } else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                result.push(cb.call(context, obj[i], i, obj));\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {Object} [memo]\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function reduce(obj, cb, memo, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.reduce && obj.reduce === nativeReduce) {\n\t            return obj.reduce(cb, memo, context);\n\t        } else {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                memo = cb.call(context, memo, obj[i], i, obj);\n\t            }\n\t            return memo;\n\t        }\n\t    }\n\t    /**\n\t     * 数组过滤\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function filter(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.filter && obj.filter === nativeFilter) {\n\t            return obj.filter(cb, context);\n\t        } else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                if (cb.call(context, obj[i], i, obj)) {\n\t                    result.push(obj[i]);\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t    /**\n\t     * 数组项查找\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function find(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        for (var i = 0, len = obj.length; i < len; i++) {\n\t            if (cb.call(context, obj[i], i, obj)) {\n\t                return obj[i];\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @param {*} context\n\t     * @return {Function}\n\t     */\n\t    function bind(func, context) {\n\t        var args = nativeSlice.call(arguments, 2);\n\t        return function () {\n\t            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @return {Function}\n\t     */\n\t    function curry(func) {\n\t        var args = nativeSlice.call(arguments, 1);\n\t        return function () {\n\t            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isArray(value) {\n\t        return objToString.call(value) === '[object Array]';\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isFunction(value) {\n\t        return typeof value === 'function';\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isString(value) {\n\t        return objToString.call(value) === '[object String]';\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isObject(value) {\n\t        // Avoid a V8 JIT bug in Chrome 19-20.\n\t        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t        var type = typeof value;\n\t        return type === 'function' || !!value && type == 'object';\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isBuildInObject(value) {\n\t        return !!BUILTIN_OBJECT[objToString.call(value)];\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isDom(value) {\n\t        return value && value.nodeType === 1 && typeof value.nodeName == 'string';\n\t    }\n\t    /**\n\t     * If value1 is not null, then return value1, otherwise judget rest of values.\n\t     * @memberOf module:zrender/core/util\n\t     * @return {*} Final value\n\t     */\n\t    function retrieve(values) {\n\t        for (var i = 0, len = arguments.length; i < len; i++) {\n\t            if (arguments[i] != null) {\n\t                return arguments[i];\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} arr\n\t     * @param {number} startIndex\n\t     * @param {number} endIndex\n\t     * @return {Array}\n\t     */\n\t    function slice() {\n\t        return Function.call.apply(nativeSlice, arguments);\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {boolean} condition\n\t     * @param {string} message\n\t     */\n\t    function assert(condition, message) {\n\t        if (!condition) {\n\t            throw new Error(message);\n\t        }\n\t    }\n\t    var util = {\n\t            inherits: inherits,\n\t            mixin: mixin,\n\t            clone: clone,\n\t            merge: merge,\n\t            mergeAll: mergeAll,\n\t            extend: extend,\n\t            defaults: defaults,\n\t            getContext: getContext,\n\t            createCanvas: createCanvas,\n\t            indexOf: indexOf,\n\t            slice: slice,\n\t            find: find,\n\t            isArrayLike: isArrayLike,\n\t            each: each,\n\t            map: map,\n\t            reduce: reduce,\n\t            filter: filter,\n\t            bind: bind,\n\t            curry: curry,\n\t            isArray: isArray,\n\t            isString: isString,\n\t            isObject: isObject,\n\t            isFunction: isFunction,\n\t            isBuildInObject: isBuildInObject,\n\t            isDom: isDom,\n\t            retrieve: retrieve,\n\t            assert: assert,\n\t            noop: function () {\n\t            }\n\t        };\n\t    return util;\n\t});\n\tdefine('echarts/visual/dataColor', ['require'], function (require) {\n\t    return function (seriesType, ecModel) {\n\t        // Pie and funnel may use diferrent scope\n\t        var paletteScope = {};\n\t        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n\t            var dataAll = seriesModel.getRawData();\n\t            var idxMap = {};\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                var data = seriesModel.getData();\n\t                data.each(function (idx) {\n\t                    var rawIdx = data.getRawIndex(idx);\n\t                    idxMap[rawIdx] = idx;\n\t                });\n\t                dataAll.each(function (rawIdx) {\n\t                    // FIXME Performance\n\t                    var itemModel = dataAll.getItemModel(rawIdx);\n\t                    var filteredIdx = idxMap[rawIdx];\n\t                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\t                    var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\t                    if (!singleDataColor) {\n\t                        var color = itemModel.get('itemStyle.normal.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n\t                        // Legend may use the visual info in data before processed\n\t                        dataAll.setItemVisual(rawIdx, 'color', color);\n\t                        // Data is not filtered\n\t                        if (filteredIdx != null) {\n\t                            data.setItemVisual(filteredIdx, 'color', color);\n\t                        }\n\t                    } else {\n\t                        // Set data all color for legend\n\t                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n\t                    }\n\t                });\n\t            }\n\t        });\n\t    };\n\t});\n\tdefine('echarts/chart/pie/pieLayout', ['require', '../../util/number', './labelLayout', 'zrender/core/util'], function (require) {\n\t    var numberUtil = require('../../util/number');\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var labelLayout = require('./labelLayout');\n\t    var zrUtil = require('zrender/core/util');\n\t    var PI2 = Math.PI * 2;\n\t    var RADIAN = Math.PI / 180;\n\t    return function (seriesType, ecModel, api, payload) {\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t            var center = seriesModel.get('center');\n\t            var radius = seriesModel.get('radius');\n\t            if (!zrUtil.isArray(radius)) {\n\t                radius = [\n\t                    0,\n\t                    radius\n\t                ];\n\t            }\n\t            if (!zrUtil.isArray(center)) {\n\t                center = [\n\t                    center,\n\t                    center\n\t                ];\n\t            }\n\t            var width = api.getWidth();\n\t            var height = api.getHeight();\n\t            var size = Math.min(width, height);\n\t            var cx = parsePercent(center[0], width);\n\t            var cy = parsePercent(center[1], height);\n\t            var r0 = parsePercent(radius[0], size / 2);\n\t            var r = parsePercent(radius[1], size / 2);\n\t            var data = seriesModel.getData();\n\t            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\t            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\t            var sum = data.getSum('value');\n\t            // Sum may be 0\n\t            var unitRadian = Math.PI / (sum || data.count()) * 2;\n\t            var clockwise = seriesModel.get('clockwise');\n\t            var roseType = seriesModel.get('roseType');\n\t            // [0...max]\n\t            var extent = data.getDataExtent('value');\n\t            extent[0] = 0;\n\t            // In the case some sector angle is smaller than minAngle\n\t            var restAngle = PI2;\n\t            var valueSumLargerThanMinAngle = 0;\n\t            var currentAngle = startAngle;\n\t            var dir = clockwise ? 1 : -1;\n\t            data.each('value', function (value, idx) {\n\t                var angle;\n\t                // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n\t                if (roseType !== 'area') {\n\t                    angle = sum === 0 ? unitRadian : value * unitRadian;\n\t                } else {\n\t                    angle = PI2 / (data.count() || 1);\n\t                }\n\t                if (angle < minAngle) {\n\t                    angle = minAngle;\n\t                    restAngle -= minAngle;\n\t                } else {\n\t                    valueSumLargerThanMinAngle += value;\n\t                }\n\t                var endAngle = currentAngle + dir * angle;\n\t                data.setItemLayout(idx, {\n\t                    angle: angle,\n\t                    startAngle: currentAngle,\n\t                    endAngle: endAngle,\n\t                    clockwise: clockwise,\n\t                    cx: cx,\n\t                    cy: cy,\n\t                    r0: r0,\n\t                    r: roseType ? numberUtil.linearMap(value, extent, [\n\t                        r0,\n\t                        r\n\t                    ]) : r\n\t                });\n\t                currentAngle = endAngle;\n\t            }, true);\n\t            // Some sector is constrained by minAngle\n\t            // Rest sectors needs recalculate angle\n\t            if (restAngle < PI2) {\n\t                // Average the angle if rest angle is not enough after all angles is\n\t                // Constrained by minAngle\n\t                if (restAngle <= 0.001) {\n\t                    var angle = PI2 / data.count();\n\t                    data.each(function (idx) {\n\t                        var layout = data.getItemLayout(idx);\n\t                        layout.startAngle = startAngle + dir * idx * angle;\n\t                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n\t                    });\n\t                } else {\n\t                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n\t                    currentAngle = startAngle;\n\t                    data.each('value', function (value, idx) {\n\t                        var layout = data.getItemLayout(idx);\n\t                        var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n\t                        layout.startAngle = currentAngle;\n\t                        layout.endAngle = currentAngle + dir * angle;\n\t                        currentAngle += angle;\n\t                    });\n\t                }\n\t            }\n\t            labelLayout(seriesModel, r, width, height);\n\t        });\n\t    };\n\t});\n\tdefine('echarts/processor/dataFilter', [], function () {\n\t    return function (seriesType, ecModel) {\n\t        var legendModels = ecModel.findComponents({ mainType: 'legend' });\n\t        if (!legendModels || !legendModels.length) {\n\t            return;\n\t        }\n\t        ecModel.eachSeriesByType(seriesType, function (series) {\n\t            var data = series.getData();\n\t            data.filterSelf(function (idx) {\n\t                var name = data.getName(idx);\n\t                // If in any legend component the status is not selected.\n\t                for (var i = 0; i < legendModels.length; i++) {\n\t                    if (!legendModels[i].isSelected(name)) {\n\t                        return false;\n\t                    }\n\t                }\n\t                return true;\n\t            }, this);\n\t        }, this);\n\t    };\n\t});\n\tdefine('echarts/coord/cartesian/Grid', ['require', 'exports', '../../util/layout', '../../coord/axisHelper', 'zrender/core/util', './Cartesian2D', './Axis2D', './GridModel', '../../CoordinateSystem'], function (require, factory) {\n\t    var layout = require('../../util/layout');\n\t    var axisHelper = require('../../coord/axisHelper');\n\t    var zrUtil = require('zrender/core/util');\n\t    var Cartesian2D = require('./Cartesian2D');\n\t    var Axis2D = require('./Axis2D');\n\t    var each = zrUtil.each;\n\t    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n\t    var niceScaleExtent = axisHelper.niceScaleExtent;\n\t    // 依赖 GridModel, AxisModel 做预处理\n\t    require('./GridModel');\n\t    /**\n\t     * Check if the axis is used in the specified grid\n\t     * @inner\n\t     */\n\t    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n\t        return axisModel.findGridModel() === gridModel;\n\t    }\n\t    function getLabelUnionRect(axis) {\n\t        var axisModel = axis.model;\n\t        var labels = axisModel.getFormattedLabels();\n\t        var rect;\n\t        var step = 1;\n\t        var labelCount = labels.length;\n\t        if (labelCount > 40) {\n\t            // Simple optimization for large amount of labels\n\t            step = Math.ceil(labelCount / 40);\n\t        }\n\t        for (var i = 0; i < labelCount; i += step) {\n\t            if (!axis.isLabelIgnored(i)) {\n\t                var singleRect = axisModel.getTextRect(labels[i]);\n\t                // FIXME consider label rotate\n\t                rect ? rect.union(singleRect) : rect = singleRect;\n\t            }\n\t        }\n\t        return rect;\n\t    }\n\t    function Grid(gridModel, ecModel, api) {\n\t        /**\n\t         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n\t         * @private\n\t         */\n\t        this._coordsMap = {};\n\t        /**\n\t         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n\t         * @private\n\t         */\n\t        this._coordsList = [];\n\t        /**\n\t         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n\t         * @private\n\t         */\n\t        this._axesMap = {};\n\t        /**\n\t         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n\t         * @private\n\t         */\n\t        this._axesList = [];\n\t        this._initCartesian(gridModel, ecModel, api);\n\t        this._model = gridModel;\n\t    }\n\t    var gridProto = Grid.prototype;\n\t    gridProto.type = 'grid';\n\t    gridProto.getRect = function () {\n\t        return this._rect;\n\t    };\n\t    gridProto.update = function (ecModel, api) {\n\t        var axesMap = this._axesMap;\n\t        this._updateScale(ecModel, this._model);\n\t        function ifAxisCanNotOnZero(otherAxisDim) {\n\t            var axes = axesMap[otherAxisDim];\n\t            for (var idx in axes) {\n\t                var axis = axes[idx];\n\t                if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n\t                    return true;\n\t                }\n\t            }\n\t            return false;\n\t        }\n\t        each(axesMap.x, function (xAxis) {\n\t            niceScaleExtent(xAxis, xAxis.model);\n\t        });\n\t        each(axesMap.y, function (yAxis) {\n\t            niceScaleExtent(yAxis, yAxis.model);\n\t        });\n\t        // Fix configuration\n\t        each(axesMap.x, function (xAxis) {\n\t            // onZero can not be enabled in these two situations\n\t            // 1. When any other axis is a category axis\n\t            // 2. When any other axis not across 0 point\n\t            if (ifAxisCanNotOnZero('y')) {\n\t                xAxis.onZero = false;\n\t            }\n\t        });\n\t        each(axesMap.y, function (yAxis) {\n\t            if (ifAxisCanNotOnZero('x')) {\n\t                yAxis.onZero = false;\n\t            }\n\t        });\n\t        // Resize again if containLabel is enabled\n\t        // FIXME It may cause getting wrong grid size in data processing stage\n\t        this.resize(this._model, api);\n\t    };\n\t    /**\n\t     * Resize the grid\n\t     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    gridProto.resize = function (gridModel, api) {\n\t        var gridRect = layout.getLayoutRect(gridModel.getBoxLayoutParams(), {\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            });\n\t        this._rect = gridRect;\n\t        var axesList = this._axesList;\n\t        adjustAxes();\n\t        // Minus label size\n\t        if (gridModel.get('containLabel')) {\n\t            each(axesList, function (axis) {\n\t                if (!axis.model.get('axisLabel.inside')) {\n\t                    var labelUnionRect = getLabelUnionRect(axis);\n\t                    if (labelUnionRect) {\n\t                        var dim = axis.isHorizontal() ? 'height' : 'width';\n\t                        var margin = axis.model.get('axisLabel.margin');\n\t                        gridRect[dim] -= labelUnionRect[dim] + margin;\n\t                        if (axis.position === 'top') {\n\t                            gridRect.y += labelUnionRect.height + margin;\n\t                        } else if (axis.position === 'left') {\n\t                            gridRect.x += labelUnionRect.width + margin;\n\t                        }\n\t                    }\n\t                }\n\t            });\n\t            adjustAxes();\n\t        }\n\t        function adjustAxes() {\n\t            each(axesList, function (axis) {\n\t                var isHorizontal = axis.isHorizontal();\n\t                var extent = isHorizontal ? [\n\t                        0,\n\t                        gridRect.width\n\t                    ] : [\n\t                        0,\n\t                        gridRect.height\n\t                    ];\n\t                var idx = axis.inverse ? 1 : 0;\n\t                axis.setExtent(extent[idx], extent[1 - idx]);\n\t                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n\t            });\n\t        }\n\t    };\n\t    /**\n\t     * @param {string} axisType\n\t     * @param {ndumber} [axisIndex]\n\t     */\n\t    gridProto.getAxis = function (axisType, axisIndex) {\n\t        var axesMapOnDim = this._axesMap[axisType];\n\t        if (axesMapOnDim != null) {\n\t            if (axisIndex == null) {\n\t                // Find first axis\n\t                for (var name in axesMapOnDim) {\n\t                    return axesMapOnDim[name];\n\t                }\n\t            }\n\t            return axesMapOnDim[axisIndex];\n\t        }\n\t    };\n\t    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n\t        if (xAxisIndex != null && yAxisIndex != null) {\n\t            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n\t            return this._coordsMap[key];\n\t        } else {\n\t            // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\t            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n\t                if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n\t                    return coordList[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t    /**\n\t     * Initialize cartesian coordinate systems\n\t     * @private\n\t     */\n\t    gridProto._initCartesian = function (gridModel, ecModel, api) {\n\t        var axisPositionUsed = {\n\t                left: false,\n\t                right: false,\n\t                top: false,\n\t                bottom: false\n\t            };\n\t        var axesMap = {\n\t                x: {},\n\t                y: {}\n\t            };\n\t        var axesCount = {\n\t                x: 0,\n\t                y: 0\n\t            };\n\t        /// Create axis\n\t        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n\t        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\t        if (!axesCount.x || !axesCount.y) {\n\t            // Roll back when there no either x or y axis\n\t            this._axesMap = {};\n\t            this._axesList = [];\n\t            return;\n\t        }\n\t        this._axesMap = axesMap;\n\t        /// Create cartesian2d\n\t        each(axesMap.x, function (xAxis, xAxisIndex) {\n\t            each(axesMap.y, function (yAxis, yAxisIndex) {\n\t                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n\t                var cartesian = new Cartesian2D(key);\n\t                cartesian.grid = this;\n\t                this._coordsMap[key] = cartesian;\n\t                this._coordsList.push(cartesian);\n\t                cartesian.addAxis(xAxis);\n\t                cartesian.addAxis(yAxis);\n\t            }, this);\n\t        }, this);\n\t        function createAxisCreator(axisType) {\n\t            return function (axisModel, idx) {\n\t                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n\t                    return;\n\t                }\n\t                var axisPosition = axisModel.get('position');\n\t                if (axisType === 'x') {\n\t                    // Fix position\n\t                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n\t                        // Default bottom of X\n\t                        axisPosition = 'bottom';\n\t                        if (axisPositionUsed[axisPosition]) {\n\t                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n\t                        }\n\t                    }\n\t                } else {\n\t                    // Fix position\n\t                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n\t                        // Default left of Y\n\t                        axisPosition = 'left';\n\t                        if (axisPositionUsed[axisPosition]) {\n\t                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n\t                        }\n\t                    }\n\t                }\n\t                axisPositionUsed[axisPosition] = true;\n\t                var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [\n\t                        0,\n\t                        0\n\t                    ], axisModel.get('type'), axisPosition);\n\t                var isCategory = axis.type === 'category';\n\t                axis.onBand = isCategory && axisModel.get('boundaryGap');\n\t                axis.inverse = axisModel.get('inverse');\n\t                axis.onZero = axisModel.get('axisLine.onZero');\n\t                // Inject axis into axisModel\n\t                axisModel.axis = axis;\n\t                // Inject axisModel into axis\n\t                axis.model = axisModel;\n\t                // Inject grid info axis\n\t                axis.grid = this;\n\t                // Index of axis, can be used as key\n\t                axis.index = idx;\n\t                this._axesList.push(axis);\n\t                axesMap[axisType][idx] = axis;\n\t                axesCount[axisType]++;\n\t            };\n\t        }\n\t    };\n\t    /**\n\t     * Update cartesian properties from series\n\t     * @param  {module:echarts/model/Option} option\n\t     * @private\n\t     */\n\t    gridProto._updateScale = function (ecModel, gridModel) {\n\t        // Reset scale\n\t        zrUtil.each(this._axesList, function (axis) {\n\t            axis.scale.setExtent(Infinity, -Infinity);\n\t        });\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            if (isCartesian2D(seriesModel)) {\n\t                var axesModels = findAxesModels(seriesModel, ecModel);\n\t                var xAxisModel = axesModels[0];\n\t                var yAxisModel = axesModels[1];\n\t                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n\t                    return;\n\t                }\n\t                var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n\t                var data = seriesModel.getData();\n\t                var xAxis = cartesian.getAxis('x');\n\t                var yAxis = cartesian.getAxis('y');\n\t                if (data.type === 'list') {\n\t                    unionExtent(data, xAxis, seriesModel);\n\t                    unionExtent(data, yAxis, seriesModel);\n\t                }\n\t            }\n\t        }, this);\n\t        function unionExtent(data, axis, seriesModel) {\n\t            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n\t                axis.scale.unionExtent(data.getDataExtent(dim, axis.scale.type !== 'ordinal'));\n\t            });\n\t        }\n\t    };\n\t    /**\n\t     * @inner\n\t     */\n\t    function updateAxisTransfrom(axis, coordBase) {\n\t        var axisExtent = axis.getExtent();\n\t        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\t        // Fast transform\n\t        axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n\t            return coord + coordBase;\n\t        } : function (coord) {\n\t            return axisExtentSum - coord + coordBase;\n\t        };\n\t        axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n\t            return coord - coordBase;\n\t        } : function (coord) {\n\t            return axisExtentSum - coord + coordBase;\n\t        };\n\t    }\n\t    var axesTypes = [\n\t            'xAxis',\n\t            'yAxis'\n\t        ];\n\t    /**\n\t     * @inner\n\t     */\n\t    function findAxesModels(seriesModel, ecModel) {\n\t        return zrUtil.map(axesTypes, function (axisType) {\n\t            var axisModel = ecModel.queryComponents({\n\t                    mainType: axisType,\n\t                    index: seriesModel.get(axisType + 'Index'),\n\t                    id: seriesModel.get(axisType + 'Id')\n\t                })[0];\n\t            if (true) {\n\t                if (!axisModel) {\n\t                    throw new Error(axisType + ' \"' + zrUtil.retrieve(seriesModel.get(axisType + 'Index'), seriesModel.get(axisType + 'Id'), 0) + '\" not found');\n\t                }\n\t            }\n\t            return axisModel;\n\t        });\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function isCartesian2D(seriesModel) {\n\t        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n\t    }\n\t    Grid.create = function (ecModel, api) {\n\t        var grids = [];\n\t        ecModel.eachComponent('grid', function (gridModel, idx) {\n\t            var grid = new Grid(gridModel, ecModel, api);\n\t            grid.name = 'grid_' + idx;\n\t            grid.resize(gridModel, api);\n\t            gridModel.coordinateSystem = grid;\n\t            grids.push(grid);\n\t        });\n\t        // Inject the coordinateSystems into seriesModel\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            if (!isCartesian2D(seriesModel)) {\n\t                return;\n\t            }\n\t            var axesModels = findAxesModels(seriesModel, ecModel);\n\t            var xAxisModel = axesModels[0];\n\t            var yAxisModel = axesModels[1];\n\t            var gridModel = xAxisModel.findGridModel();\n\t            if (true) {\n\t                if (!gridModel) {\n\t                    throw new Error('Grid \"' + zrUtil.retrieve(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '\" not found');\n\t                }\n\t                if (xAxisModel.findGridModel() !== yAxisModel.findGridModel()) {\n\t                    throw new Error('xAxis and yAxis must use the same grid');\n\t                }\n\t            }\n\t            var grid = gridModel.coordinateSystem;\n\t            seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n\t        });\n\t        return grids;\n\t    };\n\t    // For deciding which dimensions to use when creating list data\n\t    Grid.dimensions = Cartesian2D.prototype.dimensions;\n\t    require('../../CoordinateSystem').register('cartesian2d', Grid);\n\t    return Grid;\n\t});\n\tdefine('echarts/chart/bar/BarSeries', ['require', '../../model/Series', '../helper/createListFromArray'], function (require) {\n\t    'use strict';\n\t    var SeriesModel = require('../../model/Series');\n\t    var createListFromArray = require('../helper/createListFromArray');\n\t    return SeriesModel.extend({\n\t        type: 'series.bar',\n\t        dependencies: [\n\t            'grid',\n\t            'polar'\n\t        ],\n\t        getInitialData: function (option, ecModel) {\n\t            if (true) {\n\t                var coordSys = option.coordinateSystem;\n\t                if (coordSys !== 'cartesian2d') {\n\t                    throw new Error('Bar only support cartesian2d coordinateSystem');\n\t                }\n\t            }\n\t            return createListFromArray(option.data, this, ecModel);\n\t        },\n\t        getMarkerPosition: function (value) {\n\t            var coordSys = this.coordinateSystem;\n\t            if (coordSys) {\n\t                // PENDING if clamp ?\n\t                var pt = coordSys.dataToPoint(value, true);\n\t                var data = this.getData();\n\t                var offset = data.getLayout('offset');\n\t                var size = data.getLayout('size');\n\t                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n\t                pt[offsetIndex] += offset + size / 2;\n\t                return pt;\n\t            }\n\t            return [\n\t                NaN,\n\t                NaN\n\t            ];\n\t        },\n\t        brushSelector: 'rect',\n\t        defaultOption: {\n\t            zlevel: 0,\n\t            z: 2,\n\t            coordinateSystem: 'cartesian2d',\n\t            legendHoverLink: true,\n\t            barMinHeight: 0,\n\t            itemStyle: {\n\t                normal: {},\n\t                emphasis: {}\n\t            }\n\t        }\n\t    });\n\t});\n\tdefine('echarts/chart/bar/BarView', ['require', 'zrender/core/util', '../../util/graphic', '../../model/Model', './barItemStyle', '../../echarts'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var graphic = require('../../util/graphic');\n\t    zrUtil.extend(require('../../model/Model').prototype, require('./barItemStyle'));\n\t    function fixLayoutWithLineWidth(layout, lineWidth) {\n\t        var signX = layout.width > 0 ? 1 : -1;\n\t        var signY = layout.height > 0 ? 1 : -1;\n\t        // In case width or height are too small.\n\t        lineWidth = Math.min(lineWidth, Math.abs(layout.width), Math.abs(layout.height));\n\t        layout.x += signX * lineWidth / 2;\n\t        layout.y += signY * lineWidth / 2;\n\t        layout.width -= signX * lineWidth;\n\t        layout.height -= signY * lineWidth;\n\t    }\n\t    return require('../../echarts').extendChartView({\n\t        type: 'bar',\n\t        render: function (seriesModel, ecModel, api) {\n\t            var coordinateSystemType = seriesModel.get('coordinateSystem');\n\t            if (coordinateSystemType === 'cartesian2d') {\n\t                this._renderOnCartesian(seriesModel, ecModel, api);\n\t            }\n\t            return this.group;\n\t        },\n\t        _renderOnCartesian: function (seriesModel, ecModel, api) {\n\t            var group = this.group;\n\t            var data = seriesModel.getData();\n\t            var oldData = this._data;\n\t            var cartesian = seriesModel.coordinateSystem;\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var isHorizontal = baseAxis.isHorizontal();\n\t            var enableAnimation = seriesModel.get('animation');\n\t            var barBorderWidthQuery = [\n\t                    'itemStyle',\n\t                    'normal',\n\t                    'barBorderWidth'\n\t                ];\n\t            function createRect(dataIndex, isUpdate) {\n\t                var layout = data.getItemLayout(dataIndex);\n\t                var lineWidth = data.getItemModel(dataIndex).get(barBorderWidthQuery) || 0;\n\t                fixLayoutWithLineWidth(layout, lineWidth);\n\t                var rect = new graphic.Rect({ shape: zrUtil.extend({}, layout) });\n\t                // Animation\n\t                if (enableAnimation) {\n\t                    var rectShape = rect.shape;\n\t                    var animateProperty = isHorizontal ? 'height' : 'width';\n\t                    var animateTarget = {};\n\t                    rectShape[animateProperty] = 0;\n\t                    animateTarget[animateProperty] = layout[animateProperty];\n\t                    graphic[isUpdate ? 'updateProps' : 'initProps'](rect, { shape: animateTarget }, seriesModel, dataIndex);\n\t                }\n\t                return rect;\n\t            }\n\t            data.diff(oldData).add(function (dataIndex) {\n\t                // 空数据\n\t                if (!data.hasValue(dataIndex)) {\n\t                    return;\n\t                }\n\t                var rect = createRect(dataIndex);\n\t                data.setItemGraphicEl(dataIndex, rect);\n\t                group.add(rect);\n\t            }).update(function (newIndex, oldIndex) {\n\t                var rect = oldData.getItemGraphicEl(oldIndex);\n\t                // 空数据\n\t                if (!data.hasValue(newIndex)) {\n\t                    group.remove(rect);\n\t                    return;\n\t                }\n\t                if (!rect) {\n\t                    rect = createRect(newIndex, true);\n\t                }\n\t                var layout = data.getItemLayout(newIndex);\n\t                var lineWidth = data.getItemModel(newIndex).get(barBorderWidthQuery) || 0;\n\t                fixLayoutWithLineWidth(layout, lineWidth);\n\t                graphic.updateProps(rect, { shape: layout }, seriesModel, newIndex);\n\t                data.setItemGraphicEl(newIndex, rect);\n\t                // Add back\n\t                group.add(rect);\n\t            }).remove(function (idx) {\n\t                var rect = oldData.getItemGraphicEl(idx);\n\t                if (rect) {\n\t                    // Not show text when animating\n\t                    rect.style.text = '';\n\t                    graphic.updateProps(rect, { shape: { width: 0 } }, seriesModel, idx, function () {\n\t                        group.remove(rect);\n\t                    });\n\t                }\n\t            }).execute();\n\t            this._updateStyle(seriesModel, data, isHorizontal);\n\t            this._data = data;\n\t        },\n\t        _updateStyle: function (seriesModel, data, isHorizontal) {\n\t            function setLabel(style, model, color, labelText, labelPositionOutside) {\n\t                graphic.setText(style, model, color);\n\t                style.text = labelText;\n\t                if (style.textPosition === 'outside') {\n\t                    style.textPosition = labelPositionOutside;\n\t                }\n\t            }\n\t            data.eachItemGraphicEl(function (rect, idx) {\n\t                var itemModel = data.getItemModel(idx);\n\t                var color = data.getItemVisual(idx, 'color');\n\t                var opacity = data.getItemVisual(idx, 'opacity');\n\t                var layout = data.getItemLayout(idx);\n\t                var itemStyleModel = itemModel.getModel('itemStyle.normal');\n\t                var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\t                rect.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n\t                rect.useStyle(zrUtil.defaults({\n\t                    fill: color,\n\t                    opacity: opacity\n\t                }, itemStyleModel.getBarItemStyle()));\n\t                var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n\t                var labelModel = itemModel.getModel('label.normal');\n\t                var hoverLabelModel = itemModel.getModel('label.emphasis');\n\t                var rectStyle = rect.style;\n\t                if (labelModel.get('show')) {\n\t                    setLabel(rectStyle, labelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'normal'), seriesModel.getRawValue(idx)), labelPositionOutside);\n\t                } else {\n\t                    rectStyle.text = '';\n\t                }\n\t                if (hoverLabelModel.get('show')) {\n\t                    setLabel(hoverStyle, hoverLabelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'emphasis'), seriesModel.getRawValue(idx)), labelPositionOutside);\n\t                } else {\n\t                    hoverStyle.text = '';\n\t                }\n\t                graphic.setHoverStyle(rect, hoverStyle);\n\t            });\n\t        },\n\t        remove: function (ecModel, api) {\n\t            var group = this.group;\n\t            if (ecModel.get('animation')) {\n\t                if (this._data) {\n\t                    this._data.eachItemGraphicEl(function (el) {\n\t                        // Not show text when animating\n\t                        el.style.text = '';\n\t                        graphic.updateProps(el, { shape: { width: 0 } }, ecModel, el.dataIndex, function () {\n\t                            group.remove(el);\n\t                        });\n\t                    });\n\t                }\n\t            } else {\n\t                group.removeAll();\n\t            }\n\t        }\n\t    });\n\t});\n\tdefine('echarts/layout/barGrid', ['require', 'zrender/core/util', '../util/number'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var numberUtil = require('../util/number');\n\t    var parsePercent = numberUtil.parsePercent;\n\t    function getSeriesStackId(seriesModel) {\n\t        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n\t    }\n\t    function getAxisKey(axis) {\n\t        return axis.dim + axis.index;\n\t    }\n\t    function calBarWidthAndOffset(barSeries, api) {\n\t        // Columns info on each category axis. Key is cartesian name\n\t        var columnsMap = {};\n\t        zrUtil.each(barSeries, function (seriesModel, idx) {\n\t            var data = seriesModel.getData();\n\t            var cartesian = seriesModel.coordinateSystem;\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var axisExtent = baseAxis.getExtent();\n\t            var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n\t            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n\t                    bandWidth: bandWidth,\n\t                    remainedWidth: bandWidth,\n\t                    autoWidthCount: 0,\n\t                    categoryGap: '20%',\n\t                    gap: '30%',\n\t                    stacks: {}\n\t                };\n\t            var stacks = columnsOnAxis.stacks;\n\t            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n\t            var stackId = getSeriesStackId(seriesModel);\n\t            if (!stacks[stackId]) {\n\t                columnsOnAxis.autoWidthCount++;\n\t            }\n\t            stacks[stackId] = stacks[stackId] || {\n\t                width: 0,\n\t                maxWidth: 0\n\t            };\n\t            var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n\t            var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n\t            var barGap = seriesModel.get('barGap');\n\t            var barCategoryGap = seriesModel.get('barCategoryGap');\n\t            // TODO\n\t            if (barWidth && !stacks[stackId].width) {\n\t                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n\t                stacks[stackId].width = barWidth;\n\t                columnsOnAxis.remainedWidth -= barWidth;\n\t            }\n\t            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n\t            barGap != null && (columnsOnAxis.gap = barGap);\n\t            barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n\t        });\n\t        var result = {};\n\t        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n\t            result[coordSysName] = {};\n\t            var stacks = columnsOnAxis.stacks;\n\t            var bandWidth = columnsOnAxis.bandWidth;\n\t            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n\t            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n\t            var remainedWidth = columnsOnAxis.remainedWidth;\n\t            var autoWidthCount = columnsOnAxis.autoWidthCount;\n\t            var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n\t            autoWidth = Math.max(autoWidth, 0);\n\t            // Find if any auto calculated bar exceeded maxBarWidth\n\t            zrUtil.each(stacks, function (column, stack) {\n\t                var maxWidth = column.maxWidth;\n\t                if (!column.width && maxWidth && maxWidth < autoWidth) {\n\t                    maxWidth = Math.min(maxWidth, remainedWidth);\n\t                    remainedWidth -= maxWidth;\n\t                    column.width = maxWidth;\n\t                    autoWidthCount--;\n\t                }\n\t            });\n\t            // Recalculate width again\n\t            autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n\t            autoWidth = Math.max(autoWidth, 0);\n\t            var widthSum = 0;\n\t            var lastColumn;\n\t            zrUtil.each(stacks, function (column, idx) {\n\t                if (!column.width) {\n\t                    column.width = autoWidth;\n\t                }\n\t                lastColumn = column;\n\t                widthSum += column.width * (1 + barGapPercent);\n\t            });\n\t            if (lastColumn) {\n\t                widthSum -= lastColumn.width * barGapPercent;\n\t            }\n\t            var offset = -widthSum / 2;\n\t            zrUtil.each(stacks, function (column, stackId) {\n\t                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n\t                    offset: offset,\n\t                    width: column.width\n\t                };\n\t                offset += column.width * (1 + barGapPercent);\n\t            });\n\t        });\n\t        return result;\n\t    }\n\t    /**\n\t     * @param {string} seriesType\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    function barLayoutGrid(seriesType, ecModel, api) {\n\t        var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n\t                return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n\t            }));\n\t        var lastStackCoords = {};\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t            var cartesian = seriesModel.coordinateSystem;\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var stackId = getSeriesStackId(seriesModel);\n\t            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n\t            var columnOffset = columnLayoutInfo.offset;\n\t            var columnWidth = columnLayoutInfo.width;\n\t            var valueAxis = cartesian.getOtherAxis(baseAxis);\n\t            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n\t            var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];\n\t            var coords = cartesian.dataToPoints(data, true);\n\t            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n\t            data.setLayout({\n\t                offset: columnOffset,\n\t                size: columnWidth\n\t            });\n\t            data.each(valueAxis.dim, function (value, idx) {\n\t                // 空数据\n\t                if (isNaN(value)) {\n\t                    return;\n\t                }\n\t                if (!lastStackCoords[stackId][idx]) {\n\t                    lastStackCoords[stackId][idx] = {\n\t                        p: valueAxisStart,\n\t                        n: valueAxisStart\n\t                    };\n\t                }\n\t                var sign = value >= 0 ? 'p' : 'n';\n\t                var coord = coords[idx];\n\t                var lastCoord = lastStackCoords[stackId][idx][sign];\n\t                var x, y, width, height;\n\t                if (valueAxis.isHorizontal()) {\n\t                    x = lastCoord;\n\t                    y = coord[1] + columnOffset;\n\t                    width = coord[0] - lastCoord;\n\t                    height = columnWidth;\n\t                    if (Math.abs(width) < barMinHeight) {\n\t                        width = (width < 0 ? -1 : 1) * barMinHeight;\n\t                    }\n\t                    lastStackCoords[stackId][idx][sign] += width;\n\t                } else {\n\t                    x = coord[0] + columnOffset;\n\t                    y = lastCoord;\n\t                    width = columnWidth;\n\t                    height = coord[1] - lastCoord;\n\t                    if (Math.abs(height) < barMinHeight) {\n\t                        // Include zero to has a positive bar\n\t                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n\t                    }\n\t                    lastStackCoords[stackId][idx][sign] += height;\n\t                }\n\t                data.setItemLayout(idx, {\n\t                    x: x,\n\t                    y: y,\n\t                    width: width,\n\t                    height: height\n\t                });\n\t            }, true);\n\t        }, this);\n\t    }\n\t    return barLayoutGrid;\n\t});\n\tdefine('echarts/util/graphic', ['require', 'zrender/core/util', 'zrender/tool/path', 'zrender/graphic/Path', 'zrender/tool/color', 'zrender/core/matrix', 'zrender/core/vector', 'zrender/graphic/Gradient', 'zrender/container/Group', 'zrender/graphic/Image', 'zrender/graphic/Text', 'zrender/graphic/shape/Circle', 'zrender/graphic/shape/Sector', 'zrender/graphic/shape/Ring', 'zrender/graphic/shape/Polygon', 'zrender/graphic/shape/Polyline', 'zrender/graphic/shape/Rect', 'zrender/graphic/shape/Line', 'zrender/graphic/shape/BezierCurve', 'zrender/graphic/shape/Arc', 'zrender/graphic/CompoundPath', 'zrender/graphic/LinearGradient', 'zrender/graphic/RadialGradient', 'zrender/core/BoundingRect'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var pathTool = require('zrender/tool/path');\n\t    var round = Math.round;\n\t    var Path = require('zrender/graphic/Path');\n\t    var colorTool = require('zrender/tool/color');\n\t    var matrix = require('zrender/core/matrix');\n\t    var vector = require('zrender/core/vector');\n\t    var Gradient = require('zrender/graphic/Gradient');\n\t    var graphic = {};\n\t    graphic.Group = require('zrender/container/Group');\n\t    graphic.Image = require('zrender/graphic/Image');\n\t    graphic.Text = require('zrender/graphic/Text');\n\t    graphic.Circle = require('zrender/graphic/shape/Circle');\n\t    graphic.Sector = require('zrender/graphic/shape/Sector');\n\t    graphic.Ring = require('zrender/graphic/shape/Ring');\n\t    graphic.Polygon = require('zrender/graphic/shape/Polygon');\n\t    graphic.Polyline = require('zrender/graphic/shape/Polyline');\n\t    graphic.Rect = require('zrender/graphic/shape/Rect');\n\t    graphic.Line = require('zrender/graphic/shape/Line');\n\t    graphic.BezierCurve = require('zrender/graphic/shape/BezierCurve');\n\t    graphic.Arc = require('zrender/graphic/shape/Arc');\n\t    graphic.CompoundPath = require('zrender/graphic/CompoundPath');\n\t    graphic.LinearGradient = require('zrender/graphic/LinearGradient');\n\t    graphic.RadialGradient = require('zrender/graphic/RadialGradient');\n\t    graphic.BoundingRect = require('zrender/core/BoundingRect');\n\t    /**\n\t     * Extend shape with parameters\n\t     */\n\t    graphic.extendShape = function (opts) {\n\t        return Path.extend(opts);\n\t    };\n\t    /**\n\t     * Extend path\n\t     */\n\t    graphic.extendPath = function (pathData, opts) {\n\t        return pathTool.extendFromString(pathData, opts);\n\t    };\n\t    /**\n\t     * Create a path element from path data string\n\t     * @param {string} pathData\n\t     * @param {Object} opts\n\t     * @param {module:zrender/core/BoundingRect} rect\n\t     * @param {string} [layout=cover] 'center' or 'cover'\n\t     */\n\t    graphic.makePath = function (pathData, opts, rect, layout) {\n\t        var path = pathTool.createFromString(pathData, opts);\n\t        var boundingRect = path.getBoundingRect();\n\t        if (rect) {\n\t            var aspect = boundingRect.width / boundingRect.height;\n\t            if (layout === 'center') {\n\t                // Set rect to center, keep width / height ratio.\n\t                var width = rect.height * aspect;\n\t                var height;\n\t                if (width <= rect.width) {\n\t                    height = rect.height;\n\t                } else {\n\t                    width = rect.width;\n\t                    height = width / aspect;\n\t                }\n\t                var cx = rect.x + rect.width / 2;\n\t                var cy = rect.y + rect.height / 2;\n\t                rect.x = cx - width / 2;\n\t                rect.y = cy - height / 2;\n\t                rect.width = width;\n\t                rect.height = height;\n\t            }\n\t            this.resizePath(path, rect);\n\t        }\n\t        return path;\n\t    };\n\t    graphic.mergePath = pathTool.mergePath, graphic.resizePath = function (path, rect) {\n\t        if (!path.applyTransform) {\n\t            return;\n\t        }\n\t        var pathRect = path.getBoundingRect();\n\t        var m = pathRect.calculateTransform(rect);\n\t        path.applyTransform(m);\n\t    };\n\t    /**\n\t     * Sub pixel optimize line for canvas\n\t     *\n\t     * @param {Object} param\n\t     * @param {Object} [param.shape]\n\t     * @param {number} [param.shape.x1]\n\t     * @param {number} [param.shape.y1]\n\t     * @param {number} [param.shape.x2]\n\t     * @param {number} [param.shape.y2]\n\t     * @param {Object} [param.style]\n\t     * @param {number} [param.style.lineWidth]\n\t     * @return {Object} Modified param\n\t     */\n\t    graphic.subPixelOptimizeLine = function (param) {\n\t        var subPixelOptimize = graphic.subPixelOptimize;\n\t        var shape = param.shape;\n\t        var lineWidth = param.style.lineWidth;\n\t        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n\t            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n\t        }\n\t        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n\t            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n\t        }\n\t        return param;\n\t    };\n\t    /**\n\t     * Sub pixel optimize rect for canvas\n\t     *\n\t     * @param {Object} param\n\t     * @param {Object} [param.shape]\n\t     * @param {number} [param.shape.x]\n\t     * @param {number} [param.shape.y]\n\t     * @param {number} [param.shape.width]\n\t     * @param {number} [param.shape.height]\n\t     * @param {Object} [param.style]\n\t     * @param {number} [param.style.lineWidth]\n\t     * @return {Object} Modified param\n\t     */\n\t    graphic.subPixelOptimizeRect = function (param) {\n\t        var subPixelOptimize = graphic.subPixelOptimize;\n\t        var shape = param.shape;\n\t        var lineWidth = param.style.lineWidth;\n\t        var originX = shape.x;\n\t        var originY = shape.y;\n\t        var originWidth = shape.width;\n\t        var originHeight = shape.height;\n\t        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n\t        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n\t        shape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x, originWidth === 0 ? 0 : 1);\n\t        shape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y, originHeight === 0 ? 0 : 1);\n\t        return param;\n\t    };\n\t    /**\n\t     * Sub pixel optimize for canvas\n\t     *\n\t     * @param {number} position Coordinate, such as x, y\n\t     * @param {number} lineWidth Should be nonnegative integer.\n\t     * @param {boolean=} positiveOrNegative Default false (negative).\n\t     * @return {number} Optimized position.\n\t     */\n\t    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n\t        // Assure that (position + lineWidth / 2) is near integer edge,\n\t        // otherwise line will be fuzzy in canvas.\n\t        var doubledPosition = round(position * 2);\n\t        return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n\t    };\n\t    function hasFillOrStroke(fillOrStroke) {\n\t        return fillOrStroke != null && fillOrStroke != 'none';\n\t    }\n\t    function liftColor(color) {\n\t        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n\t    }\n\t    /**\n\t     * @private\n\t     */\n\t    function cacheElementStl(el) {\n\t        if (el.__hoverStlDirty) {\n\t            var stroke = el.style.stroke;\n\t            var fill = el.style.fill;\n\t            // Create hoverStyle on mouseover\n\t            var hoverStyle = el.__hoverStl;\n\t            hoverStyle.fill = hoverStyle.fill || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n\t            hoverStyle.stroke = hoverStyle.stroke || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\t            var normalStyle = {};\n\t            for (var name in hoverStyle) {\n\t                if (hoverStyle.hasOwnProperty(name)) {\n\t                    normalStyle[name] = el.style[name];\n\t                }\n\t            }\n\t            el.__normalStl = normalStyle;\n\t            el.__hoverStlDirty = false;\n\t        }\n\t    }\n\t    /**\n\t     * @private\n\t     */\n\t    function doSingleEnterHover(el) {\n\t        if (el.__isHover) {\n\t            return;\n\t        }\n\t        cacheElementStl(el);\n\t        if (el.useHoverLayer) {\n\t            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n\t        } else {\n\t            el.setStyle(el.__hoverStl);\n\t            el.z2 += 1;\n\t        }\n\t        el.__isHover = true;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function doSingleLeaveHover(el) {\n\t        if (!el.__isHover) {\n\t            return;\n\t        }\n\t        var normalStl = el.__normalStl;\n\t        if (el.useHoverLayer) {\n\t            el.__zr && el.__zr.removeHover(el);\n\t        } else {\n\t            normalStl && el.setStyle(normalStl);\n\t            el.z2 -= 1;\n\t        }\n\t        el.__isHover = false;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function doEnterHover(el) {\n\t        el.type === 'group' ? el.traverse(function (child) {\n\t            if (child.type !== 'group') {\n\t                doSingleEnterHover(child);\n\t            }\n\t        }) : doSingleEnterHover(el);\n\t    }\n\t    function doLeaveHover(el) {\n\t        el.type === 'group' ? el.traverse(function (child) {\n\t            if (child.type !== 'group') {\n\t                doSingleLeaveHover(child);\n\t            }\n\t        }) : doSingleLeaveHover(el);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function setElementHoverStl(el, hoverStl) {\n\t        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n\t        // Often used when item group has a label element and it's hoverStyle is different\n\t        el.__hoverStl = el.hoverStyle || hoverStl || {};\n\t        el.__hoverStlDirty = true;\n\t        if (el.__isHover) {\n\t            cacheElementStl(el);\n\t        }\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function onElementMouseOver() {\n\t        // Only if element is not in emphasis status\n\t        !this.__isEmphasis && doEnterHover(this);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function onElementMouseOut() {\n\t        // Only if element is not in emphasis status\n\t        !this.__isEmphasis && doLeaveHover(this);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function enterEmphasis() {\n\t        this.__isEmphasis = true;\n\t        doEnterHover(this);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function leaveEmphasis() {\n\t        this.__isEmphasis = false;\n\t        doLeaveHover(this);\n\t    }\n\t    /**\n\t     * Set hover style of element\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} [hoverStyle]\n\t     */\n\t    graphic.setHoverStyle = function (el, hoverStyle) {\n\t        el.type === 'group' ? el.traverse(function (child) {\n\t            if (child.type !== 'group') {\n\t                setElementHoverStl(child, hoverStyle);\n\t            }\n\t        }) : setElementHoverStl(el, hoverStyle);\n\t        // Remove previous bound handlers\n\t        el.on('mouseover', onElementMouseOver).on('mouseout', onElementMouseOut);\n\t        // Emphasis, normal can be triggered manually\n\t        el.on('emphasis', enterEmphasis).on('normal', leaveEmphasis);\n\t    };\n\t    /**\n\t     * Set text option in the style\n\t     * @param {Object} textStyle\n\t     * @param {module:echarts/model/Model} labelModel\n\t     * @param {string} color\n\t     */\n\t    graphic.setText = function (textStyle, labelModel, color) {\n\t        var labelPosition = labelModel.getShallow('position') || 'inside';\n\t        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n\t        var textStyleModel = labelModel.getModel('textStyle');\n\t        zrUtil.extend(textStyle, {\n\t            textDistance: labelModel.getShallow('distance') || 5,\n\t            textFont: textStyleModel.getFont(),\n\t            textPosition: labelPosition,\n\t            textFill: textStyleModel.getTextColor() || labelColor\n\t        });\n\t    };\n\t    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n\t        if (typeof dataIndex === 'function') {\n\t            cb = dataIndex;\n\t            dataIndex = null;\n\t        }\n\t        var animationEnabled = animatableModel && (animatableModel.ifEnableAnimation ? animatableModel.ifEnableAnimation() : animatableModel.getShallow('animation'));\n\t        if (animationEnabled) {\n\t            var postfix = isUpdate ? 'Update' : '';\n\t            var duration = animatableModel && animatableModel.getShallow('animationDuration' + postfix);\n\t            var animationEasing = animatableModel && animatableModel.getShallow('animationEasing' + postfix);\n\t            var animationDelay = animatableModel && animatableModel.getShallow('animationDelay' + postfix);\n\t            if (typeof animationDelay === 'function') {\n\t                animationDelay = animationDelay(dataIndex);\n\t            }\n\t            duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb) : (el.attr(props), cb && cb());\n\t        } else {\n\t            el.attr(props);\n\t            cb && cb();\n\t        }\n\t    }\n\t    /**\n\t     * Update graphic element properties with or without animation according to the configuration in series\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} props\n\t     * @param {module:echarts/model/Model} [animatableModel]\n\t     * @param {number} [dataIndex]\n\t     * @param {Function} [cb]\n\t     * @example\n\t     *     graphic.updateProps(el, {\n\t     *         position: [100, 100]\n\t     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n\t     *     // Or\n\t     *     graphic.updateProps(el, {\n\t     *         position: [100, 100]\n\t     *     }, seriesModel, function () { console.log('Animation done!'); });\n\t     */\n\t    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n\t        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n\t    };\n\t    /**\n\t     * Init graphic element properties with or without animation according to the configuration in series\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} props\n\t     * @param {module:echarts/model/Model} [animatableModel]\n\t     * @param {number} [dataIndex]\n\t     * @param {Function} cb\n\t     */\n\t    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n\t        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n\t    };\n\t    /**\n\t     * Get transform matrix of target (param target),\n\t     * in coordinate of its ancestor (param ancestor)\n\t     *\n\t     * @param {module:zrender/mixin/Transformable} target\n\t     * @param {module:zrender/mixin/Transformable} [ancestor]\n\t     */\n\t    graphic.getTransform = function (target, ancestor) {\n\t        var mat = matrix.identity([]);\n\t        while (target && target !== ancestor) {\n\t            matrix.mul(mat, target.getLocalTransform(), mat);\n\t            target = target.parent;\n\t        }\n\t        return mat;\n\t    };\n\t    /**\n\t     * Apply transform to an vertex.\n\t     * @param {Array.<number>} vertex [x, y]\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n\t     * @param {boolean=} invert Whether use invert matrix.\n\t     * @return {Array.<number>} [x, y]\n\t     */\n\t    graphic.applyTransform = function (vertex, transform, invert) {\n\t        if (invert) {\n\t            transform = matrix.invert([], transform);\n\t        }\n\t        return vector.applyTransform([], vertex, transform);\n\t    };\n\t    /**\n\t     * @param {string} direction 'left' 'right' 'top' 'bottom'\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n\t     * @param {boolean=} invert Whether use invert matrix.\n\t     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n\t     */\n\t    graphic.transformDirection = function (direction, transform, invert) {\n\t        // Pick a base, ensure that transform result will not be (0, 0).\n\t        var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);\n\t        var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\t        var vertex = [\n\t                direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n\t                direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n\t            ];\n\t        vertex = graphic.applyTransform(vertex, transform, invert);\n\t        return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n\t    };\n\t    /**\n\t     * Apply group transition animation from g1 to g2\n\t     */\n\t    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n\t        if (!g1 || !g2) {\n\t            return;\n\t        }\n\t        function getElMap(g) {\n\t            var elMap = {};\n\t            g.traverse(function (el) {\n\t                if (!el.isGroup && el.anid) {\n\t                    elMap[el.anid] = el;\n\t                }\n\t            });\n\t            return elMap;\n\t        }\n\t        function getAnimatableProps(el) {\n\t            var obj = {\n\t                    position: vector.clone(el.position),\n\t                    rotation: el.rotation\n\t                };\n\t            if (el.shape) {\n\t                obj.shape = zrUtil.extend({}, el.shape);\n\t            }\n\t            return obj;\n\t        }\n\t        var elMap1 = getElMap(g1);\n\t        g2.traverse(function (el) {\n\t            if (!el.isGroup && el.anid) {\n\t                var oldEl = elMap1[el.anid];\n\t                if (oldEl) {\n\t                    var newProp = getAnimatableProps(el);\n\t                    el.attr(getAnimatableProps(oldEl));\n\t                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n\t                }    // else {\n\t                     //     if (el.previousProps) {\n\t                     //         graphic.updateProps\n\t                     //     }\n\t                     // }\n\t            }\n\t        });\n\t    };\n\t    return graphic;\n\t});\n\tdefine('echarts/component/axis', ['require', '../coord/cartesian/AxisModel', './axis/AxisView'], function (require) {\n\t    'use strict';\n\t    require('../coord/cartesian/AxisModel');\n\t    require('./axis/AxisView');\n\t});\n\tdefine('echarts/util/layout', ['require', 'zrender/core/util', 'zrender/core/BoundingRect', './number', './format'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var BoundingRect = require('zrender/core/BoundingRect');\n\t    var numberUtil = require('./number');\n\t    var formatUtil = require('./format');\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var each = zrUtil.each;\n\t    var layout = {};\n\t    var LOCATION_PARAMS = [\n\t            'left',\n\t            'right',\n\t            'top',\n\t            'bottom',\n\t            'width',\n\t            'height'\n\t        ];\n\t    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n\t        var x = 0;\n\t        var y = 0;\n\t        if (maxWidth == null) {\n\t            maxWidth = Infinity;\n\t        }\n\t        if (maxHeight == null) {\n\t            maxHeight = Infinity;\n\t        }\n\t        var currentLineMaxSize = 0;\n\t        group.eachChild(function (child, idx) {\n\t            var position = child.position;\n\t            var rect = child.getBoundingRect();\n\t            var nextChild = group.childAt(idx + 1);\n\t            var nextChildRect = nextChild && nextChild.getBoundingRect();\n\t            var nextX;\n\t            var nextY;\n\t            if (orient === 'horizontal') {\n\t                var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n\t                nextX = x + moveX;\n\t                // Wrap when width exceeds maxWidth or meet a `newline` group\n\t                if (nextX > maxWidth || child.newline) {\n\t                    x = 0;\n\t                    nextX = moveX;\n\t                    y += currentLineMaxSize + gap;\n\t                    currentLineMaxSize = rect.height;\n\t                } else {\n\t                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n\t                }\n\t            } else {\n\t                var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n\t                nextY = y + moveY;\n\t                // Wrap when width exceeds maxHeight or meet a `newline` group\n\t                if (nextY > maxHeight || child.newline) {\n\t                    x += currentLineMaxSize + gap;\n\t                    y = 0;\n\t                    nextY = moveY;\n\t                    currentLineMaxSize = rect.width;\n\t                } else {\n\t                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n\t                }\n\t            }\n\t            if (child.newline) {\n\t                return;\n\t            }\n\t            position[0] = x;\n\t            position[1] = y;\n\t            orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n\t        });\n\t    }\n\t    /**\n\t     * VBox or HBox layouting\n\t     * @param {string} orient\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.box = boxLayout;\n\t    /**\n\t     * VBox layouting\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\t    /**\n\t     * HBox layouting\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\t    /**\n\t     * If x or x2 is not specified or 'center' 'left' 'right',\n\t     * the width would be as long as possible.\n\t     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n\t     * the height would be as long as possible.\n\t     *\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.x]\n\t     * @param {number|string} [positionInfo.y]\n\t     * @param {number|string} [positionInfo.x2]\n\t     * @param {number|string} [positionInfo.y2]\n\t     * @param {Object} containerRect\n\t     * @param {string|number} margin\n\t     * @return {Object} {width, height}\n\t     */\n\t    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n\t        var containerWidth = containerRect.width;\n\t        var containerHeight = containerRect.height;\n\t        var x = parsePercent(positionInfo.x, containerWidth);\n\t        var y = parsePercent(positionInfo.y, containerHeight);\n\t        var x2 = parsePercent(positionInfo.x2, containerWidth);\n\t        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\t        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n\t        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n\t        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n\t        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\t        margin = formatUtil.normalizeCssArray(margin || 0);\n\t        return {\n\t            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n\t            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n\t        };\n\t    };\n\t    /**\n\t     * Parse position info.\n\t     *\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.left]\n\t     * @param {number|string} [positionInfo.top]\n\t     * @param {number|string} [positionInfo.right]\n\t     * @param {number|string} [positionInfo.bottom]\n\t     * @param {number|string} [positionInfo.width]\n\t     * @param {number|string} [positionInfo.height]\n\t     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n\t     * @param {Object} containerRect\n\t     * @param {string|number} [margin]\n\t     *\n\t     * @return {module:zrender/core/BoundingRect}\n\t     */\n\t    layout.getLayoutRect = function (positionInfo, containerRect, margin) {\n\t        margin = formatUtil.normalizeCssArray(margin || 0);\n\t        var containerWidth = containerRect.width;\n\t        var containerHeight = containerRect.height;\n\t        var left = parsePercent(positionInfo.left, containerWidth);\n\t        var top = parsePercent(positionInfo.top, containerHeight);\n\t        var right = parsePercent(positionInfo.right, containerWidth);\n\t        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n\t        var width = parsePercent(positionInfo.width, containerWidth);\n\t        var height = parsePercent(positionInfo.height, containerHeight);\n\t        var verticalMargin = margin[2] + margin[0];\n\t        var horizontalMargin = margin[1] + margin[3];\n\t        var aspect = positionInfo.aspect;\n\t        // If width is not specified, calculate width from left and right\n\t        if (isNaN(width)) {\n\t            width = containerWidth - right - horizontalMargin - left;\n\t        }\n\t        if (isNaN(height)) {\n\t            height = containerHeight - bottom - verticalMargin - top;\n\t        }\n\t        // If width and height are not given\n\t        // 1. Graph should not exceeds the container\n\t        // 2. Aspect must be keeped\n\t        // 3. Graph should take the space as more as possible\n\t        if (isNaN(width) && isNaN(height)) {\n\t            if (aspect > containerWidth / containerHeight) {\n\t                width = containerWidth * 0.8;\n\t            } else {\n\t                height = containerHeight * 0.8;\n\t            }\n\t        }\n\t        if (aspect != null) {\n\t            // Calculate width or height with given aspect\n\t            if (isNaN(width)) {\n\t                width = aspect * height;\n\t            }\n\t            if (isNaN(height)) {\n\t                height = width / aspect;\n\t            }\n\t        }\n\t        // If left is not specified, calculate left from right and width\n\t        if (isNaN(left)) {\n\t            left = containerWidth - right - width - horizontalMargin;\n\t        }\n\t        if (isNaN(top)) {\n\t            top = containerHeight - bottom - height - verticalMargin;\n\t        }\n\t        // Align left and top\n\t        switch (positionInfo.left || positionInfo.right) {\n\t        case 'center':\n\t            left = containerWidth / 2 - width / 2 - margin[3];\n\t            break;\n\t        case 'right':\n\t            left = containerWidth - width - horizontalMargin;\n\t            break;\n\t        }\n\t        switch (positionInfo.top || positionInfo.bottom) {\n\t        case 'middle':\n\t        case 'center':\n\t            top = containerHeight / 2 - height / 2 - margin[0];\n\t            break;\n\t        case 'bottom':\n\t            top = containerHeight - height - verticalMargin;\n\t            break;\n\t        }\n\t        // If something is wrong and left, top, width, height are calculated as NaN\n\t        left = left || 0;\n\t        top = top || 0;\n\t        if (isNaN(width)) {\n\t            // Width may be NaN if only one value is given except width\n\t            width = containerWidth - left - (right || 0);\n\t        }\n\t        if (isNaN(height)) {\n\t            // Height may be NaN if only one value is given except height\n\t            height = containerHeight - top - (bottom || 0);\n\t        }\n\t        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n\t        rect.margin = margin;\n\t        return rect;\n\t    };\n\t    /**\n\t     * Position group of component in viewport\n\t     *  Group position is specified by either\n\t     *  {left, top}, {right, bottom}\n\t     *  If all properties exists, right and bottom will be igonred.\n\t     *\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.left]\n\t     * @param {number|string} [positionInfo.top]\n\t     * @param {number|string} [positionInfo.right]\n\t     * @param {number|string} [positionInfo.bottom]\n\t     * @param {Object} containerRect\n\t     * @param {string|number} margin\n\t     */\n\t    layout.positionGroup = function (group, positionInfo, containerRect, margin) {\n\t        var groupRect = group.getBoundingRect();\n\t        positionInfo = zrUtil.extend(zrUtil.clone(positionInfo), {\n\t            width: groupRect.width,\n\t            height: groupRect.height\n\t        });\n\t        positionInfo = layout.getLayoutRect(positionInfo, containerRect, margin);\n\t        group.attr('position', [\n\t            positionInfo.x - groupRect.x,\n\t            positionInfo.y - groupRect.y\n\t        ]);\n\t    };\n\t    /**\n\t     * Consider Case:\n\t     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n\t     * through setOption or media query, using normal zrUtil.merge will cause\n\t     * {right: 0} does not take effect.\n\t     *\n\t     * @example\n\t     * ComponentModel.extend({\n\t     *     init: function () {\n\t     *         ...\n\t     *         var inputPositionParams = layout.getLayoutParams(option);\n\t     *         this.mergeOption(inputPositionParams);\n\t     *     },\n\t     *     mergeOption: function (newOption) {\n\t     *         newOption && zrUtil.merge(thisOption, newOption, true);\n\t     *         layout.mergeLayoutParam(thisOption, newOption);\n\t     *     }\n\t     * });\n\t     *\n\t     * @param {Object} targetOption\n\t     * @param {Object} newOption\n\t     * @param {Object|string} [opt]\n\t     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.\n\t     */\n\t    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n\t        !zrUtil.isObject(opt) && (opt = {});\n\t        var hNames = [\n\t                'width',\n\t                'left',\n\t                'right'\n\t            ];\n\t        // Order by priority.\n\t        var vNames = [\n\t                'height',\n\t                'top',\n\t                'bottom'\n\t            ];\n\t        // Order by priority.\n\t        var hResult = merge(hNames);\n\t        var vResult = merge(vNames);\n\t        copy(hNames, targetOption, hResult);\n\t        copy(vNames, targetOption, vResult);\n\t        function merge(names) {\n\t            var newParams = {};\n\t            var newValueCount = 0;\n\t            var merged = {};\n\t            var mergedValueCount = 0;\n\t            var enoughParamNumber = opt.ignoreSize ? 1 : 2;\n\t            each(names, function (name) {\n\t                merged[name] = targetOption[name];\n\t            });\n\t            each(names, function (name) {\n\t                // Consider case: newOption.width is null, which is\n\t                // set by user for removing width setting.\n\t                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n\t                hasValue(newParams, name) && newValueCount++;\n\t                hasValue(merged, name) && mergedValueCount++;\n\t            });\n\t            // Case: newOption: {width: ..., right: ...},\n\t            // or targetOption: {right: ...} and newOption: {width: ...},\n\t            // There is no conflict when merged only has params count\n\t            // little than enoughParamNumber.\n\t            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n\t                return merged;\n\t            }    // Case: newOption: {width: ..., right: ...},\n\t                 // Than we can make sure user only want those two, and ignore\n\t                 // all origin params in targetOption.\n\t            else if (newValueCount >= enoughParamNumber) {\n\t                return newParams;\n\t            } else {\n\t                // Chose another param from targetOption by priority.\n\t                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.\n\t                for (var i = 0; i < names.length; i++) {\n\t                    var name = names[i];\n\t                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n\t                        newParams[name] = targetOption[name];\n\t                        break;\n\t                    }\n\t                }\n\t                return newParams;\n\t            }\n\t        }\n\t        function hasProp(obj, name) {\n\t            return obj.hasOwnProperty(name);\n\t        }\n\t        function hasValue(obj, name) {\n\t            return obj[name] != null && obj[name] !== 'auto';\n\t        }\n\t        function copy(names, target, source) {\n\t            each(names, function (name) {\n\t                target[name] = source[name];\n\t            });\n\t        }\n\t    };\n\t    /**\n\t     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n\t     * @param {Object} source\n\t     * @return {Object} Result contains those props.\n\t     */\n\t    layout.getLayoutParams = function (source) {\n\t        return layout.copyLayoutParams({}, source);\n\t    };\n\t    /**\n\t     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n\t     * @param {Object} source\n\t     * @return {Object} Result contains those props.\n\t     */\n\t    layout.copyLayoutParams = function (target, source) {\n\t        source && target && each(LOCATION_PARAMS, function (name) {\n\t            source.hasOwnProperty(name) && (target[name] = source[name]);\n\t        });\n\t        return target;\n\t    };\n\t    return layout;\n\t});\n\tdefine('echarts/util/number', ['require'], function (require) {\n\t    var number = {};\n\t    var RADIAN_EPSILON = 0.0001;\n\t    function _trim(str) {\n\t        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n\t    }\n\t    /**\n\t     * Linear mapping a value from domain to range\n\t     * @memberOf module:echarts/util/number\n\t     * @param  {(number|Array.<number>)} val\n\t     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n\t     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n\t     * @param  {boolean} clamp\n\t     * @return {(number|Array.<number>}\n\t     */\n\t    number.linearMap = function (val, domain, range, clamp) {\n\t        var subDomain = domain[1] - domain[0];\n\t        var subRange = range[1] - range[0];\n\t        if (subDomain === 0) {\n\t            return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;\n\t        }\n\t        // Avoid accuracy problem in edge, such as\n\t        // 146.39 - 62.83 === 83.55999999999999.\n\t        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n\t        // It is a little verbose for efficiency considering this method\n\t        // is a hotspot.\n\t        if (clamp) {\n\t            if (subDomain > 0) {\n\t                if (val <= domain[0]) {\n\t                    return range[0];\n\t                } else if (val >= domain[1]) {\n\t                    return range[1];\n\t                }\n\t            } else {\n\t                if (val >= domain[0]) {\n\t                    return range[0];\n\t                } else if (val <= domain[1]) {\n\t                    return range[1];\n\t                }\n\t            }\n\t        } else {\n\t            if (val === domain[0]) {\n\t                return range[0];\n\t            }\n\t            if (val === domain[1]) {\n\t                return range[1];\n\t            }\n\t        }\n\t        return (val - domain[0]) / subDomain * subRange + range[0];\n\t    };\n\t    /**\n\t     * Convert a percent string to absolute number.\n\t     * Returns NaN if percent is not a valid string or number\n\t     * @memberOf module:echarts/util/number\n\t     * @param {string|number} percent\n\t     * @param {number} all\n\t     * @return {number}\n\t     */\n\t    number.parsePercent = function (percent, all) {\n\t        switch (percent) {\n\t        case 'center':\n\t        case 'middle':\n\t            percent = '50%';\n\t            break;\n\t        case 'left':\n\t        case 'top':\n\t            percent = '0%';\n\t            break;\n\t        case 'right':\n\t        case 'bottom':\n\t            percent = '100%';\n\t            break;\n\t        }\n\t        if (typeof percent === 'string') {\n\t            if (_trim(percent).match(/%$/)) {\n\t                return parseFloat(percent) / 100 * all;\n\t            }\n\t            return parseFloat(percent);\n\t        }\n\t        return percent == null ? NaN : +percent;\n\t    };\n\t    /**\n\t     * Fix rounding error of float numbers\n\t     * @param {number} x\n\t     * @return {number}\n\t     */\n\t    number.round = function (x, precision) {\n\t        if (precision == null) {\n\t            precision = 10;\n\t        }\n\t        // PENDING\n\t        return +(+x).toFixed(precision);\n\t    };\n\t    number.asc = function (arr) {\n\t        arr.sort(function (a, b) {\n\t            return a - b;\n\t        });\n\t        return arr;\n\t    };\n\t    /**\n\t     * Get precision\n\t     * @param {number} val\n\t     */\n\t    number.getPrecision = function (val) {\n\t        val = +val;\n\t        if (isNaN(val)) {\n\t            return 0;\n\t        }\n\t        // It is much faster than methods converting number to string as follows\n\t        //      var tmp = val.toString();\n\t        //      return tmp.length - 1 - tmp.indexOf('.');\n\t        // especially when precision is low\n\t        var e = 1;\n\t        var count = 0;\n\t        while (Math.round(val * e) / e !== val) {\n\t            e *= 10;\n\t            count++;\n\t        }\n\t        return count;\n\t    };\n\t    number.getPrecisionSafe = function (val) {\n\t        var str = val.toString();\n\t        var dotIndex = str.indexOf('.');\n\t        if (dotIndex < 0) {\n\t            return 0;\n\t        }\n\t        return str.length - 1 - dotIndex;\n\t    };\n\t    /**\n\t     * @param {Array.<number>} dataExtent\n\t     * @param {Array.<number>} pixelExtent\n\t     * @return {number}  precision\n\t     */\n\t    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n\t        var log = Math.log;\n\t        var LN10 = Math.LN10;\n\t        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n\t        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n\t        return Math.max(-dataQuantity + sizeQuantity, 0);\n\t    };\n\t    // Number.MAX_SAFE_INTEGER, ie do not support.\n\t    number.MAX_SAFE_INTEGER = 9007199254740991;\n\t    /**\n\t     * To 0 - 2 * PI, considering negative radian.\n\t     * @param {number} radian\n\t     * @return {number}\n\t     */\n\t    number.remRadian = function (radian) {\n\t        var pi2 = Math.PI * 2;\n\t        return (radian % pi2 + pi2) % pi2;\n\t    };\n\t    /**\n\t     * @param {type} radian\n\t     * @return {boolean}\n\t     */\n\t    number.isRadianAroundZero = function (val) {\n\t        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n\t    };\n\t    /**\n\t     * @param {string|Date|number} value\n\t     * @return {Date} date\n\t     */\n\t    number.parseDate = function (value) {\n\t        if (value instanceof Date) {\n\t            return value;\n\t        } else if (typeof value === 'string') {\n\t            // Treat as ISO format. See issue #3623\n\t            var ret = new Date(value);\n\t            if (isNaN(+ret)) {\n\t                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local\n\t                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));\n\t            }\n\t            return ret;\n\t        }\n\t        return new Date(Math.round(value));\n\t    };\n\t    /**\n\t     * Quantity of a number. e.g. 0.1, 1, 10, 100\n\t     * @param  {number} val\n\t     * @return {number}\n\t     */\n\t    number.quantity = function (val) {\n\t        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));\n\t    };\n\t    // \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t    /**\n\t     * find a “nice” number approximately equal to x. Round the number if round = true, take ceiling if round = false\n\t     * The primary observation is that the “nicest” numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n\t     * @param  {number} val\n\t     * @param  {boolean} round\n\t     * @return {number}\n\t     */\n\t    number.nice = function (val, round) {\n\t        var exp10 = number.quantity(val);\n\t        var f = val / exp10;\n\t        // between 1 and 10\n\t        var nf;\n\t        if (round) {\n\t            if (f < 1.5) {\n\t                nf = 1;\n\t            } else if (f < 2.5) {\n\t                nf = 2;\n\t            } else if (f < 4) {\n\t                nf = 3;\n\t            } else if (f < 7) {\n\t                nf = 5;\n\t            } else {\n\t                nf = 10;\n\t            }\n\t        } else {\n\t            if (f < 1) {\n\t                nf = 1;\n\t            } else if (f < 2) {\n\t                nf = 2;\n\t            } else if (f < 3) {\n\t                nf = 3;\n\t            } else if (f < 5) {\n\t                nf = 5;\n\t            } else {\n\t                nf = 10;\n\t            }\n\t        }\n\t        return nf * exp10;\n\t    };\n\t    return number;\n\t});\n\tdefine('echarts/util/format', ['require', 'zrender/core/util', './number', 'zrender/contain/text'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var numberUtil = require('./number');\n\t    var textContain = require('zrender/contain/text');\n\t    var formatUtil = {};\n\t    /**\n\t     * 每三位默认加,格式化\n\t     * @type {string|number} x\n\t     */\n\t    formatUtil.addCommas = function (x) {\n\t        if (isNaN(x)) {\n\t            return '-';\n\t        }\n\t        x = (x + '').split('.');\n\t        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g, '$1,') + (x.length > 1 ? '.' + x[1] : '');\n\t    };\n\t    /**\n\t     * @param {string} str\n\t     * @return {string} str\n\t     */\n\t    formatUtil.toCamelCase = function (str) {\n\t        return str.toLowerCase().replace(/-(.)/g, function (match, group1) {\n\t            return group1.toUpperCase();\n\t        });\n\t    };\n\t    /**\n\t     * Normalize css liked array configuration\n\t     * e.g.\n\t     *  3 => [3, 3, 3, 3]\n\t     *  [4, 2] => [4, 2, 4, 2]\n\t     *  [4, 3, 2] => [4, 3, 2, 3]\n\t     * @param {number|Array.<number>} val\n\t     */\n\t    formatUtil.normalizeCssArray = function (val) {\n\t        var len = val.length;\n\t        if (typeof val === 'number') {\n\t            return [\n\t                val,\n\t                val,\n\t                val,\n\t                val\n\t            ];\n\t        } else if (len === 2) {\n\t            // vertical | horizontal\n\t            return [\n\t                val[0],\n\t                val[1],\n\t                val[0],\n\t                val[1]\n\t            ];\n\t        } else if (len === 3) {\n\t            // top | horizontal | bottom\n\t            return [\n\t                val[0],\n\t                val[1],\n\t                val[2],\n\t                val[1]\n\t            ];\n\t        }\n\t        return val;\n\t    };\n\t    formatUtil.encodeHTML = function (source) {\n\t        return String(source).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;');\n\t    };\n\t    var TPL_VAR_ALIAS = [\n\t            'a',\n\t            'b',\n\t            'c',\n\t            'd',\n\t            'e',\n\t            'f',\n\t            'g'\n\t        ];\n\t    var wrapVar = function (varName, seriesIdx) {\n\t        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n\t    };\n\t    /**\n\t     * Template formatter\n\t     * @param  {string} tpl\n\t     * @param  {Array.<Object>|Object} paramsList\n\t     * @return {string}\n\t     */\n\t    formatUtil.formatTpl = function (tpl, paramsList) {\n\t        if (!zrUtil.isArray(paramsList)) {\n\t            paramsList = [paramsList];\n\t        }\n\t        var seriesLen = paramsList.length;\n\t        if (!seriesLen) {\n\t            return '';\n\t        }\n\t        var $vars = paramsList[0].$vars || [];\n\t        for (var i = 0; i < $vars.length; i++) {\n\t            var alias = TPL_VAR_ALIAS[i];\n\t            tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));\n\t        }\n\t        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n\t            for (var k = 0; k < $vars.length; k++) {\n\t                tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), paramsList[seriesIdx][$vars[k]]);\n\t            }\n\t        }\n\t        return tpl;\n\t    };\n\t    /**\n\t     * @param {string} str\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    var s2d = function (str) {\n\t        return str < 10 ? '0' + str : str;\n\t    };\n\t    /**\n\t     * ISO Date format\n\t     * @param {string} tpl\n\t     * @param {number} value\n\t     * @inner\n\t     */\n\t    formatUtil.formatTime = function (tpl, value) {\n\t        if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {\n\t            tpl = 'MM-dd\\nyyyy';\n\t        }\n\t        var date = numberUtil.parseDate(value);\n\t        var y = date.getFullYear();\n\t        var M = date.getMonth() + 1;\n\t        var d = date.getDate();\n\t        var h = date.getHours();\n\t        var m = date.getMinutes();\n\t        var s = date.getSeconds();\n\t        tpl = tpl.replace('MM', s2d(M)).toLowerCase().replace('yyyy', y).replace('yy', y % 100).replace('dd', s2d(d)).replace('d', d).replace('hh', s2d(h)).replace('h', h).replace('mm', s2d(m)).replace('m', m).replace('ss', s2d(s)).replace('s', s);\n\t        return tpl;\n\t    };\n\t    /**\n\t     * Capital first\n\t     * @param {string} str\n\t     * @return {string}\n\t     */\n\t    formatUtil.capitalFirst = function (str) {\n\t        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n\t    };\n\t    formatUtil.truncateText = textContain.truncateText;\n\t    return formatUtil;\n\t});\n\tdefine('echarts/scale/Interval', ['require', '../util/number', '../util/format', './Scale'], function (require) {\n\t    var numberUtil = require('../util/number');\n\t    var formatUtil = require('../util/format');\n\t    var Scale = require('./Scale');\n\t    var mathFloor = Math.floor;\n\t    var mathCeil = Math.ceil;\n\t    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n\t    var roundingErrorFix = numberUtil.round;\n\t    /**\n\t     * @alias module:echarts/coord/scale/Interval\n\t     * @constructor\n\t     */\n\t    var IntervalScale = Scale.extend({\n\t            type: 'interval',\n\t            _interval: 0,\n\t            setExtent: function (start, end) {\n\t                var thisExtent = this._extent;\n\t                //start,end may be a Number like '25',so...\n\t                if (!isNaN(start)) {\n\t                    thisExtent[0] = parseFloat(start);\n\t                }\n\t                if (!isNaN(end)) {\n\t                    thisExtent[1] = parseFloat(end);\n\t                }\n\t            },\n\t            unionExtent: function (other) {\n\t                var extent = this._extent;\n\t                other[0] < extent[0] && (extent[0] = other[0]);\n\t                other[1] > extent[1] && (extent[1] = other[1]);\n\t                // unionExtent may called by it's sub classes\n\t                IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n\t            },\n\t            getInterval: function () {\n\t                if (!this._interval) {\n\t                    this.niceTicks();\n\t                }\n\t                return this._interval;\n\t            },\n\t            setInterval: function (interval) {\n\t                this._interval = interval;\n\t                // Dropped auto calculated niceExtent and use user setted extent\n\t                // We assume user wan't to set both interval, min, max to get a better result\n\t                this._niceExtent = this._extent.slice();\n\t            },\n\t            getTicks: function () {\n\t                if (!this._interval) {\n\t                    this.niceTicks();\n\t                }\n\t                var interval = this._interval;\n\t                var extent = this._extent;\n\t                var ticks = [];\n\t                // Consider this case: using dataZoom toolbox, zoom and zoom.\n\t                var safeLimit = 10000;\n\t                if (interval) {\n\t                    var niceExtent = this._niceExtent;\n\t                    var precision = getPrecisionSafe(interval) + 2;\n\t                    if (extent[0] < niceExtent[0]) {\n\t                        ticks.push(extent[0]);\n\t                    }\n\t                    var tick = niceExtent[0];\n\t                    while (tick <= niceExtent[1]) {\n\t                        ticks.push(tick);\n\t                        // Avoid rounding error\n\t                        tick = roundingErrorFix(tick + interval, precision);\n\t                        if (ticks.length > safeLimit) {\n\t                            return [];\n\t                        }\n\t                    }\n\t                    if (extent[1] > niceExtent[1]) {\n\t                        ticks.push(extent[1]);\n\t                    }\n\t                }\n\t                return ticks;\n\t            },\n\t            getTicksLabels: function () {\n\t                var labels = [];\n\t                var ticks = this.getTicks();\n\t                for (var i = 0; i < ticks.length; i++) {\n\t                    labels.push(this.getLabel(ticks[i]));\n\t                }\n\t                return labels;\n\t            },\n\t            getLabel: function (data) {\n\t                return formatUtil.addCommas(data);\n\t            },\n\t            niceTicks: function (splitNumber) {\n\t                splitNumber = splitNumber || 5;\n\t                var extent = this._extent;\n\t                var span = extent[1] - extent[0];\n\t                if (!isFinite(span)) {\n\t                    return;\n\t                }\n\t                // User may set axis min 0 and data are all negative\n\t                // FIXME If it needs to reverse ?\n\t                if (span < 0) {\n\t                    span = -span;\n\t                    extent.reverse();\n\t                }\n\t                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t                // var niceSpan = numberUtil.nice(span, false);\n\t                var step = roundingErrorFix(numberUtil.nice(span / splitNumber, true), Math.max(getPrecisionSafe(extent[0]), getPrecisionSafe(extent[1])) + 2);\n\t                var precision = getPrecisionSafe(step) + 2;\n\t                // Niced extent inside original extent\n\t                var niceExtent = [\n\t                        roundingErrorFix(mathCeil(extent[0] / step) * step, precision),\n\t                        roundingErrorFix(mathFloor(extent[1] / step) * step, precision)\n\t                    ];\n\t                this._interval = step;\n\t                this._niceExtent = niceExtent;\n\t            },\n\t            niceExtent: function (splitNumber, fixMin, fixMax) {\n\t                var extent = this._extent;\n\t                // If extent start and end are same, expand them\n\t                if (extent[0] === extent[1]) {\n\t                    if (extent[0] !== 0) {\n\t                        // Expand extent\n\t                        var expandSize = extent[0];\n\t                        // In the fowllowing case\n\t                        //      Axis has been fixed max 100\n\t                        //      Plus data are all 100 and axis extent are [100, 100].\n\t                        // Extend to the both side will cause expanded max is larger than fixed max.\n\t                        // So only expand to the smaller side.\n\t                        if (!fixMax) {\n\t                            extent[1] += expandSize / 2;\n\t                            extent[0] -= expandSize / 2;\n\t                        } else {\n\t                            extent[0] -= expandSize / 2;\n\t                        }\n\t                    } else {\n\t                        extent[1] = 1;\n\t                    }\n\t                }\n\t                var span = extent[1] - extent[0];\n\t                // If there are no data and extent are [Infinity, -Infinity]\n\t                if (!isFinite(span)) {\n\t                    extent[0] = 0;\n\t                    extent[1] = 1;\n\t                }\n\t                this.niceTicks(splitNumber);\n\t                // var extent = this._extent;\n\t                var interval = this._interval;\n\t                if (!fixMin) {\n\t                    extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);\n\t                }\n\t                if (!fixMax) {\n\t                    extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);\n\t                }\n\t            }\n\t        });\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    IntervalScale.create = function () {\n\t        return new IntervalScale();\n\t    };\n\t    return IntervalScale;\n\t});\n\tdefine('zrender/core/env', [], function () {\n\t    var env = {};\n\t    if (typeof navigator === 'undefined') {\n\t        // In node\n\t        env = {\n\t            browser: {},\n\t            os: {},\n\t            node: true,\n\t            canvasSupported: true\n\t        };\n\t    } else {\n\t        env = detect(navigator.userAgent);\n\t    }\n\t    return env;\n\t    // Zepto.js\n\t    // (c) 2010-2013 Thomas Fuchs\n\t    // Zepto.js may be freely distributed under the MIT license.\n\t    function detect(ua) {\n\t        var os = {};\n\t        var browser = {};\n\t        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n\t        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n\t        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\t        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n\t        // var touchpad = webos && ua.match(/TouchPad/);\n\t        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n\t        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n\t        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n\t        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n\t        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n\t        // var playbook = ua.match(/PlayBook/);\n\t        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\t        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n\t        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n\t        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\t        var ie = ua.match(/MSIE\\s([\\d.]+)/) || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n\t        var edge = ua.match(/Edge\\/([\\d.]+)/);\n\t        // IE 12 and 12+\n\t        // Todo: clean this up with a better OS/browser seperation:\n\t        // - discern (more) between multiple browsers on android\n\t        // - decide if kindle fire in silk mode is android or not\n\t        // - Firefox on Android doesn't specify the Android version\n\t        // - possibly devide in os, device and browser hashes\n\t        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\t        // if (android) os.android = true, os.version = android[2];\n\t        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n\t        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n\t        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n\t        // if (webos) os.webos = true, os.version = webos[2];\n\t        // if (touchpad) os.touchpad = true;\n\t        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n\t        // if (bb10) os.bb10 = true, os.version = bb10[2];\n\t        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n\t        // if (playbook) browser.playbook = true;\n\t        // if (kindle) os.kindle = true, os.version = kindle[1];\n\t        // if (silk) browser.silk = true, browser.version = silk[1];\n\t        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n\t        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\t        if (firefox)\n\t            browser.firefox = true, browser.version = firefox[1];\n\t        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n\t        // if (webview) browser.webview = true;\n\t        if (ie) {\n\t            browser.ie = true;\n\t            browser.version = ie[1];\n\t        }\n\t        if (ie) {\n\t            browser.ie = true;\n\t            browser.version = ie[1];\n\t        }\n\t        if (edge) {\n\t            browser.edge = true;\n\t            browser.version = edge[1];\n\t        }\n\t        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n\t        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n\t        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n\t        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n\t        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\t        return {\n\t            browser: browser,\n\t            os: os,\n\t            node: false,\n\t            canvasSupported: document.createElement('canvas').getContext ? true : false,\n\t            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n\t            pointerEventsSupported: 'onpointerdown' in window && (browser.edge || browser.ie && browser.version >= 10)\n\t        };\n\t    }\n\t});\n\tdefine('echarts/ExtensionAPI', ['require', 'zrender/core/util'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var echartsAPIList = [\n\t            'getDom',\n\t            'getZr',\n\t            'getWidth',\n\t            'getHeight',\n\t            'dispatchAction',\n\t            'isDisposed',\n\t            'on',\n\t            'off',\n\t            'getDataURL',\n\t            'getConnectedDataURL',\n\t            'getModel',\n\t            'getOption'\n\t        ];\n\t    function ExtensionAPI(chartInstance) {\n\t        zrUtil.each(echartsAPIList, function (name) {\n\t            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n\t        }, this);\n\t    }\n\t    return ExtensionAPI;\n\t});\n\tdefine('echarts/model/Global', ['require', 'zrender/core/util', '../util/model', './Model', './Component', './globalDefault', './mixin/colorPalette'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../util/model');\n\t    var Model = require('./Model');\n\t    var each = zrUtil.each;\n\t    var filter = zrUtil.filter;\n\t    var map = zrUtil.map;\n\t    var isArray = zrUtil.isArray;\n\t    var indexOf = zrUtil.indexOf;\n\t    var isObject = zrUtil.isObject;\n\t    var ComponentModel = require('./Component');\n\t    var globalDefault = require('./globalDefault');\n\t    var OPTION_INNER_KEY = '\u0000_ec_inner';\n\t    /**\n\t     * @alias module:echarts/model/Global\n\t     *\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} parentModel\n\t     * @param {Object} theme\n\t     */\n\t    var GlobalModel = Model.extend({\n\t            constructor: GlobalModel,\n\t            init: function (option, parentModel, theme, optionManager) {\n\t                theme = theme || {};\n\t                this.option = null;\n\t                // Mark as not initialized.\n\t                /**\n\t             * @type {module:echarts/model/Model}\n\t             * @private\n\t             */\n\t                this._theme = new Model(theme);\n\t                /**\n\t             * @type {module:echarts/model/OptionManager}\n\t             */\n\t                this._optionManager = optionManager;\n\t            },\n\t            setOption: function (option, optionPreprocessorFuncs) {\n\t                zrUtil.assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');\n\t                this._optionManager.setOption(option, optionPreprocessorFuncs);\n\t                this.resetOption();\n\t            },\n\t            resetOption: function (type) {\n\t                var optionChanged = false;\n\t                var optionManager = this._optionManager;\n\t                if (!type || type === 'recreate') {\n\t                    var baseOption = optionManager.mountOption(type === 'recreate');\n\t                    if (!this.option || type === 'recreate') {\n\t                        initBase.call(this, baseOption);\n\t                    } else {\n\t                        this.restoreData();\n\t                        this.mergeOption(baseOption);\n\t                    }\n\t                    optionChanged = true;\n\t                }\n\t                if (type === 'timeline' || type === 'media') {\n\t                    this.restoreData();\n\t                }\n\t                if (!type || type === 'recreate' || type === 'timeline') {\n\t                    var timelineOption = optionManager.getTimelineOption(this);\n\t                    timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n\t                }\n\t                if (!type || type === 'recreate' || type === 'media') {\n\t                    var mediaOptions = optionManager.getMediaOption(this, this._api);\n\t                    if (mediaOptions.length) {\n\t                        each(mediaOptions, function (mediaOption) {\n\t                            this.mergeOption(mediaOption, optionChanged = true);\n\t                        }, this);\n\t                    }\n\t                }\n\t                return optionChanged;\n\t            },\n\t            mergeOption: function (newOption) {\n\t                var option = this.option;\n\t                var componentsMap = this._componentsMap;\n\t                var newCptTypes = [];\n\t                // 如果不存在对应的 component model 则直接 merge\n\t                each(newOption, function (componentOption, mainType) {\n\t                    if (componentOption == null) {\n\t                        return;\n\t                    }\n\t                    if (!ComponentModel.hasClass(mainType)) {\n\t                        option[mainType] = option[mainType] == null ? zrUtil.clone(componentOption) : zrUtil.merge(option[mainType], componentOption, true);\n\t                    } else {\n\t                        newCptTypes.push(mainType);\n\t                    }\n\t                });\n\t                // FIXME OPTION 同步是否要改回原来的\n\t                ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n\t                this._seriesIndices = this._seriesIndices || [];\n\t                function visitComponent(mainType, dependencies) {\n\t                    var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\t                    var mapResult = modelUtil.mappingToExists(componentsMap[mainType], newCptOptionList);\n\t                    makeKeyInfo(mainType, mapResult);\n\t                    var dependentModels = getComponentsByTypes(componentsMap, dependencies);\n\t                    option[mainType] = [];\n\t                    componentsMap[mainType] = [];\n\t                    each(mapResult, function (resultItem, index) {\n\t                        var componentModel = resultItem.exist;\n\t                        var newCptOption = resultItem.option;\n\t                        zrUtil.assert(isObject(newCptOption) || componentModel, 'Empty component definition');\n\t                        // Consider where is no new option and should be merged using {},\n\t                        // see removeEdgeAndAdd in topologicalTravel and\n\t                        // ComponentModel.getAllClassMainTypes.\n\t                        if (!newCptOption) {\n\t                            componentModel.mergeOption({}, this);\n\t                            componentModel.optionUpdated({}, false);\n\t                        } else {\n\t                            var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\n\t                            if (componentModel && componentModel instanceof ComponentModelClass) {\n\t                                componentModel.mergeOption(newCptOption, this);\n\t                                componentModel.optionUpdated(newCptOption, false);\n\t                            } else {\n\t                                // PENDING Global as parent ?\n\t                                var extraOpt = zrUtil.extend({\n\t                                        dependentModels: dependentModels,\n\t                                        componentIndex: index\n\t                                    }, resultItem.keyInfo);\n\t                                componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);\n\t                                componentModel.init(newCptOption, this, this, extraOpt);\n\t                                // Call optionUpdated after init.\n\t                                // newCptOption has been used as componentModel.option\n\t                                // and may be merged with theme and default, so pass null\n\t                                // to avoid confusion.\n\t                                componentModel.optionUpdated(null, true);\n\t                            }\n\t                        }\n\t                        componentsMap[mainType][index] = componentModel;\n\t                        option[mainType][index] = componentModel.option;\n\t                    }, this);\n\t                    // Backup series for filtering.\n\t                    if (mainType === 'series') {\n\t                        this._seriesIndices = createSeriesIndices(componentsMap.series);\n\t                    }\n\t                }\n\t            },\n\t            getOption: function () {\n\t                var option = zrUtil.clone(this.option);\n\t                each(option, function (opts, mainType) {\n\t                    if (ComponentModel.hasClass(mainType)) {\n\t                        var opts = modelUtil.normalizeToArray(opts);\n\t                        for (var i = opts.length - 1; i >= 0; i--) {\n\t                            // Remove options with inner id.\n\t                            if (modelUtil.isIdInner(opts[i])) {\n\t                                opts.splice(i, 1);\n\t                            }\n\t                        }\n\t                        option[mainType] = opts;\n\t                    }\n\t                });\n\t                delete option[OPTION_INNER_KEY];\n\t                return option;\n\t            },\n\t            getTheme: function () {\n\t                return this._theme;\n\t            },\n\t            getComponent: function (mainType, idx) {\n\t                var list = this._componentsMap[mainType];\n\t                if (list) {\n\t                    return list[idx || 0];\n\t                }\n\t            },\n\t            queryComponents: function (condition) {\n\t                var mainType = condition.mainType;\n\t                if (!mainType) {\n\t                    return [];\n\t                }\n\t                var index = condition.index;\n\t                var id = condition.id;\n\t                var name = condition.name;\n\t                var cpts = this._componentsMap[mainType];\n\t                if (!cpts || !cpts.length) {\n\t                    return [];\n\t                }\n\t                var result;\n\t                if (index != null) {\n\t                    if (!isArray(index)) {\n\t                        index = [index];\n\t                    }\n\t                    result = filter(map(index, function (idx) {\n\t                        return cpts[idx];\n\t                    }), function (val) {\n\t                        return !!val;\n\t                    });\n\t                } else if (id != null) {\n\t                    var isIdArray = isArray(id);\n\t                    result = filter(cpts, function (cpt) {\n\t                        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;\n\t                    });\n\t                } else if (name != null) {\n\t                    var isNameArray = isArray(name);\n\t                    result = filter(cpts, function (cpt) {\n\t                        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;\n\t                    });\n\t                } else {\n\t                    // Return all components with mainType\n\t                    result = cpts;\n\t                }\n\t                return filterBySubType(result, condition);\n\t            },\n\t            findComponents: function (condition) {\n\t                var query = condition.query;\n\t                var mainType = condition.mainType;\n\t                var queryCond = getQueryCond(query);\n\t                var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap[mainType];\n\t                return doFilter(filterBySubType(result, condition));\n\t                function getQueryCond(q) {\n\t                    var indexAttr = mainType + 'Index';\n\t                    var idAttr = mainType + 'Id';\n\t                    var nameAttr = mainType + 'Name';\n\t                    return q && (q.hasOwnProperty(indexAttr) || q.hasOwnProperty(idAttr) || q.hasOwnProperty(nameAttr)) ? {\n\t                        mainType: mainType,\n\t                        index: q[indexAttr],\n\t                        id: q[idAttr],\n\t                        name: q[nameAttr]\n\t                    } : null;\n\t                }\n\t                function doFilter(res) {\n\t                    return condition.filter ? filter(res, condition.filter) : res;\n\t                }\n\t            },\n\t            eachComponent: function (mainType, cb, context) {\n\t                var componentsMap = this._componentsMap;\n\t                if (typeof mainType === 'function') {\n\t                    context = cb;\n\t                    cb = mainType;\n\t                    each(componentsMap, function (components, componentType) {\n\t                        each(components, function (component, index) {\n\t                            cb.call(context, componentType, component, index);\n\t                        });\n\t                    });\n\t                } else if (zrUtil.isString(mainType)) {\n\t                    each(componentsMap[mainType], cb, context);\n\t                } else if (isObject(mainType)) {\n\t                    var queryResult = this.findComponents(mainType);\n\t                    each(queryResult, cb, context);\n\t                }\n\t            },\n\t            getSeriesByName: function (name) {\n\t                var series = this._componentsMap.series;\n\t                return filter(series, function (oneSeries) {\n\t                    return oneSeries.name === name;\n\t                });\n\t            },\n\t            getSeriesByIndex: function (seriesIndex) {\n\t                return this._componentsMap.series[seriesIndex];\n\t            },\n\t            getSeriesByType: function (subType) {\n\t                var series = this._componentsMap.series;\n\t                return filter(series, function (oneSeries) {\n\t                    return oneSeries.subType === subType;\n\t                });\n\t            },\n\t            getSeries: function () {\n\t                return this._componentsMap.series.slice();\n\t            },\n\t            eachSeries: function (cb, context) {\n\t                assertSeriesInitialized(this);\n\t                each(this._seriesIndices, function (rawSeriesIndex) {\n\t                    var series = this._componentsMap.series[rawSeriesIndex];\n\t                    cb.call(context, series, rawSeriesIndex);\n\t                }, this);\n\t            },\n\t            eachRawSeries: function (cb, context) {\n\t                each(this._componentsMap.series, cb, context);\n\t            },\n\t            eachSeriesByType: function (subType, cb, context) {\n\t                assertSeriesInitialized(this);\n\t                each(this._seriesIndices, function (rawSeriesIndex) {\n\t                    var series = this._componentsMap.series[rawSeriesIndex];\n\t                    if (series.subType === subType) {\n\t                        cb.call(context, series, rawSeriesIndex);\n\t                    }\n\t                }, this);\n\t            },\n\t            eachRawSeriesByType: function (subType, cb, context) {\n\t                return each(this.getSeriesByType(subType), cb, context);\n\t            },\n\t            isSeriesFiltered: function (seriesModel) {\n\t                assertSeriesInitialized(this);\n\t                return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n\t            },\n\t            filterSeries: function (cb, context) {\n\t                assertSeriesInitialized(this);\n\t                var filteredSeries = filter(this._componentsMap.series, cb, context);\n\t                this._seriesIndices = createSeriesIndices(filteredSeries);\n\t            },\n\t            restoreData: function () {\n\t                var componentsMap = this._componentsMap;\n\t                this._seriesIndices = createSeriesIndices(componentsMap.series);\n\t                var componentTypes = [];\n\t                each(componentsMap, function (components, componentType) {\n\t                    componentTypes.push(componentType);\n\t                });\n\t                ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {\n\t                    each(componentsMap[componentType], function (component) {\n\t                        component.restoreData();\n\t                    });\n\t                });\n\t            }\n\t        });\n\t    /**\n\t     * @inner\n\t     */\n\t    function mergeTheme(option, theme) {\n\t        for (var name in theme) {\n\t            // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理\n\t            if (!ComponentModel.hasClass(name)) {\n\t                if (typeof theme[name] === 'object') {\n\t                    option[name] = !option[name] ? zrUtil.clone(theme[name]) : zrUtil.merge(option[name], theme[name], false);\n\t                } else {\n\t                    if (option[name] == null) {\n\t                        option[name] = theme[name];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t    function initBase(baseOption) {\n\t        baseOption = baseOption;\n\t        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n\t        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n\t        this.option = {};\n\t        this.option[OPTION_INNER_KEY] = 1;\n\t        /**\n\t         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n\t         * @private\n\t         */\n\t        this._componentsMap = {};\n\t        /**\n\t         * Mapping between filtered series list and raw series list.\n\t         * key: filtered series indices, value: raw series indices.\n\t         * @type {Array.<nubmer>}\n\t         * @private\n\t         */\n\t        this._seriesIndices = null;\n\t        mergeTheme(baseOption, this._theme.option);\n\t        // TODO Needs clone when merging to the unexisted property\n\t        zrUtil.merge(baseOption, globalDefault, false);\n\t        this.mergeOption(baseOption);\n\t    }\n\t    /**\n\t     * @inner\n\t     * @param {Array.<string>|string} types model types\n\t     * @return {Object} key: {string} type, value: {Array.<Object>} models\n\t     */\n\t    function getComponentsByTypes(componentsMap, types) {\n\t        if (!zrUtil.isArray(types)) {\n\t            types = types ? [types] : [];\n\t        }\n\t        var ret = {};\n\t        each(types, function (type) {\n\t            ret[type] = (componentsMap[type] || []).slice();\n\t        });\n\t        return ret;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function makeKeyInfo(mainType, mapResult) {\n\t        // We use this id to hash component models and view instances\n\t        // in echarts. id can be specified by user, or auto generated.\n\t        // The id generation rule ensures new view instance are able\n\t        // to mapped to old instance when setOption are called in\n\t        // no-merge mode. So we generate model id by name and plus\n\t        // type in view id.\n\t        // name can be duplicated among components, which is convenient\n\t        // to specify multi components (like series) by one name.\n\t        // Ensure that each id is distinct.\n\t        var idMap = {};\n\t        each(mapResult, function (item, index) {\n\t            var existCpt = item.exist;\n\t            existCpt && (idMap[existCpt.id] = item);\n\t        });\n\t        each(mapResult, function (item, index) {\n\t            var opt = item.option;\n\t            zrUtil.assert(!opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item, 'id duplicates: ' + (opt && opt.id));\n\t            opt && opt.id != null && (idMap[opt.id] = item);\n\t            // Complete subType\n\t            if (isObject(opt)) {\n\t                var subType = determineSubType(mainType, opt, item.exist);\n\t                item.keyInfo = {\n\t                    mainType: mainType,\n\t                    subType: subType\n\t                };\n\t            }\n\t        });\n\t        // Make name and id.\n\t        each(mapResult, function (item, index) {\n\t            var existCpt = item.exist;\n\t            var opt = item.option;\n\t            var keyInfo = item.keyInfo;\n\t            if (!isObject(opt)) {\n\t                return;\n\t            }\n\t            // name can be overwitten. Consider case: axis.name = '20km'.\n\t            // But id generated by name will not be changed, which affect\n\t            // only in that case: setOption with 'not merge mode' and view\n\t            // instance will be recreated, which can be accepted.\n\t            keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name : '\u0000-';\n\t            if (existCpt) {\n\t                keyInfo.id = existCpt.id;\n\t            } else if (opt.id != null) {\n\t                keyInfo.id = opt.id + '';\n\t            } else {\n\t                // Consider this situatoin:\n\t                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n\t                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n\t                // Series with the same name between optionA and optionB\n\t                // should be mapped.\n\t                var idNum = 0;\n\t                do {\n\t                    keyInfo.id = '\u0000' + keyInfo.name + '\u0000' + idNum++;\n\t                } while (idMap[keyInfo.id]);\n\t            }\n\t            idMap[keyInfo.id] = item;\n\t        });\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function determineSubType(mainType, newCptOption, existComponent) {\n\t        var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType : ComponentModel.determineSubType(mainType, newCptOption);\n\t        // tooltip, markline, markpoint may always has no subType\n\t        return subType;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function createSeriesIndices(seriesModels) {\n\t        return map(seriesModels, function (series) {\n\t            return series.componentIndex;\n\t        }) || [];\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function filterBySubType(components, condition) {\n\t        // Using hasOwnProperty for restrict. Consider\n\t        // subType is undefined in user payload.\n\t        return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {\n\t            return cpt.subType === condition.subType;\n\t        }) : components;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function assertSeriesInitialized(ecModel) {\n\t        // Components that use _seriesIndices should depends on series component,\n\t        // which make sure that their initialization is after series.\n\t        if (true) {\n\t            if (!ecModel._seriesIndices) {\n\t                throw new Error('Series has not been initialized yet.');\n\t            }\n\t        }\n\t    }\n\t    zrUtil.mixin(GlobalModel, require('./mixin/colorPalette'));\n\t    return GlobalModel;\n\t});\n\tdefine('echarts/model/OptionManager', ['require', 'zrender/core/util', '../util/model', './Component'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../util/model');\n\t    var ComponentModel = require('./Component');\n\t    var each = zrUtil.each;\n\t    var clone = zrUtil.clone;\n\t    var map = zrUtil.map;\n\t    var merge = zrUtil.merge;\n\t    var QUERY_REG = /^(min|max)?(.+)$/;\n\t    /**\n\t     * TERM EXPLANATIONS:\n\t     *\n\t     * [option]:\n\t     *\n\t     *     An object that contains definitions of components. For example:\n\t     *     var option = {\n\t     *         title: {...},\n\t     *         legend: {...},\n\t     *         visualMap: {...},\n\t     *         series: [\n\t     *             {data: [...]},\n\t     *             {data: [...]},\n\t     *             ...\n\t     *         ]\n\t     *     };\n\t     *\n\t     * [rawOption]:\n\t     *\n\t     *     An object input to echarts.setOption. 'rawOption' may be an\n\t     *     'option', or may be an object contains multi-options. For example:\n\t     *     var option = {\n\t     *         baseOption: {\n\t     *             title: {...},\n\t     *             legend: {...},\n\t     *             series: [\n\t     *                 {data: [...]},\n\t     *                 {data: [...]},\n\t     *                 ...\n\t     *             ]\n\t     *         },\n\t     *         timeline: {...},\n\t     *         options: [\n\t     *             {title: {...}, series: {data: [...]}},\n\t     *             {title: {...}, series: {data: [...]}},\n\t     *             ...\n\t     *         ],\n\t     *         media: [\n\t     *             {\n\t     *                 query: {maxWidth: 320},\n\t     *                 option: {series: {x: 20}, visualMap: {show: false}}\n\t     *             },\n\t     *             {\n\t     *                 query: {minWidth: 320, maxWidth: 720},\n\t     *                 option: {series: {x: 500}, visualMap: {show: true}}\n\t     *             },\n\t     *             {\n\t     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n\t     *             }\n\t     *         ]\n\t     *     };\n\t     *\n\t     * @alias module:echarts/model/OptionManager\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    function OptionManager(api) {\n\t        /**\n\t         * @private\n\t         * @type {module:echarts/ExtensionAPI}\n\t         */\n\t        this._api = api;\n\t        /**\n\t         * @private\n\t         * @type {Array.<number>}\n\t         */\n\t        this._timelineOptions = [];\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._mediaList = [];\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._mediaDefault;\n\t        /**\n\t         * -1, means default.\n\t         * empty means no media.\n\t         * @private\n\t         * @type {Array.<number>}\n\t         */\n\t        this._currentMediaIndices = [];\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._optionBackup;\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._newBaseOption;\n\t    }\n\t    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n\t    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n\t    // rawOption cloned and backuped when timeline changed, which does no\n\t    // good to performance. What's more, that both timeline and setOption\n\t    // method supply 'notMerge' brings complex and some problems.\n\t    // Consider this case:\n\t    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n\t    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\t    OptionManager.prototype = {\n\t        constructor: OptionManager,\n\t        setOption: function (rawOption, optionPreprocessorFuncs) {\n\t            rawOption = clone(rawOption, true);\n\t            // FIXME\n\t            // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。\n\t            var oldOptionBackup = this._optionBackup;\n\t            var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);\n\t            this._newBaseOption = newParsedOption.baseOption;\n\t            // For setOption at second time (using merge mode);\n\t            if (oldOptionBackup) {\n\t                // Only baseOption can be merged.\n\t                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\t                // For simplicity, timeline options and media options do not support merge,\n\t                // that is, if you `setOption` twice and both has timeline options, the latter\n\t                // timeline opitons will not be merged to the formers, but just substitude them.\n\t                if (newParsedOption.timelineOptions.length) {\n\t                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n\t                }\n\t                if (newParsedOption.mediaList.length) {\n\t                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n\t                }\n\t                if (newParsedOption.mediaDefault) {\n\t                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n\t                }\n\t            } else {\n\t                this._optionBackup = newParsedOption;\n\t            }\n\t        },\n\t        mountOption: function (isRecreate) {\n\t            var optionBackup = this._optionBackup;\n\t            // TODO\n\t            // 如果没有reset功能则不clone。\n\t            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n\t            this._mediaList = map(optionBackup.mediaList, clone);\n\t            this._mediaDefault = clone(optionBackup.mediaDefault);\n\t            this._currentMediaIndices = [];\n\t            return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);\n\t        },\n\t        getTimelineOption: function (ecModel) {\n\t            var option;\n\t            var timelineOptions = this._timelineOptions;\n\t            if (timelineOptions.length) {\n\t                // getTimelineOption can only be called after ecModel inited,\n\t                // so we can get currentIndex from timelineModel.\n\t                var timelineModel = ecModel.getComponent('timeline');\n\t                if (timelineModel) {\n\t                    option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);\n\t                }\n\t            }\n\t            return option;\n\t        },\n\t        getMediaOption: function (ecModel) {\n\t            var ecWidth = this._api.getWidth();\n\t            var ecHeight = this._api.getHeight();\n\t            var mediaList = this._mediaList;\n\t            var mediaDefault = this._mediaDefault;\n\t            var indices = [];\n\t            var result = [];\n\t            // No media defined.\n\t            if (!mediaList.length && !mediaDefault) {\n\t                return result;\n\t            }\n\t            // Multi media may be applied, the latter defined media has higher priority.\n\t            for (var i = 0, len = mediaList.length; i < len; i++) {\n\t                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n\t                    indices.push(i);\n\t                }\n\t            }\n\t            // FIXME\n\t            // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。\n\t            if (!indices.length && mediaDefault) {\n\t                indices = [-1];\n\t            }\n\t            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n\t                result = map(indices, function (index) {\n\t                    return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\n\t                });\n\t            }\n\t            // Otherwise return nothing.\n\t            this._currentMediaIndices = indices;\n\t            return result;\n\t        }\n\t    };\n\t    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n\t        var timelineOptions = [];\n\t        var mediaList = [];\n\t        var mediaDefault;\n\t        var baseOption;\n\t        // Compatible with ec2.\n\t        var timelineOpt = rawOption.timeline;\n\t        if (rawOption.baseOption) {\n\t            baseOption = rawOption.baseOption;\n\t        }\n\t        // For timeline\n\t        if (timelineOpt || rawOption.options) {\n\t            baseOption = baseOption || {};\n\t            timelineOptions = (rawOption.options || []).slice();\n\t        }\n\t        // For media query\n\t        if (rawOption.media) {\n\t            baseOption = baseOption || {};\n\t            var media = rawOption.media;\n\t            each(media, function (singleMedia) {\n\t                if (singleMedia && singleMedia.option) {\n\t                    if (singleMedia.query) {\n\t                        mediaList.push(singleMedia);\n\t                    } else if (!mediaDefault) {\n\t                        // Use the first media default.\n\t                        mediaDefault = singleMedia;\n\t                    }\n\t                }\n\t            });\n\t        }\n\t        // For normal option\n\t        if (!baseOption) {\n\t            baseOption = rawOption;\n\t        }\n\t        // Set timelineOpt to baseOption in ec3,\n\t        // which is convenient for merge option.\n\t        if (!baseOption.timeline) {\n\t            baseOption.timeline = timelineOpt;\n\t        }\n\t        // Preprocess.\n\t        each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {\n\t            return media.option;\n\t        })), function (option) {\n\t            each(optionPreprocessorFuncs, function (preProcess) {\n\t                preProcess(option, isNew);\n\t            });\n\t        });\n\t        return {\n\t            baseOption: baseOption,\n\t            timelineOptions: timelineOptions,\n\t            mediaDefault: mediaDefault,\n\t            mediaList: mediaList\n\t        };\n\t    }\n\t    /**\n\t     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n\t     * Support: width, height, aspectRatio\n\t     * Can use max or min as prefix.\n\t     */\n\t    function applyMediaQuery(query, ecWidth, ecHeight) {\n\t        var realMap = {\n\t                width: ecWidth,\n\t                height: ecHeight,\n\t                aspectratio: ecWidth / ecHeight\n\t            };\n\t        var applicatable = true;\n\t        zrUtil.each(query, function (value, attr) {\n\t            var matched = attr.match(QUERY_REG);\n\t            if (!matched || !matched[1] || !matched[2]) {\n\t                return;\n\t            }\n\t            var operator = matched[1];\n\t            var realAttr = matched[2].toLowerCase();\n\t            if (!compare(realMap[realAttr], value, operator)) {\n\t                applicatable = false;\n\t            }\n\t        });\n\t        return applicatable;\n\t    }\n\t    function compare(real, expect, operator) {\n\t        if (operator === 'min') {\n\t            return real >= expect;\n\t        } else if (operator === 'max') {\n\t            return real <= expect;\n\t        } else {\n\t            // Equals\n\t            return real === expect;\n\t        }\n\t    }\n\t    function indicesEquals(indices1, indices2) {\n\t        // indices is always order by asc and has only finite number.\n\t        return indices1.join(',') === indices2.join(',');\n\t    }\n\t    /**\n\t     * Consider case:\n\t     * `chart.setOption(opt1);`\n\t     * Then user do some interaction like dataZoom, dataView changing.\n\t     * `chart.setOption(opt2);`\n\t     * Then user press 'reset button' in toolbox.\n\t     *\n\t     * After doing that all of the interaction effects should be reset, the\n\t     * chart should be the same as the result of invoke\n\t     * `chart.setOption(opt1); chart.setOption(opt2);`.\n\t     *\n\t     * Although it is not able ensure that\n\t     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n\t     * `chart.setOption(merge(opt1, opt2));` exactly,\n\t     * this might be the only simple way to implement that feature.\n\t     *\n\t     * MEMO: We've considered some other approaches:\n\t     * 1. Each model handle its self restoration but not uniform treatment.\n\t     *     (Too complex in logic and error-prone)\n\t     * 2. Use a shadow ecModel. (Performace expensive)\n\t     */\n\t    function mergeOption(oldOption, newOption) {\n\t        newOption = newOption || {};\n\t        each(newOption, function (newCptOpt, mainType) {\n\t            if (newCptOpt == null) {\n\t                return;\n\t            }\n\t            var oldCptOpt = oldOption[mainType];\n\t            if (!ComponentModel.hasClass(mainType)) {\n\t                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n\t            } else {\n\t                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n\t                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\t                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\t                oldOption[mainType] = map(mapResult, function (item) {\n\t                    return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;\n\t                });\n\t            }\n\t        });\n\t    }\n\t    return OptionManager;\n\t});\n\tdefine('echarts/CoordinateSystem', ['require'], function (require) {\n\t    'use strict';\n\t    var coordinateSystemCreators = {};\n\t    function CoordinateSystemManager() {\n\t        this._coordinateSystems = [];\n\t    }\n\t    CoordinateSystemManager.prototype = {\n\t        constructor: CoordinateSystemManager,\n\t        create: function (ecModel, api) {\n\t            var coordinateSystems = [];\n\t            for (var type in coordinateSystemCreators) {\n\t                var list = coordinateSystemCreators[type].create(ecModel, api);\n\t                list && (coordinateSystems = coordinateSystems.concat(list));\n\t            }\n\t            this._coordinateSystems = coordinateSystems;\n\t        },\n\t        update: function (ecModel, api) {\n\t            var coordinateSystems = this._coordinateSystems;\n\t            for (var i = 0; i < coordinateSystems.length; i++) {\n\t                // FIXME MUST have\n\t                coordinateSystems[i].update && coordinateSystems[i].update(ecModel, api);\n\t            }\n\t        }\n\t    };\n\t    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n\t        coordinateSystemCreators[type] = coordinateSystemCreator;\n\t    };\n\t    CoordinateSystemManager.get = function (type) {\n\t        return coordinateSystemCreators[type];\n\t    };\n\t    return CoordinateSystemManager;\n\t});\n\tdefine('echarts/model/Series', ['require', 'zrender/core/util', '../util/format', '../util/model', './Component', './mixin/colorPalette', 'zrender/core/env'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var formatUtil = require('../util/format');\n\t    var modelUtil = require('../util/model');\n\t    var ComponentModel = require('./Component');\n\t    var colorPaletteMixin = require('./mixin/colorPalette');\n\t    var env = require('zrender/core/env');\n\t    var encodeHTML = formatUtil.encodeHTML;\n\t    var addCommas = formatUtil.addCommas;\n\t    var SeriesModel = ComponentModel.extend({\n\t            type: 'series.__base__',\n\t            seriesIndex: 0,\n\t            coordinateSystem: null,\n\t            defaultOption: null,\n\t            legendDataProvider: null,\n\t            visualColorAccessPath: 'itemStyle.normal.color',\n\t            init: function (option, parentModel, ecModel, extraOpt) {\n\t                /**\n\t             * @type {number}\n\t             * @readOnly\n\t             */\n\t                this.seriesIndex = this.componentIndex;\n\t                this.mergeDefaultAndTheme(option, ecModel);\n\t                /**\n\t             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n\t             * @private\n\t             */\n\t                this._dataBeforeProcessed = this.getInitialData(option, ecModel);\n\t                // If we reverse the order (make this._data firstly, and then make\n\t                // this._dataBeforeProcessed by cloneShallow), cloneShallow will\n\t                // cause this._data.graph.data !== this._data when using\n\t                // module:echarts/data/Graph or module:echarts/data/Tree.\n\t                // See module:echarts/data/helper/linkList\n\t                this._data = this._dataBeforeProcessed.cloneShallow();\n\t            },\n\t            mergeDefaultAndTheme: function (option, ecModel) {\n\t                zrUtil.merge(option, ecModel.getTheme().get(this.subType));\n\t                zrUtil.merge(option, this.getDefaultOption());\n\t                // Default label emphasis `position` and `show`\n\t                // FIXME Set label in mergeOption\n\t                modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\t                this.fillDataTextStyle(option.data);\n\t            },\n\t            mergeOption: function (newSeriesOption, ecModel) {\n\t                newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n\t                this.fillDataTextStyle(newSeriesOption.data);\n\t                var data = this.getInitialData(newSeriesOption, ecModel);\n\t                // TODO Merge data?\n\t                if (data) {\n\t                    this._data = data;\n\t                    this._dataBeforeProcessed = data.cloneShallow();\n\t                }\n\t            },\n\t            fillDataTextStyle: function (data) {\n\t                // Default data label emphasis `position` and `show`\n\t                // FIXME Tree structure data ?\n\t                // FIXME Performance ?\n\t                if (data) {\n\t                    for (var i = 0; i < data.length; i++) {\n\t                        if (data[i] && data[i].label) {\n\t                            modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            getInitialData: function () {\n\t            },\n\t            getData: function (dataType) {\n\t                return dataType == null ? this._data : this._data.getLinkedData(dataType);\n\t            },\n\t            setData: function (data) {\n\t                this._data = data;\n\t            },\n\t            getRawData: function () {\n\t                return this._dataBeforeProcessed;\n\t            },\n\t            coordDimToDataDim: function (coordDim) {\n\t                return [coordDim];\n\t            },\n\t            dataDimToCoordDim: function (dataDim) {\n\t                return dataDim;\n\t            },\n\t            getBaseAxis: function () {\n\t                var coordSys = this.coordinateSystem;\n\t                return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n\t            },\n\t            formatTooltip: function (dataIndex, multipleSeries, dataType) {\n\t                function formatArrayValue(value) {\n\t                    return zrUtil.map(value, function (val, idx) {\n\t                        var dimInfo = data.getDimensionInfo(idx);\n\t                        var dimType = dimInfo && dimInfo.type;\n\t                        if (dimType === 'ordinal') {\n\t                            return val;\n\t                        } else if (dimType === 'time') {\n\t                            return multipleSeries ? '' : formatUtil.formatTime('yyyy/mm/dd hh:mm:ss', val);\n\t                        } else {\n\t                            return addCommas(val);\n\t                        }\n\t                    }).filter(function (val) {\n\t                        return !!val;\n\t                    }).join(', ');\n\t                }\n\t                var data = this._data;\n\t                var value = this.getRawValue(dataIndex);\n\t                var formattedValue = zrUtil.isArray(value) ? formatArrayValue(value) : addCommas(value);\n\t                var name = data.getName(dataIndex);\n\t                var color = data.getItemVisual(dataIndex, 'color');\n\t                var colorEl = '<span style=\"display:inline-block;margin-right:5px;' + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '\"></span>';\n\t                var seriesName = this.name;\n\t                // FIXME\n\t                if (seriesName === '\u0000-') {\n\t                    // Not show '-'\n\t                    seriesName = '';\n\t                }\n\t                return !multipleSeries ? (seriesName && encodeHTML(seriesName) + '<br />') + colorEl + (name ? encodeHTML(name) + ' : ' + formattedValue : formattedValue) : colorEl + encodeHTML(this.name) + ' : ' + formattedValue;\n\t            },\n\t            ifEnableAnimation: function () {\n\t                if (env.node) {\n\t                    return false;\n\t                }\n\t                var animationEnabled = this.getShallow('animation');\n\t                if (animationEnabled) {\n\t                    if (this.getData().count() > this.getShallow('animationThreshold')) {\n\t                        animationEnabled = false;\n\t                    }\n\t                }\n\t                return animationEnabled;\n\t            },\n\t            restoreData: function () {\n\t                this._data = this._dataBeforeProcessed.cloneShallow();\n\t            },\n\t            getColorFromPalette: function (name, scope) {\n\t                var ecModel = this.ecModel;\n\t                // PENDING\n\t                var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n\t                if (!color) {\n\t                    color = ecModel.getColorFromPalette(name, scope);\n\t                }\n\t                return color;\n\t            },\n\t            getAxisTooltipDataIndex: null\n\t        });\n\t    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n\t    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\t    return SeriesModel;\n\t});\n\tdefine('echarts/model/Component', ['require', './Model', 'zrender/core/util', '../util/component', '../util/clazz', '../util/layout', './mixin/boxLayout'], function (require) {\n\t    var Model = require('./Model');\n\t    var zrUtil = require('zrender/core/util');\n\t    var arrayPush = Array.prototype.push;\n\t    var componentUtil = require('../util/component');\n\t    var clazzUtil = require('../util/clazz');\n\t    var layout = require('../util/layout');\n\t    /**\n\t     * @alias module:echarts/model/Component\n\t     * @constructor\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} parentModel\n\t     * @param {module:echarts/model/Model} ecModel\n\t     */\n\t    var ComponentModel = Model.extend({\n\t            type: 'component',\n\t            id: '',\n\t            name: '',\n\t            mainType: '',\n\t            subType: '',\n\t            componentIndex: 0,\n\t            defaultOption: null,\n\t            ecModel: null,\n\t            dependentModels: [],\n\t            uid: null,\n\t            layoutMode: null,\n\t            $constructor: function (option, parentModel, ecModel, extraOpt) {\n\t                Model.call(this, option, parentModel, ecModel, extraOpt);\n\t                // Set dependentModels, componentIndex, name, id, mainType, subType.\n\t                zrUtil.extend(this, extraOpt);\n\t                this.uid = componentUtil.getUID('componentModel');\n\t            },\n\t            init: function (option, parentModel, ecModel, extraOpt) {\n\t                this.mergeDefaultAndTheme(option, ecModel);\n\t            },\n\t            mergeDefaultAndTheme: function (option, ecModel) {\n\t                var layoutMode = this.layoutMode;\n\t                var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};\n\t                var themeModel = ecModel.getTheme();\n\t                zrUtil.merge(option, themeModel.get(this.mainType));\n\t                zrUtil.merge(option, this.getDefaultOption());\n\t                if (layoutMode) {\n\t                    layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n\t                }\n\t            },\n\t            mergeOption: function (option) {\n\t                zrUtil.merge(this.option, option, true);\n\t                var layoutMode = this.layoutMode;\n\t                if (layoutMode) {\n\t                    layout.mergeLayoutParam(this.option, option, layoutMode);\n\t                }\n\t            },\n\t            optionUpdated: function (newCptOption, isInit) {\n\t            },\n\t            getDefaultOption: function () {\n\t                if (!this.hasOwnProperty('__defaultOption')) {\n\t                    var optList = [];\n\t                    var Class = this.constructor;\n\t                    while (Class) {\n\t                        var opt = Class.prototype.defaultOption;\n\t                        opt && optList.push(opt);\n\t                        Class = Class.superClass;\n\t                    }\n\t                    var defaultOption = {};\n\t                    for (var i = optList.length - 1; i >= 0; i--) {\n\t                        defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n\t                    }\n\t                    this.__defaultOption = defaultOption;\n\t                }\n\t                return this.__defaultOption;\n\t            }\n\t        });\n\t    // Reset ComponentModel.extend, add preConstruct.\n\t    // clazzUtil.enableClassExtend(\n\t    //     ComponentModel,\n\t    //     function (option, parentModel, ecModel, extraOpt) {\n\t    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n\t    //         zrUtil.extend(this, extraOpt);\n\t    //         this.uid = componentUtil.getUID('componentModel');\n\t    //         // this.setReadOnly([\n\t    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n\t    //         //     'dependentModels', 'componentIndex'\n\t    //         // ]);\n\t    //     }\n\t    // );\n\t    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(ComponentModel, { registerWhenExtend: true });\n\t    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\t    // Add capability of ComponentModel.topologicalTravel.\n\t    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\t    function getDependencies(componentType) {\n\t        var deps = [];\n\t        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n\t            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n\t        });\n\t        // Ensure main type\n\t        return zrUtil.map(deps, function (type) {\n\t            return clazzUtil.parseClassType(type).main;\n\t        });\n\t    }\n\t    zrUtil.mixin(ComponentModel, require('./mixin/boxLayout'));\n\t    return ComponentModel;\n\t});\n\tdefine('echarts/view/Component', ['require', 'zrender/container/Group', '../util/component', '../util/clazz'], function (require) {\n\t    var Group = require('zrender/container/Group');\n\t    var componentUtil = require('../util/component');\n\t    var clazzUtil = require('../util/clazz');\n\t    var Component = function () {\n\t        /**\n\t         * @type {module:zrender/container/Group}\n\t         * @readOnly\n\t         */\n\t        this.group = new Group();\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        this.uid = componentUtil.getUID('viewComponent');\n\t    };\n\t    Component.prototype = {\n\t        constructor: Component,\n\t        init: function (ecModel, api) {\n\t        },\n\t        render: function (componentModel, ecModel, api, payload) {\n\t        },\n\t        dispose: function () {\n\t        }\n\t    };\n\t    var componentProto = Component.prototype;\n\t    componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function (seriesModel, ecModel, api, payload) {\n\t    };\n\t    // Enable Component.extend.\n\t    clazzUtil.enableClassExtend(Component);\n\t    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(Component, { registerWhenExtend: true });\n\t    return Component;\n\t});\n\tdefine('echarts/view/Chart', ['require', 'zrender/container/Group', '../util/component', '../util/clazz'], function (require) {\n\t    var Group = require('zrender/container/Group');\n\t    var componentUtil = require('../util/component');\n\t    var clazzUtil = require('../util/clazz');\n\t    function Chart() {\n\t        /**\n\t         * @type {module:zrender/container/Group}\n\t         * @readOnly\n\t         */\n\t        this.group = new Group();\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        this.uid = componentUtil.getUID('viewChart');\n\t    }\n\t    Chart.prototype = {\n\t        type: 'chart',\n\t        init: function (ecModel, api) {\n\t        },\n\t        render: function (seriesModel, ecModel, api, payload) {\n\t        },\n\t        highlight: function (seriesModel, ecModel, api, payload) {\n\t            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n\t        },\n\t        downplay: function (seriesModel, ecModel, api, payload) {\n\t            toggleHighlight(seriesModel.getData(), payload, 'normal');\n\t        },\n\t        remove: function (ecModel, api) {\n\t            this.group.removeAll();\n\t        },\n\t        dispose: function () {\n\t        }\n\t    };\n\t    var chartProto = Chart.prototype;\n\t    chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function (seriesModel, ecModel, api, payload) {\n\t        this.render(seriesModel, ecModel, api, payload);\n\t    };\n\t    /**\n\t     * Set state of single element\n\t     * @param  {module:zrender/Element} el\n\t     * @param  {string} state\n\t     */\n\t    function elSetState(el, state) {\n\t        if (el) {\n\t            el.trigger(state);\n\t            if (el.type === 'group') {\n\t                for (var i = 0; i < el.childCount(); i++) {\n\t                    elSetState(el.childAt(i), state);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @param  {module:echarts/data/List} data\n\t     * @param  {Object} payload\n\t     * @param  {string} state 'normal'|'emphasis'\n\t     * @inner\n\t     */\n\t    function toggleHighlight(data, payload, state) {\n\t        var dataIndex = payload && payload.dataIndex;\n\t        var name = payload && payload.name;\n\t        if (dataIndex != null) {\n\t            var dataIndices = dataIndex instanceof Array ? dataIndex : [dataIndex];\n\t            for (var i = 0, len = dataIndices.length; i < len; i++) {\n\t                elSetState(data.getItemGraphicEl(dataIndices[i]), state);\n\t            }\n\t        } else if (name) {\n\t            var names = name instanceof Array ? name : [name];\n\t            for (var i = 0, len = names.length; i < len; i++) {\n\t                var dataIndex = data.indexOfName(names[i]);\n\t                elSetState(data.getItemGraphicEl(dataIndex), state);\n\t            }\n\t        } else {\n\t            data.eachItemGraphicEl(function (el) {\n\t                elSetState(el, state);\n\t            });\n\t        }\n\t    }\n\t    // Enable Chart.extend.\n\t    clazzUtil.enableClassExtend(Chart);\n\t    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(Chart, { registerWhenExtend: true });\n\t    return Chart;\n\t});\n\tdefine('zrender/zrender', ['require', './core/guid', './core/env', './Handler', './Storage', './animation/Animation', './dom/HandlerProxy', './Painter'], function (require) {\n\t    var guid = require('./core/guid');\n\t    var env = require('./core/env');\n\t    var Handler = require('./Handler');\n\t    var Storage = require('./Storage');\n\t    var Animation = require('./animation/Animation');\n\t    var HandlerProxy = require('./dom/HandlerProxy');\n\t    var useVML = !env.canvasSupported;\n\t    var painterCtors = { canvas: require('./Painter') };\n\t    var instances = {};\n\t    // ZRender实例map索引\n\t    var zrender = {};\n\t    /**\n\t     * @type {string}\n\t     */\n\t    zrender.version = '3.1.3';\n\t    /**\n\t     * Initializing a zrender instance\n\t     * @param {HTMLElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.init = function (dom, opts) {\n\t        var zr = new ZRender(guid(), dom, opts);\n\t        instances[zr.id] = zr;\n\t        return zr;\n\t    };\n\t    /**\n\t     * Dispose zrender instance\n\t     * @param {module:zrender/ZRender} zr\n\t     */\n\t    zrender.dispose = function (zr) {\n\t        if (zr) {\n\t            zr.dispose();\n\t        } else {\n\t            for (var key in instances) {\n\t                instances[key].dispose();\n\t            }\n\t            instances = {};\n\t        }\n\t        return zrender;\n\t    };\n\t    /**\n\t     * Get zrender instance by id\n\t     * @param {string} id zrender instance id\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.getInstance = function (id) {\n\t        return instances[id];\n\t    };\n\t    zrender.registerPainter = function (name, Ctor) {\n\t        painterCtors[name] = Ctor;\n\t    };\n\t    function delInstance(id) {\n\t        delete instances[id];\n\t    }\n\t    /**\n\t     * @module zrender/ZRender\n\t     */\n\t    /**\n\t     * @constructor\n\t     * @alias module:zrender/ZRender\n\t     * @param {string} id\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     */\n\t    var ZRender = function (id, dom, opts) {\n\t        opts = opts || {};\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         */\n\t        this.dom = dom;\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id = id;\n\t        var self = this;\n\t        var storage = new Storage();\n\t        var rendererType = opts.renderer;\n\t        if (useVML) {\n\t            if (!painterCtors.vml) {\n\t                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n\t            }\n\t            rendererType = 'vml';\n\t        } else if (!rendererType || !painterCtors[rendererType]) {\n\t            rendererType = 'canvas';\n\t        }\n\t        var painter = new painterCtors[rendererType](dom, storage, opts);\n\t        this.storage = storage;\n\t        this.painter = painter;\n\t        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n\t        this.handler = new Handler(storage, painter, handerProxy);\n\t        /**\n\t         * @type {module:zrender/animation/Animation}\n\t         */\n\t        this.animation = new Animation({\n\t            stage: {\n\t                update: function () {\n\t                    if (self._needsRefresh) {\n\t                        self.refreshImmediately();\n\t                    }\n\t                    if (self._needsRefreshHover) {\n\t                        self.refreshHoverImmediately();\n\t                    }\n\t                }\n\t            }\n\t        });\n\t        this.animation.start();\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._needsRefresh;\n\t        // 修改 storage.delFromMap, 每次删除元素之前删除动画\n\t        // FIXME 有点ugly\n\t        var oldDelFromMap = storage.delFromMap;\n\t        var oldAddToMap = storage.addToMap;\n\t        storage.delFromMap = function (elId) {\n\t            var el = storage.get(elId);\n\t            oldDelFromMap.call(storage, elId);\n\t            el && el.removeSelfFromZr(self);\n\t        };\n\t        storage.addToMap = function (el) {\n\t            oldAddToMap.call(storage, el);\n\t            el.addSelfToZr(self);\n\t        };\n\t    };\n\t    ZRender.prototype = {\n\t        constructor: ZRender,\n\t        getId: function () {\n\t            return this.id;\n\t        },\n\t        add: function (el) {\n\t            this.storage.addRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t        remove: function (el) {\n\t            this.storage.delRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t        configLayer: function (zLevel, config) {\n\t            this.painter.configLayer(zLevel, config);\n\t            this._needsRefresh = true;\n\t        },\n\t        refreshImmediately: function () {\n\t            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n\t            // Or it will cause zrender refreshes again and again.\n\t            this._needsRefresh = false;\n\t            this.painter.refresh();\n\t            /**\n\t             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n\t             */\n\t            this._needsRefresh = false;\n\t        },\n\t        refresh: function () {\n\t            this._needsRefresh = true;\n\t        },\n\t        addHover: function (el, style) {\n\t            if (this.painter.addHover) {\n\t                this.painter.addHover(el, style);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t        removeHover: function (el) {\n\t            if (this.painter.removeHover) {\n\t                this.painter.removeHover(el);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t        clearHover: function () {\n\t            if (this.painter.clearHover) {\n\t                this.painter.clearHover();\n\t                this.refreshHover();\n\t            }\n\t        },\n\t        refreshHover: function () {\n\t            this._needsRefreshHover = true;\n\t        },\n\t        refreshHoverImmediately: function () {\n\t            this._needsRefreshHover = false;\n\t            this.painter.refreshHover && this.painter.refreshHover();\n\t        },\n\t        resize: function () {\n\t            this.painter.resize();\n\t            this.handler.resize();\n\t        },\n\t        clearAnimation: function () {\n\t            this.animation.clear();\n\t        },\n\t        getWidth: function () {\n\t            return this.painter.getWidth();\n\t        },\n\t        getHeight: function () {\n\t            return this.painter.getHeight();\n\t        },\n\t        pathToImage: function (e, width, height) {\n\t            var id = guid();\n\t            return this.painter.pathToImage(id, e, width, height);\n\t        },\n\t        setCursorStyle: function (cursorStyle) {\n\t            this.handler.setCursorStyle(cursorStyle);\n\t        },\n\t        on: function (eventName, eventHandler, context) {\n\t            this.handler.on(eventName, eventHandler, context);\n\t        },\n\t        off: function (eventName, eventHandler) {\n\t            this.handler.off(eventName, eventHandler);\n\t        },\n\t        trigger: function (eventName, event) {\n\t            this.handler.trigger(eventName, event);\n\t        },\n\t        clear: function () {\n\t            this.storage.delRoot();\n\t            this.painter.clear();\n\t        },\n\t        dispose: function () {\n\t            this.animation.stop();\n\t            this.clear();\n\t            this.storage.dispose();\n\t            this.painter.dispose();\n\t            this.handler.dispose();\n\t            this.animation = this.storage = this.painter = this.handler = null;\n\t            delInstance(this.id);\n\t        }\n\t    };\n\t    return zrender;\n\t});\n\tdefine('zrender/mixin/Eventful', ['require'], function (require) {\n\t    var arrySlice = Array.prototype.slice;\n\t    /**\n\t     * 事件分发器\n\t     * @alias module:zrender/mixin/Eventful\n\t     * @constructor\n\t     */\n\t    var Eventful = function () {\n\t        this._$handlers = {};\n\t    };\n\t    Eventful.prototype = {\n\t        constructor: Eventful,\n\t        one: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t            _h[event].push({\n\t                h: handler,\n\t                one: true,\n\t                ctx: context || this\n\t            });\n\t            return this;\n\t        },\n\t        on: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t            _h[event].push({\n\t                h: handler,\n\t                one: false,\n\t                ctx: context || this\n\t            });\n\t            return this;\n\t        },\n\t        isSilent: function (event) {\n\t            var _h = this._$handlers;\n\t            return _h[event] && _h[event].length;\n\t        },\n\t        off: function (event, handler) {\n\t            var _h = this._$handlers;\n\t            if (!event) {\n\t                this._$handlers = {};\n\t                return this;\n\t            }\n\t            if (handler) {\n\t                if (_h[event]) {\n\t                    var newList = [];\n\t                    for (var i = 0, l = _h[event].length; i < l; i++) {\n\t                        if (_h[event][i]['h'] != handler) {\n\t                            newList.push(_h[event][i]);\n\t                        }\n\t                    }\n\t                    _h[event] = newList;\n\t                }\n\t                if (_h[event] && _h[event].length === 0) {\n\t                    delete _h[event];\n\t                }\n\t            } else {\n\t                delete _h[event];\n\t            }\n\t            return this;\n\t        },\n\t        trigger: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t                if (argLen > 3) {\n\t                    args = arrySlice.call(args, 1);\n\t                }\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                    case 1:\n\t                        _h[i]['h'].call(_h[i]['ctx']);\n\t                        break;\n\t                    case 2:\n\t                        _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\t                        break;\n\t                    case 3:\n\t                        _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\t                        break;\n\t                    default:\n\t                        // have more than 2 given arguments\n\t                        _h[i]['h'].apply(_h[i]['ctx'], args);\n\t                        break;\n\t                    }\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    } else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t        triggerWithContext: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t                if (argLen > 4) {\n\t                    args = arrySlice.call(args, 1, args.length - 1);\n\t                }\n\t                var ctx = args[args.length - 1];\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                    case 1:\n\t                        _h[i]['h'].call(ctx);\n\t                        break;\n\t                    case 2:\n\t                        _h[i]['h'].call(ctx, args[1]);\n\t                        break;\n\t                    case 3:\n\t                        _h[i]['h'].call(ctx, args[1], args[2]);\n\t                        break;\n\t                    default:\n\t                        // have more than 2 given arguments\n\t                        _h[i]['h'].apply(ctx, args);\n\t                        break;\n\t                    }\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    } else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t            return this;\n\t        }\n\t    };\n\t    // 对象可以通过 onxxxx 绑定事件\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onclick\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseout\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousemove\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousewheel\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousedown\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseup\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragstart\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragend\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragenter\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragleave\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrop\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    return Eventful;\n\t});\n\tdefine('zrender/tool/color', ['require'], function (require) {\n\t    var kCSSColorTable = {\n\t            'transparent': [\n\t                0,\n\t                0,\n\t                0,\n\t                0\n\t            ],\n\t            'aliceblue': [\n\t                240,\n\t                248,\n\t                255,\n\t                1\n\t            ],\n\t            'antiquewhite': [\n\t                250,\n\t                235,\n\t                215,\n\t                1\n\t            ],\n\t            'aqua': [\n\t                0,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'aquamarine': [\n\t                127,\n\t                255,\n\t                212,\n\t                1\n\t            ],\n\t            'azure': [\n\t                240,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'beige': [\n\t                245,\n\t                245,\n\t                220,\n\t                1\n\t            ],\n\t            'bisque': [\n\t                255,\n\t                228,\n\t                196,\n\t                1\n\t            ],\n\t            'black': [\n\t                0,\n\t                0,\n\t                0,\n\t                1\n\t            ],\n\t            'blanchedalmond': [\n\t                255,\n\t                235,\n\t                205,\n\t                1\n\t            ],\n\t            'blue': [\n\t                0,\n\t                0,\n\t                255,\n\t                1\n\t            ],\n\t            'blueviolet': [\n\t                138,\n\t                43,\n\t                226,\n\t                1\n\t            ],\n\t            'brown': [\n\t                165,\n\t                42,\n\t                42,\n\t                1\n\t            ],\n\t            'burlywood': [\n\t                222,\n\t                184,\n\t                135,\n\t                1\n\t            ],\n\t            'cadetblue': [\n\t                95,\n\t                158,\n\t                160,\n\t                1\n\t            ],\n\t            'chartreuse': [\n\t                127,\n\t                255,\n\t                0,\n\t                1\n\t            ],\n\t            'chocolate': [\n\t                210,\n\t                105,\n\t                30,\n\t                1\n\t            ],\n\t            'coral': [\n\t                255,\n\t                127,\n\t                80,\n\t                1\n\t            ],\n\t            'cornflowerblue': [\n\t                100,\n\t                149,\n\t                237,\n\t                1\n\t            ],\n\t            'cornsilk': [\n\t                255,\n\t                248,\n\t                220,\n\t                1\n\t            ],\n\t            'crimson': [\n\t                220,\n\t                20,\n\t                60,\n\t                1\n\t            ],\n\t            'cyan': [\n\t                0,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'darkblue': [\n\t                0,\n\t                0,\n\t                139,\n\t                1\n\t            ],\n\t            'darkcyan': [\n\t                0,\n\t                139,\n\t                139,\n\t                1\n\t            ],\n\t            'darkgoldenrod': [\n\t                184,\n\t                134,\n\t                11,\n\t                1\n\t            ],\n\t            'darkgray': [\n\t                169,\n\t                169,\n\t                169,\n\t                1\n\t            ],\n\t            'darkgreen': [\n\t                0,\n\t                100,\n\t                0,\n\t                1\n\t            ],\n\t            'darkgrey': [\n\t                169,\n\t                169,\n\t                169,\n\t                1\n\t            ],\n\t            'darkkhaki': [\n\t                189,\n\t                183,\n\t                107,\n\t                1\n\t            ],\n\t            'darkmagenta': [\n\t                139,\n\t                0,\n\t                139,\n\t                1\n\t            ],\n\t            'darkolivegreen': [\n\t                85,\n\t                107,\n\t                47,\n\t                1\n\t            ],\n\t            'darkorange': [\n\t                255,\n\t                140,\n\t                0,\n\t                1\n\t            ],\n\t            'darkorchid': [\n\t                153,\n\t                50,\n\t                204,\n\t                1\n\t            ],\n\t            'darkred': [\n\t                139,\n\t                0,\n\t                0,\n\t                1\n\t            ],\n\t            'darksalmon': [\n\t                233,\n\t                150,\n\t                122,\n\t                1\n\t            ],\n\t            'darkseagreen': [\n\t                143,\n\t                188,\n\t                143,\n\t                1\n\t            ],\n\t            'darkslateblue': [\n\t                72,\n\t                61,\n\t                139,\n\t                1\n\t            ],\n\t            'darkslategray': [\n\t                47,\n\t                79,\n\t                79,\n\t                1\n\t            ],\n\t            'darkslategrey': [\n\t                47,\n\t                79,\n\t                79,\n\t                1\n\t            ],\n\t            'darkturquoise': [\n\t                0,\n\t                206,\n\t                209,\n\t                1\n\t            ],\n\t            'darkviolet': [\n\t                148,\n\t                0,\n\t                211,\n\t                1\n\t            ],\n\t            'deeppink': [\n\t                255,\n\t                20,\n\t                147,\n\t                1\n\t            ],\n\t            'deepskyblue': [\n\t                0,\n\t                191,\n\t                255,\n\t                1\n\t            ],\n\t            'dimgray': [\n\t                105,\n\t                105,\n\t                105,\n\t                1\n\t            ],\n\t            'dimgrey': [\n\t                105,\n\t                105,\n\t                105,\n\t                1\n\t            ],\n\t            'dodgerblue': [\n\t                30,\n\t                144,\n\t                255,\n\t                1\n\t            ],\n\t            'firebrick': [\n\t                178,\n\t                34,\n\t                34,\n\t                1\n\t            ],\n\t            'floralwhite': [\n\t                255,\n\t                250,\n\t                240,\n\t                1\n\t            ],\n\t            'forestgreen': [\n\t                34,\n\t                139,\n\t                34,\n\t                1\n\t            ],\n\t            'fuchsia': [\n\t                255,\n\t                0,\n\t                255,\n\t                1\n\t            ],\n\t            'gainsboro': [\n\t                220,\n\t                220,\n\t                220,\n\t                1\n\t            ],\n\t            'ghostwhite': [\n\t                248,\n\t                248,\n\t                255,\n\t                1\n\t            ],\n\t            'gold': [\n\t                255,\n\t                215,\n\t                0,\n\t                1\n\t            ],\n\t            'goldenrod': [\n\t                218,\n\t                165,\n\t                32,\n\t                1\n\t            ],\n\t            'gray': [\n\t                128,\n\t                128,\n\t                128,\n\t                1\n\t            ],\n\t            'green': [\n\t                0,\n\t                128,\n\t                0,\n\t                1\n\t            ],\n\t            'greenyellow': [\n\t                173,\n\t                255,\n\t                47,\n\t                1\n\t            ],\n\t            'grey': [\n\t                128,\n\t                128,\n\t                128,\n\t                1\n\t            ],\n\t            'honeydew': [\n\t                240,\n\t                255,\n\t                240,\n\t                1\n\t            ],\n\t            'hotpink': [\n\t                255,\n\t                105,\n\t                180,\n\t                1\n\t            ],\n\t            'indianred': [\n\t                205,\n\t                92,\n\t                92,\n\t                1\n\t            ],\n\t            'indigo': [\n\t                75,\n\t                0,\n\t                130,\n\t                1\n\t            ],\n\t            'ivory': [\n\t                255,\n\t                255,\n\t                240,\n\t                1\n\t            ],\n\t            'khaki': [\n\t                240,\n\t                230,\n\t                140,\n\t                1\n\t            ],\n\t            'lavender': [\n\t                230,\n\t                230,\n\t                250,\n\t                1\n\t            ],\n\t            'lavenderblush': [\n\t                255,\n\t                240,\n\t                245,\n\t                1\n\t            ],\n\t            'lawngreen': [\n\t                124,\n\t                252,\n\t                0,\n\t                1\n\t            ],\n\t            'lemonchiffon': [\n\t                255,\n\t                250,\n\t                205,\n\t                1\n\t            ],\n\t            'lightblue': [\n\t                173,\n\t                216,\n\t                230,\n\t                1\n\t            ],\n\t            'lightcoral': [\n\t                240,\n\t                128,\n\t                128,\n\t                1\n\t            ],\n\t            'lightcyan': [\n\t                224,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'lightgoldenrodyellow': [\n\t                250,\n\t                250,\n\t                210,\n\t                1\n\t            ],\n\t            'lightgray': [\n\t                211,\n\t                211,\n\t                211,\n\t                1\n\t            ],\n\t            'lightgreen': [\n\t                144,\n\t                238,\n\t                144,\n\t                1\n\t            ],\n\t            'lightgrey': [\n\t                211,\n\t                211,\n\t                211,\n\t                1\n\t            ],\n\t            'lightpink': [\n\t                255,\n\t                182,\n\t                193,\n\t                1\n\t            ],\n\t            'lightsalmon': [\n\t                255,\n\t                160,\n\t                122,\n\t                1\n\t            ],\n\t            'lightseagreen': [\n\t                32,\n\t                178,\n\t                170,\n\t                1\n\t            ],\n\t            'lightskyblue': [\n\t                135,\n\t                206,\n\t                250,\n\t                1\n\t            ],\n\t            'lightslategray': [\n\t                119,\n\t                136,\n\t                153,\n\t                1\n\t            ],\n\t            'lightslategrey': [\n\t                119,\n\t                136,\n\t                153,\n\t                1\n\t            ],\n\t            'lightsteelblue': [\n\t                176,\n\t                196,\n\t                222,\n\t                1\n\t            ],\n\t            'lightyellow': [\n\t                255,\n\t                255,\n\t                224,\n\t                1\n\t            ],\n\t            'lime': [\n\t                0,\n\t                255,\n\t                0,\n\t                1\n\t            ],\n\t            'limegreen': [\n\t                50,\n\t                205,\n\t                50,\n\t                1\n\t            ],\n\t            'linen': [\n\t                250,\n\t                240,\n\t                230,\n\t                1\n\t            ],\n\t            'magenta': [\n\t                255,\n\t                0,\n\t                255,\n\t                1\n\t            ],\n\t            'maroon': [\n\t                128,\n\t                0,\n\t                0,\n\t                1\n\t            ],\n\t            'mediumaquamarine': [\n\t                102,\n\t                205,\n\t                170,\n\t                1\n\t            ],\n\t            'mediumblue': [\n\t                0,\n\t                0,\n\t                205,\n\t                1\n\t            ],\n\t            'mediumorchid': [\n\t                186,\n\t                85,\n\t                211,\n\t                1\n\t            ],\n\t            'mediumpurple': [\n\t                147,\n\t                112,\n\t                219,\n\t                1\n\t            ],\n\t            'mediumseagreen': [\n\t                60,\n\t                179,\n\t                113,\n\t                1\n\t            ],\n\t            'mediumslateblue': [\n\t                123,\n\t                104,\n\t                238,\n\t                1\n\t            ],\n\t            'mediumspringgreen': [\n\t                0,\n\t                250,\n\t                154,\n\t                1\n\t            ],\n\t            'mediumturquoise': [\n\t                72,\n\t                209,\n\t                204,\n\t                1\n\t            ],\n\t            'mediumvioletred': [\n\t                199,\n\t                21,\n\t                133,\n\t                1\n\t            ],\n\t            'midnightblue': [\n\t                25,\n\t                25,\n\t                112,\n\t                1\n\t            ],\n\t            'mintcream': [\n\t                245,\n\t                255,\n\t                250,\n\t                1\n\t            ],\n\t            'mistyrose': [\n\t                255,\n\t                228,\n\t                225,\n\t                1\n\t            ],\n\t            'moccasin': [\n\t                255,\n\t                228,\n\t                181,\n\t                1\n\t            ],\n\t            'navajowhite': [\n\t                255,\n\t                222,\n\t                173,\n\t                1\n\t            ],\n\t            'navy': [\n\t                0,\n\t                0,\n\t                128,\n\t                1\n\t            ],\n\t            'oldlace': [\n\t                253,\n\t                245,\n\t                230,\n\t                1\n\t            ],\n\t            'olive': [\n\t                128,\n\t                128,\n\t                0,\n\t                1\n\t            ],\n\t            'olivedrab': [\n\t                107,\n\t                142,\n\t                35,\n\t                1\n\t            ],\n\t            'orange': [\n\t                255,\n\t                165,\n\t                0,\n\t                1\n\t            ],\n\t            'orangered': [\n\t                255,\n\t                69,\n\t                0,\n\t                1\n\t            ],\n\t            'orchid': [\n\t                218,\n\t                112,\n\t                214,\n\t                1\n\t            ],\n\t            'palegoldenrod': [\n\t                238,\n\t                232,\n\t                170,\n\t                1\n\t            ],\n\t            'palegreen': [\n\t                152,\n\t                251,\n\t                152,\n\t                1\n\t            ],\n\t            'paleturquoise': [\n\t                175,\n\t                238,\n\t                238,\n\t                1\n\t            ],\n\t            'palevioletred': [\n\t                219,\n\t                112,\n\t                147,\n\t                1\n\t            ],\n\t            'papayawhip': [\n\t                255,\n\t                239,\n\t                213,\n\t                1\n\t            ],\n\t            'peachpuff': [\n\t                255,\n\t                218,\n\t                185,\n\t                1\n\t            ],\n\t            'peru': [\n\t                205,\n\t                133,\n\t                63,\n\t                1\n\t            ],\n\t            'pink': [\n\t                255,\n\t                192,\n\t                203,\n\t                1\n\t            ],\n\t            'plum': [\n\t                221,\n\t                160,\n\t                221,\n\t                1\n\t            ],\n\t            'powderblue': [\n\t                176,\n\t                224,\n\t                230,\n\t                1\n\t            ],\n\t            'purple': [\n\t                128,\n\t                0,\n\t                128,\n\t                1\n\t            ],\n\t            'red': [\n\t                255,\n\t                0,\n\t                0,\n\t                1\n\t            ],\n\t            'rosybrown': [\n\t                188,\n\t                143,\n\t                143,\n\t                1\n\t            ],\n\t            'royalblue': [\n\t                65,\n\t                105,\n\t                225,\n\t                1\n\t            ],\n\t            'saddlebrown': [\n\t                139,\n\t                69,\n\t                19,\n\t                1\n\t            ],\n\t            'salmon': [\n\t                250,\n\t                128,\n\t                114,\n\t                1\n\t            ],\n\t            'sandybrown': [\n\t                244,\n\t                164,\n\t                96,\n\t                1\n\t            ],\n\t            'seagreen': [\n\t                46,\n\t                139,\n\t                87,\n\t                1\n\t            ],\n\t            'seashell': [\n\t                255,\n\t                245,\n\t                238,\n\t                1\n\t            ],\n\t            'sienna': [\n\t                160,\n\t                82,\n\t                45,\n\t                1\n\t            ],\n\t            'silver': [\n\t                192,\n\t                192,\n\t                192,\n\t                1\n\t            ],\n\t            'skyblue': [\n\t                135,\n\t                206,\n\t                235,\n\t                1\n\t            ],\n\t            'slateblue': [\n\t                106,\n\t                90,\n\t                205,\n\t                1\n\t            ],\n\t            'slategray': [\n\t                112,\n\t                128,\n\t                144,\n\t                1\n\t            ],\n\t            'slategrey': [\n\t                112,\n\t                128,\n\t                144,\n\t                1\n\t            ],\n\t            'snow': [\n\t                255,\n\t                250,\n\t                250,\n\t                1\n\t            ],\n\t            'springgreen': [\n\t                0,\n\t                255,\n\t                127,\n\t                1\n\t            ],\n\t            'steelblue': [\n\t                70,\n\t                130,\n\t                180,\n\t                1\n\t            ],\n\t            'tan': [\n\t                210,\n\t                180,\n\t                140,\n\t                1\n\t            ],\n\t            'teal': [\n\t                0,\n\t                128,\n\t                128,\n\t                1\n\t            ],\n\t            'thistle': [\n\t                216,\n\t                191,\n\t                216,\n\t                1\n\t            ],\n\t            'tomato': [\n\t                255,\n\t                99,\n\t                71,\n\t                1\n\t            ],\n\t            'turquoise': [\n\t                64,\n\t                224,\n\t                208,\n\t                1\n\t            ],\n\t            'violet': [\n\t                238,\n\t                130,\n\t                238,\n\t                1\n\t            ],\n\t            'wheat': [\n\t                245,\n\t                222,\n\t                179,\n\t                1\n\t            ],\n\t            'white': [\n\t                255,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'whitesmoke': [\n\t                245,\n\t                245,\n\t                245,\n\t                1\n\t            ],\n\t            'yellow': [\n\t                255,\n\t                255,\n\t                0,\n\t                1\n\t            ],\n\t            'yellowgreen': [\n\t                154,\n\t                205,\n\t                50,\n\t                1\n\t            ]\n\t        };\n\t    function clampCssByte(i) {\n\t        // Clamp to integer 0 .. 255.\n\t        i = Math.round(i);\n\t        // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 255 ? 255 : i;\n\t    }\n\t    function clampCssAngle(i) {\n\t        // Clamp to integer 0 .. 360.\n\t        i = Math.round(i);\n\t        // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 360 ? 360 : i;\n\t    }\n\t    function clampCssFloat(f) {\n\t        // Clamp to float 0.0 .. 1.0.\n\t        return f < 0 ? 0 : f > 1 ? 1 : f;\n\t    }\n\t    function parseCssInt(str) {\n\t        // int or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssByte(parseFloat(str) / 100 * 255);\n\t        }\n\t        return clampCssByte(parseInt(str, 10));\n\t    }\n\t    function parseCssFloat(str) {\n\t        // float or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssFloat(parseFloat(str) / 100);\n\t        }\n\t        return clampCssFloat(parseFloat(str));\n\t    }\n\t    function cssHueToRgb(m1, m2, h) {\n\t        if (h < 0) {\n\t            h += 1;\n\t        } else if (h > 1) {\n\t            h -= 1;\n\t        }\n\t        if (h * 6 < 1) {\n\t            return m1 + (m2 - m1) * h * 6;\n\t        }\n\t        if (h * 2 < 1) {\n\t            return m2;\n\t        }\n\t        if (h * 3 < 2) {\n\t            return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n\t        }\n\t        return m1;\n\t    }\n\t    function lerp(a, b, p) {\n\t        return a + (b - a) * p;\n\t    }\n\t    /**\n\t     * @param {string} colorStr\n\t     * @return {Array.<number>}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function parse(colorStr) {\n\t        if (!colorStr) {\n\t            return;\n\t        }\n\t        // colorStr may be not string\n\t        colorStr = colorStr + '';\n\t        // Remove all whitespace, not compliant, but should just be more accepting.\n\t        var str = colorStr.replace(/ /g, '').toLowerCase();\n\t        // Color keywords (and transparent) lookup.\n\t        if (str in kCSSColorTable) {\n\t            return kCSSColorTable[str].slice();    // dup.\n\t        }\n\t        // #abc and #abc123 syntax.\n\t        if (str.charAt(0) === '#') {\n\t            if (str.length === 4) {\n\t                var iv = parseInt(str.substr(1), 16);\n\t                // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 4095)) {\n\t                    return;    // Covers NaN.\n\t                }\n\t                return [\n\t                    (iv & 3840) >> 4 | (iv & 3840) >> 8,\n\t                    iv & 240 | (iv & 240) >> 4,\n\t                    iv & 15 | (iv & 15) << 4,\n\t                    1\n\t                ];\n\t            } else if (str.length === 7) {\n\t                var iv = parseInt(str.substr(1), 16);\n\t                // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 16777215)) {\n\t                    return;    // Covers NaN.\n\t                }\n\t                return [\n\t                    (iv & 16711680) >> 16,\n\t                    (iv & 65280) >> 8,\n\t                    iv & 255,\n\t                    1\n\t                ];\n\t            }\n\t            return;\n\t        }\n\t        var op = str.indexOf('('), ep = str.indexOf(')');\n\t        if (op !== -1 && ep + 1 === str.length) {\n\t            var fname = str.substr(0, op);\n\t            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n\t            var alpha = 1;\n\t            // To allow case fallthrough.\n\t            switch (fname) {\n\t            case 'rgba':\n\t                if (params.length !== 4) {\n\t                    return;\n\t                }\n\t                alpha = parseCssFloat(params.pop());\n\t            // jshint ignore:line\n\t            // Fall through.\n\t            case 'rgb':\n\t                if (params.length !== 3) {\n\t                    return;\n\t                }\n\t                return [\n\t                    parseCssInt(params[0]),\n\t                    parseCssInt(params[1]),\n\t                    parseCssInt(params[2]),\n\t                    alpha\n\t                ];\n\t            case 'hsla':\n\t                if (params.length !== 4) {\n\t                    return;\n\t                }\n\t                params[3] = parseCssFloat(params[3]);\n\t                return hsla2rgba(params);\n\t            case 'hsl':\n\t                if (params.length !== 3) {\n\t                    return;\n\t                }\n\t                return hsla2rgba(params);\n\t            default:\n\t                return;\n\t            }\n\t        }\n\t        return;\n\t    }\n\t    /**\n\t     * @param {Array.<number>} hsla\n\t     * @return {Array.<number>} rgba\n\t     */\n\t    function hsla2rgba(hsla) {\n\t        var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;\n\t        // 0 .. 1\n\t        // NOTE(deanm): According to the CSS spec s/l should only be\n\t        // percentages, but we don't bother and let float or percentage.\n\t        var s = parseCssFloat(hsla[1]);\n\t        var l = parseCssFloat(hsla[2]);\n\t        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\t        var m1 = l * 2 - m2;\n\t        var rgba = [\n\t                clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n\t                clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n\t                clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n\t            ];\n\t        if (hsla.length === 4) {\n\t            rgba[3] = hsla[3];\n\t        }\n\t        return rgba;\n\t    }\n\t    /**\n\t     * @param {Array.<number>} rgba\n\t     * @return {Array.<number>} hsla\n\t     */\n\t    function rgba2hsla(rgba) {\n\t        if (!rgba) {\n\t            return;\n\t        }\n\t        // RGB from 0 to 255\n\t        var R = rgba[0] / 255;\n\t        var G = rgba[1] / 255;\n\t        var B = rgba[2] / 255;\n\t        var vMin = Math.min(R, G, B);\n\t        // Min. value of RGB\n\t        var vMax = Math.max(R, G, B);\n\t        // Max. value of RGB\n\t        var delta = vMax - vMin;\n\t        // Delta RGB value\n\t        var L = (vMax + vMin) / 2;\n\t        var H;\n\t        var S;\n\t        // HSL results from 0 to 1\n\t        if (delta === 0) {\n\t            H = 0;\n\t            S = 0;\n\t        } else {\n\t            if (L < 0.5) {\n\t                S = delta / (vMax + vMin);\n\t            } else {\n\t                S = delta / (2 - vMax - vMin);\n\t            }\n\t            var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n\t            var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n\t            var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n\t            if (R === vMax) {\n\t                H = deltaB - deltaG;\n\t            } else if (G === vMax) {\n\t                H = 1 / 3 + deltaR - deltaB;\n\t            } else if (B === vMax) {\n\t                H = 2 / 3 + deltaG - deltaR;\n\t            }\n\t            if (H < 0) {\n\t                H += 1;\n\t            }\n\t            if (H > 1) {\n\t                H -= 1;\n\t            }\n\t        }\n\t        var hsla = [\n\t                H * 360,\n\t                S,\n\t                L\n\t            ];\n\t        if (rgba[3] != null) {\n\t            hsla.push(rgba[3]);\n\t        }\n\t        return hsla;\n\t    }\n\t    /**\n\t     * @param {string} color\n\t     * @param {number} level\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function lift(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            for (var i = 0; i < 3; i++) {\n\t                if (level < 0) {\n\t                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n\t                } else {\n\t                    colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n\t                }\n\t            }\n\t            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n\t        }\n\t    }\n\t    /**\n\t     * @param {string} color\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function toHex(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n\t        }\n\t    }\n\t    /**\n\t     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<Array.<number>>} colors List of rgba color array\n\t     * @param {Array.<number>} [out] Mapped gba color array\n\t     * @return {Array.<number>}\n\t     */\n\t    function fastMapToColor(normalizedValue, colors, out) {\n\t        if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n\t            return;\n\t        }\n\t        out = out || [\n\t            0,\n\t            0,\n\t            0,\n\t            0\n\t        ];\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = colors[leftIndex];\n\t        var rightColor = colors[rightIndex];\n\t        var dv = value - leftIndex;\n\t        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n\t        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n\t        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n\t        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n\t        return out;\n\t    }\n\t    /**\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {boolean=} fullOutput Default false.\n\t     * @return {(string|Object)} Result color. If fullOutput,\n\t     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function mapToColor(normalizedValue, colors, fullOutput) {\n\t        if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n\t            return;\n\t        }\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = parse(colors[leftIndex]);\n\t        var rightColor = parse(colors[rightIndex]);\n\t        var dv = value - leftIndex;\n\t        var color = stringify([\n\t                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n\t                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n\t                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n\t                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n\t            ], 'rgba');\n\t        return fullOutput ? {\n\t            color: color,\n\t            leftIndex: leftIndex,\n\t            rightIndex: rightIndex,\n\t            value: value\n\t        } : color;\n\t    }\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} h 0 ~ 360, ignore when null.\n\t     * @param {number=} s 0 ~ 1, ignore when null.\n\t     * @param {number=} l 0 ~ 1, ignore when null.\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyHSL(color, h, s, l) {\n\t        color = parse(color);\n\t        if (color) {\n\t            color = rgba2hsla(color);\n\t            h != null && (color[0] = clampCssAngle(h));\n\t            s != null && (color[1] = parseCssFloat(s));\n\t            l != null && (color[2] = parseCssFloat(l));\n\t            return stringify(hsla2rgba(color), 'rgba');\n\t        }\n\t    }\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} alpha 0 ~ 1\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyAlpha(color, alpha) {\n\t        color = parse(color);\n\t        if (color && alpha != null) {\n\t            color[3] = clampCssFloat(alpha);\n\t            return stringify(color, 'rgba');\n\t        }\n\t    }\n\t    /**\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {string} type 'rgba', 'hsva', ...\n\t     * @return {string} Result color.\n\t     */\n\t    function stringify(arrColor, type) {\n\t        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\t        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n\t            colorStr += ',' + arrColor[3];\n\t        }\n\t        return type + '(' + colorStr + ')';\n\t    }\n\t    return {\n\t        parse: parse,\n\t        lift: lift,\n\t        toHex: toHex,\n\t        fastMapToColor: fastMapToColor,\n\t        mapToColor: mapToColor,\n\t        modifyHSL: modifyHSL,\n\t        modifyAlpha: modifyAlpha,\n\t        stringify: stringify\n\t    };\n\t});\n\tdefine('zrender/core/timsort', [], function () {\n\t    var DEFAULT_MIN_MERGE = 32;\n\t    var DEFAULT_MIN_GALLOPING = 7;\n\t    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\t    function minRunLength(n) {\n\t        var r = 0;\n\t        while (n >= DEFAULT_MIN_MERGE) {\n\t            r |= n & 1;\n\t            n >>= 1;\n\t        }\n\t        return n + r;\n\t    }\n\t    function makeAscendingRun(array, lo, hi, compare) {\n\t        var runHi = lo + 1;\n\t        if (runHi === hi) {\n\t            return 1;\n\t        }\n\t        if (compare(array[runHi++], array[lo]) < 0) {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n\t                runHi++;\n\t            }\n\t            reverseRun(array, lo, runHi);\n\t        } else {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n\t                runHi++;\n\t            }\n\t        }\n\t        return runHi - lo;\n\t    }\n\t    function reverseRun(array, lo, hi) {\n\t        hi--;\n\t        while (lo < hi) {\n\t            var t = array[lo];\n\t            array[lo++] = array[hi];\n\t            array[hi--] = t;\n\t        }\n\t    }\n\t    function binaryInsertionSort(array, lo, hi, start, compare) {\n\t        if (start === lo) {\n\t            start++;\n\t        }\n\t        for (; start < hi; start++) {\n\t            var pivot = array[start];\n\t            var left = lo;\n\t            var right = start;\n\t            var mid;\n\t            while (left < right) {\n\t                mid = left + right >>> 1;\n\t                if (compare(pivot, array[mid]) < 0) {\n\t                    right = mid;\n\t                } else {\n\t                    left = mid + 1;\n\t                }\n\t            }\n\t            var n = start - left;\n\t            switch (n) {\n\t            case 3:\n\t                array[left + 3] = array[left + 2];\n\t            case 2:\n\t                array[left + 2] = array[left + 1];\n\t            case 1:\n\t                array[left + 1] = array[left];\n\t                break;\n\t            default:\n\t                while (n > 0) {\n\t                    array[left + n] = array[left + n - 1];\n\t                    n--;\n\t                }\n\t            }\n\t            array[left] = pivot;\n\t        }\n\t    }\n\t    function gallopLeft(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t        if (compare(value, array[start + hint]) > 0) {\n\t            maxOffset = length - hint;\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        } else {\n\t            maxOffset = hint + 1;\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t        lastOffset++;\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t            if (compare(value, array[start + m]) > 0) {\n\t                lastOffset = m + 1;\n\t            } else {\n\t                offset = m;\n\t            }\n\t        }\n\t        return offset;\n\t    }\n\t    function gallopRight(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t        if (compare(value, array[start + hint]) < 0) {\n\t            maxOffset = hint + 1;\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        } else {\n\t            maxOffset = length - hint;\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t        lastOffset++;\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t            if (compare(value, array[start + m]) < 0) {\n\t                offset = m;\n\t            } else {\n\t                lastOffset = m + 1;\n\t            }\n\t        }\n\t        return offset;\n\t    }\n\t    function TimSort(array, compare) {\n\t        var minGallop = DEFAULT_MIN_GALLOPING;\n\t        var length = 0;\n\t        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n\t        var stackLength = 0;\n\t        var runStart;\n\t        var runLength;\n\t        var stackSize = 0;\n\t        length = array.length;\n\t        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n\t            tmpStorageLength = length >>> 1;\n\t        }\n\t        var tmp = [];\n\t        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\t        runStart = [];\n\t        runLength = [];\n\t        function pushRun(_runStart, _runLength) {\n\t            runStart[stackSize] = _runStart;\n\t            runLength[stackSize] = _runLength;\n\t            stackSize += 1;\n\t        }\n\t        function mergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n\t                    if (runLength[n - 1] < runLength[n + 1]) {\n\t                        n--;\n\t                    }\n\t                } else if (runLength[n] > runLength[n + 1]) {\n\t                    break;\n\t                }\n\t                mergeAt(n);\n\t            }\n\t        }\n\t        function forceMergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n\t                    n--;\n\t                }\n\t                mergeAt(n);\n\t            }\n\t        }\n\t        function mergeAt(i) {\n\t            var start1 = runStart[i];\n\t            var length1 = runLength[i];\n\t            var start2 = runStart[i + 1];\n\t            var length2 = runLength[i + 1];\n\t            runLength[i] = length1 + length2;\n\t            if (i === stackSize - 3) {\n\t                runStart[i + 1] = runStart[i + 2];\n\t                runLength[i + 1] = runLength[i + 2];\n\t            }\n\t            stackSize--;\n\t            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n\t            start1 += k;\n\t            length1 -= k;\n\t            if (length1 === 0) {\n\t                return;\n\t            }\n\t            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\t            if (length2 === 0) {\n\t                return;\n\t            }\n\t            if (length1 <= length2) {\n\t                mergeLow(start1, length1, start2, length2);\n\t            } else {\n\t                mergeHigh(start1, length1, start2, length2);\n\t            }\n\t        }\n\t        function mergeLow(start1, length1, start2, length2) {\n\t            var i = 0;\n\t            for (i = 0; i < length1; i++) {\n\t                tmp[i] = array[start1 + i];\n\t            }\n\t            var cursor1 = 0;\n\t            var cursor2 = start2;\n\t            var dest = start1;\n\t            array[dest++] = array[cursor2++];\n\t            if (--length2 === 0) {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t                return;\n\t            }\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t                return;\n\t            }\n\t            var _minGallop = minGallop;\n\t            var count1, count2, exit;\n\t            while (1) {\n\t                count1 = 0;\n\t                count2 = 0;\n\t                exit = false;\n\t                do {\n\t                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n\t                        array[dest++] = array[cursor2++];\n\t                        count2++;\n\t                        count1 = 0;\n\t                        if (--length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    } else {\n\t                        array[dest++] = tmp[cursor1++];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t                if (exit) {\n\t                    break;\n\t                }\n\t                do {\n\t                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\t                    if (count1 !== 0) {\n\t                        for (i = 0; i < count1; i++) {\n\t                            array[dest + i] = tmp[cursor1 + i];\n\t                        }\n\t                        dest += count1;\n\t                        cursor1 += count1;\n\t                        length1 -= count1;\n\t                        if (length1 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest++] = array[cursor2++];\n\t                    if (--length2 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\t                    if (count2 !== 0) {\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[dest + i] = array[cursor2 + i];\n\t                        }\n\t                        dest += count2;\n\t                        cursor2 += count2;\n\t                        length2 -= count2;\n\t                        if (length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest++] = tmp[cursor1++];\n\t                    if (--length1 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t                if (exit) {\n\t                    break;\n\t                }\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t                _minGallop += 2;\n\t            }\n\t            minGallop = _minGallop;\n\t            minGallop < 1 && (minGallop = 1);\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t            } else if (length1 === 0) {\n\t                throw new Error();    // throw new Error('mergeLow preconditions were not respected');\n\t            } else {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t            }\n\t        }\n\t        function mergeHigh(start1, length1, start2, length2) {\n\t            var i = 0;\n\t            for (i = 0; i < length2; i++) {\n\t                tmp[i] = array[start2 + i];\n\t            }\n\t            var cursor1 = start1 + length1 - 1;\n\t            var cursor2 = length2 - 1;\n\t            var dest = start2 + length2 - 1;\n\t            var customCursor = 0;\n\t            var customDest = 0;\n\t            array[dest--] = array[cursor1--];\n\t            if (--length1 === 0) {\n\t                customCursor = dest - (length2 - 1);\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t                return;\n\t            }\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t                array[dest] = tmp[cursor2];\n\t                return;\n\t            }\n\t            var _minGallop = minGallop;\n\t            while (true) {\n\t                var count1 = 0;\n\t                var count2 = 0;\n\t                var exit = false;\n\t                do {\n\t                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n\t                        array[dest--] = array[cursor1--];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    } else {\n\t                        array[dest--] = tmp[cursor2--];\n\t                        count2++;\n\t                        count1 = 0;\n\t                        if (--length2 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t                if (exit) {\n\t                    break;\n\t                }\n\t                do {\n\t                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\t                    if (count1 !== 0) {\n\t                        dest -= count1;\n\t                        cursor1 -= count1;\n\t                        length1 -= count1;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor1 + 1;\n\t                        for (i = count1 - 1; i >= 0; i--) {\n\t                            array[customDest + i] = array[customCursor + i];\n\t                        }\n\t                        if (length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest--] = tmp[cursor2--];\n\t                    if (--length2 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\t                    if (count2 !== 0) {\n\t                        dest -= count2;\n\t                        cursor2 -= count2;\n\t                        length2 -= count2;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor2 + 1;\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[customDest + i] = tmp[customCursor + i];\n\t                        }\n\t                        if (length2 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest--] = array[cursor1--];\n\t                    if (--length1 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t                if (exit) {\n\t                    break;\n\t                }\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t                _minGallop += 2;\n\t            }\n\t            minGallop = _minGallop;\n\t            if (minGallop < 1) {\n\t                minGallop = 1;\n\t            }\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t                array[dest] = tmp[cursor2];\n\t            } else if (length2 === 0) {\n\t                throw new Error();    // throw new Error('mergeHigh preconditions were not respected');\n\t            } else {\n\t                customCursor = dest - (length2 - 1);\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t            }\n\t        }\n\t        this.mergeRuns = mergeRuns;\n\t        this.forceMergeRuns = forceMergeRuns;\n\t        this.pushRun = pushRun;\n\t    }\n\t    function sort(array, compare, lo, hi) {\n\t        if (!lo) {\n\t            lo = 0;\n\t        }\n\t        if (!hi) {\n\t            hi = array.length;\n\t        }\n\t        var remaining = hi - lo;\n\t        if (remaining < 2) {\n\t            return;\n\t        }\n\t        var runLength = 0;\n\t        if (remaining < DEFAULT_MIN_MERGE) {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n\t            return;\n\t        }\n\t        var ts = new TimSort(array, compare);\n\t        var minRun = minRunLength(remaining);\n\t        do {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            if (runLength < minRun) {\n\t                var force = remaining;\n\t                if (force > minRun) {\n\t                    force = minRun;\n\t                }\n\t                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n\t                runLength = force;\n\t            }\n\t            ts.pushRun(lo, runLength);\n\t            ts.mergeRuns();\n\t            remaining -= runLength;\n\t            lo += runLength;\n\t        } while (remaining !== 0);\n\t        ts.forceMergeRuns();\n\t    }\n\t    return sort;\n\t});\n\tdefine('echarts/visual/seriesColor', ['require', 'zrender/graphic/Gradient'], function (require) {\n\t    var Gradient = require('zrender/graphic/Gradient');\n\t    return function (ecModel) {\n\t        function encodeColor(seriesModel) {\n\t            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n\t            var data = seriesModel.getData();\n\t            var color = seriesModel.get(colorAccessPath) || seriesModel.getColorFromPalette(seriesModel.get('name'));\n\t            // Default color\n\t            // FIXME Set color function or use the platte color\n\t            data.setVisual('color', color);\n\t            // Only visible series has each data be visual encoded\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                if (typeof color === 'function' && !(color instanceof Gradient)) {\n\t                    data.each(function (idx) {\n\t                        data.setItemVisual(idx, 'color', color(seriesModel.getDataParams(idx)));\n\t                    });\n\t                }\n\t                // itemStyle in each data item\n\t                data.each(function (idx) {\n\t                    var itemModel = data.getItemModel(idx);\n\t                    var color = itemModel.get(colorAccessPath, true);\n\t                    if (color != null) {\n\t                        data.setItemVisual(idx, 'color', color);\n\t                    }\n\t                });\n\t            }\n\t        }\n\t        ecModel.eachRawSeries(encodeColor);\n\t    };\n\t});\n\tdefine('echarts/preprocessor/backwardCompat', ['require', 'zrender/core/util', './helper/compatStyle'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var compatStyle = require('./helper/compatStyle');\n\t    function get(opt, path) {\n\t        path = path.split(',');\n\t        var obj = opt;\n\t        for (var i = 0; i < path.length; i++) {\n\t            obj = obj && obj[path[i]];\n\t            if (obj == null) {\n\t                break;\n\t            }\n\t        }\n\t        return obj;\n\t    }\n\t    function set(opt, path, val, overwrite) {\n\t        path = path.split(',');\n\t        var obj = opt;\n\t        var key;\n\t        for (var i = 0; i < path.length - 1; i++) {\n\t            key = path[i];\n\t            if (obj[key] == null) {\n\t                obj[key] = {};\n\t            }\n\t            obj = obj[key];\n\t        }\n\t        if (overwrite || obj[path[i]] == null) {\n\t            obj[path[i]] = val;\n\t        }\n\t    }\n\t    function compatLayoutProperties(option) {\n\t        each(LAYOUT_PROPERTIES, function (prop) {\n\t            if (prop[0] in option && !(prop[1] in option)) {\n\t                option[prop[1]] = option[prop[0]];\n\t            }\n\t        });\n\t    }\n\t    var LAYOUT_PROPERTIES = [\n\t            [\n\t                'x',\n\t                'left'\n\t            ],\n\t            [\n\t                'y',\n\t                'top'\n\t            ],\n\t            [\n\t                'x2',\n\t                'right'\n\t            ],\n\t            [\n\t                'y2',\n\t                'bottom'\n\t            ]\n\t        ];\n\t    var COMPATITABLE_COMPONENTS = [\n\t            'grid',\n\t            'geo',\n\t            'parallel',\n\t            'legend',\n\t            'toolbox',\n\t            'title',\n\t            'visualMap',\n\t            'dataZoom',\n\t            'timeline'\n\t        ];\n\t    var COMPATITABLE_SERIES = [\n\t            'bar',\n\t            'boxplot',\n\t            'candlestick',\n\t            'chord',\n\t            'effectScatter',\n\t            'funnel',\n\t            'gauge',\n\t            'lines',\n\t            'graph',\n\t            'heatmap',\n\t            'line',\n\t            'map',\n\t            'parallel',\n\t            'pie',\n\t            'radar',\n\t            'sankey',\n\t            'scatter',\n\t            'treemap'\n\t        ];\n\t    var each = zrUtil.each;\n\t    return function (option) {\n\t        each(option.series, function (seriesOpt) {\n\t            if (!zrUtil.isObject(seriesOpt)) {\n\t                return;\n\t            }\n\t            var seriesType = seriesOpt.type;\n\t            compatStyle(seriesOpt);\n\t            if (seriesType === 'pie' || seriesType === 'gauge') {\n\t                if (seriesOpt.clockWise != null) {\n\t                    seriesOpt.clockwise = seriesOpt.clockWise;\n\t                }\n\t            }\n\t            if (seriesType === 'gauge') {\n\t                var pointerColor = get(seriesOpt, 'pointer.color');\n\t                pointerColor != null && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n\t            }\n\t            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n\t                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n\t                    compatLayoutProperties(seriesOpt);\n\t                    break;\n\t                }\n\t            }\n\t        });\n\t        // dataRange has changed to visualMap\n\t        if (option.dataRange) {\n\t            option.visualMap = option.dataRange;\n\t        }\n\t        each(COMPATITABLE_COMPONENTS, function (componentName) {\n\t            var options = option[componentName];\n\t            if (options) {\n\t                if (!zrUtil.isArray(options)) {\n\t                    options = [options];\n\t                }\n\t                each(options, function (option) {\n\t                    compatLayoutProperties(option);\n\t                });\n\t            }\n\t        });\n\t    };\n\t});\n\tdefine('echarts/loading/default', ['require', '../util/graphic', 'zrender/core/util'], function (require) {\n\t    var graphic = require('../util/graphic');\n\t    var zrUtil = require('zrender/core/util');\n\t    var PI = Math.PI;\n\t    /**\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     * @param {Object} [opts]\n\t     * @param {string} [opts.text]\n\t     * @param {string} [opts.color]\n\t     * @param {string} [opts.textColor]\n\t     * @return {module:zrender/Element}\n\t     */\n\t    return function (api, opts) {\n\t        opts = opts || {};\n\t        zrUtil.defaults(opts, {\n\t            text: 'loading',\n\t            color: '#c23531',\n\t            textColor: '#000',\n\t            maskColor: 'rgba(255, 255, 255, 0.8)',\n\t            zlevel: 0\n\t        });\n\t        var mask = new graphic.Rect({\n\t                style: { fill: opts.maskColor },\n\t                zlevel: opts.zlevel,\n\t                z: 10000\n\t            });\n\t        var arc = new graphic.Arc({\n\t                shape: {\n\t                    startAngle: -PI / 2,\n\t                    endAngle: -PI / 2 + 0.1,\n\t                    r: 10\n\t                },\n\t                style: {\n\t                    stroke: opts.color,\n\t                    lineCap: 'round',\n\t                    lineWidth: 5\n\t                },\n\t                zlevel: opts.zlevel,\n\t                z: 10001\n\t            });\n\t        var labelRect = new graphic.Rect({\n\t                style: {\n\t                    fill: 'none',\n\t                    text: opts.text,\n\t                    textPosition: 'right',\n\t                    textDistance: 10,\n\t                    textFill: opts.textColor\n\t                },\n\t                zlevel: opts.zlevel,\n\t                z: 10001\n\t            });\n\t        arc.animateShape(true).when(1000, { endAngle: PI * 3 / 2 }).start('circularInOut');\n\t        arc.animateShape(true).when(1000, { startAngle: PI * 3 / 2 }).delay(300).start('circularInOut');\n\t        var group = new graphic.Group();\n\t        group.add(arc);\n\t        group.add(labelRect);\n\t        group.add(mask);\n\t        // Inject resize\n\t        group.resize = function () {\n\t            var cx = api.getWidth() / 2;\n\t            var cy = api.getHeight() / 2;\n\t            arc.setShape({\n\t                cx: cx,\n\t                cy: cy\n\t            });\n\t            var r = arc.shape.r;\n\t            labelRect.setShape({\n\t                x: cx - r,\n\t                y: cy - r,\n\t                width: r * 2,\n\t                height: r * 2\n\t            });\n\t            mask.setShape({\n\t                x: 0,\n\t                y: 0,\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            });\n\t        };\n\t        group.resize();\n\t        return group;\n\t    };\n\t});\n\tdefine('zrender/core/matrix', [], function () {\n\t    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n\t    /**\n\t     * 3x2矩阵操作类\n\t     * @exports zrender/tool/matrix\n\t     */\n\t    var matrix = {\n\t            create: function () {\n\t                var out = new ArrayCtor(6);\n\t                matrix.identity(out);\n\t                return out;\n\t            },\n\t            identity: function (out) {\n\t                out[0] = 1;\n\t                out[1] = 0;\n\t                out[2] = 0;\n\t                out[3] = 1;\n\t                out[4] = 0;\n\t                out[5] = 0;\n\t                return out;\n\t            },\n\t            copy: function (out, m) {\n\t                out[0] = m[0];\n\t                out[1] = m[1];\n\t                out[2] = m[2];\n\t                out[3] = m[3];\n\t                out[4] = m[4];\n\t                out[5] = m[5];\n\t                return out;\n\t            },\n\t            mul: function (out, m1, m2) {\n\t                // Consider matrix.mul(m, m2, m);\n\t                // where out is the same as m2.\n\t                // So use temp variable to escape error.\n\t                var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n\t                var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n\t                var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n\t                var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n\t                var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n\t                var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n\t                out[0] = out0;\n\t                out[1] = out1;\n\t                out[2] = out2;\n\t                out[3] = out3;\n\t                out[4] = out4;\n\t                out[5] = out5;\n\t                return out;\n\t            },\n\t            translate: function (out, a, v) {\n\t                out[0] = a[0];\n\t                out[1] = a[1];\n\t                out[2] = a[2];\n\t                out[3] = a[3];\n\t                out[4] = a[4] + v[0];\n\t                out[5] = a[5] + v[1];\n\t                return out;\n\t            },\n\t            rotate: function (out, a, rad) {\n\t                var aa = a[0];\n\t                var ac = a[2];\n\t                var atx = a[4];\n\t                var ab = a[1];\n\t                var ad = a[3];\n\t                var aty = a[5];\n\t                var st = Math.sin(rad);\n\t                var ct = Math.cos(rad);\n\t                out[0] = aa * ct + ab * st;\n\t                out[1] = -aa * st + ab * ct;\n\t                out[2] = ac * ct + ad * st;\n\t                out[3] = -ac * st + ct * ad;\n\t                out[4] = ct * atx + st * aty;\n\t                out[5] = ct * aty - st * atx;\n\t                return out;\n\t            },\n\t            scale: function (out, a, v) {\n\t                var vx = v[0];\n\t                var vy = v[1];\n\t                out[0] = a[0] * vx;\n\t                out[1] = a[1] * vy;\n\t                out[2] = a[2] * vx;\n\t                out[3] = a[3] * vy;\n\t                out[4] = a[4] * vx;\n\t                out[5] = a[5] * vy;\n\t                return out;\n\t            },\n\t            invert: function (out, a) {\n\t                var aa = a[0];\n\t                var ac = a[2];\n\t                var atx = a[4];\n\t                var ab = a[1];\n\t                var ad = a[3];\n\t                var aty = a[5];\n\t                var det = aa * ad - ab * ac;\n\t                if (!det) {\n\t                    return null;\n\t                }\n\t                det = 1 / det;\n\t                out[0] = ad * det;\n\t                out[1] = -ab * det;\n\t                out[2] = -ac * det;\n\t                out[3] = aa * det;\n\t                out[4] = (ac * aty - ad * atx) * det;\n\t                out[5] = (ab * atx - aa * aty) * det;\n\t                return out;\n\t            }\n\t        };\n\t    return matrix;\n\t});\n\tdefine('echarts/model/Model', ['require', 'zrender/core/util', '../util/clazz', './mixin/lineStyle', './mixin/areaStyle', './mixin/textStyle', './mixin/itemStyle'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var clazzUtil = require('../util/clazz');\n\t    /**\n\t     * @alias module:echarts/model/Model\n\t     * @constructor\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} [parentModel]\n\t     * @param {module:echarts/model/Global} [ecModel]\n\t     */\n\t    function Model(option, parentModel, ecModel) {\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         * @readOnly\n\t         */\n\t        this.parentModel = parentModel;\n\t        /**\n\t         * @type {module:echarts/model/Global}\n\t         * @readOnly\n\t         */\n\t        this.ecModel = ecModel;\n\t        /**\n\t         * @type {Object}\n\t         * @protected\n\t         */\n\t        this.option = option;    // Simple optimization\n\t                                 // if (this.init) {\n\t                                 //     if (arguments.length <= 4) {\n\t                                 //         this.init(option, parentModel, ecModel, extraOpt);\n\t                                 //     }\n\t                                 //     else {\n\t                                 //         this.init.apply(this, arguments);\n\t                                 //     }\n\t                                 // }\n\t    }\n\t    Model.prototype = {\n\t        constructor: Model,\n\t        init: null,\n\t        mergeOption: function (option) {\n\t            zrUtil.merge(this.option, option, true);\n\t        },\n\t        get: function (path, ignoreParent) {\n\t            if (!path) {\n\t                return this.option;\n\t            }\n\t            if (typeof path === 'string') {\n\t                path = path.split('.');\n\t            }\n\t            var obj = this.option;\n\t            var parentModel = this.parentModel;\n\t            for (var i = 0; i < path.length; i++) {\n\t                // Ignore empty\n\t                if (!path[i]) {\n\t                    continue;\n\t                }\n\t                // obj could be number/string/... (like 0)\n\t                obj = obj && typeof obj === 'object' ? obj[path[i]] : null;\n\t                if (obj == null) {\n\t                    break;\n\t                }\n\t            }\n\t            if (obj == null && parentModel && !ignoreParent) {\n\t                obj = parentModel.get(path);\n\t            }\n\t            return obj;\n\t        },\n\t        getShallow: function (key, ignoreParent) {\n\t            var option = this.option;\n\t            var val = option == null ? option : option[key];\n\t            var parentModel = this.parentModel;\n\t            if (val == null && parentModel && !ignoreParent) {\n\t                val = parentModel.getShallow(key);\n\t            }\n\t            return val;\n\t        },\n\t        getModel: function (path, parentModel) {\n\t            var obj = this.get(path, true);\n\t            var thisParentModel = this.parentModel;\n\t            var model = new Model(obj, parentModel || thisParentModel && thisParentModel.getModel(path), this.ecModel);\n\t            return model;\n\t        },\n\t        isEmpty: function () {\n\t            return this.option == null;\n\t        },\n\t        restoreData: function () {\n\t        },\n\t        clone: function () {\n\t            var Ctor = this.constructor;\n\t            return new Ctor(zrUtil.clone(this.option));\n\t        },\n\t        setReadOnly: function (properties) {\n\t            clazzUtil.setReadOnly(this, properties);\n\t        }\n\t    };\n\t    // Enable Model.extend.\n\t    clazzUtil.enableClassExtend(Model);\n\t    var mixin = zrUtil.mixin;\n\t    mixin(Model, require('./mixin/lineStyle'));\n\t    mixin(Model, require('./mixin/areaStyle'));\n\t    mixin(Model, require('./mixin/textStyle'));\n\t    mixin(Model, require('./mixin/itemStyle'));\n\t    return Model;\n\t});\n\tdefine('echarts/data/List', ['require', '../model/Model', './DataDiffer', 'zrender/core/util', '../util/model'], function (require) {\n\t    var UNDEFINED = 'undefined';\n\t    var globalObj = typeof window === 'undefined' ? global : window;\n\t    var Float64Array = typeof globalObj.Float64Array === UNDEFINED ? Array : globalObj.Float64Array;\n\t    var Int32Array = typeof globalObj.Int32Array === UNDEFINED ? Array : globalObj.Int32Array;\n\t    var dataCtors = {\n\t            'float': Float64Array,\n\t            'int': Int32Array,\n\t            'ordinal': Array,\n\t            'number': Array,\n\t            'time': Array\n\t        };\n\t    var Model = require('../model/Model');\n\t    var DataDiffer = require('./DataDiffer');\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../util/model');\n\t    var isObject = zrUtil.isObject;\n\t    var TRANSFERABLE_PROPERTIES = [\n\t            'stackedOn',\n\t            'hasItemOption',\n\t            '_nameList',\n\t            '_idList',\n\t            '_rawData'\n\t        ];\n\t    var transferProperties = function (a, b) {\n\t        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n\t            if (b.hasOwnProperty(propName)) {\n\t                a[propName] = b[propName];\n\t            }\n\t        });\n\t        a.__wrappedMethods = b.__wrappedMethods;\n\t    };\n\t    /**\n\t     * @constructor\n\t     * @alias module:echarts/data/List\n\t     *\n\t     * @param {Array.<string>} dimensions\n\t     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n\t     * @param {module:echarts/model/Model} hostModel\n\t     */\n\t    var List = function (dimensions, hostModel) {\n\t        dimensions = dimensions || [\n\t            'x',\n\t            'y'\n\t        ];\n\t        var dimensionInfos = {};\n\t        var dimensionNames = [];\n\t        for (var i = 0; i < dimensions.length; i++) {\n\t            var dimensionName;\n\t            var dimensionInfo = {};\n\t            if (typeof dimensions[i] === 'string') {\n\t                dimensionName = dimensions[i];\n\t                dimensionInfo = {\n\t                    name: dimensionName,\n\t                    stackable: false,\n\t                    type: 'number'\n\t                };\n\t            } else {\n\t                dimensionInfo = dimensions[i];\n\t                dimensionName = dimensionInfo.name;\n\t                dimensionInfo.type = dimensionInfo.type || 'number';\n\t            }\n\t            dimensionNames.push(dimensionName);\n\t            dimensionInfos[dimensionName] = dimensionInfo;\n\t        }\n\t        /**\n\t         * @readOnly\n\t         * @type {Array.<string>}\n\t         */\n\t        this.dimensions = dimensionNames;\n\t        /**\n\t         * Infomation of each data dimension, like data type.\n\t         * @type {Object}\n\t         */\n\t        this._dimensionInfos = dimensionInfos;\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         */\n\t        this.hostModel = hostModel;\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         */\n\t        this.dataType;\n\t        /**\n\t         * Indices stores the indices of data subset after filtered.\n\t         * This data subset will be used in chart.\n\t         * @type {Array.<number>}\n\t         * @readOnly\n\t         */\n\t        this.indices = [];\n\t        /**\n\t         * Data storage\n\t         * @type {Object.<key, TypedArray|Array>}\n\t         * @private\n\t         */\n\t        this._storage = {};\n\t        /**\n\t         * @type {Array.<string>}\n\t         */\n\t        this._nameList = [];\n\t        /**\n\t         * @type {Array.<string>}\n\t         */\n\t        this._idList = [];\n\t        /**\n\t         * Models of data option is stored sparse for optimizing memory cost\n\t         * @type {Array.<module:echarts/model/Model>}\n\t         * @private\n\t         */\n\t        this._optionModels = [];\n\t        /**\n\t         * @param {module:echarts/data/List}\n\t         */\n\t        this.stackedOn = null;\n\t        /**\n\t         * Global visual properties after visual coding\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._visual = {};\n\t        /**\n\t         * Globel layout properties.\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._layout = {};\n\t        /**\n\t         * Item visual properties after visual coding\n\t         * @type {Array.<Object>}\n\t         * @private\n\t         */\n\t        this._itemVisuals = [];\n\t        /**\n\t         * Item layout properties after layout\n\t         * @type {Array.<Object>}\n\t         * @private\n\t         */\n\t        this._itemLayouts = [];\n\t        /**\n\t         * Graphic elemnents\n\t         * @type {Array.<module:zrender/Element>}\n\t         * @private\n\t         */\n\t        this._graphicEls = [];\n\t        /**\n\t         * @type {Array.<Array|Object>}\n\t         * @private\n\t         */\n\t        this._rawData;\n\t        /**\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._extent;\n\t    };\n\t    var listProto = List.prototype;\n\t    listProto.type = 'list';\n\t    /**\n\t     * If each data item has it's own option\n\t     * @type {boolean}\n\t     */\n\t    listProto.hasItemOption = true;\n\t    /**\n\t     * Get dimension name\n\t     * @param {string|number} dim\n\t     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n\t     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n\t     * @return {string} Concrete dim name.\n\t     */\n\t    listProto.getDimension = function (dim) {\n\t        if (!isNaN(dim)) {\n\t            dim = this.dimensions[dim] || dim;\n\t        }\n\t        return dim;\n\t    };\n\t    /**\n\t     * Get type and stackable info of particular dimension\n\t     * @param {string|number} dim\n\t     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n\t     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n\t     */\n\t    listProto.getDimensionInfo = function (dim) {\n\t        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n\t    };\n\t    /**\n\t     * Initialize from data\n\t     * @param {Array.<Object|number|Array>} data\n\t     * @param {Array.<string>} [nameList]\n\t     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n\t     */\n\t    listProto.initData = function (data, nameList, dimValueGetter) {\n\t        data = data || [];\n\t        if (true) {\n\t            if (!zrUtil.isArray(data)) {\n\t                throw new Error('Invalid data.');\n\t            }\n\t        }\n\t        this._rawData = data;\n\t        // Clear\n\t        var storage = this._storage = {};\n\t        var indices = this.indices = [];\n\t        var dimensions = this.dimensions;\n\t        var size = data.length;\n\t        var dimensionInfoMap = this._dimensionInfos;\n\t        var idList = [];\n\t        var nameRepeatCount = {};\n\t        nameList = nameList || [];\n\t        // Init storage\n\t        for (var i = 0; i < dimensions.length; i++) {\n\t            var dimInfo = dimensionInfoMap[dimensions[i]];\n\t            var DataCtor = dataCtors[dimInfo.type];\n\t            storage[dimensions[i]] = new DataCtor(size);\n\t        }\n\t        var self = this;\n\t        if (!dimValueGetter) {\n\t            self.hasItemOption = false;\n\t        }\n\t        // Default dim value getter\n\t        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n\t            var value = modelUtil.getDataItemValue(dataItem);\n\t            // If any dataItem is like { value: 10 }\n\t            if (modelUtil.isDataItemOption(dataItem)) {\n\t                self.hasItemOption = true;\n\t            }\n\t            return modelUtil.converDataValue(value instanceof Array ? value[dimIndex] : value, dimensionInfoMap[dimName]);\n\t        };\n\t        for (var idx = 0; idx < data.length; idx++) {\n\t            var dataItem = data[idx];\n\t            // Each data item is value\n\t            // [1, 2]\n\t            // 2\n\t            // Bar chart, line chart which uses category axis\n\t            // only gives the 'y' value. 'x' value is the indices of cateogry\n\t            // Use a tempValue to normalize the value to be a (x, y) value\n\t            // Store the data by dimensions\n\t            for (var k = 0; k < dimensions.length; k++) {\n\t                var dim = dimensions[k];\n\t                var dimStorage = storage[dim];\n\t                // PENDING NULL is empty or zero\n\t                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n\t            }\n\t            indices.push(idx);\n\t        }\n\t        // Use the name in option and create id\n\t        for (var i = 0; i < data.length; i++) {\n\t            if (!nameList[i]) {\n\t                if (data[i] && data[i].name != null) {\n\t                    nameList[i] = data[i].name;\n\t                }\n\t            }\n\t            var name = nameList[i] || '';\n\t            // Try using the id in option\n\t            var id = data[i] && data[i].id;\n\t            if (!id && name) {\n\t                // Use name as id and add counter to avoid same name\n\t                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n\t                id = name;\n\t                if (nameRepeatCount[name] > 0) {\n\t                    id += '__ec__' + nameRepeatCount[name];\n\t                }\n\t                nameRepeatCount[name]++;\n\t            }\n\t            id && (idList[i] = id);\n\t        }\n\t        this._nameList = nameList;\n\t        this._idList = idList;\n\t    };\n\t    /**\n\t     * @return {number}\n\t     */\n\t    listProto.count = function () {\n\t        return this.indices.length;\n\t    };\n\t    /**\n\t     * Get value. Return NaN if idx is out of range.\n\t     * @param {string} dim Dim must be concrete name.\n\t     * @param {number} idx\n\t     * @param {boolean} stack\n\t     * @return {number}\n\t     */\n\t    listProto.get = function (dim, idx, stack) {\n\t        var storage = this._storage;\n\t        var dataIndex = this.indices[idx];\n\t        // If value not exists\n\t        if (dataIndex == null) {\n\t            return NaN;\n\t        }\n\t        var value = storage[dim] && storage[dim][dataIndex];\n\t        // FIXME ordinal data type is not stackable\n\t        if (stack) {\n\t            var dimensionInfo = this._dimensionInfos[dim];\n\t            if (dimensionInfo && dimensionInfo.stackable) {\n\t                var stackedOn = this.stackedOn;\n\t                while (stackedOn) {\n\t                    // Get no stacked data of stacked on\n\t                    var stackedValue = stackedOn.get(dim, idx);\n\t                    // Considering positive stack, negative stack and empty data\n\t                    if (value >= 0 && stackedValue > 0 || value <= 0 && stackedValue < 0) {\n\t                        value += stackedValue;\n\t                    }\n\t                    stackedOn = stackedOn.stackedOn;\n\t                }\n\t            }\n\t        }\n\t        return value;\n\t    };\n\t    /**\n\t     * Get value for multi dimensions.\n\t     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n\t     * @param {number} idx\n\t     * @param {boolean} stack\n\t     * @return {number}\n\t     */\n\t    listProto.getValues = function (dimensions, idx, stack) {\n\t        var values = [];\n\t        if (!zrUtil.isArray(dimensions)) {\n\t            stack = idx;\n\t            idx = dimensions;\n\t            dimensions = this.dimensions;\n\t        }\n\t        for (var i = 0, len = dimensions.length; i < len; i++) {\n\t            values.push(this.get(dimensions[i], idx, stack));\n\t        }\n\t        return values;\n\t    };\n\t    /**\n\t     * If value is NaN. Inlcuding '-'\n\t     * @param {string} dim\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.hasValue = function (idx) {\n\t        var dimensions = this.dimensions;\n\t        var dimensionInfos = this._dimensionInfos;\n\t        for (var i = 0, len = dimensions.length; i < len; i++) {\n\t            if (dimensionInfos[dimensions[i]].type !== 'ordinal' && isNaN(this.get(dimensions[i], idx))) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    };\n\t    /**\n\t     * Get extent of data in one dimension\n\t     * @param {string} dim\n\t     * @param {boolean} stack\n\t     */\n\t    listProto.getDataExtent = function (dim, stack) {\n\t        dim = this.getDimension(dim);\n\t        var dimData = this._storage[dim];\n\t        var dimInfo = this.getDimensionInfo(dim);\n\t        stack = dimInfo && dimInfo.stackable && stack;\n\t        var dimExtent = (this._extent || (this._extent = {}))[dim + !!stack];\n\t        var value;\n\t        if (dimExtent) {\n\t            return dimExtent;\n\t        }\n\t        // var dimInfo = this._dimensionInfos[dim];\n\t        if (dimData) {\n\t            var min = Infinity;\n\t            var max = -Infinity;\n\t            // var isOrdinal = dimInfo.type === 'ordinal';\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                value = this.get(dim, i, stack);\n\t                // FIXME\n\t                // if (isOrdinal && typeof value === 'string') {\n\t                //     value = zrUtil.indexOf(dimData, value);\n\t                // }\n\t                value < min && (min = value);\n\t                value > max && (max = value);\n\t            }\n\t            return this._extent[dim + !!stack] = [\n\t                min,\n\t                max\n\t            ];\n\t        } else {\n\t            return [\n\t                Infinity,\n\t                -Infinity\n\t            ];\n\t        }\n\t    };\n\t    /**\n\t     * Get sum of data in one dimension\n\t     * @param {string} dim\n\t     * @param {boolean} stack\n\t     */\n\t    listProto.getSum = function (dim, stack) {\n\t        var dimData = this._storage[dim];\n\t        var sum = 0;\n\t        if (dimData) {\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                var value = this.get(dim, i, stack);\n\t                if (!isNaN(value)) {\n\t                    sum += value;\n\t                }\n\t            }\n\t        }\n\t        return sum;\n\t    };\n\t    /**\n\t     * Retreive the index with given value\n\t     * @param {number} idx\n\t     * @param {number} value\n\t     * @return {number}\n\t     */\n\t    // FIXME Precision of float value\n\t    listProto.indexOf = function (dim, value) {\n\t        var storage = this._storage;\n\t        var dimData = storage[dim];\n\t        var indices = this.indices;\n\t        if (dimData) {\n\t            for (var i = 0, len = indices.length; i < len; i++) {\n\t                var rawIndex = indices[i];\n\t                if (dimData[rawIndex] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t    /**\n\t     * Retreive the index with given name\n\t     * @param {number} idx\n\t     * @param {number} name\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfName = function (name) {\n\t        var indices = this.indices;\n\t        var nameList = this._nameList;\n\t        for (var i = 0, len = indices.length; i < len; i++) {\n\t            var rawIndex = indices[i];\n\t            if (nameList[rawIndex] === name) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t    /**\n\t     * Retreive the index with given raw data index\n\t     * @param {number} idx\n\t     * @param {number} name\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfRawIndex = function (rawIndex) {\n\t        // Indices are ascending\n\t        var indices = this.indices;\n\t        var left = 0;\n\t        var right = indices.length - 1;\n\t        while (left <= right) {\n\t            var mid = (left + right) / 2 | 0;\n\t            if (indices[mid] < rawIndex) {\n\t                left = mid + 1;\n\t            } else if (indices[mid] > rawIndex) {\n\t                right = mid - 1;\n\t            } else {\n\t                return mid;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t    /**\n\t     * Retreive the index of nearest value\n\t     * @param {string} dim\n\t     * @param {number} value\n\t     * @param {boolean} stack If given value is after stacked\n\t     * @param {number} [maxDistance=Infinity]\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {\n\t        var storage = this._storage;\n\t        var dimData = storage[dim];\n\t        if (maxDistance == null) {\n\t            maxDistance = Infinity;\n\t        }\n\t        var nearestIdx = -1;\n\t        if (dimData) {\n\t            var minDist = Number.MAX_VALUE;\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                var diff = value - this.get(dim, i, stack);\n\t                var dist = Math.abs(diff);\n\t                if (diff <= maxDistance && (dist < minDist || dist === minDist && diff > 0)) {\n\t                    minDist = dist;\n\t                    nearestIdx = i;\n\t                }\n\t            }\n\t        }\n\t        return nearestIdx;\n\t    };\n\t    /**\n\t     * Get raw data index\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.getRawIndex = function (idx) {\n\t        var rawIdx = this.indices[idx];\n\t        return rawIdx == null ? -1 : rawIdx;\n\t    };\n\t    /**\n\t     * Get raw data item\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.getRawDataItem = function (idx) {\n\t        return this._rawData[this.getRawIndex(idx)];\n\t    };\n\t    /**\n\t     * @param {number} idx\n\t     * @param {boolean} [notDefaultIdx=false]\n\t     * @return {string}\n\t     */\n\t    listProto.getName = function (idx) {\n\t        return this._nameList[this.indices[idx]] || '';\n\t    };\n\t    /**\n\t     * @param {number} idx\n\t     * @param {boolean} [notDefaultIdx=false]\n\t     * @return {string}\n\t     */\n\t    listProto.getId = function (idx) {\n\t        return this._idList[this.indices[idx]] || this.getRawIndex(idx) + '';\n\t    };\n\t    function normalizeDimensions(dimensions) {\n\t        if (!zrUtil.isArray(dimensions)) {\n\t            dimensions = [dimensions];\n\t        }\n\t        return dimensions;\n\t    }\n\t    /**\n\t     * Data iteration\n\t     * @param {string|Array.<string>}\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     *\n\t     * @example\n\t     *  list.each('x', function (x, idx) {});\n\t     *  list.each(['x', 'y'], function (x, y, idx) {});\n\t     *  list.each(function (idx) {})\n\t     */\n\t    listProto.each = function (dims, cb, stack, context) {\n\t        if (typeof dims === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dims;\n\t            dims = [];\n\t        }\n\t        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\t        var value = [];\n\t        var dimSize = dims.length;\n\t        var indices = this.indices;\n\t        context = context || this;\n\t        for (var i = 0; i < indices.length; i++) {\n\t            // Simple optimization\n\t            switch (dimSize) {\n\t            case 0:\n\t                cb.call(context, i);\n\t                break;\n\t            case 1:\n\t                cb.call(context, this.get(dims[0], i, stack), i);\n\t                break;\n\t            case 2:\n\t                cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n\t                break;\n\t            default:\n\t                for (var k = 0; k < dimSize; k++) {\n\t                    value[k] = this.get(dims[k], i, stack);\n\t                }\n\t                // Index\n\t                value[k] = i;\n\t                cb.apply(context, value);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t     * Data filter\n\t     * @param {string|Array.<string>}\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     */\n\t    listProto.filterSelf = function (dimensions, cb, stack, context) {\n\t        if (typeof dimensions === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dimensions;\n\t            dimensions = [];\n\t        }\n\t        dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n\t        var newIndices = [];\n\t        var value = [];\n\t        var dimSize = dimensions.length;\n\t        var indices = this.indices;\n\t        context = context || this;\n\t        for (var i = 0; i < indices.length; i++) {\n\t            var keep;\n\t            // Simple optimization\n\t            if (dimSize === 1) {\n\t                keep = cb.call(context, this.get(dimensions[0], i, stack), i);\n\t            } else {\n\t                for (var k = 0; k < dimSize; k++) {\n\t                    value[k] = this.get(dimensions[k], i, stack);\n\t                }\n\t                value[k] = i;\n\t                keep = cb.apply(context, value);\n\t            }\n\t            if (keep) {\n\t                newIndices.push(indices[i]);\n\t            }\n\t        }\n\t        this.indices = newIndices;\n\t        // Reset data extent\n\t        this._extent = {};\n\t        return this;\n\t    };\n\t    /**\n\t     * Data mapping to a plain array\n\t     * @param {string|Array.<string>} [dimensions]\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     * @return {Array}\n\t     */\n\t    listProto.mapArray = function (dimensions, cb, stack, context) {\n\t        if (typeof dimensions === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dimensions;\n\t            dimensions = [];\n\t        }\n\t        var result = [];\n\t        this.each(dimensions, function () {\n\t            result.push(cb && cb.apply(this, arguments));\n\t        }, stack, context);\n\t        return result;\n\t    };\n\t    function cloneListForMapAndSample(original, excludeDimensions) {\n\t        var allDimensions = original.dimensions;\n\t        var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel);\n\t        // FIXME If needs stackedOn, value may already been stacked\n\t        transferProperties(list, original);\n\t        var storage = list._storage = {};\n\t        var originalStorage = original._storage;\n\t        // Init storage\n\t        for (var i = 0; i < allDimensions.length; i++) {\n\t            var dim = allDimensions[i];\n\t            var dimStore = originalStorage[dim];\n\t            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n\t                storage[dim] = new dimStore.constructor(originalStorage[dim].length);\n\t            } else {\n\t                // Direct reference for other dimensions\n\t                storage[dim] = originalStorage[dim];\n\t            }\n\t        }\n\t        return list;\n\t    }\n\t    /**\n\t     * Data mapping to a new List with given dimensions\n\t     * @param {string|Array.<string>} dimensions\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     * @return {Array}\n\t     */\n\t    listProto.map = function (dimensions, cb, stack, context) {\n\t        dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n\t        var list = cloneListForMapAndSample(this, dimensions);\n\t        // Following properties are all immutable.\n\t        // So we can reference to the same value\n\t        var indices = list.indices = this.indices;\n\t        var storage = list._storage;\n\t        var tmpRetValue = [];\n\t        this.each(dimensions, function () {\n\t            var idx = arguments[arguments.length - 1];\n\t            var retValue = cb && cb.apply(this, arguments);\n\t            if (retValue != null) {\n\t                // a number\n\t                if (typeof retValue === 'number') {\n\t                    tmpRetValue[0] = retValue;\n\t                    retValue = tmpRetValue;\n\t                }\n\t                for (var i = 0; i < retValue.length; i++) {\n\t                    var dim = dimensions[i];\n\t                    var dimStore = storage[dim];\n\t                    var rawIdx = indices[idx];\n\t                    if (dimStore) {\n\t                        dimStore[rawIdx] = retValue[i];\n\t                    }\n\t                }\n\t            }\n\t        }, stack, context);\n\t        return list;\n\t    };\n\t    /**\n\t     * Large data down sampling on given dimension\n\t     * @param {string} dimension\n\t     * @param {number} rate\n\t     * @param {Function} sampleValue\n\t     * @param {Function} sampleIndex Sample index for name and id\n\t     */\n\t    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n\t        var list = cloneListForMapAndSample(this, [dimension]);\n\t        var storage = this._storage;\n\t        var targetStorage = list._storage;\n\t        var originalIndices = this.indices;\n\t        var indices = list.indices = [];\n\t        var frameValues = [];\n\t        var frameIndices = [];\n\t        var frameSize = Math.floor(1 / rate);\n\t        var dimStore = targetStorage[dimension];\n\t        var len = this.count();\n\t        // Copy data from original data\n\t        for (var i = 0; i < storage[dimension].length; i++) {\n\t            targetStorage[dimension][i] = storage[dimension][i];\n\t        }\n\t        for (var i = 0; i < len; i += frameSize) {\n\t            // Last frame\n\t            if (frameSize > len - i) {\n\t                frameSize = len - i;\n\t                frameValues.length = frameSize;\n\t            }\n\t            for (var k = 0; k < frameSize; k++) {\n\t                var idx = originalIndices[i + k];\n\t                frameValues[k] = dimStore[idx];\n\t                frameIndices[k] = idx;\n\t            }\n\t            var value = sampleValue(frameValues);\n\t            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n\t            // Only write value on the filtered data\n\t            dimStore[idx] = value;\n\t            indices.push(idx);\n\t        }\n\t        return list;\n\t    };\n\t    /**\n\t     * Get model of one data item.\n\t     *\n\t     * @param {number} idx\n\t     */\n\t    // FIXME Model proxy ?\n\t    listProto.getItemModel = function (idx) {\n\t        var hostModel = this.hostModel;\n\t        idx = this.indices[idx];\n\t        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n\t    };\n\t    /**\n\t     * Create a data differ\n\t     * @param {module:echarts/data/List} otherList\n\t     * @return {module:echarts/data/DataDiffer}\n\t     */\n\t    listProto.diff = function (otherList) {\n\t        var idList = this._idList;\n\t        var otherIdList = otherList && otherList._idList;\n\t        return new DataDiffer(otherList ? otherList.indices : [], this.indices, function (idx) {\n\t            return otherIdList[idx] || idx + '';\n\t        }, function (idx) {\n\t            return idList[idx] || idx + '';\n\t        });\n\t    };\n\t    /**\n\t     * Get visual property.\n\t     * @param {string} key\n\t     */\n\t    listProto.getVisual = function (key) {\n\t        var visual = this._visual;\n\t        return visual && visual[key];\n\t    };\n\t    /**\n\t     * Set visual property\n\t     * @param {string|Object} key\n\t     * @param {*} [value]\n\t     *\n\t     * @example\n\t     *  setVisual('color', color);\n\t     *  setVisual({\n\t     *      'color': color\n\t     *  });\n\t     */\n\t    listProto.setVisual = function (key, val) {\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    this.setVisual(name, key[name]);\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        this._visual = this._visual || {};\n\t        this._visual[key] = val;\n\t    };\n\t    /**\n\t     * Set layout property.\n\t     * @param {string} key\n\t     * @param {*} [val]\n\t     */\n\t    listProto.setLayout = function (key, val) {\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    this.setLayout(name, key[name]);\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        this._layout[key] = val;\n\t    };\n\t    /**\n\t     * Get layout property.\n\t     * @param  {string} key.\n\t     * @return {*}\n\t     */\n\t    listProto.getLayout = function (key) {\n\t        return this._layout[key];\n\t    };\n\t    /**\n\t     * Get layout of single data item\n\t     * @param {number} idx\n\t     */\n\t    listProto.getItemLayout = function (idx) {\n\t        return this._itemLayouts[idx];\n\t    };\n\t    /**\n\t     * Set layout of single data item\n\t     * @param {number} idx\n\t     * @param {Object} layout\n\t     * @param {boolean=} [merge=false]\n\t     */\n\t    listProto.setItemLayout = function (idx, layout, merge) {\n\t        this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n\t    };\n\t    /**\n\t     * Clear all layout of single data item\n\t     */\n\t    listProto.clearItemLayouts = function () {\n\t        this._itemLayouts.length = 0;\n\t    };\n\t    /**\n\t     * Get visual property of single data item\n\t     * @param {number} idx\n\t     * @param {string} key\n\t     * @param {boolean} ignoreParent\n\t     */\n\t    listProto.getItemVisual = function (idx, key, ignoreParent) {\n\t        var itemVisual = this._itemVisuals[idx];\n\t        var val = itemVisual && itemVisual[key];\n\t        if (val == null && !ignoreParent) {\n\t            // Use global visual property\n\t            return this.getVisual(key);\n\t        }\n\t        return val;\n\t    };\n\t    /**\n\t     * Set visual property of single data item\n\t     *\n\t     * @param {number} idx\n\t     * @param {string|Object} key\n\t     * @param {*} [value]\n\t     *\n\t     * @example\n\t     *  setItemVisual(0, 'color', color);\n\t     *  setItemVisual(0, {\n\t     *      'color': color\n\t     *  });\n\t     */\n\t    listProto.setItemVisual = function (idx, key, value) {\n\t        var itemVisual = this._itemVisuals[idx] || {};\n\t        this._itemVisuals[idx] = itemVisual;\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    itemVisual[name] = key[name];\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        itemVisual[key] = value;\n\t    };\n\t    /**\n\t     * Clear itemVisuals and list visual.\n\t     */\n\t    listProto.clearAllVisual = function () {\n\t        this._visual = {};\n\t        this._itemVisuals = [];\n\t    };\n\t    var setItemDataAndSeriesIndex = function (child) {\n\t        child.seriesIndex = this.seriesIndex;\n\t        child.dataIndex = this.dataIndex;\n\t        child.dataType = this.dataType;\n\t    };\n\t    /**\n\t     * Set graphic element relative to data. It can be set as null\n\t     * @param {number} idx\n\t     * @param {module:zrender/Element} [el]\n\t     */\n\t    listProto.setItemGraphicEl = function (idx, el) {\n\t        var hostModel = this.hostModel;\n\t        if (el) {\n\t            // Add data index and series index for indexing the data by element\n\t            // Useful in tooltip\n\t            el.dataIndex = idx;\n\t            el.dataType = this.dataType;\n\t            el.seriesIndex = hostModel && hostModel.seriesIndex;\n\t            if (el.type === 'group') {\n\t                el.traverse(setItemDataAndSeriesIndex, el);\n\t            }\n\t        }\n\t        this._graphicEls[idx] = el;\n\t    };\n\t    /**\n\t     * @param {number} idx\n\t     * @return {module:zrender/Element}\n\t     */\n\t    listProto.getItemGraphicEl = function (idx) {\n\t        return this._graphicEls[idx];\n\t    };\n\t    /**\n\t     * @param {Function} cb\n\t     * @param {*} context\n\t     */\n\t    listProto.eachItemGraphicEl = function (cb, context) {\n\t        zrUtil.each(this._graphicEls, function (el, idx) {\n\t            if (el) {\n\t                cb && cb.call(context, el, idx);\n\t            }\n\t        });\n\t    };\n\t    /**\n\t     * Shallow clone a new list except visual and layout properties, and graph elements.\n\t     * New list only change the indices.\n\t     */\n\t    listProto.cloneShallow = function () {\n\t        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n\t        var list = new List(dimensionInfoList, this.hostModel);\n\t        // FIXME\n\t        list._storage = this._storage;\n\t        transferProperties(list, this);\n\t        // Clone will not change the data extent and indices\n\t        list.indices = this.indices.slice();\n\t        if (this._extent) {\n\t            list._extent = zrUtil.extend({}, this._extent);\n\t        }\n\t        return list;\n\t    };\n\t    /**\n\t     * Wrap some method to add more feature\n\t     * @param {string} methodName\n\t     * @param {Function} injectFunction\n\t     */\n\t    listProto.wrapMethod = function (methodName, injectFunction) {\n\t        var originalMethod = this[methodName];\n\t        if (typeof originalMethod !== 'function') {\n\t            return;\n\t        }\n\t        this.__wrappedMethods = this.__wrappedMethods || [];\n\t        this.__wrappedMethods.push(methodName);\n\t        this[methodName] = function () {\n\t            var res = originalMethod.apply(this, arguments);\n\t            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n\t        };\n\t    };\n\t    // Methods that create a new list based on this list should be listed here.\n\t    // Notice that those method should `RETURN` the new list.\n\t    listProto.TRANSFERABLE_METHODS = [\n\t        'cloneShallow',\n\t        'downSample',\n\t        'map'\n\t    ];\n\t    // Methods that change indices of this list should be listed here.\n\t    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\t    return List;\n\t});\n\tdefine('zrender/core/vector', [], function () {\n\t    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n\t    /**\n\t     * @typedef {Float32Array|Array.<number>} Vector2\n\t     */\n\t    /**\n\t     * 二维向量类\n\t     * @exports zrender/tool/vector\n\t     */\n\t    var vector = {\n\t            create: function (x, y) {\n\t                var out = new ArrayCtor(2);\n\t                if (x == null) {\n\t                    x = 0;\n\t                }\n\t                if (y == null) {\n\t                    y = 0;\n\t                }\n\t                out[0] = x;\n\t                out[1] = y;\n\t                return out;\n\t            },\n\t            copy: function (out, v) {\n\t                out[0] = v[0];\n\t                out[1] = v[1];\n\t                return out;\n\t            },\n\t            clone: function (v) {\n\t                var out = new ArrayCtor(2);\n\t                out[0] = v[0];\n\t                out[1] = v[1];\n\t                return out;\n\t            },\n\t            set: function (out, a, b) {\n\t                out[0] = a;\n\t                out[1] = b;\n\t                return out;\n\t            },\n\t            add: function (out, v1, v2) {\n\t                out[0] = v1[0] + v2[0];\n\t                out[1] = v1[1] + v2[1];\n\t                return out;\n\t            },\n\t            scaleAndAdd: function (out, v1, v2, a) {\n\t                out[0] = v1[0] + v2[0] * a;\n\t                out[1] = v1[1] + v2[1] * a;\n\t                return out;\n\t            },\n\t            sub: function (out, v1, v2) {\n\t                out[0] = v1[0] - v2[0];\n\t                out[1] = v1[1] - v2[1];\n\t                return out;\n\t            },\n\t            len: function (v) {\n\t                return Math.sqrt(this.lenSquare(v));\n\t            },\n\t            lenSquare: function (v) {\n\t                return v[0] * v[0] + v[1] * v[1];\n\t            },\n\t            mul: function (out, v1, v2) {\n\t                out[0] = v1[0] * v2[0];\n\t                out[1] = v1[1] * v2[1];\n\t                return out;\n\t            },\n\t            div: function (out, v1, v2) {\n\t                out[0] = v1[0] / v2[0];\n\t                out[1] = v1[1] / v2[1];\n\t                return out;\n\t            },\n\t            dot: function (v1, v2) {\n\t                return v1[0] * v2[0] + v1[1] * v2[1];\n\t            },\n\t            scale: function (out, v, s) {\n\t                out[0] = v[0] * s;\n\t                out[1] = v[1] * s;\n\t                return out;\n\t            },\n\t            normalize: function (out, v) {\n\t                var d = vector.len(v);\n\t                if (d === 0) {\n\t                    out[0] = 0;\n\t                    out[1] = 0;\n\t                } else {\n\t                    out[0] = v[0] / d;\n\t                    out[1] = v[1] / d;\n\t                }\n\t                return out;\n\t            },\n\t            distance: function (v1, v2) {\n\t                return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n\t            },\n\t            distanceSquare: function (v1, v2) {\n\t                return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n\t            },\n\t            negate: function (out, v) {\n\t                out[0] = -v[0];\n\t                out[1] = -v[1];\n\t                return out;\n\t            },\n\t            lerp: function (out, v1, v2, t) {\n\t                out[0] = v1[0] + t * (v2[0] - v1[0]);\n\t                out[1] = v1[1] + t * (v2[1] - v1[1]);\n\t                return out;\n\t            },\n\t            applyTransform: function (out, v, m) {\n\t                var x = v[0];\n\t                var y = v[1];\n\t                out[0] = m[0] * x + m[2] * y + m[4];\n\t                out[1] = m[1] * x + m[3] * y + m[5];\n\t                return out;\n\t            },\n\t            min: function (out, v1, v2) {\n\t                out[0] = Math.min(v1[0], v2[0]);\n\t                out[1] = Math.min(v1[1], v2[1]);\n\t                return out;\n\t            },\n\t            max: function (out, v1, v2) {\n\t                out[0] = Math.max(v1[0], v2[0]);\n\t                out[1] = Math.max(v1[1], v2[1]);\n\t                return out;\n\t            }\n\t        };\n\t    vector.length = vector.len;\n\t    vector.lengthSquare = vector.lenSquare;\n\t    vector.dist = vector.distance;\n\t    vector.distSquare = vector.distanceSquare;\n\t    return vector;\n\t});\n\tdefine('echarts/scale/Scale', ['require', '../util/clazz'], function (require) {\n\t    var clazzUtil = require('../util/clazz');\n\t    function Scale() {\n\t        /**\n\t         * Extent\n\t         * @type {Array.<number>}\n\t         * @protected\n\t         */\n\t        this._extent = [\n\t            Infinity,\n\t            -Infinity\n\t        ];\n\t        /**\n\t         * Step is calculated in adjustExtent\n\t         * @type {Array.<number>}\n\t         * @protected\n\t         */\n\t        this._interval = 0;\n\t        this.init && this.init.apply(this, arguments);\n\t    }\n\t    var scaleProto = Scale.prototype;\n\t    /**\n\t     * Parse input val to valid inner number.\n\t     * @param {*} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.parse = function (val) {\n\t        // Notice: This would be a trap here, If the implementation\n\t        // of this method depends on extent, and this method is used\n\t        // before extent set (like in dataZoom), it would be wrong.\n\t        // Nevertheless, parse does not depend on extent generally.\n\t        return val;\n\t    };\n\t    scaleProto.contain = function (val) {\n\t        var extent = this._extent;\n\t        return val >= extent[0] && val <= extent[1];\n\t    };\n\t    /**\n\t     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n\t     * @param {number} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.normalize = function (val) {\n\t        var extent = this._extent;\n\t        if (extent[1] === extent[0]) {\n\t            return 0.5;\n\t        }\n\t        return (val - extent[0]) / (extent[1] - extent[0]);\n\t    };\n\t    /**\n\t     * Scale normalized value\n\t     * @param {number} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.scale = function (val) {\n\t        var extent = this._extent;\n\t        return val * (extent[1] - extent[0]) + extent[0];\n\t    };\n\t    /**\n\t     * Set extent from data\n\t     * @param {Array.<number>} other\n\t     */\n\t    scaleProto.unionExtent = function (other) {\n\t        var extent = this._extent;\n\t        other[0] < extent[0] && (extent[0] = other[0]);\n\t        other[1] > extent[1] && (extent[1] = other[1]);    // not setExtent because in log axis it may transformed to power\n\t                                                           // this.setExtent(extent[0], extent[1]);\n\t    };\n\t    /**\n\t     * Get extent\n\t     * @return {Array.<number>}\n\t     */\n\t    scaleProto.getExtent = function () {\n\t        return this._extent.slice();\n\t    };\n\t    /**\n\t     * Set extent\n\t     * @param {number} start\n\t     * @param {number} end\n\t     */\n\t    scaleProto.setExtent = function (start, end) {\n\t        var thisExtent = this._extent;\n\t        if (!isNaN(start)) {\n\t            thisExtent[0] = start;\n\t        }\n\t        if (!isNaN(end)) {\n\t            thisExtent[1] = end;\n\t        }\n\t    };\n\t    /**\n\t     * @return {Array.<string>}\n\t     */\n\t    scaleProto.getTicksLabels = function () {\n\t        var labels = [];\n\t        var ticks = this.getTicks();\n\t        for (var i = 0; i < ticks.length; i++) {\n\t            labels.push(this.getLabel(ticks[i]));\n\t        }\n\t        return labels;\n\t    };\n\t    clazzUtil.enableClassExtend(Scale);\n\t    clazzUtil.enableClassManagement(Scale, { registerWhenExtend: true });\n\t    return Scale;\n\t});\n\tdefine('echarts/coord/axisHelper', ['require', '../scale/Ordinal', '../scale/Interval', '../scale/Time', '../scale/Log', '../scale/Scale', '../util/number', 'zrender/core/util', 'zrender/contain/text'], function (require) {\n\t    var OrdinalScale = require('../scale/Ordinal');\n\t    var IntervalScale = require('../scale/Interval');\n\t    require('../scale/Time');\n\t    require('../scale/Log');\n\t    var Scale = require('../scale/Scale');\n\t    var numberUtil = require('../util/number');\n\t    var zrUtil = require('zrender/core/util');\n\t    var textContain = require('zrender/contain/text');\n\t    var axisHelper = {};\n\t    /**\n\t     * Get axis scale extent before niced.\n\t     */\n\t    axisHelper.getScaleExtent = function (axis, model) {\n\t        var scale = axis.scale;\n\t        var originalExtent = scale.getExtent();\n\t        var span = originalExtent[1] - originalExtent[0];\n\t        if (scale.type === 'ordinal') {\n\t            // If series has no data, scale extent may be wrong\n\t            if (!isFinite(span)) {\n\t                return [\n\t                    0,\n\t                    0\n\t                ];\n\t            } else {\n\t                return originalExtent;\n\t            }\n\t        }\n\t        var min = model.getMin ? model.getMin() : model.get('min');\n\t        var max = model.getMax ? model.getMax() : model.get('max');\n\t        var crossZero = model.getNeedCrossZero ? model.getNeedCrossZero() : !model.get('scale');\n\t        var boundaryGap = model.get('boundaryGap');\n\t        if (!zrUtil.isArray(boundaryGap)) {\n\t            boundaryGap = [\n\t                boundaryGap || 0,\n\t                boundaryGap || 0\n\t            ];\n\t        }\n\t        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n\t        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n\t        var fixMin = true;\n\t        var fixMax = true;\n\t        // Add boundary gap\n\t        if (min == null) {\n\t            min = originalExtent[0] - boundaryGap[0] * span;\n\t            fixMin = false;\n\t        }\n\t        if (max == null) {\n\t            max = originalExtent[1] + boundaryGap[1] * span;\n\t            fixMax = false;\n\t        }\n\t        if (min === 'dataMin') {\n\t            min = originalExtent[0];\n\t        }\n\t        if (max === 'dataMax') {\n\t            max = originalExtent[1];\n\t        }\n\t        // Evaluate if axis needs cross zero\n\t        if (crossZero) {\n\t            // Axis is over zero and min is not set\n\t            if (min > 0 && max > 0 && !fixMin) {\n\t                min = 0;\n\t            }\n\t            // Axis is under zero and max is not set\n\t            if (min < 0 && max < 0 && !fixMax) {\n\t                max = 0;\n\t            }\n\t        }\n\t        return [\n\t            min,\n\t            max\n\t        ];\n\t    };\n\t    axisHelper.niceScaleExtent = function (axis, model) {\n\t        var scale = axis.scale;\n\t        var extent = axisHelper.getScaleExtent(axis, model);\n\t        var fixMin = (model.getMin ? model.getMin() : model.get('min')) != null;\n\t        var fixMax = (model.getMax ? model.getMax() : model.get('max')) != null;\n\t        var splitNumber = model.get('splitNumber');\n\t        if (scale.type === 'log') {\n\t            scale.base = model.get('logBase');\n\t        }\n\t        scale.setExtent(extent[0], extent[1]);\n\t        scale.niceExtent(splitNumber, fixMin, fixMax);\n\t        // Use minInterval to constraint the calculated interval.\n\t        // If calculated interval is less than minInterval. increase the interval quantity until\n\t        // it is larger than minInterval.\n\t        // For example:\n\t        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n\t        //  an integer axis.\n\t        var minInterval = model.get('minInterval');\n\t        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n\t            var interval = scale.getInterval();\n\t            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n\t            // while (interval < minInterval) {\n\t            //     var quantity = numberUtil.quantity(interval);\n\t            //     interval = quantity * 10;\n\t            //     scaleQuantity *= 10;\n\t            // }\n\t            extent = scale.getExtent();\n\t            scale.setExtent(intervalScale * extent[0], extent[1] * intervalScale);\n\t            scale.niceExtent(splitNumber);\n\t        }\n\t        // If some one specified the min, max. And the default calculated interval\n\t        // is not good enough. He can specify the interval. It is often appeared\n\t        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n\t        // to be 60.\n\t        // FIXME\n\t        var interval = model.get('interval');\n\t        if (interval != null) {\n\t            scale.setInterval && scale.setInterval(interval);\n\t        }\n\t    };\n\t    /**\n\t     * @param {module:echarts/model/Model} model\n\t     * @param {string} [axisType] Default retrieve from model.type\n\t     * @return {module:echarts/scale/*}\n\t     */\n\t    axisHelper.createScaleByModel = function (model, axisType) {\n\t        axisType = axisType || model.get('type');\n\t        if (axisType) {\n\t            switch (axisType) {\n\t            // Buildin scale\n\t            case 'category':\n\t                return new OrdinalScale(model.getCategories(), [\n\t                    Infinity,\n\t                    -Infinity\n\t                ]);\n\t            case 'value':\n\t                return new IntervalScale();\n\t            // Extended scale, like time and log\n\t            default:\n\t                return (Scale.getClass(axisType) || IntervalScale).create(model);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t     * Check if the axis corss 0\n\t     */\n\t    axisHelper.ifAxisCrossZero = function (axis) {\n\t        var dataExtent = axis.scale.getExtent();\n\t        var min = dataExtent[0];\n\t        var max = dataExtent[1];\n\t        return !(min > 0 && max > 0 || min < 0 && max < 0);\n\t    };\n\t    /**\n\t     * @param {Array.<number>} tickCoords In axis self coordinate.\n\t     * @param {Array.<string>} labels\n\t     * @param {string} font\n\t     * @param {boolean} isAxisHorizontal\n\t     * @return {number}\n\t     */\n\t    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n\t        // FIXME\n\t        // 不同角的axis和label，不只是horizontal和vertical.\n\t        var textSpaceTakenRect;\n\t        var autoLabelInterval = 0;\n\t        var accumulatedLabelInterval = 0;\n\t        var step = 1;\n\t        if (labels.length > 40) {\n\t            // Simple optimization for large amount of labels\n\t            step = Math.floor(labels.length / 40);\n\t        }\n\t        for (var i = 0; i < tickCoords.length; i += step) {\n\t            var tickCoord = tickCoords[i];\n\t            var rect = textContain.getBoundingRect(labels[i], font, 'center', 'top');\n\t            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n\t            // FIXME Magic number 1.5\n\t            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n\t            if (!textSpaceTakenRect) {\n\t                textSpaceTakenRect = rect.clone();\n\t            }    // There is no space for current label;\n\t            else if (textSpaceTakenRect.intersect(rect)) {\n\t                accumulatedLabelInterval++;\n\t                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n\t            } else {\n\t                textSpaceTakenRect.union(rect);\n\t                // Reset\n\t                accumulatedLabelInterval = 0;\n\t            }\n\t        }\n\t        if (autoLabelInterval === 0 && step > 1) {\n\t            return step;\n\t        }\n\t        return (autoLabelInterval + 1) * step - 1;\n\t    };\n\t    /**\n\t     * @param {Object} axis\n\t     * @param {Function} labelFormatter\n\t     * @return {Array.<string>}\n\t     */\n\t    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n\t        var scale = axis.scale;\n\t        var labels = scale.getTicksLabels();\n\t        var ticks = scale.getTicks();\n\t        if (typeof labelFormatter === 'string') {\n\t            labelFormatter = function (tpl) {\n\t                return function (val) {\n\t                    return tpl.replace('{value}', val);\n\t                };\n\t            }(labelFormatter);\n\t            return zrUtil.map(labels, labelFormatter);\n\t        } else if (typeof labelFormatter === 'function') {\n\t            return zrUtil.map(ticks, function (tick, idx) {\n\t                return labelFormatter(axis.type === 'category' ? scale.getLabel(tick) : tick, idx);\n\t            }, this);\n\t        } else {\n\t            return labels;\n\t        }\n\t    };\n\t    return axisHelper;\n\t});\n\tdefine('echarts/coord/cartesian/Cartesian2D', ['require', 'zrender/core/util', './Cartesian'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var Cartesian = require('./Cartesian');\n\t    function Cartesian2D(name) {\n\t        Cartesian.call(this, name);\n\t    }\n\t    Cartesian2D.prototype = {\n\t        constructor: Cartesian2D,\n\t        type: 'cartesian2d',\n\t        dimensions: [\n\t            'x',\n\t            'y'\n\t        ],\n\t        getBaseAxis: function () {\n\t            return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n\t        },\n\t        containPoint: function (point) {\n\t            var axisX = this.getAxis('x');\n\t            var axisY = this.getAxis('y');\n\t            return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n\t        },\n\t        containData: function (data) {\n\t            return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n\t        },\n\t        dataToPoints: function (data, stack) {\n\t            return data.mapArray([\n\t                'x',\n\t                'y'\n\t            ], function (x, y) {\n\t                return this.dataToPoint([\n\t                    x,\n\t                    y\n\t                ]);\n\t            }, stack, this);\n\t        },\n\t        dataToPoint: function (data, clamp) {\n\t            var xAxis = this.getAxis('x');\n\t            var yAxis = this.getAxis('y');\n\t            return [\n\t                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n\t                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n\t            ];\n\t        },\n\t        pointToData: function (point, clamp) {\n\t            var xAxis = this.getAxis('x');\n\t            var yAxis = this.getAxis('y');\n\t            return [\n\t                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n\t                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n\t            ];\n\t        },\n\t        getOtherAxis: function (axis) {\n\t            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n\t        }\n\t    };\n\t    zrUtil.inherits(Cartesian2D, Cartesian);\n\t    return Cartesian2D;\n\t});\n\tdefine('echarts/coord/cartesian/Axis2D', ['require', 'zrender/core/util', '../Axis', './axisLabelInterval'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var Axis = require('../Axis');\n\t    var axisLabelInterval = require('./axisLabelInterval');\n\t    /**\n\t     * Extend axis 2d\n\t     * @constructor module:echarts/coord/cartesian/Axis2D\n\t     * @extends {module:echarts/coord/cartesian/Axis}\n\t     * @param {string} dim\n\t     * @param {*} scale\n\t     * @param {Array.<number>} coordExtent\n\t     * @param {string} axisType\n\t     * @param {string} position\n\t     */\n\t    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n\t        Axis.call(this, dim, scale, coordExtent);\n\t        /**\n\t         * Axis type\n\t         *  - 'category'\n\t         *  - 'value'\n\t         *  - 'time'\n\t         *  - 'log'\n\t         * @type {string}\n\t         */\n\t        this.type = axisType || 'value';\n\t        /**\n\t         * Axis position\n\t         *  - 'top'\n\t         *  - 'bottom'\n\t         *  - 'left'\n\t         *  - 'right'\n\t         */\n\t        this.position = position || 'bottom';\n\t    };\n\t    Axis2D.prototype = {\n\t        constructor: Axis2D,\n\t        index: 0,\n\t        onZero: false,\n\t        model: null,\n\t        isHorizontal: function () {\n\t            var position = this.position;\n\t            return position === 'top' || position === 'bottom';\n\t        },\n\t        getGlobalExtent: function () {\n\t            var ret = this.getExtent();\n\t            ret[0] = this.toGlobalCoord(ret[0]);\n\t            ret[1] = this.toGlobalCoord(ret[1]);\n\t            return ret;\n\t        },\n\t        getLabelInterval: function () {\n\t            var labelInterval = this._labelInterval;\n\t            if (!labelInterval) {\n\t                labelInterval = this._labelInterval = axisLabelInterval(this);\n\t            }\n\t            return labelInterval;\n\t        },\n\t        isLabelIgnored: function (idx) {\n\t            if (this.type === 'category') {\n\t                var labelInterval = this.getLabelInterval();\n\t                return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);\n\t            }\n\t        },\n\t        toLocalCoord: null,\n\t        toGlobalCoord: null\n\t    };\n\t    zrUtil.inherits(Axis2D, Axis);\n\t    return Axis2D;\n\t});\n\tdefine('echarts/coord/cartesian/GridModel', ['require', './AxisModel', '../../model/Component'], function (require) {\n\t    'use strict';\n\t    require('./AxisModel');\n\t    var ComponentModel = require('../../model/Component');\n\t    return ComponentModel.extend({\n\t        type: 'grid',\n\t        dependencies: [\n\t            'xAxis',\n\t            'yAxis'\n\t        ],\n\t        layoutMode: 'box',\n\t        coordinateSystem: null,\n\t        defaultOption: {\n\t            show: false,\n\t            zlevel: 0,\n\t            z: 0,\n\t            left: '10%',\n\t            top: 60,\n\t            right: '10%',\n\t            bottom: 60,\n\t            containLabel: false,\n\t            backgroundColor: 'rgba(0,0,0,0)',\n\t            borderWidth: 1,\n\t            borderColor: '#ccc'\n\t        }\n\t    });\n\t});\n\tdefine('zrender/tool/path', ['require', '../graphic/Path', '../core/PathProxy', './transformPath', '../core/matrix'], function (require) {\n\t    var Path = require('../graphic/Path');\n\t    var PathProxy = require('../core/PathProxy');\n\t    var transformPath = require('./transformPath');\n\t    var matrix = require('../core/matrix');\n\t    // command chars\n\t    var cc = [\n\t            'm',\n\t            'M',\n\t            'l',\n\t            'L',\n\t            'v',\n\t            'V',\n\t            'h',\n\t            'H',\n\t            'z',\n\t            'Z',\n\t            'c',\n\t            'C',\n\t            'q',\n\t            'Q',\n\t            't',\n\t            'T',\n\t            's',\n\t            'S',\n\t            'a',\n\t            'A'\n\t        ];\n\t    var mathSqrt = Math.sqrt;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t    var PI = Math.PI;\n\t    var vMag = function (v) {\n\t        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n\t    };\n\t    var vRatio = function (u, v) {\n\t        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n\t    };\n\t    var vAngle = function (u, v) {\n\t        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n\t    };\n\t    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n\t        var psi = psiDeg * (PI / 180);\n\t        var xp = mathCos(psi) * (x1 - x2) / 2 + mathSin(psi) * (y1 - y2) / 2;\n\t        var yp = -1 * mathSin(psi) * (x1 - x2) / 2 + mathCos(psi) * (y1 - y2) / 2;\n\t        var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n\t        if (lambda > 1) {\n\t            rx *= mathSqrt(lambda);\n\t            ry *= mathSqrt(lambda);\n\t        }\n\t        var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n\t        var cxp = f * rx * yp / ry;\n\t        var cyp = f * -ry * xp / rx;\n\t        var cx = (x1 + x2) / 2 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n\t        var cy = (y1 + y2) / 2 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n\t        var theta = vAngle([\n\t                1,\n\t                0\n\t            ], [\n\t                (xp - cxp) / rx,\n\t                (yp - cyp) / ry\n\t            ]);\n\t        var u = [\n\t                (xp - cxp) / rx,\n\t                (yp - cyp) / ry\n\t            ];\n\t        var v = [\n\t                (-1 * xp - cxp) / rx,\n\t                (-1 * yp - cyp) / ry\n\t            ];\n\t        var dTheta = vAngle(u, v);\n\t        if (vRatio(u, v) <= -1) {\n\t            dTheta = PI;\n\t        }\n\t        if (vRatio(u, v) >= 1) {\n\t            dTheta = 0;\n\t        }\n\t        if (fs === 0 && dTheta > 0) {\n\t            dTheta = dTheta - 2 * PI;\n\t        }\n\t        if (fs === 1 && dTheta < 0) {\n\t            dTheta = dTheta + 2 * PI;\n\t        }\n\t        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n\t    }\n\t    function createPathProxyFromString(data) {\n\t        if (!data) {\n\t            return [];\n\t        }\n\t        // command string\n\t        var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');\n\t        var n;\n\t        // create pipes so that we can split the data\n\t        for (n = 0; n < cc.length; n++) {\n\t            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n\t        }\n\t        // create array\n\t        var arr = cs.split('|');\n\t        // init context point\n\t        var cpx = 0;\n\t        var cpy = 0;\n\t        var path = new PathProxy();\n\t        var CMD = PathProxy.CMD;\n\t        var prevCmd;\n\t        for (n = 1; n < arr.length; n++) {\n\t            var str = arr[n];\n\t            var c = str.charAt(0);\n\t            var off = 0;\n\t            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n\t            var cmd;\n\t            if (p.length > 0 && p[0] === '') {\n\t                p.shift();\n\t            }\n\t            for (var i = 0; i < p.length; i++) {\n\t                p[i] = parseFloat(p[i]);\n\t            }\n\t            while (off < p.length && !isNaN(p[off])) {\n\t                if (isNaN(p[0])) {\n\t                    break;\n\t                }\n\t                var ctlPtx;\n\t                var ctlPty;\n\t                var rx;\n\t                var ry;\n\t                var psi;\n\t                var fa;\n\t                var fs;\n\t                var x1 = cpx;\n\t                var y1 = cpy;\n\t                // convert l, H, h, V, and v to L\n\t                switch (c) {\n\t                case 'l':\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'L':\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'm':\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.M;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    c = 'l';\n\t                    break;\n\t                case 'M':\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.M;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    c = 'L';\n\t                    break;\n\t                case 'h':\n\t                    cpx += p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'H':\n\t                    cpx = p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'v':\n\t                    cpy += p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'V':\n\t                    cpy = p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'C':\n\t                    cmd = CMD.C;\n\t                    path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n\t                    cpx = p[off - 2];\n\t                    cpy = p[off - 1];\n\t                    break;\n\t                case 'c':\n\t                    cmd = CMD.C;\n\t                    path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n\t                    cpx += p[off - 2];\n\t                    cpy += p[off - 1];\n\t                    break;\n\t                case 'S':\n\t                    ctlPtx = cpx;\n\t                    ctlPty = cpy;\n\t                    var len = path.len();\n\t                    var pathData = path.data;\n\t                    if (prevCmd === CMD.C) {\n\t                        ctlPtx += cpx - pathData[len - 4];\n\t                        ctlPty += cpy - pathData[len - 3];\n\t                    }\n\t                    cmd = CMD.C;\n\t                    x1 = p[off++];\n\t                    y1 = p[off++];\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                    break;\n\t                case 's':\n\t                    ctlPtx = cpx;\n\t                    ctlPty = cpy;\n\t                    var len = path.len();\n\t                    var pathData = path.data;\n\t                    if (prevCmd === CMD.C) {\n\t                        ctlPtx += cpx - pathData[len - 4];\n\t                        ctlPty += cpy - pathData[len - 3];\n\t                    }\n\t                    cmd = CMD.C;\n\t                    x1 = cpx + p[off++];\n\t                    y1 = cpy + p[off++];\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                    break;\n\t                case 'Q':\n\t                    x1 = p[off++];\n\t                    y1 = p[off++];\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.Q;\n\t                    path.addData(cmd, x1, y1, cpx, cpy);\n\t                    break;\n\t                case 'q':\n\t                    x1 = p[off++] + cpx;\n\t                    y1 = p[off++] + cpy;\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.Q;\n\t                    path.addData(cmd, x1, y1, cpx, cpy);\n\t                    break;\n\t                case 'T':\n\t                    ctlPtx = cpx;\n\t                    ctlPty = cpy;\n\t                    var len = path.len();\n\t                    var pathData = path.data;\n\t                    if (prevCmd === CMD.Q) {\n\t                        ctlPtx += cpx - pathData[len - 4];\n\t                        ctlPty += cpy - pathData[len - 3];\n\t                    }\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.Q;\n\t                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                    break;\n\t                case 't':\n\t                    ctlPtx = cpx;\n\t                    ctlPty = cpy;\n\t                    var len = path.len();\n\t                    var pathData = path.data;\n\t                    if (prevCmd === CMD.Q) {\n\t                        ctlPtx += cpx - pathData[len - 4];\n\t                        ctlPty += cpy - pathData[len - 3];\n\t                    }\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.Q;\n\t                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                    break;\n\t                case 'A':\n\t                    rx = p[off++];\n\t                    ry = p[off++];\n\t                    psi = p[off++];\n\t                    fa = p[off++];\n\t                    fs = p[off++];\n\t                    x1 = cpx, y1 = cpy;\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.A;\n\t                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n\t                    break;\n\t                case 'a':\n\t                    rx = p[off++];\n\t                    ry = p[off++];\n\t                    psi = p[off++];\n\t                    fa = p[off++];\n\t                    fs = p[off++];\n\t                    x1 = cpx, y1 = cpy;\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.A;\n\t                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n\t                    break;\n\t                }\n\t            }\n\t            if (c === 'z' || c === 'Z') {\n\t                cmd = CMD.Z;\n\t                path.addData(cmd);\n\t            }\n\t            prevCmd = cmd;\n\t        }\n\t        path.toStatic();\n\t        return path;\n\t    }\n\t    // TODO Optimize double memory cost problem\n\t    function createPathOptions(str, opts) {\n\t        var pathProxy = createPathProxyFromString(str);\n\t        var transform;\n\t        opts = opts || {};\n\t        opts.buildPath = function (path) {\n\t            path.setData(pathProxy.data);\n\t            transform && transformPath(path, transform);\n\t            // Svg and vml renderer don't have context\n\t            var ctx = path.getContext();\n\t            if (ctx) {\n\t                path.rebuildPath(ctx);\n\t            }\n\t        };\n\t        opts.applyTransform = function (m) {\n\t            if (!transform) {\n\t                transform = matrix.create();\n\t            }\n\t            matrix.mul(transform, m, transform);\n\t            this.dirty(true);\n\t        };\n\t        return opts;\n\t    }\n\t    return {\n\t        createFromString: function (str, opts) {\n\t            return new Path(createPathOptions(str, opts));\n\t        },\n\t        extendFromString: function (str, opts) {\n\t            return Path.extend(createPathOptions(str, opts));\n\t        },\n\t        mergePath: function (pathEls, opts) {\n\t            var pathList = [];\n\t            var len = pathEls.length;\n\t            for (var i = 0; i < len; i++) {\n\t                var pathEl = pathEls[i];\n\t                if (pathEl.__dirty) {\n\t                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n\t                }\n\t                pathList.push(pathEl.path);\n\t            }\n\t            var pathBundle = new Path(opts);\n\t            pathBundle.buildPath = function (path) {\n\t                path.appendPath(pathList);\n\t                // Svg and vml renderer don't have context\n\t                var ctx = path.getContext();\n\t                if (ctx) {\n\t                    path.rebuildPath(ctx);\n\t                }\n\t            };\n\t            return pathBundle;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/graphic/Path', ['require', './Displayable', '../core/util', '../core/PathProxy', '../contain/path', './Pattern'], function (require) {\n\t    var Displayable = require('./Displayable');\n\t    var zrUtil = require('../core/util');\n\t    var PathProxy = require('../core/PathProxy');\n\t    var pathContain = require('../contain/path');\n\t    var Pattern = require('./Pattern');\n\t    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\t    var abs = Math.abs;\n\t    /**\n\t     * @alias module:zrender/graphic/Path\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function Path(opts) {\n\t        Displayable.call(this, opts);\n\t        /**\n\t         * @type {module:zrender/core/PathProxy}\n\t         * @readOnly\n\t         */\n\t        this.path = new PathProxy();\n\t    }\n\t    Path.prototype = {\n\t        constructor: Path,\n\t        type: 'path',\n\t        __dirtyPath: true,\n\t        strokeContainThreshold: 5,\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var path = this.path;\n\t            var hasStroke = style.hasStroke();\n\t            var hasFill = style.hasFill();\n\t            var fill = style.fill;\n\t            var stroke = style.stroke;\n\t            var hasFillGradient = hasFill && !!fill.colorStops;\n\t            var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n\t            var hasFillPattern = hasFill && !!fill.image;\n\t            var hasStrokePattern = hasStroke && !!stroke.image;\n\t            style.bind(ctx, this, prevEl);\n\t            this.setTransform(ctx);\n\t            if (this.__dirty) {\n\t                var rect = this.getBoundingRect();\n\t                // Update gradient because bounding rect may changed\n\t                if (hasFillGradient) {\n\t                    this._fillGradient = style.getGradient(ctx, fill, rect);\n\t                }\n\t                if (hasStrokeGradient) {\n\t                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n\t                }\n\t            }\n\t            // Use the gradient or pattern\n\t            if (hasFillGradient) {\n\t                // PENDING If may have affect the state\n\t                ctx.fillStyle = this._fillGradient;\n\t            } else if (hasFillPattern) {\n\t                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n\t            }\n\t            if (hasStrokeGradient) {\n\t                ctx.strokeStyle = this._strokeGradient;\n\t            } else if (hasStrokePattern) {\n\t                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n\t            }\n\t            var lineDash = style.lineDash;\n\t            var lineDashOffset = style.lineDashOffset;\n\t            var ctxLineDash = !!ctx.setLineDash;\n\t            // Update path sx, sy\n\t            var scale = this.getGlobalScale();\n\t            path.setScale(scale[0], scale[1]);\n\t            // Proxy context\n\t            // Rebuild path in following 2 cases\n\t            // 1. Path is dirty\n\t            // 2. Path needs javascript implemented lineDash stroking.\n\t            //    In this case, lineDash information will not be saved in PathProxy\n\t            if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n\t                path = this.path.beginPath(ctx);\n\t                // Setting line dash before build path\n\t                if (lineDash && !ctxLineDash) {\n\t                    path.setLineDash(lineDash);\n\t                    path.setLineDashOffset(lineDashOffset);\n\t                }\n\t                this.buildPath(path, this.shape, false);\n\t                // Clear path dirty flag\n\t                this.__dirtyPath = false;\n\t            } else {\n\t                // Replay path building\n\t                ctx.beginPath();\n\t                this.path.rebuildPath(ctx);\n\t            }\n\t            hasFill && path.fill(ctx);\n\t            if (lineDash && ctxLineDash) {\n\t                ctx.setLineDash(lineDash);\n\t                ctx.lineDashOffset = lineDashOffset;\n\t            }\n\t            hasStroke && path.stroke(ctx);\n\t            if (lineDash && ctxLineDash) {\n\t                // PENDING\n\t                // Remove lineDash\n\t                ctx.setLineDash([]);\n\t            }\n\t            this.restoreTransform(ctx);\n\t            // Draw rect text\n\t            if (style.text || style.text === 0) {\n\t                // var rect = this.getBoundingRect();\n\t                this.drawRectText(ctx, this.getBoundingRect());\n\t            }\n\t        },\n\t        buildPath: function (ctx, shapeCfg, inBundle) {\n\t        },\n\t        getBoundingRect: function () {\n\t            var rect = this._rect;\n\t            var style = this.style;\n\t            var needsUpdateRect = !rect;\n\t            if (needsUpdateRect) {\n\t                var path = this.path;\n\t                if (this.__dirtyPath) {\n\t                    path.beginPath();\n\t                    this.buildPath(path, this.shape, false);\n\t                }\n\t                rect = path.getBoundingRect();\n\t            }\n\t            this._rect = rect;\n\t            if (style.hasStroke()) {\n\t                // Needs update rect with stroke lineWidth when\n\t                // 1. Element changes scale or lineWidth\n\t                // 2. Shape is changed\n\t                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\t                if (this.__dirty || needsUpdateRect) {\n\t                    rectWithStroke.copy(rect);\n\t                    // FIXME Must after updateTransform\n\t                    var w = style.lineWidth;\n\t                    // PENDING, Min line width is needed when line is horizontal or vertical\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t                    // Only add extra hover lineWidth when there are no fill\n\t                    if (!style.hasFill()) {\n\t                        w = Math.max(w, this.strokeContainThreshold || 4);\n\t                    }\n\t                    // Consider line width\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        rectWithStroke.width += w / lineScale;\n\t                        rectWithStroke.height += w / lineScale;\n\t                        rectWithStroke.x -= w / lineScale / 2;\n\t                        rectWithStroke.y -= w / lineScale / 2;\n\t                    }\n\t                }\n\t                // Return rect with stroke\n\t                return rectWithStroke;\n\t            }\n\t            return rect;\n\t        },\n\t        contain: function (x, y) {\n\t            var localPos = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            var style = this.style;\n\t            x = localPos[0];\n\t            y = localPos[1];\n\t            if (rect.contain(x, y)) {\n\t                var pathData = this.path.data;\n\t                if (style.hasStroke()) {\n\t                    var lineWidth = style.lineWidth;\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        // Only add extra hover lineWidth when there are no fill\n\t                        if (!style.hasFill()) {\n\t                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n\t                        }\n\t                        if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t                if (style.hasFill()) {\n\t                    return pathContain.contain(pathData, x, y);\n\t                }\n\t            }\n\t            return false;\n\t        },\n\t        dirty: function (dirtyPath) {\n\t            if (dirtyPath == null) {\n\t                dirtyPath = true;\n\t            }\n\t            // Only mark dirty, not mark clean\n\t            if (dirtyPath) {\n\t                this.__dirtyPath = dirtyPath;\n\t                this._rect = null;\n\t            }\n\t            this.__dirty = true;\n\t            this.__zr && this.__zr.refresh();\n\t            // Used as a clipping path\n\t            if (this.__clipTarget) {\n\t                this.__clipTarget.dirty();\n\t            }\n\t        },\n\t        animateShape: function (loop) {\n\t            return this.animate('shape', loop);\n\t        },\n\t        attrKV: function (key, value) {\n\t            // FIXME\n\t            if (key === 'shape') {\n\t                this.setShape(value);\n\t                this.__dirtyPath = true;\n\t                this._rect = null;\n\t            } else {\n\t                Displayable.prototype.attrKV.call(this, key, value);\n\t            }\n\t        },\n\t        setShape: function (key, value) {\n\t            var shape = this.shape;\n\t            // Path from string may not have shape\n\t            if (shape) {\n\t                if (zrUtil.isObject(key)) {\n\t                    for (var name in key) {\n\t                        shape[name] = key[name];\n\t                    }\n\t                } else {\n\t                    shape[key] = value;\n\t                }\n\t                this.dirty(true);\n\t            }\n\t            return this;\n\t        },\n\t        getLineScale: function () {\n\t            var m = this.transform;\n\t            // Get the line scale.\n\t            // Determinant of `m` means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n\t        }\n\t    };\n\t    /**\n\t     * 扩展一个 Path element, 比如星形，圆等。\n\t     * Extend a path element\n\t     * @param {Object} props\n\t     * @param {string} props.type Path type\n\t     * @param {Function} props.init Initialize\n\t     * @param {Function} props.buildPath Overwrite buildPath method\n\t     * @param {Object} [props.style] Extended default style config\n\t     * @param {Object} [props.shape] Extended default shape config\n\t     */\n\t    Path.extend = function (defaults) {\n\t        var Sub = function (opts) {\n\t            Path.call(this, opts);\n\t            if (defaults.style) {\n\t                // Extend default style\n\t                this.style.extendFrom(defaults.style, false);\n\t            }\n\t            // Extend default shape\n\t            var defaultShape = defaults.shape;\n\t            if (defaultShape) {\n\t                this.shape = this.shape || {};\n\t                var thisShape = this.shape;\n\t                for (var name in defaultShape) {\n\t                    if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n\t                        thisShape[name] = defaultShape[name];\n\t                    }\n\t                }\n\t            }\n\t            defaults.init && defaults.init.call(this, opts);\n\t        };\n\t        zrUtil.inherits(Sub, Path);\n\t        // FIXME 不能 extend position, rotation 等引用对象\n\t        for (var name in defaults) {\n\t            // Extending prototype values and methods\n\t            if (name !== 'style' && name !== 'shape') {\n\t                Sub.prototype[name] = defaults[name];\n\t            }\n\t        }\n\t        return Sub;\n\t    };\n\t    zrUtil.inherits(Path, Displayable);\n\t    return Path;\n\t});\n\tdefine('zrender/graphic/Gradient', ['require'], function (require) {\n\t    /**\n\t     * @param {Array.<Object>} colorStops\n\t     */\n\t    var Gradient = function (colorStops) {\n\t        this.colorStops = colorStops || [];\n\t    };\n\t    Gradient.prototype = {\n\t        constructor: Gradient,\n\t        addColorStop: function (offset, color) {\n\t            this.colorStops.push({\n\t                offset: offset,\n\t                color: color\n\t            });\n\t        }\n\t    };\n\t    return Gradient;\n\t});\n\tdefine('zrender/container/Group', ['require', '../core/util', '../Element', '../core/BoundingRect'], function (require) {\n\t    var zrUtil = require('../core/util');\n\t    var Element = require('../Element');\n\t    var BoundingRect = require('../core/BoundingRect');\n\t    /**\n\t     * @alias module:zrender/graphic/Group\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @extends module:zrender/mixin/Eventful\n\t     */\n\t    var Group = function (opts) {\n\t        opts = opts || {};\n\t        Element.call(this, opts);\n\t        for (var key in opts) {\n\t            this[key] = opts[key];\n\t        }\n\t        this._children = [];\n\t        this.__storage = null;\n\t        this.__dirty = true;\n\t    };\n\t    Group.prototype = {\n\t        constructor: Group,\n\t        isGroup: true,\n\t        type: 'group',\n\t        silent: false,\n\t        children: function () {\n\t            return this._children.slice();\n\t        },\n\t        childAt: function (idx) {\n\t            return this._children[idx];\n\t        },\n\t        childOfName: function (name) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                if (children[i].name === name) {\n\t                    return children[i];\n\t                }\n\t            }\n\t        },\n\t        childCount: function () {\n\t            return this._children.length;\n\t        },\n\t        add: function (child) {\n\t            if (child && child !== this && child.parent !== this) {\n\t                this._children.push(child);\n\t                this._doAdd(child);\n\t            }\n\t            return this;\n\t        },\n\t        addBefore: function (child, nextSibling) {\n\t            if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n\t                var children = this._children;\n\t                var idx = children.indexOf(nextSibling);\n\t                if (idx >= 0) {\n\t                    children.splice(idx, 0, child);\n\t                    this._doAdd(child);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t        _doAdd: function (child) {\n\t            if (child.parent) {\n\t                child.parent.remove(child);\n\t            }\n\t            child.parent = this;\n\t            var storage = this.__storage;\n\t            var zr = this.__zr;\n\t            if (storage && storage !== child.__storage) {\n\t                storage.addToMap(child);\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t            zr && zr.refresh();\n\t        },\n\t        remove: function (child) {\n\t            var zr = this.__zr;\n\t            var storage = this.__storage;\n\t            var children = this._children;\n\t            var idx = zrUtil.indexOf(children, child);\n\t            if (idx < 0) {\n\t                return this;\n\t            }\n\t            children.splice(idx, 1);\n\t            child.parent = null;\n\t            if (storage) {\n\t                storage.delFromMap(child.id);\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t            zr && zr.refresh();\n\t            return this;\n\t        },\n\t        removeAll: function () {\n\t            var children = this._children;\n\t            var storage = this.__storage;\n\t            var child;\n\t            var i;\n\t            for (i = 0; i < children.length; i++) {\n\t                child = children[i];\n\t                if (storage) {\n\t                    storage.delFromMap(child.id);\n\t                    if (child instanceof Group) {\n\t                        child.delChildrenFromStorage(storage);\n\t                    }\n\t                }\n\t                child.parent = null;\n\t            }\n\t            children.length = 0;\n\t            return this;\n\t        },\n\t        eachChild: function (cb, context) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                cb.call(context, child, i);\n\t            }\n\t            return this;\n\t        },\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                cb.call(context, child);\n\t                if (child.type === 'group') {\n\t                    child.traverse(cb, context);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t        addChildrenToStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.addToMap(child);\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t        },\n\t        delChildrenFromStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.delFromMap(child.id);\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t        },\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t            this.__zr && this.__zr.refresh();\n\t            return this;\n\t        },\n\t        getBoundingRect: function (includeChildren) {\n\t            // TODO Caching\n\t            // TODO Transform\n\t            var rect = null;\n\t            var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t            var children = includeChildren || this._children;\n\t            var tmpMat = [];\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                if (child.ignore || child.invisible) {\n\t                    continue;\n\t                }\n\t                var childRect = child.getBoundingRect();\n\t                var transform = child.getLocalTransform(tmpMat);\n\t                if (transform) {\n\t                    tmpRect.copy(childRect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = rect || tmpRect.clone();\n\t                    rect.union(tmpRect);\n\t                } else {\n\t                    rect = rect || childRect.clone();\n\t                    rect.union(childRect);\n\t                }\n\t            }\n\t            return rect || tmpRect;\n\t        }\n\t    };\n\t    zrUtil.inherits(Group, Element);\n\t    return Group;\n\t});\n\tdefine('zrender/graphic/Text', ['require', './Displayable', '../core/util', '../contain/text'], function (require) {\n\t    var Displayable = require('./Displayable');\n\t    var zrUtil = require('../core/util');\n\t    var textContain = require('../contain/text');\n\t    /**\n\t     * @alias zrender/graphic/Text\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    var Text = function (opts) {\n\t        Displayable.call(this, opts);\n\t    };\n\t    Text.prototype = {\n\t        constructor: Text,\n\t        type: 'text',\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var x = style.x || 0;\n\t            var y = style.y || 0;\n\t            // Convert to string\n\t            var text = style.text;\n\t            // Convert to string\n\t            text != null && (text += '');\n\t            // Always bind style\n\t            style.bind(ctx, this, prevEl);\n\t            if (text) {\n\t                this.setTransform(ctx);\n\t                var textBaseline;\n\t                var textAlign = style.textAlign;\n\t                var font = style.textFont || style.font;\n\t                if (style.textVerticalAlign) {\n\t                    var rect = textContain.getBoundingRect(text, font, style.textAlign, 'top');\n\t                    // Ignore textBaseline\n\t                    textBaseline = 'middle';\n\t                    switch (style.textVerticalAlign) {\n\t                    case 'middle':\n\t                        y -= rect.height / 2 - rect.lineHeight / 2;\n\t                        break;\n\t                    case 'bottom':\n\t                        y -= rect.height - rect.lineHeight / 2;\n\t                        break;\n\t                    default:\n\t                        y += rect.lineHeight / 2;\n\t                    }\n\t                } else {\n\t                    textBaseline = style.textBaseline;\n\t                }\n\t                // TODO Invalid font\n\t                ctx.font = font || '12px sans-serif';\n\t                ctx.textAlign = textAlign || 'left';\n\t                // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t                if (ctx.textAlign !== textAlign) {\n\t                    ctx.textAlign = 'left';\n\t                }\n\t                ctx.textBaseline = textBaseline || 'alphabetic';\n\t                // Use canvas default alphabetic baseline\n\t                if (ctx.textBaseline !== textBaseline) {\n\t                    ctx.textBaseline = 'alphabetic';\n\t                }\n\t                var lineHeight = textContain.measureText('国', ctx.font).width;\n\t                var textLines = text.split('\\n');\n\t                for (var i = 0; i < textLines.length; i++) {\n\t                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n\t                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n\t                    y += lineHeight;\n\t                }\n\t                this.restoreTransform(ctx);\n\t            }\n\t        },\n\t        getBoundingRect: function () {\n\t            if (!this._rect) {\n\t                var style = this.style;\n\t                var textVerticalAlign = style.textVerticalAlign;\n\t                var rect = textContain.getBoundingRect(style.text + '', style.textFont || style.font, style.textAlign, textVerticalAlign ? 'top' : style.textBaseline);\n\t                switch (textVerticalAlign) {\n\t                case 'middle':\n\t                    rect.y -= rect.height / 2;\n\t                    break;\n\t                case 'bottom':\n\t                    rect.y -= rect.height;\n\t                    break;\n\t                }\n\t                rect.x += style.x || 0;\n\t                rect.y += style.y || 0;\n\t                this._rect = rect;\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t    zrUtil.inherits(Text, Displayable);\n\t    return Text;\n\t});\n\tdefine('zrender/graphic/Image', ['require', './Displayable', '../core/BoundingRect', '../core/util', '../core/LRU'], function (require) {\n\t    var Displayable = require('./Displayable');\n\t    var BoundingRect = require('../core/BoundingRect');\n\t    var zrUtil = require('../core/util');\n\t    var LRU = require('../core/LRU');\n\t    var globalImageCache = new LRU(50);\n\t    /**\n\t     * @alias zrender/graphic/Image\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function ZImage(opts) {\n\t        Displayable.call(this, opts);\n\t    }\n\t    ZImage.prototype = {\n\t        constructor: ZImage,\n\t        type: 'image',\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var src = style.image;\n\t            var image;\n\t            // Must bind each time\n\t            style.bind(ctx, this, prevEl);\n\t            // style.image is a url string\n\t            if (typeof src === 'string') {\n\t                image = this._image;\n\t            }    // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n\t            else {\n\t                image = src;\n\t            }\n\t            // FIXME Case create many images with src\n\t            if (!image && src) {\n\t                // Try get from global image cache\n\t                var cachedImgObj = globalImageCache.get(src);\n\t                if (!cachedImgObj) {\n\t                    // Create a new image\n\t                    image = new Image();\n\t                    image.onload = function () {\n\t                        image.onload = null;\n\t                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n\t                            cachedImgObj.pending[i].dirty();\n\t                        }\n\t                    };\n\t                    cachedImgObj = {\n\t                        image: image,\n\t                        pending: [this]\n\t                    };\n\t                    image.src = src;\n\t                    globalImageCache.put(src, cachedImgObj);\n\t                    this._image = image;\n\t                    return;\n\t                } else {\n\t                    image = cachedImgObj.image;\n\t                    this._image = image;\n\t                    // Image is not complete finish, add to pending list\n\t                    if (!image.width || !image.height) {\n\t                        cachedImgObj.pending.push(this);\n\t                        return;\n\t                    }\n\t                }\n\t            }\n\t            if (image) {\n\t                // 图片已经加载完成\n\t                // if (image.nodeName.toUpperCase() == 'IMG') {\n\t                //     if (!image.complete) {\n\t                //         return;\n\t                //     }\n\t                // }\n\t                // Else is canvas\n\t                var width = style.width || image.width;\n\t                var height = style.height || image.height;\n\t                var x = style.x || 0;\n\t                var y = style.y || 0;\n\t                // 图片加载失败\n\t                if (!image.width || !image.height) {\n\t                    return;\n\t                }\n\t                // 设置transform\n\t                this.setTransform(ctx);\n\t                if (style.sWidth && style.sHeight) {\n\t                    var sx = style.sx || 0;\n\t                    var sy = style.sy || 0;\n\t                    ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n\t                } else if (style.sx && style.sy) {\n\t                    var sx = style.sx;\n\t                    var sy = style.sy;\n\t                    var sWidth = width - sx;\n\t                    var sHeight = height - sy;\n\t                    ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n\t                } else {\n\t                    ctx.drawImage(image, x, y, width, height);\n\t                }\n\t                // 如果没设置宽和高的话自动根据图片宽高设置\n\t                if (style.width == null) {\n\t                    style.width = width;\n\t                }\n\t                if (style.height == null) {\n\t                    style.height = height;\n\t                }\n\t                this.restoreTransform(ctx);\n\t                // Draw rect text\n\t                if (style.text != null) {\n\t                    this.drawRectText(ctx, this.getBoundingRect());\n\t                }\n\t            }\n\t        },\n\t        getBoundingRect: function () {\n\t            var style = this.style;\n\t            if (!this._rect) {\n\t                this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t    zrUtil.inherits(ZImage, Displayable);\n\t    return ZImage;\n\t});\n\tdefine('zrender/graphic/shape/Circle', ['require', '../Path'], function (require) {\n\t    'use strict';\n\t    return require('../Path').extend({\n\t        type: 'circle',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0\n\t        },\n\t        buildPath: function (ctx, shape, inBundle) {\n\t            // Better stroking in ShapeBundle\n\t            // Always do it may have performence issue ( fill may be 2x more cost)\n\t            if (inBundle) {\n\t                ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            }\n\t            // Better stroking in ShapeBundle\n\t            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Ring', ['require', '../Path'], function (require) {\n\t    return require('../Path').extend({\n\t        type: 'ring',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0,\n\t            r0: 0\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var PI2 = Math.PI * 2;\n\t            ctx.moveTo(x + shape.r, y);\n\t            ctx.arc(x, y, shape.r, 0, PI2, false);\n\t            ctx.moveTo(x + shape.r0, y);\n\t            ctx.arc(x, y, shape.r0, 0, PI2, true);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Sector', ['require', '../Path'], function (require) {\n\t    return require('../Path').extend({\n\t        type: 'sector',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r0: 0,\n\t            r: 0,\n\t            startAngle: 0,\n\t            endAngle: Math.PI * 2,\n\t            clockwise: true\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r0 = Math.max(shape.r0 || 0, 0);\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\t            ctx.lineTo(unitX * r + x, unitY * r + y);\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t            ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n\t            if (r0 !== 0) {\n\t                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n\t            }\n\t            ctx.closePath();\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Rect', ['require', '../helper/roundRect', '../Path'], function (require) {\n\t    var roundRectHelper = require('../helper/roundRect');\n\t    return require('../Path').extend({\n\t        type: 'rect',\n\t        shape: {\n\t            r: 0,\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            if (!shape.r) {\n\t                ctx.rect(x, y, width, height);\n\t            } else {\n\t                roundRectHelper.buildPath(ctx, shape);\n\t            }\n\t            ctx.closePath();\n\t            return;\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Polygon', ['require', '../helper/poly', '../Path'], function (require) {\n\t    var polyHelper = require('../helper/poly');\n\t    return require('../Path').extend({\n\t        type: 'polygon',\n\t        shape: {\n\t            points: null,\n\t            smooth: false,\n\t            smoothConstraint: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, true);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Polyline', ['require', '../helper/poly', '../Path'], function (require) {\n\t    var polyHelper = require('../helper/poly');\n\t    return require('../Path').extend({\n\t        type: 'polyline',\n\t        shape: {\n\t            points: null,\n\t            smooth: false,\n\t            smoothConstraint: null\n\t        },\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, false);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Line', ['require', '../Path'], function (require) {\n\t    return require('../Path').extend({\n\t        type: 'line',\n\t        shape: {\n\t            x1: 0,\n\t            y1: 0,\n\t            x2: 0,\n\t            y2: 0,\n\t            percent: 1\n\t        },\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var percent = shape.percent;\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t            ctx.moveTo(x1, y1);\n\t            if (percent < 1) {\n\t                x2 = x1 * (1 - percent) + x2 * percent;\n\t                y2 = y1 * (1 - percent) + y2 * percent;\n\t            }\n\t            ctx.lineTo(x2, y2);\n\t        },\n\t        pointAt: function (p) {\n\t            var shape = this.shape;\n\t            return [\n\t                shape.x1 * (1 - p) + shape.x2 * p,\n\t                shape.y1 * (1 - p) + shape.y2 * p\n\t            ];\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/BezierCurve', ['require', '../../core/curve', '../../core/vector', '../Path'], function (require) {\n\t    'use strict';\n\t    var curveTool = require('../../core/curve');\n\t    var vec2 = require('../../core/vector');\n\t    var quadraticSubdivide = curveTool.quadraticSubdivide;\n\t    var cubicSubdivide = curveTool.cubicSubdivide;\n\t    var quadraticAt = curveTool.quadraticAt;\n\t    var cubicAt = curveTool.cubicAt;\n\t    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n\t    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\t    var out = [];\n\t    function someVectorAt(shape, t, isTangent) {\n\t        var cpx2 = shape.cpx2;\n\t        var cpy2 = shape.cpy2;\n\t        if (cpx2 === null || cpy2 === null) {\n\t            return [\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n\t            ];\n\t        } else {\n\t            return [\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n\t            ];\n\t        }\n\t    }\n\t    return require('../Path').extend({\n\t        type: 'bezier-curve',\n\t        shape: {\n\t            x1: 0,\n\t            y1: 0,\n\t            x2: 0,\n\t            y2: 0,\n\t            cpx1: 0,\n\t            cpy1: 0,\n\t            percent: 1\n\t        },\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var cpx1 = shape.cpx1;\n\t            var cpy1 = shape.cpy1;\n\t            var cpx2 = shape.cpx2;\n\t            var cpy2 = shape.cpy2;\n\t            var percent = shape.percent;\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t            ctx.moveTo(x1, y1);\n\t            if (cpx2 == null || cpy2 == null) {\n\t                if (percent < 1) {\n\t                    quadraticSubdivide(x1, cpx1, x2, percent, out);\n\t                    cpx1 = out[1];\n\t                    x2 = out[2];\n\t                    quadraticSubdivide(y1, cpy1, y2, percent, out);\n\t                    cpy1 = out[1];\n\t                    y2 = out[2];\n\t                }\n\t                ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n\t            } else {\n\t                if (percent < 1) {\n\t                    cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n\t                    cpx1 = out[1];\n\t                    cpx2 = out[2];\n\t                    x2 = out[3];\n\t                    cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n\t                    cpy1 = out[1];\n\t                    cpy2 = out[2];\n\t                    y2 = out[3];\n\t                }\n\t                ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n\t            }\n\t        },\n\t        pointAt: function (t) {\n\t            return someVectorAt(this.shape, t, false);\n\t        },\n\t        tangentAt: function (t) {\n\t            var p = someVectorAt(this.shape, t, true);\n\t            return vec2.normalize(p, p);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Arc', ['require', '../Path'], function (require) {\n\t    return require('../Path').extend({\n\t        type: 'arc',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0,\n\t            startAngle: 0,\n\t            endAngle: Math.PI * 2,\n\t            clockwise: true\n\t        },\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t            ctx.moveTo(unitX * r + x, unitY * r + y);\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/RadialGradient', ['require', '../core/util', './Gradient'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('../core/util');\n\t    var Gradient = require('./Gradient');\n\t    /**\n\t     * x, y, r are all percent from 0 to 1\n\t     * @param {number} [x=0.5]\n\t     * @param {number} [y=0.5]\n\t     * @param {number} [r=0.5]\n\t     * @param {Array.<Object>} [colorStops]\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n\t        this.x = x == null ? 0.5 : x;\n\t        this.y = y == null ? 0.5 : y;\n\t        this.r = r == null ? 0.5 : r;\n\t        // Can be cloned\n\t        this.type = 'radial';\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t        Gradient.call(this, colorStops);\n\t    };\n\t    RadialGradient.prototype = { constructor: RadialGradient };\n\t    zrUtil.inherits(RadialGradient, Gradient);\n\t    return RadialGradient;\n\t});\n\tdefine('zrender/graphic/LinearGradient', ['require', '../core/util', './Gradient'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('../core/util');\n\t    var Gradient = require('./Gradient');\n\t    /**\n\t     * x, y, x2, y2 are all percent from 0 to 1\n\t     * @param {number} [x=0]\n\t     * @param {number} [y=0]\n\t     * @param {number} [x2=1]\n\t     * @param {number} [y2=0]\n\t     * @param {Array.<Object>} colorStops\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n\t        this.x = x == null ? 0 : x;\n\t        this.y = y == null ? 0 : y;\n\t        this.x2 = x2 == null ? 1 : x2;\n\t        this.y2 = y2 == null ? 0 : y2;\n\t        // Can be cloned\n\t        this.type = 'linear';\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t        Gradient.call(this, colorStops);\n\t    };\n\t    LinearGradient.prototype = { constructor: LinearGradient };\n\t    zrUtil.inherits(LinearGradient, Gradient);\n\t    return LinearGradient;\n\t});\n\tdefine('zrender/graphic/CompoundPath', ['require', './Path'], function (require) {\n\t    var Path = require('./Path');\n\t    return Path.extend({\n\t        type: 'compound',\n\t        shape: { paths: null },\n\t        _updatePathDirty: function () {\n\t            var dirtyPath = this.__dirtyPath;\n\t            var paths = this.shape.paths;\n\t            for (var i = 0; i < paths.length; i++) {\n\t                // Mark as dirty if any subpath is dirty\n\t                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n\t            }\n\t            this.__dirtyPath = dirtyPath;\n\t            this.__dirty = this.__dirty || dirtyPath;\n\t        },\n\t        beforeBrush: function () {\n\t            this._updatePathDirty();\n\t            var paths = this.shape.paths || [];\n\t            var scale = this.getGlobalScale();\n\t            // Update path scale\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].path.setScale(scale[0], scale[1]);\n\t            }\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var paths = shape.paths || [];\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].buildPath(ctx, paths[i].shape, true);\n\t            }\n\t        },\n\t        afterBrush: function () {\n\t            var paths = this.shape.paths;\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].__dirtyPath = false;\n\t            }\n\t        },\n\t        getBoundingRect: function () {\n\t            this._updatePathDirty();\n\t            return Path.prototype.getBoundingRect.call(this);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/core/BoundingRect', ['require', './vector', './matrix'], function (require) {\n\t    'use strict';\n\t    var vec2 = require('./vector');\n\t    var matrix = require('./matrix');\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var mathMin = Math.min;\n\t    var mathAbs = Math.abs;\n\t    var mathMax = Math.max;\n\t    /**\n\t     * @alias module:echarts/core/BoundingRect\n\t     */\n\t    function BoundingRect(x, y, width, height) {\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.x = x;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.y = y;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.width = width;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.height = height;\n\t    }\n\t    BoundingRect.prototype = {\n\t        constructor: BoundingRect,\n\t        union: function (other) {\n\t            var x = mathMin(other.x, this.x);\n\t            var y = mathMin(other.y, this.y);\n\t            this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n\t            this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n\t            this.x = x;\n\t            this.y = y;\n\t        },\n\t        applyTransform: function () {\n\t            var min = [];\n\t            var max = [];\n\t            return function (m) {\n\t                // In case usage like this\n\t                // el.getBoundingRect().applyTransform(el.transform)\n\t                // And element has no transform\n\t                if (!m) {\n\t                    return;\n\t                }\n\t                min[0] = this.x;\n\t                min[1] = this.y;\n\t                max[0] = this.x + this.width;\n\t                max[1] = this.y + this.height;\n\t                v2ApplyTransform(min, min, m);\n\t                v2ApplyTransform(max, max, m);\n\t                this.x = mathMin(min[0], max[0]);\n\t                this.y = mathMin(min[1], max[1]);\n\t                this.width = mathAbs(max[0] - min[0]);\n\t                this.height = mathAbs(max[1] - min[1]);\n\t            };\n\t        }(),\n\t        calculateTransform: function (b) {\n\t            var a = this;\n\t            var sx = b.width / a.width;\n\t            var sy = b.height / a.height;\n\t            var m = matrix.create();\n\t            // 矩阵右乘\n\t            matrix.translate(m, m, [\n\t                -a.x,\n\t                -a.y\n\t            ]);\n\t            matrix.scale(m, m, [\n\t                sx,\n\t                sy\n\t            ]);\n\t            matrix.translate(m, m, [\n\t                b.x,\n\t                b.y\n\t            ]);\n\t            return m;\n\t        },\n\t        intersect: function (b) {\n\t            var a = this;\n\t            var ax0 = a.x;\n\t            var ax1 = a.x + a.width;\n\t            var ay0 = a.y;\n\t            var ay1 = a.y + a.height;\n\t            var bx0 = b.x;\n\t            var bx1 = b.x + b.width;\n\t            var by0 = b.y;\n\t            var by1 = b.y + b.height;\n\t            return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\t        },\n\t        contain: function (x, y) {\n\t            var rect = this;\n\t            return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n\t        },\n\t        clone: function () {\n\t            return new BoundingRect(this.x, this.y, this.width, this.height);\n\t        },\n\t        copy: function (other) {\n\t            this.x = other.x;\n\t            this.y = other.y;\n\t            this.width = other.width;\n\t            this.height = other.height;\n\t        }\n\t    };\n\t    return BoundingRect;\n\t});\n\tdefine('zrender/contain/text', ['require', '../core/util', '../core/BoundingRect'], function (require) {\n\t    var textWidthCache = {};\n\t    var textWidthCacheCounter = 0;\n\t    var TEXT_CACHE_MAX = 5000;\n\t    var util = require('../core/util');\n\t    var BoundingRect = require('../core/BoundingRect');\n\t    var retrieve = util.retrieve;\n\t    function getTextWidth(text, textFont) {\n\t        var key = text + ':' + textFont;\n\t        if (textWidthCache[key]) {\n\t            return textWidthCache[key];\n\t        }\n\t        var textLines = (text + '').split('\\n');\n\t        var width = 0;\n\t        for (var i = 0, l = textLines.length; i < l; i++) {\n\t            // measureText 可以被覆盖以兼容不支持 Canvas 的环境\n\t            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n\t        }\n\t        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n\t            textWidthCacheCounter = 0;\n\t            textWidthCache = {};\n\t        }\n\t        textWidthCacheCounter++;\n\t        textWidthCache[key] = width;\n\t        return width;\n\t    }\n\t    function getTextRect(text, textFont, textAlign, textBaseline) {\n\t        var textLineLen = ((text || '') + '').split('\\n').length;\n\t        var width = getTextWidth(text, textFont);\n\t        // FIXME 高度计算比较粗暴\n\t        var lineHeight = getTextWidth('国', textFont);\n\t        var height = textLineLen * lineHeight;\n\t        var rect = new BoundingRect(0, 0, width, height);\n\t        // Text has a special line height property\n\t        rect.lineHeight = lineHeight;\n\t        switch (textBaseline) {\n\t        case 'bottom':\n\t        case 'alphabetic':\n\t            rect.y -= lineHeight;\n\t            break;\n\t        case 'middle':\n\t            rect.y -= lineHeight / 2;\n\t            break;    // case 'hanging':\n\t                      // case 'top':\n\t        }\n\t        // FIXME Right to left language\n\t        switch (textAlign) {\n\t        case 'end':\n\t        case 'right':\n\t            rect.x -= rect.width;\n\t            break;\n\t        case 'center':\n\t            rect.x -= rect.width / 2;\n\t            break;    // case 'start':\n\t                      // case 'left':\n\t        }\n\t        return rect;\n\t    }\n\t    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\t        var x = rect.x;\n\t        var y = rect.y;\n\t        var height = rect.height;\n\t        var width = rect.width;\n\t        var textHeight = textRect.height;\n\t        var halfHeight = height / 2 - textHeight / 2;\n\t        var textAlign = 'left';\n\t        switch (textPosition) {\n\t        case 'left':\n\t            x -= distance;\n\t            y += halfHeight;\n\t            textAlign = 'right';\n\t            break;\n\t        case 'right':\n\t            x += distance + width;\n\t            y += halfHeight;\n\t            textAlign = 'left';\n\t            break;\n\t        case 'top':\n\t            x += width / 2;\n\t            y -= distance + textHeight;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'bottom':\n\t            x += width / 2;\n\t            y += height + distance;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'inside':\n\t            x += width / 2;\n\t            y += halfHeight;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'insideLeft':\n\t            x += distance;\n\t            y += halfHeight;\n\t            textAlign = 'left';\n\t            break;\n\t        case 'insideRight':\n\t            x += width - distance;\n\t            y += halfHeight;\n\t            textAlign = 'right';\n\t            break;\n\t        case 'insideTop':\n\t            x += width / 2;\n\t            y += distance;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'insideBottom':\n\t            x += width / 2;\n\t            y += height - textHeight - distance;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'insideTopLeft':\n\t            x += distance;\n\t            y += distance;\n\t            textAlign = 'left';\n\t            break;\n\t        case 'insideTopRight':\n\t            x += width - distance;\n\t            y += distance;\n\t            textAlign = 'right';\n\t            break;\n\t        case 'insideBottomLeft':\n\t            x += distance;\n\t            y += height - textHeight - distance;\n\t            break;\n\t        case 'insideBottomRight':\n\t            x += width - distance;\n\t            y += height - textHeight - distance;\n\t            textAlign = 'right';\n\t            break;\n\t        }\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            textAlign: textAlign,\n\t            textBaseline: 'top'\n\t        };\n\t    }\n\t    /**\n\t     * Show ellipsis if overflow.\n\t     *\n\t     * @param  {string} text\n\t     * @param  {string} containerWidth\n\t     * @param  {string} textFont\n\t     * @param  {number} [ellipsis='...']\n\t     * @param  {Object} [options]\n\t     * @param  {number} [options.maxIterations=3]\n\t     * @param  {number} [options.minChar=0] If truncate result are less\n\t     *                  then minChar, ellipsis will not show, which is\n\t     *                  better for user hint in some cases.\n\t     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n\t     * @return {string}\n\t     */\n\t    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n\t        if (!containerWidth) {\n\t            return '';\n\t        }\n\t        options = options || {};\n\t        ellipsis = retrieve(ellipsis, '...');\n\t        var maxIterations = retrieve(options.maxIterations, 2);\n\t        var minChar = retrieve(options.minChar, 0);\n\t        // FIXME\n\t        // Other languages?\n\t        var cnCharWidth = getTextWidth('国', textFont);\n\t        // FIXME\n\t        // Consider proportional font?\n\t        var ascCharWidth = getTextWidth('a', textFont);\n\t        var placeholder = retrieve(options.placeholder, '');\n\t        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n\t        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\t        var contentWidth = containerWidth = Math.max(0, containerWidth - 1);\n\t        // Reserve some gap.\n\t        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n\t            contentWidth -= ascCharWidth;\n\t        }\n\t        var ellipsisWidth = getTextWidth(ellipsis);\n\t        if (ellipsisWidth > contentWidth) {\n\t            ellipsis = '';\n\t            ellipsisWidth = 0;\n\t        }\n\t        contentWidth = containerWidth - ellipsisWidth;\n\t        var textLines = (text + '').split('\\n');\n\t        for (var i = 0, len = textLines.length; i < len; i++) {\n\t            var textLine = textLines[i];\n\t            var lineWidth = getTextWidth(textLine, textFont);\n\t            if (lineWidth <= containerWidth) {\n\t                continue;\n\t            }\n\t            for (var j = 0;; j++) {\n\t                if (lineWidth <= contentWidth || j >= maxIterations) {\n\t                    textLine += ellipsis;\n\t                    break;\n\t                }\n\t                var subLength = j === 0 ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n\t                textLine = textLine.substr(0, subLength);\n\t                lineWidth = getTextWidth(textLine, textFont);\n\t            }\n\t            if (textLine === '') {\n\t                textLine = placeholder;\n\t            }\n\t            textLines[i] = textLine;\n\t        }\n\t        return textLines.join('\\n');\n\t    }\n\t    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n\t        var width = 0;\n\t        var i = 0;\n\t        for (var len = text.length; i < len && width < contentWidth; i++) {\n\t            var charCode = text.charCodeAt(i);\n\t            width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n\t        }\n\t        return i;\n\t    }\n\t    var textContain = {\n\t            getWidth: getTextWidth,\n\t            getBoundingRect: getTextRect,\n\t            adjustTextPositionOnRect: adjustTextPositionOnRect,\n\t            truncateText: truncateText,\n\t            measureText: function (text, textFont) {\n\t                var ctx = util.getContext();\n\t                ctx.font = textFont || '12px sans-serif';\n\t                return ctx.measureText(text);\n\t            }\n\t        };\n\t    return textContain;\n\t});\n\tdefine('echarts/util/model', ['require', './format', './number', '../model/Model', 'zrender/core/util'], function (require) {\n\t    var formatUtil = require('./format');\n\t    var nubmerUtil = require('./number');\n\t    var Model = require('../model/Model');\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = {};\n\t    /**\n\t     * If value is not array, then translate it to array.\n\t     * @param  {*} value\n\t     * @return {Array} [value] or value\n\t     */\n\t    modelUtil.normalizeToArray = function (value) {\n\t        return value instanceof Array ? value : value == null ? [] : [value];\n\t    };\n\t    /**\n\t     * Sync default option between normal and emphasis like `position` and `show`\n\t     * In case some one will write code like\n\t     *     label: {\n\t     *         normal: {\n\t     *             show: false,\n\t     *             position: 'outside',\n\t     *             textStyle: {\n\t     *                 fontSize: 18\n\t     *             }\n\t     *         },\n\t     *         emphasis: {\n\t     *             show: true\n\t     *         }\n\t     *     }\n\t     * @param {Object} opt\n\t     * @param {Array.<string>} subOpts\n\t     */\n\t    modelUtil.defaultEmphasis = function (opt, subOpts) {\n\t        if (opt) {\n\t            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n\t            var normalOpt = opt.normal = opt.normal || {};\n\t            // Default emphasis option from normal\n\t            zrUtil.each(subOpts, function (subOptName) {\n\t                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n\t                if (val != null) {\n\t                    emphasisOpt[subOptName] = val;\n\t                }\n\t            });\n\t        }\n\t    };\n\t    modelUtil.LABEL_OPTIONS = [\n\t        'position',\n\t        'show',\n\t        'textStyle',\n\t        'distance',\n\t        'formatter'\n\t    ];\n\t    /**\n\t     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n\t     * This helper method retieves value from data.\n\t     * @param {string|number|Date|Array|Object} dataItem\n\t     * @return {number|string|Date|Array.<number|string|Date>}\n\t     */\n\t    modelUtil.getDataItemValue = function (dataItem) {\n\t        // Performance sensitive.\n\t        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n\t    };\n\t    /**\n\t     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n\t     * This helper method determine if dataItem has extra option besides value\n\t     * @param {string|number|Date|Array|Object} dataItem\n\t     */\n\t    modelUtil.isDataItemOption = function (dataItem) {\n\t        return zrUtil.isObject(dataItem) && !(dataItem instanceof Array);    // // markLine data can be array\n\t                                                                             // && !(dataItem[0] && zrUtil.isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n\t    };\n\t    /**\n\t     * This helper method convert value in data.\n\t     * @param {string|number|Date} value\n\t     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n\t     */\n\t    modelUtil.converDataValue = function (value, dimInfo) {\n\t        // Performance sensitive.\n\t        var dimType = dimInfo && dimInfo.type;\n\t        if (dimType === 'ordinal') {\n\t            return value;\n\t        }\n\t        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {\n\t            value = +nubmerUtil.parseDate(value);\n\t        }\n\t        // dimType defaults 'number'.\n\t        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n\t        // parse to NaN.\n\t        return value == null || value === '' ? NaN : +value;    // If string (like '-'), using '+' parse to NaN\n\t    };\n\t    /**\n\t     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n\t     * @param {module:echarts/data/List} data\n\t     * @param {Object} opt\n\t     * @param {string} [opt.seriesIndex]\n\t     * @param {Object} [opt.name]\n\t     * @param {Object} [opt.mainType]\n\t     * @param {Object} [opt.subType]\n\t     */\n\t    modelUtil.createDataFormatModel = function (data, opt) {\n\t        var model = new Model();\n\t        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n\t        model.seriesIndex = opt.seriesIndex;\n\t        model.name = opt.name || '';\n\t        model.mainType = opt.mainType;\n\t        model.subType = opt.subType;\n\t        model.getData = function () {\n\t            return data;\n\t        };\n\t        return model;\n\t    };\n\t    // PENDING A little ugly\n\t    modelUtil.dataFormatMixin = {\n\t        getDataParams: function (dataIndex, dataType) {\n\t            var data = this.getData(dataType);\n\t            var seriesIndex = this.seriesIndex;\n\t            var seriesName = this.name;\n\t            var rawValue = this.getRawValue(dataIndex, dataType);\n\t            var rawDataIndex = data.getRawIndex(dataIndex);\n\t            var name = data.getName(dataIndex, true);\n\t            var itemOpt = data.getRawDataItem(dataIndex);\n\t            return {\n\t                componentType: this.mainType,\n\t                componentSubType: this.subType,\n\t                seriesType: this.mainType === 'series' ? this.subType : null,\n\t                seriesIndex: seriesIndex,\n\t                seriesName: seriesName,\n\t                name: name,\n\t                dataIndex: rawDataIndex,\n\t                data: itemOpt,\n\t                dataType: dataType,\n\t                value: rawValue,\n\t                color: data.getItemVisual(dataIndex, 'color'),\n\t                $vars: [\n\t                    'seriesName',\n\t                    'name',\n\t                    'value'\n\t                ]\n\t            };\n\t        },\n\t        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n\t            status = status || 'normal';\n\t            var data = this.getData(dataType);\n\t            var itemModel = data.getItemModel(dataIndex);\n\t            var params = this.getDataParams(dataIndex, dataType);\n\t            if (dimIndex != null && params.value instanceof Array) {\n\t                params.value = params.value[dimIndex];\n\t            }\n\t            var formatter = itemModel.get([\n\t                    'label',\n\t                    status,\n\t                    'formatter'\n\t                ]);\n\t            if (typeof formatter === 'function') {\n\t                params.status = status;\n\t                return formatter(params);\n\t            } else if (typeof formatter === 'string') {\n\t                return formatUtil.formatTpl(formatter, params);\n\t            }\n\t        },\n\t        getRawValue: function (idx, dataType) {\n\t            var data = this.getData(dataType);\n\t            var dataItem = data.getRawDataItem(idx);\n\t            if (dataItem != null) {\n\t                return zrUtil.isObject(dataItem) && !(dataItem instanceof Array) ? dataItem.value : dataItem;\n\t            }\n\t        },\n\t        formatTooltip: zrUtil.noop\n\t    };\n\t    /**\n\t     * Mapping to exists for merge.\n\t     *\n\t     * @public\n\t     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n\t     * @param {Object|Array.<Object>} newCptOptions\n\t     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n\t     *                          which order is the same as exists.\n\t     */\n\t    modelUtil.mappingToExists = function (exists, newCptOptions) {\n\t        // Mapping by the order by original option (but not order of\n\t        // new option) in merge mode. Because we should ensure\n\t        // some specified index (like xAxisIndex) is consistent with\n\t        // original option, which is easy to understand, espatially in\n\t        // media query. And in most case, merge option is used to\n\t        // update partial option but not be expected to change order.\n\t        newCptOptions = (newCptOptions || []).slice();\n\t        var result = zrUtil.map(exists || [], function (obj, index) {\n\t                return { exist: obj };\n\t            });\n\t        // Mapping by id or name if specified.\n\t        zrUtil.each(newCptOptions, function (cptOption, index) {\n\t            if (!zrUtil.isObject(cptOption)) {\n\t                return;\n\t            }\n\t            // id has highest priority.\n\t            for (var i = 0; i < result.length; i++) {\n\t                if (!result[i].option && cptOption.id != null && result[i].exist.id === cptOption.id + '') {\n\t                    result[i].option = cptOption;\n\t                    newCptOptions[index] = null;\n\t                    return;\n\t                }\n\t            }\n\t            for (var i = 0; i < result.length; i++) {\n\t                var exist = result[i].exist;\n\t                if (!result[i].option && (exist.id == null || cptOption.id == null) && cptOption.name != null && !modelUtil.isIdInner(cptOption) && !modelUtil.isIdInner(exist) && exist.name === cptOption.name + '') {\n\t                    result[i].option = cptOption;\n\t                    newCptOptions[index] = null;\n\t                    return;\n\t                }\n\t            }\n\t        });\n\t        // Otherwise mapping by index.\n\t        zrUtil.each(newCptOptions, function (cptOption, index) {\n\t            if (!zrUtil.isObject(cptOption)) {\n\t                return;\n\t            }\n\t            var i = 0;\n\t            for (; i < result.length; i++) {\n\t                var exist = result[i].exist;\n\t                if (!result[i].option && !modelUtil.isIdInner(exist) && cptOption.id == null) {\n\t                    result[i].option = cptOption;\n\t                    break;\n\t                }\n\t            }\n\t            if (i >= result.length) {\n\t                result.push({ option: cptOption });\n\t            }\n\t        });\n\t        return result;\n\t    };\n\t    /**\n\t     * @public\n\t     * @param {Object} cptOption\n\t     * @return {boolean}\n\t     */\n\t    modelUtil.isIdInner = function (cptOption) {\n\t        return zrUtil.isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\u0000_ec_\u0000') === 0;\n\t    };\n\t    /**\n\t     * A helper for removing duplicate items between batchA and batchB,\n\t     * and in themselves, and categorize by series.\n\t     *\n\t     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n\t     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n\t     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n\t     */\n\t    modelUtil.compressBatches = function (batchA, batchB) {\n\t        var mapA = {};\n\t        var mapB = {};\n\t        makeMap(batchA || [], mapA);\n\t        makeMap(batchB || [], mapB, mapA);\n\t        return [\n\t            mapToArray(mapA),\n\t            mapToArray(mapB)\n\t        ];\n\t        function makeMap(sourceBatch, map, otherMap) {\n\t            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n\t                var seriesId = sourceBatch[i].seriesId;\n\t                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n\t                var otherDataIndices = otherMap && otherMap[seriesId];\n\t                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n\t                    var dataIndex = dataIndices[j];\n\t                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n\t                        otherDataIndices[dataIndex] = null;\n\t                    } else {\n\t                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        function mapToArray(map, isData) {\n\t            var result = [];\n\t            for (var i in map) {\n\t                if (map.hasOwnProperty(i) && map[i] != null) {\n\t                    if (isData) {\n\t                        result.push(+i);\n\t                    } else {\n\t                        var dataIndices = mapToArray(map[i], true);\n\t                        dataIndices.length && result.push({\n\t                            seriesId: i,\n\t                            dataIndex: dataIndices\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    };\n\t    return modelUtil;\n\t});\n\tdefine('echarts/model/globalDefault', [], function () {\n\t    var platform = '';\n\t    // Navigator not exists in node\n\t    if (typeof navigator !== 'undefined') {\n\t        platform = navigator.platform || '';\n\t    }\n\t    return {\n\t        color: [\n\t            '#c23531',\n\t            '#2f4554',\n\t            '#61a0a8',\n\t            '#d48265',\n\t            '#91c7ae',\n\t            '#749f83',\n\t            '#ca8622',\n\t            '#bda29a',\n\t            '#6e7074',\n\t            '#546570',\n\t            '#c4ccd3'\n\t        ],\n\t        textStyle: {\n\t            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n\t            fontSize: 12,\n\t            fontStyle: 'normal',\n\t            fontWeight: 'normal'\n\t        },\n\t        blendMode: null,\n\t        animation: true,\n\t        animationDuration: 1000,\n\t        animationDurationUpdate: 300,\n\t        animationEasing: 'exponentialOut',\n\t        animationEasingUpdate: 'cubicOut',\n\t        animationThreshold: 2000,\n\t        progressiveThreshold: 3000,\n\t        progressive: 400,\n\t        hoverLayerThreshold: 3000\n\t    };\n\t});\n\tdefine('echarts/model/mixin/colorPalette', [], function () {\n\t    return {\n\t        clearColorPalette: function () {\n\t            this._colorIdx = 0;\n\t            this._colorNameMap = {};\n\t        },\n\t        getColorFromPalette: function (name, scope) {\n\t            scope = scope || this;\n\t            var colorIdx = scope._colorIdx || 0;\n\t            var colorNameMap = scope._colorNameMap || (scope._colorNameMap = {});\n\t            if (colorNameMap[name]) {\n\t                return colorNameMap[name];\n\t            }\n\t            var colorPalette = this.get('color', true) || [];\n\t            if (!colorPalette.length) {\n\t                return;\n\t            }\n\t            var color = colorPalette[colorIdx];\n\t            if (name) {\n\t                colorNameMap[name] = color;\n\t            }\n\t            scope._colorIdx = (colorIdx + 1) % colorPalette.length;\n\t            return color;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/core/PathProxy', ['require', './curve', './vector', './bbox', './BoundingRect', '../config'], function (require) {\n\t    'use strict';\n\t    var curve = require('./curve');\n\t    var vec2 = require('./vector');\n\t    var bbox = require('./bbox');\n\t    var BoundingRect = require('./BoundingRect');\n\t    var dpr = require('../config').devicePixelRatio;\n\t    var CMD = {\n\t            M: 1,\n\t            L: 2,\n\t            C: 3,\n\t            Q: 4,\n\t            A: 5,\n\t            Z: 6,\n\t            R: 7\n\t        };\n\t    var min = [];\n\t    var max = [];\n\t    var min2 = [];\n\t    var max2 = [];\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathCos = Math.cos;\n\t    var mathSin = Math.sin;\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAbs = Math.abs;\n\t    var hasTypedArray = typeof Float32Array != 'undefined';\n\t    /**\n\t     * @alias module:zrender/core/PathProxy\n\t     * @constructor\n\t     */\n\t    var PathProxy = function () {\n\t        /**\n\t         * Path data. Stored as flat array\n\t         * @type {Array.<Object>}\n\t         */\n\t        this.data = [];\n\t        this._len = 0;\n\t        this._ctx = null;\n\t        this._xi = 0;\n\t        this._yi = 0;\n\t        this._x0 = 0;\n\t        this._y0 = 0;\n\t        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n\t        this._ux = 0;\n\t        this._uy = 0;\n\t    };\n\t    /**\n\t     * 快速计算Path包围盒（并不是最小包围盒）\n\t     * @return {Object}\n\t     */\n\t    PathProxy.prototype = {\n\t        constructor: PathProxy,\n\t        _lineDash: null,\n\t        _dashOffset: 0,\n\t        _dashIdx: 0,\n\t        _dashSum: 0,\n\t        setScale: function (sx, sy) {\n\t            this._ux = mathAbs(1 / dpr / sx) || 0;\n\t            this._uy = mathAbs(1 / dpr / sy) || 0;\n\t        },\n\t        getContext: function () {\n\t            return this._ctx;\n\t        },\n\t        beginPath: function (ctx) {\n\t            this._ctx = ctx;\n\t            ctx && ctx.beginPath();\n\t            ctx && (this.dpr = ctx.dpr);\n\t            // Reset\n\t            this._len = 0;\n\t            if (this._lineDash) {\n\t                this._lineDash = null;\n\t                this._dashOffset = 0;\n\t            }\n\t            return this;\n\t        },\n\t        moveTo: function (x, y) {\n\t            this.addData(CMD.M, x, y);\n\t            this._ctx && this._ctx.moveTo(x, y);\n\t            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n\t            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n\t            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n\t            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n\t            this._x0 = x;\n\t            this._y0 = y;\n\t            this._xi = x;\n\t            this._yi = y;\n\t            return this;\n\t        },\n\t        lineTo: function (x, y) {\n\t            var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy || this._len < 5;\n\t            this.addData(CMD.L, x, y);\n\t            if (this._ctx && exceedUnit) {\n\t                this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n\t            }\n\t            if (exceedUnit) {\n\t                this._xi = x;\n\t                this._yi = y;\n\t            }\n\t            return this;\n\t        },\n\t        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n\t            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n\t            }\n\t            this._xi = x3;\n\t            this._yi = y3;\n\t            return this;\n\t        },\n\t        quadraticCurveTo: function (x1, y1, x2, y2) {\n\t            this.addData(CMD.Q, x1, y1, x2, y2);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n\t            }\n\t            this._xi = x2;\n\t            this._yi = y2;\n\t            return this;\n\t        },\n\t        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n\t            this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n\t            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\t            this._xi = mathCos(endAngle) * r + cx;\n\t            this._xi = mathSin(endAngle) * r + cx;\n\t            return this;\n\t        },\n\t        arcTo: function (x1, y1, x2, y2, radius) {\n\t            if (this._ctx) {\n\t                this._ctx.arcTo(x1, y1, x2, y2, radius);\n\t            }\n\t            return this;\n\t        },\n\t        rect: function (x, y, w, h) {\n\t            this._ctx && this._ctx.rect(x, y, w, h);\n\t            this.addData(CMD.R, x, y, w, h);\n\t            return this;\n\t        },\n\t        closePath: function () {\n\t            this.addData(CMD.Z);\n\t            var ctx = this._ctx;\n\t            var x0 = this._x0;\n\t            var y0 = this._y0;\n\t            if (ctx) {\n\t                this._needsDash() && this._dashedLineTo(x0, y0);\n\t                ctx.closePath();\n\t            }\n\t            this._xi = x0;\n\t            this._yi = y0;\n\t            return this;\n\t        },\n\t        fill: function (ctx) {\n\t            ctx && ctx.fill();\n\t            this.toStatic();\n\t        },\n\t        stroke: function (ctx) {\n\t            ctx && ctx.stroke();\n\t            this.toStatic();\n\t        },\n\t        setLineDash: function (lineDash) {\n\t            if (lineDash instanceof Array) {\n\t                this._lineDash = lineDash;\n\t                this._dashIdx = 0;\n\t                var lineDashSum = 0;\n\t                for (var i = 0; i < lineDash.length; i++) {\n\t                    lineDashSum += lineDash[i];\n\t                }\n\t                this._dashSum = lineDashSum;\n\t            }\n\t            return this;\n\t        },\n\t        setLineDashOffset: function (offset) {\n\t            this._dashOffset = offset;\n\t            return this;\n\t        },\n\t        len: function () {\n\t            return this._len;\n\t        },\n\t        setData: function (data) {\n\t            var len = data.length;\n\t            if (!(this.data && this.data.length == len) && hasTypedArray) {\n\t                this.data = new Float32Array(len);\n\t            }\n\t            for (var i = 0; i < len; i++) {\n\t                this.data[i] = data[i];\n\t            }\n\t            this._len = len;\n\t        },\n\t        appendPath: function (path) {\n\t            if (!(path instanceof Array)) {\n\t                path = [path];\n\t            }\n\t            var len = path.length;\n\t            var appendSize = 0;\n\t            var offset = this._len;\n\t            for (var i = 0; i < len; i++) {\n\t                appendSize += path[i].len();\n\t            }\n\t            if (hasTypedArray && this.data instanceof Float32Array) {\n\t                this.data = new Float32Array(offset + appendSize);\n\t            }\n\t            for (var i = 0; i < len; i++) {\n\t                var appendPathData = path[i].data;\n\t                for (var k = 0; k < appendPathData.length; k++) {\n\t                    this.data[offset++] = appendPathData[k];\n\t                }\n\t            }\n\t            this._len = offset;\n\t        },\n\t        addData: function (cmd) {\n\t            var data = this.data;\n\t            if (this._len + arguments.length > data.length) {\n\t                // 因为之前的数组已经转换成静态的 Float32Array\n\t                // 所以不够用时需要扩展一个新的动态数组\n\t                this._expandData();\n\t                data = this.data;\n\t            }\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                data[this._len++] = arguments[i];\n\t            }\n\t            this._prevCmd = cmd;\n\t        },\n\t        _expandData: function () {\n\t            // Only if data is Float32Array\n\t            if (!(this.data instanceof Array)) {\n\t                var newData = [];\n\t                for (var i = 0; i < this._len; i++) {\n\t                    newData[i] = this.data[i];\n\t                }\n\t                this.data = newData;\n\t            }\n\t        },\n\t        _needsDash: function () {\n\t            return this._lineDash;\n\t        },\n\t        _dashedLineTo: function (x1, y1) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var dx = x1 - x0;\n\t            var dy = y1 - y0;\n\t            var dist = mathSqrt(dx * dx + dy * dy);\n\t            var x = x0;\n\t            var y = y0;\n\t            var dash;\n\t            var nDash = lineDash.length;\n\t            var idx;\n\t            dx /= dist;\n\t            dy /= dist;\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            x -= offset * dx;\n\t            y -= offset * dy;\n\t            while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n\t                idx = this._dashIdx;\n\t                dash = lineDash[idx];\n\t                x += dx * dash;\n\t                y += dy * dash;\n\t                this._dashIdx = (idx + 1) % nDash;\n\t                // Skip positive offset\n\t                if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n\t                    continue;\n\t                }\n\t                ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n\t            }\n\t            // Offset for next lineTo\n\t            dx = x - x1;\n\t            dy = y - y1;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var t;\n\t            var dx;\n\t            var dy;\n\t            var cubicAt = curve.cubicAt;\n\t            var bezierLen = 0;\n\t            var idx = this._dashIdx;\n\t            var nDash = lineDash.length;\n\t            var x;\n\t            var y;\n\t            var tmpLen = 0;\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            // Bezier approx length\n\t            for (t = 0; t < 1; t += 0.1) {\n\t                dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n\t                dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n\t                bezierLen += mathSqrt(dx * dx + dy * dy);\n\t            }\n\t            // Find idx after add offset\n\t            for (; idx < nDash; idx++) {\n\t                tmpLen += lineDash[idx];\n\t                if (tmpLen > offset) {\n\t                    break;\n\t                }\n\t            }\n\t            t = (tmpLen - offset) / bezierLen;\n\t            while (t <= 1) {\n\t                x = cubicAt(x0, x1, x2, x3, t);\n\t                y = cubicAt(y0, y1, y2, y3, t);\n\t                // Use line to approximate dashed bezier\n\t                // Bad result if dash is long\n\t                idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n\t                t += lineDash[idx] / bezierLen;\n\t                idx = (idx + 1) % nDash;\n\t            }\n\t            // Finish the last segment and calculate the new offset\n\t            idx % 2 !== 0 && ctx.lineTo(x3, y3);\n\t            dx = x3 - x;\n\t            dy = y3 - y;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n\t            // Convert quadratic to cubic using degree elevation\n\t            var x3 = x2;\n\t            var y3 = y2;\n\t            x2 = (x2 + 2 * x1) / 3;\n\t            y2 = (y2 + 2 * y1) / 3;\n\t            x1 = (this._xi + 2 * x1) / 3;\n\t            y1 = (this._yi + 2 * y1) / 3;\n\t            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n\t        },\n\t        toStatic: function () {\n\t            var data = this.data;\n\t            if (data instanceof Array) {\n\t                data.length = this._len;\n\t                if (hasTypedArray) {\n\t                    this.data = new Float32Array(data);\n\t                }\n\t            }\n\t        },\n\t        getBoundingRect: function () {\n\t            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n\t            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\t            var data = this.data;\n\t            var xi = 0;\n\t            var yi = 0;\n\t            var x0 = 0;\n\t            var y0 = 0;\n\t            for (var i = 0; i < data.length;) {\n\t                var cmd = data[i++];\n\t                if (i == 1) {\n\t                    // 如果第一个命令是 L, C, Q\n\t                    // 则 previous point 同绘制命令的第一个 point\n\t                    //\n\t                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                    xi = data[i];\n\t                    yi = data[i + 1];\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t                switch (cmd) {\n\t                case CMD.M:\n\t                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t                    // 在 closePath 的时候使用\n\t                    x0 = data[i++];\n\t                    y0 = data[i++];\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    min2[0] = x0;\n\t                    min2[1] = y0;\n\t                    max2[0] = x0;\n\t                    max2[1] = y0;\n\t                    break;\n\t                case CMD.L:\n\t                    bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.C:\n\t                    bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.Q:\n\t                    bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.A:\n\t                    // TODO Arc 判断的开销比较大\n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var startAngle = data[i++];\n\t                    var endAngle = data[i++] + startAngle;\n\t                    // TODO Arc 旋转\n\t                    var psi = data[i++];\n\t                    var anticlockwise = 1 - data[i++];\n\t                    if (i == 1) {\n\t                        // 直接使用 arc 命令\n\t                        // 第一个命令起点还未定义\n\t                        x0 = mathCos(startAngle) * rx + cx;\n\t                        y0 = mathSin(startAngle) * ry + cy;\n\t                    }\n\t                    bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n\t                    xi = mathCos(endAngle) * rx + cx;\n\t                    yi = mathSin(endAngle) * ry + cy;\n\t                    break;\n\t                case CMD.R:\n\t                    x0 = xi = data[i++];\n\t                    y0 = yi = data[i++];\n\t                    var width = data[i++];\n\t                    var height = data[i++];\n\t                    // Use fromLine\n\t                    bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n\t                    break;\n\t                case CMD.Z:\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t                }\n\t                // Union\n\t                vec2.min(min, min, min2);\n\t                vec2.max(max, max, max2);\n\t            }\n\t            // No data\n\t            if (i === 0) {\n\t                min[0] = min[1] = max[0] = max[1] = 0;\n\t            }\n\t            return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t        },\n\t        rebuildPath: function (ctx) {\n\t            var d = this.data;\n\t            var x0, y0;\n\t            var xi, yi;\n\t            var x, y;\n\t            var ux = this._ux;\n\t            var uy = this._uy;\n\t            var len = this._len;\n\t            for (var i = 0; i < len;) {\n\t                var cmd = d[i++];\n\t                if (i == 1) {\n\t                    // 如果第一个命令是 L, C, Q\n\t                    // 则 previous point 同绘制命令的第一个 point\n\t                    //\n\t                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                    xi = d[i];\n\t                    yi = d[i + 1];\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t                switch (cmd) {\n\t                case CMD.M:\n\t                    x0 = xi = d[i++];\n\t                    y0 = yi = d[i++];\n\t                    ctx.moveTo(xi, yi);\n\t                    break;\n\t                case CMD.L:\n\t                    x = d[i++];\n\t                    y = d[i++];\n\t                    // Not draw too small seg between\n\t                    if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n\t                        ctx.lineTo(x, y);\n\t                        xi = x;\n\t                        yi = y;\n\t                    }\n\t                    break;\n\t                case CMD.C:\n\t                    ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n\t                    xi = d[i - 2];\n\t                    yi = d[i - 1];\n\t                    break;\n\t                case CMD.Q:\n\t                    ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n\t                    xi = d[i - 2];\n\t                    yi = d[i - 1];\n\t                    break;\n\t                case CMD.A:\n\t                    var cx = d[i++];\n\t                    var cy = d[i++];\n\t                    var rx = d[i++];\n\t                    var ry = d[i++];\n\t                    var theta = d[i++];\n\t                    var dTheta = d[i++];\n\t                    var psi = d[i++];\n\t                    var fs = d[i++];\n\t                    var r = rx > ry ? rx : ry;\n\t                    var scaleX = rx > ry ? 1 : rx / ry;\n\t                    var scaleY = rx > ry ? ry / rx : 1;\n\t                    var isEllipse = Math.abs(rx - ry) > 0.001;\n\t                    var endAngle = theta + dTheta;\n\t                    if (isEllipse) {\n\t                        ctx.translate(cx, cy);\n\t                        ctx.rotate(psi);\n\t                        ctx.scale(scaleX, scaleY);\n\t                        ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n\t                        ctx.scale(1 / scaleX, 1 / scaleY);\n\t                        ctx.rotate(-psi);\n\t                        ctx.translate(-cx, -cy);\n\t                    } else {\n\t                        ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n\t                    }\n\t                    if (i == 1) {\n\t                        // 直接使用 arc 命令\n\t                        // 第一个命令起点还未定义\n\t                        x0 = mathCos(theta) * rx + cx;\n\t                        y0 = mathSin(theta) * ry + cy;\n\t                    }\n\t                    xi = mathCos(endAngle) * rx + cx;\n\t                    yi = mathSin(endAngle) * ry + cy;\n\t                    break;\n\t                case CMD.R:\n\t                    x0 = xi = d[i];\n\t                    y0 = yi = d[i + 1];\n\t                    ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n\t                    break;\n\t                case CMD.Z:\n\t                    ctx.closePath();\n\t                    xi = x0;\n\t                    yi = y0;\n\t                }\n\t            }\n\t        }\n\t    };\n\t    PathProxy.CMD = CMD;\n\t    return PathProxy;\n\t});\n\tdefine('zrender/tool/transformPath', ['require', '../core/PathProxy', '../core/vector'], function (require) {\n\t    var CMD = require('../core/PathProxy').CMD;\n\t    var vec2 = require('../core/vector');\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var points = [\n\t            [],\n\t            [],\n\t            []\n\t        ];\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAtan2 = Math.atan2;\n\t    function transformPath(path, m) {\n\t        var data = path.data;\n\t        var cmd;\n\t        var nPoint;\n\t        var i;\n\t        var j;\n\t        var k;\n\t        var p;\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var R = CMD.R;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t        for (i = 0, j = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            j = i;\n\t            nPoint = 0;\n\t            switch (cmd) {\n\t            case M:\n\t                nPoint = 1;\n\t                break;\n\t            case L:\n\t                nPoint = 1;\n\t                break;\n\t            case C:\n\t                nPoint = 3;\n\t                break;\n\t            case Q:\n\t                nPoint = 2;\n\t                break;\n\t            case A:\n\t                var x = m[4];\n\t                var y = m[5];\n\t                var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n\t                var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n\t                var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n\t                // cx\n\t                data[i++] += x;\n\t                // cy\n\t                data[i++] += y;\n\t                // Scale rx and ry\n\t                // FIXME Assume psi is 0 here\n\t                data[i++] *= sx;\n\t                data[i++] *= sy;\n\t                // Start angle\n\t                data[i++] += angle;\n\t                // end angle\n\t                data[i++] += angle;\n\t                // FIXME psi\n\t                i += 2;\n\t                j = i;\n\t                break;\n\t            case R:\n\t                // x0, y0\n\t                p[0] = data[i++];\n\t                p[1] = data[i++];\n\t                v2ApplyTransform(p, p, m);\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t                // x1, y1\n\t                p[0] += data[i++];\n\t                p[1] += data[i++];\n\t                v2ApplyTransform(p, p, m);\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t            }\n\t            for (k = 0; k < nPoint; k++) {\n\t                var p = points[k];\n\t                p[0] = data[i++];\n\t                p[1] = data[i++];\n\t                v2ApplyTransform(p, p, m);\n\t                // Write back\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t            }\n\t        }\n\t    }\n\t    return transformPath;\n\t});\n\tdefine('echarts/util/clazz', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var clazz = {};\n\t    var TYPE_DELIMITER = '.';\n\t    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n\t    /**\n\t     * @public\n\t     */\n\t    var parseClassType = clazz.parseClassType = function (componentType) {\n\t            var ret = {\n\t                    main: '',\n\t                    sub: ''\n\t                };\n\t            if (componentType) {\n\t                componentType = componentType.split(TYPE_DELIMITER);\n\t                ret.main = componentType[0] || '';\n\t                ret.sub = componentType[1] || '';\n\t            }\n\t            return ret;\n\t        };\n\t    /**\n\t     * @public\n\t     */\n\t    clazz.enableClassExtend = function (RootClass) {\n\t        RootClass.$constructor = RootClass;\n\t        RootClass.extend = function (proto) {\n\t            var superClass = this;\n\t            var ExtendedClass = function () {\n\t                if (!proto.$constructor) {\n\t                    superClass.apply(this, arguments);\n\t                } else {\n\t                    proto.$constructor.apply(this, arguments);\n\t                }\n\t            };\n\t            zrUtil.extend(ExtendedClass.prototype, proto);\n\t            ExtendedClass.extend = this.extend;\n\t            ExtendedClass.superCall = superCall;\n\t            ExtendedClass.superApply = superApply;\n\t            zrUtil.inherits(ExtendedClass, this);\n\t            ExtendedClass.superClass = superClass;\n\t            return ExtendedClass;\n\t        };\n\t    };\n\t    // superCall should have class info, which can not be fetch from 'this'.\n\t    // Consider this case:\n\t    // class A has method f,\n\t    // class B inherits class A, overrides method f, f call superApply('f'),\n\t    // class C inherits class B, do not overrides method f,\n\t    // then when method of class C is called, dead loop occured.\n\t    function superCall(context, methodName) {\n\t        var args = zrUtil.slice(arguments, 2);\n\t        return this.superClass.prototype[methodName].apply(context, args);\n\t    }\n\t    function superApply(context, methodName, args) {\n\t        return this.superClass.prototype[methodName].apply(context, args);\n\t    }\n\t    /**\n\t     * @param {Object} entity\n\t     * @param {Object} options\n\t     * @param {boolean} [options.registerWhenExtend]\n\t     * @public\n\t     */\n\t    clazz.enableClassManagement = function (entity, options) {\n\t        options = options || {};\n\t        /**\n\t         * Component model classes\n\t         * key: componentType,\n\t         * value:\n\t         *     componentClass, when componentType is 'xxx'\n\t         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n\t         * @type {Object}\n\t         */\n\t        var storage = {};\n\t        entity.registerClass = function (Clazz, componentType) {\n\t            if (componentType) {\n\t                componentType = parseClassType(componentType);\n\t                if (!componentType.sub) {\n\t                    if (true) {\n\t                        if (storage[componentType.main]) {\n\t                            console.warn(componentType.main + ' exists.');\n\t                        }\n\t                    }\n\t                    storage[componentType.main] = Clazz;\n\t                } else if (componentType.sub !== IS_CONTAINER) {\n\t                    var container = makeContainer(componentType);\n\t                    container[componentType.sub] = Clazz;\n\t                }\n\t            }\n\t            return Clazz;\n\t        };\n\t        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\n\t            var Clazz = storage[componentTypeMain];\n\t            if (Clazz && Clazz[IS_CONTAINER]) {\n\t                Clazz = subType ? Clazz[subType] : null;\n\t            }\n\t            if (throwWhenNotFound && !Clazz) {\n\t                throw new Error('Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.');\n\t            }\n\t            return Clazz;\n\t        };\n\t        entity.getClassesByMainType = function (componentType) {\n\t            componentType = parseClassType(componentType);\n\t            var result = [];\n\t            var obj = storage[componentType.main];\n\t            if (obj && obj[IS_CONTAINER]) {\n\t                zrUtil.each(obj, function (o, type) {\n\t                    type !== IS_CONTAINER && result.push(o);\n\t                });\n\t            } else {\n\t                result.push(obj);\n\t            }\n\t            return result;\n\t        };\n\t        entity.hasClass = function (componentType) {\n\t            // Just consider componentType.main.\n\t            componentType = parseClassType(componentType);\n\t            return !!storage[componentType.main];\n\t        };\n\t        /**\n\t         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n\t         */\n\t        entity.getAllClassMainTypes = function () {\n\t            var types = [];\n\t            zrUtil.each(storage, function (obj, type) {\n\t                types.push(type);\n\t            });\n\t            return types;\n\t        };\n\t        /**\n\t         * If a main type is container and has sub types\n\t         * @param  {string}  mainType\n\t         * @return {boolean}\n\t         */\n\t        entity.hasSubTypes = function (componentType) {\n\t            componentType = parseClassType(componentType);\n\t            var obj = storage[componentType.main];\n\t            return obj && obj[IS_CONTAINER];\n\t        };\n\t        entity.parseClassType = parseClassType;\n\t        function makeContainer(componentType) {\n\t            var container = storage[componentType.main];\n\t            if (!container || !container[IS_CONTAINER]) {\n\t                container = storage[componentType.main] = {};\n\t                container[IS_CONTAINER] = true;\n\t            }\n\t            return container;\n\t        }\n\t        if (options.registerWhenExtend) {\n\t            var originalExtend = entity.extend;\n\t            if (originalExtend) {\n\t                entity.extend = function (proto) {\n\t                    var ExtendedClass = originalExtend.call(this, proto);\n\t                    return entity.registerClass(ExtendedClass, proto.type);\n\t                };\n\t            }\n\t        }\n\t        return entity;\n\t    };\n\t    /**\n\t     * @param {string|Array.<string>} properties\n\t     */\n\t    clazz.setReadOnly = function (obj, properties) {\n\t    };\n\t    return clazz;\n\t});\n\tdefine('zrender/graphic/Displayable', ['require', '../core/util', './Style', '../Element', './mixin/RectText'], function (require) {\n\t    var zrUtil = require('../core/util');\n\t    var Style = require('./Style');\n\t    var Element = require('../Element');\n\t    var RectText = require('./mixin/RectText');\n\t    // var Stateful = require('./mixin/Stateful');\n\t    /**\n\t     * @alias module:zrender/graphic/Displayable\n\t     * @extends module:zrender/Element\n\t     * @extends module:zrender/graphic/mixin/RectText\n\t     */\n\t    function Displayable(opts) {\n\t        opts = opts || {};\n\t        Element.call(this, opts);\n\t        // Extend properties\n\t        for (var name in opts) {\n\t            if (opts.hasOwnProperty(name) && name !== 'style') {\n\t                this[name] = opts[name];\n\t            }\n\t        }\n\t        /**\n\t         * @type {module:zrender/graphic/Style}\n\t         */\n\t        this.style = new Style(opts.style);\n\t        this._rect = null;\n\t        // Shapes for cascade clipping.\n\t        this.__clipPaths = [];    // FIXME Stateful must be mixined after style is setted\n\t                                  // Stateful.call(this, opts);\n\t    }\n\t    Displayable.prototype = {\n\t        constructor: Displayable,\n\t        type: 'displayable',\n\t        __dirty: true,\n\t        invisible: false,\n\t        z: 0,\n\t        z2: 0,\n\t        zlevel: 0,\n\t        draggable: false,\n\t        dragging: false,\n\t        silent: false,\n\t        culling: false,\n\t        cursor: 'pointer',\n\t        rectHover: false,\n\t        progressive: -1,\n\t        beforeBrush: function (ctx) {\n\t        },\n\t        afterBrush: function (ctx) {\n\t        },\n\t        brush: function (ctx, prevEl) {\n\t        },\n\t        getBoundingRect: function () {\n\t        },\n\t        contain: function (x, y) {\n\t            return this.rectContain(x, y);\n\t        },\n\t        traverse: function (cb, context) {\n\t            cb.call(context, this);\n\t        },\n\t        rectContain: function (x, y) {\n\t            var coord = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            return rect.contain(coord[0], coord[1]);\n\t        },\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t            this._rect = null;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t        animateStyle: function (loop) {\n\t            return this.animate('style', loop);\n\t        },\n\t        attrKV: function (key, value) {\n\t            if (key !== 'style') {\n\t                Element.prototype.attrKV.call(this, key, value);\n\t            } else {\n\t                this.style.set(value);\n\t            }\n\t        },\n\t        setStyle: function (key, value) {\n\t            this.style.set(key, value);\n\t            this.dirty(false);\n\t            return this;\n\t        },\n\t        useStyle: function (obj) {\n\t            this.style = new Style(obj);\n\t            this.dirty(false);\n\t            return this;\n\t        }\n\t    };\n\t    zrUtil.inherits(Displayable, Element);\n\t    zrUtil.mixin(Displayable, RectText);\n\t    // zrUtil.mixin(Displayable, Stateful);\n\t    return Displayable;\n\t});\n\tdefine('zrender/contain/path', ['require', '../core/PathProxy', './line', './cubic', './quadratic', './arc', './util', '../core/curve', './windingLine'], function (require) {\n\t    'use strict';\n\t    var CMD = require('../core/PathProxy').CMD;\n\t    var line = require('./line');\n\t    var cubic = require('./cubic');\n\t    var quadratic = require('./quadratic');\n\t    var arc = require('./arc');\n\t    var normalizeRadian = require('./util').normalizeRadian;\n\t    var curve = require('../core/curve');\n\t    var windingLine = require('./windingLine');\n\t    var containStroke = line.containStroke;\n\t    var PI2 = Math.PI * 2;\n\t    var EPSILON = 0.0001;\n\t    function isAroundEqual(a, b) {\n\t        return Math.abs(a - b) < EPSILON;\n\t    }\n\t    // 临时数组\n\t    var roots = [\n\t            -1,\n\t            -1,\n\t            -1\n\t        ];\n\t    var extrema = [\n\t            -1,\n\t            -1\n\t        ];\n\t    function swapExtrema() {\n\t        var tmp = extrema[0];\n\t        extrema[0] = extrema[1];\n\t        extrema[1] = tmp;\n\t    }\n\t    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n\t        // Quick reject\n\t        if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        } else {\n\t            var w = 0;\n\t            var nExtrema = -1;\n\t            var y0_, y1_;\n\t            for (var i = 0; i < nRoots; i++) {\n\t                var t = roots[i];\n\t                // Avoid winding error when intersection point is the connect point of two line of polygon\n\t                var unit = t === 0 || t === 1 ? 0.5 : 1;\n\t                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\t                if (x_ < x) {\n\t                    // Quick reject\n\t                    continue;\n\t                }\n\t                if (nExtrema < 0) {\n\t                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\t                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n\t                        swapExtrema();\n\t                    }\n\t                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\t                    if (nExtrema > 1) {\n\t                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n\t                    }\n\t                }\n\t                if (nExtrema == 2) {\n\t                    // 分成三段单调函数\n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    } else if (t < extrema[1]) {\n\t                        w += y1_ < y0_ ? unit : -unit;\n\t                    } else {\n\t                        w += y3 < y1_ ? unit : -unit;\n\t                    }\n\t                } else {\n\t                    // 分成两段单调函数\n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    } else {\n\t                        w += y3 < y0_ ? unit : -unit;\n\t                    }\n\t                }\n\t            }\n\t            return w;\n\t        }\n\t    }\n\t    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n\t        // Quick reject\n\t        if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        } else {\n\t            var t = curve.quadraticExtremum(y0, y1, y2);\n\t            if (t >= 0 && t <= 1) {\n\t                var w = 0;\n\t                var y_ = curve.quadraticAt(y0, y1, y2, t);\n\t                for (var i = 0; i < nRoots; i++) {\n\t                    // Remove one endpoint.\n\t                    var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n\t                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\t                    if (x_ < x) {\n\t                        // Quick reject\n\t                        continue;\n\t                    }\n\t                    if (roots[i] < t) {\n\t                        w += y_ < y0 ? unit : -unit;\n\t                    } else {\n\t                        w += y2 < y_ ? unit : -unit;\n\t                    }\n\t                }\n\t                return w;\n\t            } else {\n\t                // Remove one endpoint.\n\t                var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n\t                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\t                if (x_ < x) {\n\t                    // Quick reject\n\t                    return 0;\n\t                }\n\t                return y2 < y0 ? unit : -unit;\n\t            }\n\t        }\n\t    }\n\t    // TODO\n\t    // Arc 旋转\n\t    function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n\t        y -= cy;\n\t        if (y > r || y < -r) {\n\t            return 0;\n\t        }\n\t        var tmp = Math.sqrt(r * r - y * y);\n\t        roots[0] = -tmp;\n\t        roots[1] = tmp;\n\t        var diff = Math.abs(startAngle - endAngle);\n\t        if (diff < 0.0001) {\n\t            return 0;\n\t        }\n\t        if (diff % PI2 < 0.0001) {\n\t            // Is a circle\n\t            startAngle = 0;\n\t            endAngle = PI2;\n\t            var dir = anticlockwise ? 1 : -1;\n\t            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n\t                return dir;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t        if (anticlockwise) {\n\t            var tmp = startAngle;\n\t            startAngle = normalizeRadian(endAngle);\n\t            endAngle = normalizeRadian(tmp);\n\t        } else {\n\t            startAngle = normalizeRadian(startAngle);\n\t            endAngle = normalizeRadian(endAngle);\n\t        }\n\t        if (startAngle > endAngle) {\n\t            endAngle += PI2;\n\t        }\n\t        var w = 0;\n\t        for (var i = 0; i < 2; i++) {\n\t            var x_ = roots[i];\n\t            if (x_ + cx > x) {\n\t                var angle = Math.atan2(y, x_);\n\t                var dir = anticlockwise ? 1 : -1;\n\t                if (angle < 0) {\n\t                    angle = PI2 + angle;\n\t                }\n\t                if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n\t                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n\t                        dir = -dir;\n\t                    }\n\t                    w += dir;\n\t                }\n\t            }\n\t        }\n\t        return w;\n\t    }\n\t    function containPath(data, lineWidth, isStroke, x, y) {\n\t        var w = 0;\n\t        var xi = 0;\n\t        var yi = 0;\n\t        var x0 = 0;\n\t        var y0 = 0;\n\t        for (var i = 0; i < data.length;) {\n\t            var cmd = data[i++];\n\t            // Begin a new subpath\n\t            if (cmd === CMD.M && i > 1) {\n\t                // Close previous subpath\n\t                if (!isStroke) {\n\t                    w += windingLine(xi, yi, x0, y0, x, y);\n\t                }    // 如果被任何一个 subpath 包含\n\t                     // if (w !== 0) {\n\t                     //     return true;\n\t                     // }\n\t            }\n\t            if (i == 1) {\n\t                // 如果第一个命令是 L, C, Q\n\t                // 则 previous point 同绘制命令的第一个 point\n\t                //\n\t                // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                xi = data[i];\n\t                yi = data[i + 1];\n\t                x0 = xi;\n\t                y0 = yi;\n\t            }\n\t            switch (cmd) {\n\t            case CMD.M:\n\t                // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t                // 在 closePath 的时候使用\n\t                x0 = data[i++];\n\t                y0 = data[i++];\n\t                xi = x0;\n\t                yi = y0;\n\t                break;\n\t            case CMD.L:\n\t                if (isStroke) {\n\t                    if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n\t                    w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n\t                }\n\t                xi = data[i++];\n\t                yi = data[i++];\n\t                break;\n\t            case CMD.C:\n\t                if (isStroke) {\n\t                    if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n\t                }\n\t                xi = data[i++];\n\t                yi = data[i++];\n\t                break;\n\t            case CMD.Q:\n\t                if (isStroke) {\n\t                    if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n\t                }\n\t                xi = data[i++];\n\t                yi = data[i++];\n\t                break;\n\t            case CMD.A:\n\t                // TODO Arc 判断的开销比较大\n\t                var cx = data[i++];\n\t                var cy = data[i++];\n\t                var rx = data[i++];\n\t                var ry = data[i++];\n\t                var theta = data[i++];\n\t                var dTheta = data[i++];\n\t                // TODO Arc 旋转\n\t                var psi = data[i++];\n\t                var anticlockwise = 1 - data[i++];\n\t                var x1 = Math.cos(theta) * rx + cx;\n\t                var y1 = Math.sin(theta) * ry + cy;\n\t                // 不是直接使用 arc 命令\n\t                if (i > 1) {\n\t                    w += windingLine(xi, yi, x1, y1, x, y);\n\t                } else {\n\t                    // 第一个命令起点还未定义\n\t                    x0 = x1;\n\t                    y0 = y1;\n\t                }\n\t                // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\t                var _x = (x - cx) * ry / rx + cx;\n\t                if (isStroke) {\n\t                    if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n\t                }\n\t                xi = Math.cos(theta + dTheta) * rx + cx;\n\t                yi = Math.sin(theta + dTheta) * ry + cy;\n\t                break;\n\t            case CMD.R:\n\t                x0 = xi = data[i++];\n\t                y0 = yi = data[i++];\n\t                var width = data[i++];\n\t                var height = data[i++];\n\t                var x1 = x0 + width;\n\t                var y1 = y0 + height;\n\t                if (isStroke) {\n\t                    if (containStroke(x0, y0, x1, y0, lineWidth, x, y) || containStroke(x1, y0, x1, y1, lineWidth, x, y) || containStroke(x1, y1, x0, y1, lineWidth, x, y) || containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    // FIXME Clockwise ?\n\t                    w += windingLine(x1, y0, x1, y1, x, y);\n\t                    w += windingLine(x0, y1, x0, y0, x, y);\n\t                }\n\t                break;\n\t            case CMD.Z:\n\t                if (isStroke) {\n\t                    if (containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    // Close a subpath\n\t                    w += windingLine(xi, yi, x0, y0, x, y);    // 如果被任何一个 subpath 包含\n\t                                                               // FIXME subpaths may overlap\n\t                                                               // if (w !== 0) {\n\t                                                               //     return true;\n\t                                                               // }\n\t                }\n\t                xi = x0;\n\t                yi = y0;\n\t                break;\n\t            }\n\t        }\n\t        if (!isStroke && !isAroundEqual(yi, y0)) {\n\t            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n\t        }\n\t        return w !== 0;\n\t    }\n\t    return {\n\t        contain: function (pathData, x, y) {\n\t            return containPath(pathData, 0, false, x, y);\n\t        },\n\t        containStroke: function (pathData, lineWidth, x, y) {\n\t            return containPath(pathData, lineWidth, true, x, y);\n\t        }\n\t    };\n\t});\n\tdefine('echarts/model/mixin/lineStyle', ['require', './makeStyleMapper'], function (require) {\n\t    var getLineStyle = require('./makeStyleMapper')([\n\t            [\n\t                'lineWidth',\n\t                'width'\n\t            ],\n\t            [\n\t                'stroke',\n\t                'color'\n\t            ],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor']\n\t        ]);\n\t    return {\n\t        getLineStyle: function (excludes) {\n\t            var style = getLineStyle.call(this, excludes);\n\t            var lineDash = this.getLineDash();\n\t            lineDash && (style.lineDash = lineDash);\n\t            return style;\n\t        },\n\t        getLineDash: function () {\n\t            var lineType = this.get('type');\n\t            return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [\n\t                5,\n\t                5\n\t            ] : [\n\t                2,\n\t                2\n\t            ];\n\t        }\n\t    };\n\t});\n\tdefine('echarts/scale/Ordinal', ['require', 'zrender/core/util', './Scale'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var Scale = require('./Scale');\n\t    var scaleProto = Scale.prototype;\n\t    var OrdinalScale = Scale.extend({\n\t            type: 'ordinal',\n\t            init: function (data, extent) {\n\t                this._data = data;\n\t                this._extent = extent || [\n\t                    0,\n\t                    data.length - 1\n\t                ];\n\t            },\n\t            parse: function (val) {\n\t                return typeof val === 'string' ? zrUtil.indexOf(this._data, val) : Math.round(val);\n\t            },\n\t            contain: function (rank) {\n\t                rank = this.parse(rank);\n\t                return scaleProto.contain.call(this, rank) && this._data[rank] != null;\n\t            },\n\t            normalize: function (val) {\n\t                return scaleProto.normalize.call(this, this.parse(val));\n\t            },\n\t            scale: function (val) {\n\t                return Math.round(scaleProto.scale.call(this, val));\n\t            },\n\t            getTicks: function () {\n\t                var ticks = [];\n\t                var extent = this._extent;\n\t                var rank = extent[0];\n\t                while (rank <= extent[1]) {\n\t                    ticks.push(rank);\n\t                    rank++;\n\t                }\n\t                return ticks;\n\t            },\n\t            getLabel: function (n) {\n\t                return this._data[n];\n\t            },\n\t            count: function () {\n\t                return this._extent[1] - this._extent[0] + 1;\n\t            },\n\t            niceTicks: zrUtil.noop,\n\t            niceExtent: zrUtil.noop\n\t        });\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    OrdinalScale.create = function () {\n\t        return new OrdinalScale();\n\t    };\n\t    return OrdinalScale;\n\t});\n\tdefine('zrender/graphic/Pattern', ['require'], function (require) {\n\t    var Pattern = function (image, repeat) {\n\t        this.image = image;\n\t        this.repeat = repeat;\n\t        // Can be cloned\n\t        this.type = 'pattern';\n\t    };\n\t    Pattern.prototype.getCanvasPattern = function (ctx) {\n\t        return this._canvasPattern || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n\t    };\n\t    return Pattern;\n\t});\n\tdefine('echarts/model/mixin/areaStyle', ['require', './makeStyleMapper'], function (require) {\n\t    return {\n\t        getAreaStyle: require('./makeStyleMapper')([\n\t            [\n\t                'fill',\n\t                'color'\n\t            ],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['opacity'],\n\t            ['shadowColor']\n\t        ])\n\t    };\n\t});\n\tdefine('echarts/model/mixin/textStyle', ['require', 'zrender/contain/text'], function (require) {\n\t    var textContain = require('zrender/contain/text');\n\t    function getShallow(model, path) {\n\t        return model && model.getShallow(path);\n\t    }\n\t    return {\n\t        getTextColor: function () {\n\t            var ecModel = this.ecModel;\n\t            return this.getShallow('color') || ecModel && ecModel.get('textStyle.color');\n\t        },\n\t        getFont: function () {\n\t            var ecModel = this.ecModel;\n\t            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n\t            return [\n\t                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n\t                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n\t                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n\t                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n\t            ].join(' ');\n\t        },\n\t        getTextRect: function (text) {\n\t            var textStyle = this.get('textStyle') || {};\n\t            return textContain.getBoundingRect(text, this.getFont(), textStyle.align, textStyle.baseline);\n\t        },\n\t        truncateText: function (text, containerWidth, ellipsis, options) {\n\t            return textContain.truncateText(text, containerWidth, this.getFont(), ellipsis, options);\n\t        }\n\t    };\n\t});\n\tdefine('echarts/model/mixin/itemStyle', ['require', './makeStyleMapper'], function (require) {\n\t    var getItemStyle = require('./makeStyleMapper')([\n\t            [\n\t                'fill',\n\t                'color'\n\t            ],\n\t            [\n\t                'stroke',\n\t                'borderColor'\n\t            ],\n\t            [\n\t                'lineWidth',\n\t                'borderWidth'\n\t            ],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor']\n\t        ]);\n\t    return {\n\t        getItemStyle: function (excludes) {\n\t            var style = getItemStyle.call(this, excludes);\n\t            var lineDash = this.getBorderLineDash();\n\t            lineDash && (style.lineDash = lineDash);\n\t            return style;\n\t        },\n\t        getBorderLineDash: function () {\n\t            var lineType = this.get('borderType');\n\t            return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [\n\t                5,\n\t                5\n\t            ] : [\n\t                1,\n\t                1\n\t            ];\n\t        }\n\t    };\n\t});\n\tdefine('zrender/graphic/Style', ['require'], function (require) {\n\t    var STYLE_COMMON_PROPS = [\n\t            [\n\t                'shadowBlur',\n\t                0\n\t            ],\n\t            [\n\t                'shadowOffsetX',\n\t                0\n\t            ],\n\t            [\n\t                'shadowOffsetY',\n\t                0\n\t            ],\n\t            [\n\t                'shadowColor',\n\t                '#000'\n\t            ],\n\t            [\n\t                'lineCap',\n\t                'butt'\n\t            ],\n\t            [\n\t                'lineJoin',\n\t                'miter'\n\t            ],\n\t            [\n\t                'miterLimit',\n\t                10\n\t            ]\n\t        ];\n\t    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n\t    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\t    var Style = function (opts) {\n\t        this.extendFrom(opts);\n\t    };\n\t    function createLinearGradient(ctx, obj, rect) {\n\t        // var size =\n\t        var x = obj.x;\n\t        var x2 = obj.x2;\n\t        var y = obj.y;\n\t        var y2 = obj.y2;\n\t        if (!obj.global) {\n\t            x = x * rect.width + rect.x;\n\t            x2 = x2 * rect.width + rect.x;\n\t            y = y * rect.height + rect.y;\n\t            y2 = y2 * rect.height + rect.y;\n\t        }\n\t        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\t        return canvasGradient;\n\t    }\n\t    function createRadialGradient(ctx, obj, rect) {\n\t        var width = rect.width;\n\t        var height = rect.height;\n\t        var min = Math.min(width, height);\n\t        var x = obj.x;\n\t        var y = obj.y;\n\t        var r = obj.r;\n\t        if (!obj.global) {\n\t            x = x * width + rect.x;\n\t            y = y * height + rect.y;\n\t            r = r * min;\n\t        }\n\t        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\t        return canvasGradient;\n\t    }\n\t    Style.prototype = {\n\t        constructor: Style,\n\t        fill: '#000000',\n\t        stroke: null,\n\t        opacity: 1,\n\t        lineDash: null,\n\t        lineDashOffset: 0,\n\t        shadowBlur: 0,\n\t        shadowOffsetX: 0,\n\t        shadowOffsetY: 0,\n\t        lineWidth: 1,\n\t        strokeNoScale: false,\n\t        text: null,\n\t        textFill: '#000',\n\t        textStroke: null,\n\t        textPosition: 'inside',\n\t        textBaseline: null,\n\t        textAlign: null,\n\t        textVerticalAlign: null,\n\t        textDistance: 5,\n\t        textShadowBlur: 0,\n\t        textShadowOffsetX: 0,\n\t        textShadowOffsetY: 0,\n\t        textTransform: false,\n\t        textRotation: 0,\n\t        blend: null,\n\t        bind: function (ctx, el, prevEl) {\n\t            var style = this;\n\t            var prevStyle = prevEl && prevEl.style;\n\t            var firstDraw = !prevStyle;\n\t            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t                var prop = STYLE_COMMON_PROPS[i];\n\t                var styleName = prop[0];\n\t                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n\t                    // FIXME Invalid property value will cause style leak from previous element.\n\t                    ctx[styleName] = style[styleName] || prop[1];\n\t                }\n\t            }\n\t            if (firstDraw || style.fill !== prevStyle.fill) {\n\t                ctx.fillStyle = style.fill;\n\t            }\n\t            if (firstDraw || style.stroke !== prevStyle.stroke) {\n\t                ctx.strokeStyle = style.stroke;\n\t            }\n\t            if (firstDraw || style.opacity !== prevStyle.opacity) {\n\t                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n\t            }\n\t            if (firstDraw || style.blend !== prevStyle.blend) {\n\t                ctx.globalCompositeOperation = style.blend || 'source-over';\n\t            }\n\t            if (this.hasStroke()) {\n\t                var lineWidth = style.lineWidth;\n\t                ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n\t            }\n\t        },\n\t        hasFill: function () {\n\t            var fill = this.fill;\n\t            return fill != null && fill !== 'none';\n\t        },\n\t        hasStroke: function () {\n\t            var stroke = this.stroke;\n\t            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n\t        },\n\t        extendFrom: function (otherStyle, overwrite) {\n\t            if (otherStyle) {\n\t                var target = this;\n\t                for (var name in otherStyle) {\n\t                    if (otherStyle.hasOwnProperty(name) && (overwrite || !target.hasOwnProperty(name))) {\n\t                        target[name] = otherStyle[name];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        set: function (obj, value) {\n\t            if (typeof obj === 'string') {\n\t                this[obj] = value;\n\t            } else {\n\t                this.extendFrom(obj, true);\n\t            }\n\t        },\n\t        clone: function () {\n\t            var newStyle = new this.constructor();\n\t            newStyle.extendFrom(this, true);\n\t            return newStyle;\n\t        },\n\t        getGradient: function (ctx, obj, rect) {\n\t            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n\t            var canvasGradient = method(ctx, obj, rect);\n\t            var colorStops = obj.colorStops;\n\t            for (var i = 0; i < colorStops.length; i++) {\n\t                canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n\t            }\n\t            return canvasGradient;\n\t        }\n\t    };\n\t    var styleProto = Style.prototype;\n\t    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t        var prop = STYLE_COMMON_PROPS[i];\n\t        if (!(prop[0] in styleProto)) {\n\t            styleProto[prop[0]] = prop[1];\n\t        }\n\t    }\n\t    // Provide for others\n\t    Style.getGradient = styleProto.getGradient;\n\t    return Style;\n\t});\n\tdefine('zrender/graphic/mixin/RectText', ['require', '../../contain/text', '../../core/BoundingRect'], function (require) {\n\t    var textContain = require('../../contain/text');\n\t    var BoundingRect = require('../../core/BoundingRect');\n\t    var tmpRect = new BoundingRect();\n\t    var RectText = function () {\n\t    };\n\t    function parsePercent(value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    }\n\t    RectText.prototype = {\n\t        constructor: RectText,\n\t        drawRectText: function (ctx, rect, textRect) {\n\t            var style = this.style;\n\t            var text = style.text;\n\t            // Convert to string\n\t            text != null && (text += '');\n\t            if (!text) {\n\t                return;\n\t            }\n\t            // FIXME\n\t            ctx.save();\n\t            var x;\n\t            var y;\n\t            var textPosition = style.textPosition;\n\t            var distance = style.textDistance;\n\t            var align = style.textAlign;\n\t            var font = style.textFont || style.font;\n\t            var baseline = style.textBaseline;\n\t            var verticalAlign = style.textVerticalAlign;\n\t            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\t            // Transform rect to view space\n\t            var transform = this.transform;\n\t            if (!style.textTransform) {\n\t                if (transform) {\n\t                    tmpRect.copy(rect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = tmpRect;\n\t                }\n\t            } else {\n\t                this.setTransform(ctx);\n\t            }\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                // Percent\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t                align = align || 'left';\n\t                baseline = baseline || 'top';\n\t                if (verticalAlign) {\n\t                    switch (verticalAlign) {\n\t                    case 'middle':\n\t                        y -= textRect.height / 2 - textRect.lineHeight / 2;\n\t                        break;\n\t                    case 'bottom':\n\t                        y -= textRect.height - textRect.lineHeight / 2;\n\t                        break;\n\t                    default:\n\t                        y += textRect.lineHeight / 2;\n\t                    }\n\t                    // Force bseline to be middle\n\t                    baseline = 'middle';\n\t                }\n\t            } else {\n\t                var res = textContain.adjustTextPositionOnRect(textPosition, rect, textRect, distance);\n\t                x = res.x;\n\t                y = res.y;\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                baseline = baseline || res.textBaseline;\n\t            }\n\t            // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t            ctx.textAlign = align || 'left';\n\t            // Use canvas default alphabetic baseline\n\t            ctx.textBaseline = baseline || 'alphabetic';\n\t            var textFill = style.textFill;\n\t            var textStroke = style.textStroke;\n\t            textFill && (ctx.fillStyle = textFill);\n\t            textStroke && (ctx.strokeStyle = textStroke);\n\t            // TODO Invalid font\n\t            ctx.font = font || '12px sans-serif';\n\t            // Text shadow\n\t            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n\t            ctx.shadowBlur = style.textShadowBlur;\n\t            ctx.shadowColor = style.textShadowColor || 'transparent';\n\t            ctx.shadowOffsetX = style.textShadowOffsetX;\n\t            ctx.shadowOffsetY = style.textShadowOffsetY;\n\t            var textLines = text.split('\\n');\n\t            if (style.textRotation) {\n\t                transform && ctx.translate(transform[4], transform[5]);\n\t                ctx.rotate(style.textRotation);\n\t                transform && ctx.translate(-transform[4], -transform[5]);\n\t            }\n\t            for (var i = 0; i < textLines.length; i++) {\n\t                textFill && ctx.fillText(textLines[i], x, y);\n\t                textStroke && ctx.strokeText(textLines[i], x, y);\n\t                y += textRect.lineHeight;\n\t            }\n\t            ctx.restore();\n\t        }\n\t    };\n\t    return RectText;\n\t});\n\tdefine('zrender/Element', ['require', './core/guid', './mixin/Eventful', './mixin/Transformable', './mixin/Animatable', './core/util'], function (require) {\n\t    'use strict';\n\t    var guid = require('./core/guid');\n\t    var Eventful = require('./mixin/Eventful');\n\t    var Transformable = require('./mixin/Transformable');\n\t    var Animatable = require('./mixin/Animatable');\n\t    var zrUtil = require('./core/util');\n\t    /**\n\t     * @alias module:zrender/Element\n\t     * @constructor\n\t     * @extends {module:zrender/mixin/Animatable}\n\t     * @extends {module:zrender/mixin/Transformable}\n\t     * @extends {module:zrender/mixin/Eventful}\n\t     */\n\t    var Element = function (opts) {\n\t        Transformable.call(this, opts);\n\t        Eventful.call(this, opts);\n\t        Animatable.call(this, opts);\n\t        /**\n\t         * 画布元素ID\n\t         * @type {string}\n\t         */\n\t        this.id = opts.id || guid();\n\t    };\n\t    Element.prototype = {\n\t        type: 'element',\n\t        name: '',\n\t        __zr: null,\n\t        ignore: false,\n\t        clipPath: null,\n\t        drift: function (dx, dy) {\n\t            switch (this.draggable) {\n\t            case 'horizontal':\n\t                dy = 0;\n\t                break;\n\t            case 'vertical':\n\t                dx = 0;\n\t                break;\n\t            }\n\t            var m = this.transform;\n\t            if (!m) {\n\t                m = this.transform = [\n\t                    1,\n\t                    0,\n\t                    0,\n\t                    1,\n\t                    0,\n\t                    0\n\t                ];\n\t            }\n\t            m[4] += dx;\n\t            m[5] += dy;\n\t            this.decomposeTransform();\n\t            this.dirty(false);\n\t        },\n\t        beforeUpdate: function () {\n\t        },\n\t        afterUpdate: function () {\n\t        },\n\t        update: function () {\n\t            this.updateTransform();\n\t        },\n\t        traverse: function (cb, context) {\n\t        },\n\t        attrKV: function (key, value) {\n\t            if (key === 'position' || key === 'scale' || key === 'origin') {\n\t                // Copy the array\n\t                if (value) {\n\t                    var target = this[key];\n\t                    if (!target) {\n\t                        target = this[key] = [];\n\t                    }\n\t                    target[0] = value[0];\n\t                    target[1] = value[1];\n\t                }\n\t            } else {\n\t                this[key] = value;\n\t            }\n\t        },\n\t        hide: function () {\n\t            this.ignore = true;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t        show: function () {\n\t            this.ignore = false;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t        attr: function (key, value) {\n\t            if (typeof key === 'string') {\n\t                this.attrKV(key, value);\n\t            } else if (zrUtil.isObject(key)) {\n\t                for (var name in key) {\n\t                    if (key.hasOwnProperty(name)) {\n\t                        this.attrKV(name, key[name]);\n\t                    }\n\t                }\n\t            }\n\t            this.dirty(false);\n\t            return this;\n\t        },\n\t        setClipPath: function (clipPath) {\n\t            var zr = this.__zr;\n\t            if (zr) {\n\t                clipPath.addSelfToZr(zr);\n\t            }\n\t            // Remove previous clip path\n\t            if (this.clipPath && this.clipPath !== clipPath) {\n\t                this.removeClipPath();\n\t            }\n\t            this.clipPath = clipPath;\n\t            clipPath.__zr = zr;\n\t            clipPath.__clipTarget = this;\n\t            this.dirty(false);\n\t        },\n\t        removeClipPath: function () {\n\t            var clipPath = this.clipPath;\n\t            if (clipPath) {\n\t                if (clipPath.__zr) {\n\t                    clipPath.removeSelfFromZr(clipPath.__zr);\n\t                }\n\t                clipPath.__zr = null;\n\t                clipPath.__clipTarget = null;\n\t                this.clipPath = null;\n\t                this.dirty(false);\n\t            }\n\t        },\n\t        addSelfToZr: function (zr) {\n\t            this.__zr = zr;\n\t            // 添加动画\n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.addAnimator(animators[i]);\n\t                }\n\t            }\n\t            if (this.clipPath) {\n\t                this.clipPath.addSelfToZr(zr);\n\t            }\n\t        },\n\t        removeSelfFromZr: function (zr) {\n\t            this.__zr = null;\n\t            // 移除动画\n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.removeAnimator(animators[i]);\n\t                }\n\t            }\n\t            if (this.clipPath) {\n\t                this.clipPath.removeSelfFromZr(zr);\n\t            }\n\t        }\n\t    };\n\t    zrUtil.mixin(Element, Animatable);\n\t    zrUtil.mixin(Element, Transformable);\n\t    zrUtil.mixin(Element, Eventful);\n\t    return Element;\n\t});\n\tdefine('echarts/model/mixin/makeStyleMapper', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    return function (properties) {\n\t        // Normalize\n\t        for (var i = 0; i < properties.length; i++) {\n\t            if (!properties[i][1]) {\n\t                properties[i][1] = properties[i][0];\n\t            }\n\t        }\n\t        return function (excludes) {\n\t            var style = {};\n\t            for (var i = 0; i < properties.length; i++) {\n\t                var propName = properties[i][1];\n\t                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {\n\t                    continue;\n\t                }\n\t                var val = this.getShallow(propName);\n\t                if (val != null) {\n\t                    style[properties[i][0]] = val;\n\t                }\n\t            }\n\t            return style;\n\t        };\n\t    };\n\t});\n\tdefine('echarts/coord/cartesian/Cartesian', ['require', 'zrender/core/util'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    function dimAxisMapper(dim) {\n\t        return this._axes[dim];\n\t    }\n\t    /**\n\t     * @alias module:echarts/coord/Cartesian\n\t     * @constructor\n\t     */\n\t    var Cartesian = function (name) {\n\t        this._axes = {};\n\t        this._dimList = [];\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.name = name || '';\n\t    };\n\t    Cartesian.prototype = {\n\t        constructor: Cartesian,\n\t        type: 'cartesian',\n\t        getAxis: function (dim) {\n\t            return this._axes[dim];\n\t        },\n\t        getAxes: function () {\n\t            return zrUtil.map(this._dimList, dimAxisMapper, this);\n\t        },\n\t        getAxesByScale: function (scaleType) {\n\t            scaleType = scaleType.toLowerCase();\n\t            return zrUtil.filter(this.getAxes(), function (axis) {\n\t                return axis.scale.type === scaleType;\n\t            });\n\t        },\n\t        addAxis: function (axis) {\n\t            var dim = axis.dim;\n\t            this._axes[dim] = axis;\n\t            this._dimList.push(dim);\n\t        },\n\t        dataToCoord: function (val) {\n\t            return this._dataCoordConvert(val, 'dataToCoord');\n\t        },\n\t        coordToData: function (val) {\n\t            return this._dataCoordConvert(val, 'coordToData');\n\t        },\n\t        _dataCoordConvert: function (input, method) {\n\t            var dimList = this._dimList;\n\t            var output = input instanceof Array ? [] : {};\n\t            for (var i = 0; i < dimList.length; i++) {\n\t                var dim = dimList[i];\n\t                var axis = this._axes[dim];\n\t                output[dim] = axis[method](input[dim]);\n\t            }\n\t            return output;\n\t        }\n\t    };\n\t    return Cartesian;\n\t});\n\tdefine('zrender/core/guid', [], function () {\n\t    var idStart = 2311;\n\t    return function () {\n\t        return idStart++;\n\t    };\n\t});\n\tdefine('zrender/mixin/Transformable', ['require', '../core/matrix', '../core/vector'], function (require) {\n\t    'use strict';\n\t    var matrix = require('../core/matrix');\n\t    var vector = require('../core/vector');\n\t    var mIdentity = matrix.identity;\n\t    var EPSILON = 0.00005;\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t    /**\n\t     * @alias module:zrender/mixin/Transformable\n\t     * @constructor\n\t     */\n\t    var Transformable = function (opts) {\n\t        opts = opts || {};\n\t        // If there are no given position, rotation, scale\n\t        if (!opts.position) {\n\t            /**\n\t             * 平移\n\t             * @type {Array.<number>}\n\t             * @default [0, 0]\n\t             */\n\t            this.position = [\n\t                0,\n\t                0\n\t            ];\n\t        }\n\t        if (opts.rotation == null) {\n\t            /**\n\t             * 旋转\n\t             * @type {Array.<number>}\n\t             * @default 0\n\t             */\n\t            this.rotation = 0;\n\t        }\n\t        if (!opts.scale) {\n\t            /**\n\t             * 缩放\n\t             * @type {Array.<number>}\n\t             * @default [1, 1]\n\t             */\n\t            this.scale = [\n\t                1,\n\t                1\n\t            ];\n\t        }\n\t        /**\n\t         * 旋转和缩放的原点\n\t         * @type {Array.<number>}\n\t         * @default null\n\t         */\n\t        this.origin = this.origin || null;\n\t    };\n\t    var transformableProto = Transformable.prototype;\n\t    transformableProto.transform = null;\n\t    /**\n\t     * 判断是否需要有坐标变换\n\t     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n\t     */\n\t    transformableProto.needLocalTransform = function () {\n\t        return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n\t    };\n\t    transformableProto.updateTransform = function () {\n\t        var parent = this.parent;\n\t        var parentHasTransform = parent && parent.transform;\n\t        var needLocalTransform = this.needLocalTransform();\n\t        var m = this.transform;\n\t        if (!(needLocalTransform || parentHasTransform)) {\n\t            m && mIdentity(m);\n\t            return;\n\t        }\n\t        m = m || matrix.create();\n\t        if (needLocalTransform) {\n\t            this.getLocalTransform(m);\n\t        } else {\n\t            mIdentity(m);\n\t        }\n\t        // 应用父节点变换\n\t        if (parentHasTransform) {\n\t            if (needLocalTransform) {\n\t                matrix.mul(m, parent.transform, m);\n\t            } else {\n\t                matrix.copy(m, parent.transform);\n\t            }\n\t        }\n\t        // 保存这个变换矩阵\n\t        this.transform = m;\n\t        this.invTransform = this.invTransform || matrix.create();\n\t        matrix.invert(this.invTransform, m);\n\t    };\n\t    transformableProto.getLocalTransform = function (m) {\n\t        m = m || [];\n\t        mIdentity(m);\n\t        var origin = this.origin;\n\t        var scale = this.scale;\n\t        var rotation = this.rotation;\n\t        var position = this.position;\n\t        if (origin) {\n\t            // Translate to origin\n\t            m[4] -= origin[0];\n\t            m[5] -= origin[1];\n\t        }\n\t        matrix.scale(m, m, scale);\n\t        if (rotation) {\n\t            matrix.rotate(m, m, rotation);\n\t        }\n\t        if (origin) {\n\t            // Translate back from origin\n\t            m[4] += origin[0];\n\t            m[5] += origin[1];\n\t        }\n\t        m[4] += position[0];\n\t        m[5] += position[1];\n\t        return m;\n\t    };\n\t    /**\n\t     * 将自己的transform应用到context上\n\t     * @param {Context2D} ctx\n\t     */\n\t    transformableProto.setTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        if (m) {\n\t            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n\t        } else {\n\t            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t        }\n\t    };\n\t    transformableProto.restoreTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t    };\n\t    var tmpTransform = [];\n\t    /**\n\t     * 分解`transform`矩阵到`position`, `rotation`, `scale`\n\t     */\n\t    transformableProto.decomposeTransform = function () {\n\t        if (!this.transform) {\n\t            return;\n\t        }\n\t        var parent = this.parent;\n\t        var m = this.transform;\n\t        if (parent && parent.transform) {\n\t            // Get local transform and decompose them to position, scale, rotation\n\t            matrix.mul(tmpTransform, parent.invTransform, m);\n\t            m = tmpTransform;\n\t        }\n\t        var sx = m[0] * m[0] + m[1] * m[1];\n\t        var sy = m[2] * m[2] + m[3] * m[3];\n\t        var position = this.position;\n\t        var scale = this.scale;\n\t        if (isNotAroundZero(sx - 1)) {\n\t            sx = Math.sqrt(sx);\n\t        }\n\t        if (isNotAroundZero(sy - 1)) {\n\t            sy = Math.sqrt(sy);\n\t        }\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        position[0] = m[4];\n\t        position[1] = m[5];\n\t        scale[0] = sx;\n\t        scale[1] = sy;\n\t        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n\t    };\n\t    /**\n\t     * Get global scale\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.getGlobalScale = function () {\n\t        var m = this.transform;\n\t        if (!m) {\n\t            return [\n\t                1,\n\t                1\n\t            ];\n\t        }\n\t        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n\t        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        return [\n\t            sx,\n\t            sy\n\t        ];\n\t    };\n\t    /**\n\t     * 变换坐标位置到 shape 的局部坐标空间\n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToLocal = function (x, y) {\n\t        var v2 = [\n\t                x,\n\t                y\n\t            ];\n\t        var invTransform = this.invTransform;\n\t        if (invTransform) {\n\t            vector.applyTransform(v2, v2, invTransform);\n\t        }\n\t        return v2;\n\t    };\n\t    /**\n\t     * 变换局部坐标位置到全局坐标空间\n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToGlobal = function (x, y) {\n\t        var v2 = [\n\t                x,\n\t                y\n\t            ];\n\t        var transform = this.transform;\n\t        if (transform) {\n\t            vector.applyTransform(v2, v2, transform);\n\t        }\n\t        return v2;\n\t    };\n\t    return Transformable;\n\t});\n\tdefine('zrender/mixin/Animatable', ['require', '../animation/Animator', '../core/util', '../core/log'], function (require) {\n\t    'use strict';\n\t    var Animator = require('../animation/Animator');\n\t    var util = require('../core/util');\n\t    var isString = util.isString;\n\t    var isFunction = util.isFunction;\n\t    var isObject = util.isObject;\n\t    var log = require('../core/log');\n\t    /**\n\t     * @alias modue:zrender/mixin/Animatable\n\t     * @constructor\n\t     */\n\t    var Animatable = function () {\n\t        /**\n\t         * @type {Array.<module:zrender/animation/Animator>}\n\t         * @readOnly\n\t         */\n\t        this.animators = [];\n\t    };\n\t    Animatable.prototype = {\n\t        constructor: Animatable,\n\t        animate: function (path, loop) {\n\t            var target;\n\t            var animatingShape = false;\n\t            var el = this;\n\t            var zr = this.__zr;\n\t            if (path) {\n\t                var pathSplitted = path.split('.');\n\t                var prop = el;\n\t                // If animating shape\n\t                animatingShape = pathSplitted[0] === 'shape';\n\t                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n\t                    if (!prop) {\n\t                        continue;\n\t                    }\n\t                    prop = prop[pathSplitted[i]];\n\t                }\n\t                if (prop) {\n\t                    target = prop;\n\t                }\n\t            } else {\n\t                target = el;\n\t            }\n\t            if (!target) {\n\t                log('Property \"' + path + '\" is not existed in element ' + el.id);\n\t                return;\n\t            }\n\t            var animators = el.animators;\n\t            var animator = new Animator(target, loop);\n\t            animator.during(function (target) {\n\t                el.dirty(animatingShape);\n\t            }).done(function () {\n\t                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n\t                animators.splice(util.indexOf(animators, animator), 1);\n\t            });\n\t            animators.push(animator);\n\t            // If animate after added to the zrender\n\t            if (zr) {\n\t                zr.animation.addAnimator(animator);\n\t            }\n\t            return animator;\n\t        },\n\t        stopAnimation: function (forwardToLast) {\n\t            var animators = this.animators;\n\t            var len = animators.length;\n\t            for (var i = 0; i < len; i++) {\n\t                animators[i].stop(forwardToLast);\n\t            }\n\t            animators.length = 0;\n\t            return this;\n\t        },\n\t        animateTo: function (target, time, delay, easing, callback) {\n\t            // animateTo(target, time, easing, callback);\n\t            if (isString(delay)) {\n\t                callback = easing;\n\t                easing = delay;\n\t                delay = 0;\n\t            }    // animateTo(target, time, delay, callback);\n\t            else if (isFunction(easing)) {\n\t                callback = easing;\n\t                easing = 'linear';\n\t                delay = 0;\n\t            }    // animateTo(target, time, callback);\n\t            else if (isFunction(delay)) {\n\t                callback = delay;\n\t                delay = 0;\n\t            }    // animateTo(target, callback)\n\t            else if (isFunction(time)) {\n\t                callback = time;\n\t                time = 500;\n\t            }    // animateTo(target)\n\t            else if (!time) {\n\t                time = 500;\n\t            }\n\t            // Stop all previous animations\n\t            this.stopAnimation();\n\t            this._animateToShallow('', this, target, time, delay, easing, callback);\n\t            // Animators may be removed immediately after start\n\t            // if there is nothing to animate\n\t            var animators = this.animators.slice();\n\t            var count = animators.length;\n\t            function done() {\n\t                count--;\n\t                if (!count) {\n\t                    callback && callback();\n\t                }\n\t            }\n\t            // No animators. This should be checked before animators[i].start(),\n\t            // because 'done' may be executed immediately if no need to animate.\n\t            if (!count) {\n\t                callback && callback();\n\t            }\n\t            // Start after all animators created\n\t            // Incase any animator is done immediately when all animation properties are not changed\n\t            for (var i = 0; i < animators.length; i++) {\n\t                animators[i].done(done).start(easing);\n\t            }\n\t        },\n\t        _animateToShallow: function (path, source, target, time, delay) {\n\t            var objShallow = {};\n\t            var propertyCount = 0;\n\t            for (var name in target) {\n\t                if (source[name] != null) {\n\t                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n\t                        this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n\t                    } else {\n\t                        objShallow[name] = target[name];\n\t                        propertyCount++;\n\t                    }\n\t                } else if (target[name] != null) {\n\t                    // Attr directly if not has property\n\t                    // FIXME, if some property not needed for element ?\n\t                    if (!path) {\n\t                        this.attr(name, target[name]);\n\t                    } else {\n\t                        // Shape or style\n\t                        var props = {};\n\t                        props[path] = {};\n\t                        props[path][name] = target[name];\n\t                        this.attr(props);\n\t                    }\n\t                }\n\t            }\n\t            if (propertyCount > 0) {\n\t                this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n\t            }\n\t            return this;\n\t        }\n\t    };\n\t    return Animatable;\n\t});\n\tdefine('echarts/util/component', ['require', 'zrender/core/util', './clazz'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var clazz = require('./clazz');\n\t    var parseClassType = clazz.parseClassType;\n\t    var base = 0;\n\t    var componentUtil = {};\n\t    var DELIMITER = '_';\n\t    /**\n\t     * @public\n\t     * @param {string} type\n\t     * @return {string}\n\t     */\n\t    componentUtil.getUID = function (type) {\n\t        // Considering the case of crossing js context,\n\t        // use Math.random to make id as unique as possible.\n\t        return [\n\t            type || '',\n\t            base++,\n\t            Math.random()\n\t        ].join(DELIMITER);\n\t    };\n\t    /**\n\t     * @inner\n\t     */\n\t    componentUtil.enableSubTypeDefaulter = function (entity) {\n\t        var subTypeDefaulters = {};\n\t        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n\t            componentType = parseClassType(componentType);\n\t            subTypeDefaulters[componentType.main] = defaulter;\n\t        };\n\t        entity.determineSubType = function (componentType, option) {\n\t            var type = option.type;\n\t            if (!type) {\n\t                var componentTypeMain = parseClassType(componentType).main;\n\t                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n\t                    type = subTypeDefaulters[componentTypeMain](option);\n\t                }\n\t            }\n\t            return type;\n\t        };\n\t        return entity;\n\t    };\n\t    /**\n\t     * Topological travel on Activity Network (Activity On Vertices).\n\t     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n\t     *\n\t     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n\t     *\n\t     * If there is circle dependencey, Error will be thrown.\n\t     *\n\t     */\n\t    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\t        /**\n\t         * @public\n\t         * @param {Array.<string>} targetNameList Target Component type list.\n\t         *                                           Can be ['aa', 'bb', 'aa.xx']\n\t         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n\t         * @param {Function} callback Params: componentType, dependencies.\n\t         * @param {Object} context Scope of callback.\n\t         */\n\t        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n\t            if (!targetNameList.length) {\n\t                return;\n\t            }\n\t            var result = makeDepndencyGraph(fullNameList);\n\t            var graph = result.graph;\n\t            var stack = result.noEntryList;\n\t            var targetNameSet = {};\n\t            zrUtil.each(targetNameList, function (name) {\n\t                targetNameSet[name] = true;\n\t            });\n\t            while (stack.length) {\n\t                var currComponentType = stack.pop();\n\t                var currVertex = graph[currComponentType];\n\t                var isInTargetNameSet = !!targetNameSet[currComponentType];\n\t                if (isInTargetNameSet) {\n\t                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n\t                    delete targetNameSet[currComponentType];\n\t                }\n\t                zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);\n\t            }\n\t            zrUtil.each(targetNameSet, function () {\n\t                throw new Error('Circle dependency may exists');\n\t            });\n\t            function removeEdge(succComponentType) {\n\t                graph[succComponentType].entryCount--;\n\t                if (graph[succComponentType].entryCount === 0) {\n\t                    stack.push(succComponentType);\n\t                }\n\t            }\n\t            // Consider this case: legend depends on series, and we call\n\t            // chart.setOption({series: [...]}), where only series is in option.\n\t            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n\t            // not be called, but only sereis.mergeOption is called. Thus legend\n\t            // have no chance to update its local record about series (like which\n\t            // name of series is available in legend).\n\t            function removeEdgeAndAdd(succComponentType) {\n\t                targetNameSet[succComponentType] = true;\n\t                removeEdge(succComponentType);\n\t            }\n\t        };\n\t        /**\n\t         * DepndencyGraph: {Object}\n\t         * key: conponentType,\n\t         * value: {\n\t         *     successor: [conponentTypes...],\n\t         *     originalDeps: [conponentTypes...],\n\t         *     entryCount: {number}\n\t         * }\n\t         */\n\t        function makeDepndencyGraph(fullNameList) {\n\t            var graph = {};\n\t            var noEntryList = [];\n\t            zrUtil.each(fullNameList, function (name) {\n\t                var thisItem = createDependencyGraphItem(graph, name);\n\t                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\t                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n\t                thisItem.entryCount = availableDeps.length;\n\t                if (thisItem.entryCount === 0) {\n\t                    noEntryList.push(name);\n\t                }\n\t                zrUtil.each(availableDeps, function (dependentName) {\n\t                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n\t                        thisItem.predecessor.push(dependentName);\n\t                    }\n\t                    var thatItem = createDependencyGraphItem(graph, dependentName);\n\t                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n\t                        thatItem.successor.push(name);\n\t                    }\n\t                });\n\t            });\n\t            return {\n\t                graph: graph,\n\t                noEntryList: noEntryList\n\t            };\n\t        }\n\t        function createDependencyGraphItem(graph, name) {\n\t            if (!graph[name]) {\n\t                graph[name] = {\n\t                    predecessor: [],\n\t                    successor: []\n\t                };\n\t            }\n\t            return graph[name];\n\t        }\n\t        function getAvailableDependencies(originalDeps, fullNameList) {\n\t            var availableDeps = [];\n\t            zrUtil.each(originalDeps, function (dep) {\n\t                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n\t            });\n\t            return availableDeps;\n\t        }\n\t    };\n\t    return componentUtil;\n\t});\n\tdefine('echarts/model/mixin/boxLayout', ['require'], function (require) {\n\t    return {\n\t        getBoxLayoutParams: function () {\n\t            return {\n\t                left: this.get('left'),\n\t                top: this.get('top'),\n\t                right: this.get('right'),\n\t                bottom: this.get('bottom'),\n\t                width: this.get('width'),\n\t                height: this.get('height')\n\t            };\n\t        }\n\t    };\n\t});\n\tdefine('echarts/coord/Axis', ['require', '../util/number', 'zrender/core/util'], function (require) {\n\t    var numberUtil = require('../util/number');\n\t    var linearMap = numberUtil.linearMap;\n\t    var zrUtil = require('zrender/core/util');\n\t    function fixExtentWithBands(extent, nTick) {\n\t        var size = extent[1] - extent[0];\n\t        var len = nTick;\n\t        var margin = size / len / 2;\n\t        extent[0] += margin;\n\t        extent[1] -= margin;\n\t    }\n\t    var normalizedExtent = [\n\t            0,\n\t            1\n\t        ];\n\t    /**\n\t     * @name module:echarts/coord/CartesianAxis\n\t     * @constructor\n\t     */\n\t    var Axis = function (dim, scale, extent) {\n\t        /**\n\t         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n\t         * @type {string}\n\t         */\n\t        this.dim = dim;\n\t        /**\n\t         * Axis scale\n\t         * @type {module:echarts/coord/scale/*}\n\t         */\n\t        this.scale = scale;\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        this._extent = extent || [\n\t            0,\n\t            0\n\t        ];\n\t        /**\n\t         * @type {boolean}\n\t         */\n\t        this.inverse = false;\n\t        /**\n\t         * Usually true when axis has a ordinal scale\n\t         * @type {boolean}\n\t         */\n\t        this.onBand = false;\n\t    };\n\t    Axis.prototype = {\n\t        constructor: Axis,\n\t        contain: function (coord) {\n\t            var extent = this._extent;\n\t            var min = Math.min(extent[0], extent[1]);\n\t            var max = Math.max(extent[0], extent[1]);\n\t            return coord >= min && coord <= max;\n\t        },\n\t        containData: function (data) {\n\t            return this.contain(this.dataToCoord(data));\n\t        },\n\t        getExtent: function () {\n\t            var ret = this._extent.slice();\n\t            return ret;\n\t        },\n\t        getPixelPrecision: function (dataExtent) {\n\t            return numberUtil.getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);\n\t        },\n\t        setExtent: function (start, end) {\n\t            var extent = this._extent;\n\t            extent[0] = start;\n\t            extent[1] = end;\n\t        },\n\t        dataToCoord: function (data, clamp) {\n\t            var extent = this._extent;\n\t            var scale = this.scale;\n\t            data = scale.normalize(data);\n\t            if (this.onBand && scale.type === 'ordinal') {\n\t                extent = extent.slice();\n\t                fixExtentWithBands(extent, scale.count());\n\t            }\n\t            return linearMap(data, normalizedExtent, extent, clamp);\n\t        },\n\t        coordToData: function (coord, clamp) {\n\t            var extent = this._extent;\n\t            var scale = this.scale;\n\t            if (this.onBand && scale.type === 'ordinal') {\n\t                extent = extent.slice();\n\t                fixExtentWithBands(extent, scale.count());\n\t            }\n\t            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\t            return this.scale.scale(t);\n\t        },\n\t        getTicksCoords: function (alignWithLabel) {\n\t            if (this.onBand && !alignWithLabel) {\n\t                var bands = this.getBands();\n\t                var coords = [];\n\t                for (var i = 0; i < bands.length; i++) {\n\t                    coords.push(bands[i][0]);\n\t                }\n\t                if (bands[i - 1]) {\n\t                    coords.push(bands[i - 1][1]);\n\t                }\n\t                return coords;\n\t            } else {\n\t                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n\t            }\n\t        },\n\t        getLabelsCoords: function () {\n\t            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n\t        },\n\t        getBands: function () {\n\t            var extent = this.getExtent();\n\t            var bands = [];\n\t            var len = this.scale.count();\n\t            var start = extent[0];\n\t            var end = extent[1];\n\t            var span = end - start;\n\t            for (var i = 0; i < len; i++) {\n\t                bands.push([\n\t                    span * i / len + start,\n\t                    span * (i + 1) / len + start\n\t                ]);\n\t            }\n\t            return bands;\n\t        },\n\t        getBandWidth: function () {\n\t            var axisExtent = this._extent;\n\t            var dataExtent = this.scale.getExtent();\n\t            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n\t            // Fix #2728, avoid NaN when only one data.\n\t            len === 0 && (len = 1);\n\t            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\t            return Math.abs(size) / len;\n\t        }\n\t    };\n\t    return Axis;\n\t});\n\tdefine('echarts/coord/cartesian/axisLabelInterval', ['require', 'zrender/core/util', '../axisHelper'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var axisHelper = require('../axisHelper');\n\t    return function (axis) {\n\t        var axisModel = axis.model;\n\t        var labelModel = axisModel.getModel('axisLabel');\n\t        var labelInterval = labelModel.get('interval');\n\t        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n\t            return labelInterval === 'auto' ? 0 : labelInterval;\n\t        }\n\t        return axisHelper.getAxisLabelInterval(zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis), axisModel.getFormattedLabels(), labelModel.getModel('textStyle').getFont(), axis.isHorizontal());\n\t    };\n\t});\n\tdefine('zrender/core/log', ['require', '../config'], function (require) {\n\t    var config = require('../config');\n\t    /**\n\t         * @exports zrender/tool/log\n\t         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t         */\n\t    return function () {\n\t        if (config.debugMode === 0) {\n\t            return;\n\t        } else if (config.debugMode == 1) {\n\t            for (var k in arguments) {\n\t                throw new Error(arguments[k]);\n\t            }\n\t        } else if (config.debugMode > 1) {\n\t            for (var k in arguments) {\n\t                console.log(arguments[k]);\n\t            }\n\t        }\n\t    };    /* for debug\n\t        return function(mes) {\n\t            document.getElementById('wrong-message').innerHTML =\n\t                mes + ' ' + (new Date() - 0)\n\t                + '<br/>' \n\t                + document.getElementById('wrong-message').innerHTML;\n\t        };\n\t        */\n\t});\n\tdefine('zrender/animation/Animator', ['require', './Clip', '../tool/color', '../core/util'], function (require) {\n\t    var Clip = require('./Clip');\n\t    var color = require('../tool/color');\n\t    var util = require('../core/util');\n\t    var isArrayLike = util.isArrayLike;\n\t    var arraySlice = Array.prototype.slice;\n\t    function defaultGetter(target, key) {\n\t        return target[key];\n\t    }\n\t    function defaultSetter(target, key, value) {\n\t        target[key] = value;\n\t    }\n\t    /**\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} percent\n\t     * @return {number}\n\t     */\n\t    function interpolateNumber(p0, p1, percent) {\n\t        return (p1 - p0) * percent + p0;\n\t    }\n\t    /**\n\t     * @param  {string} p0\n\t     * @param  {string} p1\n\t     * @param  {number} percent\n\t     * @return {string}\n\t     */\n\t    function interpolateString(p0, p1, percent) {\n\t        return percent > 0.5 ? p1 : p0;\n\t    }\n\t    /**\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {number} percent\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function interpolateArray(p0, p1, percent, out, arrDim) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = interpolateNumber(p0[i], p1[i], percent);\n\t            }\n\t        } else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    // arr0 is source array, arr1 is target array.\n\t    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\t    function fillArr(arr0, arr1, arrDim) {\n\t        var arr0Len = arr0.length;\n\t        var arr1Len = arr1.length;\n\t        if (arr0Len !== arr1Len) {\n\t            // FIXME Not work for TypedArray\n\t            var isPreviousLarger = arr0Len > arr1Len;\n\t            if (isPreviousLarger) {\n\t                // Cut the previous\n\t                arr0.length = arr1Len;\n\t            } else {\n\t                // Fill the previous\n\t                for (var i = arr0Len; i < arr1Len; i++) {\n\t                    arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n\t                }\n\t            }\n\t        }\n\t        // Handling NaN value\n\t        var len2 = arr0[0] && arr0[0].length;\n\t        for (var i = 0; i < arr0.length; i++) {\n\t            if (arrDim === 1) {\n\t                if (isNaN(arr0[i])) {\n\t                    arr0[i] = arr1[i];\n\t                }\n\t            } else {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (isNaN(arr0[i][j])) {\n\t                        arr0[i][j] = arr1[i][j];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @param  {Array} arr0\n\t     * @param  {Array} arr1\n\t     * @param  {number} arrDim\n\t     * @return {boolean}\n\t     */\n\t    function isArraySame(arr0, arr1, arrDim) {\n\t        if (arr0 === arr1) {\n\t            return true;\n\t        }\n\t        var len = arr0.length;\n\t        if (len !== arr1.length) {\n\t            return false;\n\t        }\n\t        if (arrDim === 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                if (arr0[i] !== arr1[i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        } else {\n\t            var len2 = arr0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (arr0[i][j] !== arr1[i][j]) {\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    /**\n\t     * Catmull Rom interpolate array\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {Array} p2\n\t     * @param  {Array} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n\t            }\n\t        } else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * Catmull Rom interpolate number\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @return {number}\n\t     */\n\t    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t    }\n\t    function cloneValue(value) {\n\t        if (isArrayLike(value)) {\n\t            var len = value.length;\n\t            if (isArrayLike(value[0])) {\n\t                var ret = [];\n\t                for (var i = 0; i < len; i++) {\n\t                    ret.push(arraySlice.call(value[i]));\n\t                }\n\t                return ret;\n\t            }\n\t            return arraySlice.call(value);\n\t        }\n\t        return value;\n\t    }\n\t    function rgba2String(rgba) {\n\t        rgba[0] = Math.floor(rgba[0]);\n\t        rgba[1] = Math.floor(rgba[1]);\n\t        rgba[2] = Math.floor(rgba[2]);\n\t        return 'rgba(' + rgba.join(',') + ')';\n\t    }\n\t    function createTrackClip(animator, easing, oneTrackDone, keyframes, propName) {\n\t        var getter = animator._getter;\n\t        var setter = animator._setter;\n\t        var useSpline = easing === 'spline';\n\t        var trackLen = keyframes.length;\n\t        if (!trackLen) {\n\t            return;\n\t        }\n\t        // Guess data type\n\t        var firstVal = keyframes[0].value;\n\t        var isValueArray = isArrayLike(firstVal);\n\t        var isValueColor = false;\n\t        var isValueString = false;\n\t        // For vertices morphing\n\t        var arrDim = isValueArray && isArrayLike(firstVal[0]) ? 2 : 1;\n\t        var trackMaxTime;\n\t        // Sort keyframe as ascending\n\t        keyframes.sort(function (a, b) {\n\t            return a.time - b.time;\n\t        });\n\t        trackMaxTime = keyframes[trackLen - 1].time;\n\t        // Percents of each keyframe\n\t        var kfPercents = [];\n\t        // Value of each keyframe\n\t        var kfValues = [];\n\t        var prevValue = keyframes[0].value;\n\t        var isAllValueEqual = true;\n\t        for (var i = 0; i < trackLen; i++) {\n\t            kfPercents.push(keyframes[i].time / trackMaxTime);\n\t            // Assume value is a color when it is a string\n\t            var value = keyframes[i].value;\n\t            // Check if value is equal, deep check if value is array\n\t            if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n\t                isAllValueEqual = false;\n\t            }\n\t            prevValue = value;\n\t            // Try converting a string to a color array\n\t            if (typeof value == 'string') {\n\t                var colorArray = color.parse(value);\n\t                if (colorArray) {\n\t                    value = colorArray;\n\t                    isValueColor = true;\n\t                } else {\n\t                    isValueString = true;\n\t                }\n\t            }\n\t            kfValues.push(value);\n\t        }\n\t        if (isAllValueEqual) {\n\t            return;\n\t        }\n\t        var lastValue = kfValues[trackLen - 1];\n\t        // Polyfill array and NaN value\n\t        for (var i = 0; i < trackLen - 1; i++) {\n\t            if (isValueArray) {\n\t                fillArr(kfValues[i], lastValue, arrDim);\n\t            } else {\n\t                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n\t                    kfValues[i] = lastValue;\n\t                }\n\t            }\n\t        }\n\t        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\t        // Cache the key of last frame to speed up when\n\t        // animation playback is sequency\n\t        var lastFrame = 0;\n\t        var lastFramePercent = 0;\n\t        var start;\n\t        var w;\n\t        var p0;\n\t        var p1;\n\t        var p2;\n\t        var p3;\n\t        if (isValueColor) {\n\t            var rgba = [\n\t                    0,\n\t                    0,\n\t                    0,\n\t                    0\n\t                ];\n\t        }\n\t        var onframe = function (target, percent) {\n\t            // Find the range keyframes\n\t            // kf1-----kf2---------current--------kf3\n\t            // find kf2 and kf3 and do interpolation\n\t            var frame;\n\t            // In the easing function like elasticOut, percent may less than 0\n\t            if (percent < 0) {\n\t                frame = 0;\n\t            } else if (percent < lastFramePercent) {\n\t                // Start from next key\n\t                // PENDING start from lastFrame ?\n\t                start = Math.min(lastFrame + 1, trackLen - 1);\n\t                for (frame = start; frame >= 0; frame--) {\n\t                    if (kfPercents[frame] <= percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                // PENDING really need to do this ?\n\t                frame = Math.min(frame, trackLen - 2);\n\t            } else {\n\t                for (frame = lastFrame; frame < trackLen; frame++) {\n\t                    if (kfPercents[frame] > percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                frame = Math.min(frame - 1, trackLen - 2);\n\t            }\n\t            lastFrame = frame;\n\t            lastFramePercent = percent;\n\t            var range = kfPercents[frame + 1] - kfPercents[frame];\n\t            if (range === 0) {\n\t                return;\n\t            } else {\n\t                w = (percent - kfPercents[frame]) / range;\n\t            }\n\t            if (useSpline) {\n\t                p1 = kfValues[frame];\n\t                p0 = kfValues[frame === 0 ? frame : frame - 1];\n\t                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n\t                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\t                if (isValueArray) {\n\t                    catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n\t                } else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n\t                        value = rgba2String(rgba);\n\t                    } else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(p1, p2, w);\n\t                    } else {\n\t                        value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n\t                    }\n\t                    setter(target, propName, value);\n\t                }\n\t            } else {\n\t                if (isValueArray) {\n\t                    interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n\t                } else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n\t                        value = rgba2String(rgba);\n\t                    } else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n\t                    } else {\n\t                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    setter(target, propName, value);\n\t                }\n\t            }\n\t        };\n\t        var clip = new Clip({\n\t                target: animator._target,\n\t                life: trackMaxTime,\n\t                loop: animator._loop,\n\t                delay: animator._delay,\n\t                onframe: onframe,\n\t                ondestroy: oneTrackDone\n\t            });\n\t        if (easing && easing !== 'spline') {\n\t            clip.easing = easing;\n\t        }\n\t        return clip;\n\t    }\n\t    /**\n\t     * @alias module:zrender/animation/Animator\n\t     * @constructor\n\t     * @param {Object} target\n\t     * @param {boolean} loop\n\t     * @param {Function} getter\n\t     * @param {Function} setter\n\t     */\n\t    var Animator = function (target, loop, getter, setter) {\n\t        this._tracks = {};\n\t        this._target = target;\n\t        this._loop = loop || false;\n\t        this._getter = getter || defaultGetter;\n\t        this._setter = setter || defaultSetter;\n\t        this._clipCount = 0;\n\t        this._delay = 0;\n\t        this._doneList = [];\n\t        this._onframeList = [];\n\t        this._clipList = [];\n\t    };\n\t    Animator.prototype = {\n\t        when: function (time, props) {\n\t            var tracks = this._tracks;\n\t            for (var propName in props) {\n\t                if (!tracks[propName]) {\n\t                    tracks[propName] = [];\n\t                    // Invalid value\n\t                    var value = this._getter(this._target, propName);\n\t                    if (value == null) {\n\t                        // zrLog('Invalid property ' + propName);\n\t                        continue;\n\t                    }\n\t                    // If time is 0\n\t                    //  Then props is given initialize value\n\t                    // Else\n\t                    //  Initialize value from current prop value\n\t                    if (time !== 0) {\n\t                        tracks[propName].push({\n\t                            time: 0,\n\t                            value: cloneValue(value)\n\t                        });\n\t                    }\n\t                }\n\t                tracks[propName].push({\n\t                    time: time,\n\t                    value: props[propName]\n\t                });\n\t            }\n\t            return this;\n\t        },\n\t        during: function (callback) {\n\t            this._onframeList.push(callback);\n\t            return this;\n\t        },\n\t        _doneCallback: function () {\n\t            // Clear all tracks\n\t            this._tracks = {};\n\t            // Clear all clips\n\t            this._clipList.length = 0;\n\t            var doneList = this._doneList;\n\t            var len = doneList.length;\n\t            for (var i = 0; i < len; i++) {\n\t                doneList[i].call(this);\n\t            }\n\t        },\n\t        start: function (easing) {\n\t            var self = this;\n\t            var clipCount = 0;\n\t            var oneTrackDone = function () {\n\t                clipCount--;\n\t                if (!clipCount) {\n\t                    self._doneCallback();\n\t                }\n\t            };\n\t            var lastClip;\n\t            for (var propName in this._tracks) {\n\t                var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName);\n\t                if (clip) {\n\t                    this._clipList.push(clip);\n\t                    clipCount++;\n\t                    // If start after added to animation\n\t                    if (this.animation) {\n\t                        this.animation.addClip(clip);\n\t                    }\n\t                    lastClip = clip;\n\t                }\n\t            }\n\t            // Add during callback on the last clip\n\t            if (lastClip) {\n\t                var oldOnFrame = lastClip.onframe;\n\t                lastClip.onframe = function (target, percent) {\n\t                    oldOnFrame(target, percent);\n\t                    for (var i = 0; i < self._onframeList.length; i++) {\n\t                        self._onframeList[i](target, percent);\n\t                    }\n\t                };\n\t            }\n\t            if (!clipCount) {\n\t                this._doneCallback();\n\t            }\n\t            return this;\n\t        },\n\t        stop: function (forwardToLast) {\n\t            var clipList = this._clipList;\n\t            var animation = this.animation;\n\t            for (var i = 0; i < clipList.length; i++) {\n\t                var clip = clipList[i];\n\t                if (forwardToLast) {\n\t                    // Move to last frame before stop\n\t                    clip.onframe(this._target, 1);\n\t                }\n\t                animation && animation.removeClip(clip);\n\t            }\n\t            clipList.length = 0;\n\t        },\n\t        delay: function (time) {\n\t            this._delay = time;\n\t            return this;\n\t        },\n\t        done: function (cb) {\n\t            if (cb) {\n\t                this._doneList.push(cb);\n\t            }\n\t            return this;\n\t        },\n\t        getClips: function () {\n\t            return this._clipList;\n\t        }\n\t    };\n\t    return Animator;\n\t});\n\tdefine('echarts/coord/cartesian/AxisModel', ['require', '../../model/Component', 'zrender/core/util', '../axisModelCreator', '../axisModelCommonMixin'], function (require) {\n\t    'use strict';\n\t    var ComponentModel = require('../../model/Component');\n\t    var zrUtil = require('zrender/core/util');\n\t    var axisModelCreator = require('../axisModelCreator');\n\t    var AxisModel = ComponentModel.extend({\n\t            type: 'cartesian2dAxis',\n\t            axis: null,\n\t            init: function () {\n\t                AxisModel.superApply(this, 'init', arguments);\n\t                this._resetRange();\n\t            },\n\t            mergeOption: function () {\n\t                AxisModel.superApply(this, 'mergeOption', arguments);\n\t                this._resetRange();\n\t            },\n\t            restoreData: function () {\n\t                AxisModel.superApply(this, 'restoreData', arguments);\n\t                this._resetRange();\n\t            },\n\t            setRange: function (rangeStart, rangeEnd) {\n\t                this.option.rangeStart = rangeStart;\n\t                this.option.rangeEnd = rangeEnd;\n\t            },\n\t            getMin: function () {\n\t                var option = this.option;\n\t                return option.rangeStart != null ? option.rangeStart : option.min;\n\t            },\n\t            getMax: function () {\n\t                var option = this.option;\n\t                return option.rangeEnd != null ? option.rangeEnd : option.max;\n\t            },\n\t            getNeedCrossZero: function () {\n\t                var option = this.option;\n\t                return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;\n\t            },\n\t            findGridModel: function () {\n\t                return this.ecModel.queryComponents({\n\t                    mainType: 'grid',\n\t                    index: this.get('gridIndex'),\n\t                    id: this.get('gridId')\n\t                })[0];\n\t            },\n\t            _resetRange: function () {\n\t                // rangeStart and rangeEnd is readonly.\n\t                this.option.rangeStart = this.option.rangeEnd = null;\n\t            }\n\t        });\n\t    function getAxisType(axisDim, option) {\n\t        // Default axis with data is category axis\n\t        return option.type || (option.data ? 'category' : 'value');\n\t    }\n\t    zrUtil.merge(AxisModel.prototype, require('../axisModelCommonMixin'));\n\t    var extraOption = { offset: 0 };\n\t    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n\t    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\t    return AxisModel;\n\t});\n\tdefine('zrender/animation/Clip', ['require', './easing'], function (require) {\n\t    var easingFuncs = require('./easing');\n\t    function Clip(options) {\n\t        this._target = options.target;\n\t        // 生命周期\n\t        this._life = options.life || 1000;\n\t        // 延时\n\t        this._delay = options.delay || 0;\n\t        // 开始时间\n\t        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n\t        this._initialized = false;\n\t        // 是否循环\n\t        this.loop = options.loop == null ? false : options.loop;\n\t        this.gap = options.gap || 0;\n\t        this.easing = options.easing || 'Linear';\n\t        this.onframe = options.onframe;\n\t        this.ondestroy = options.ondestroy;\n\t        this.onrestart = options.onrestart;\n\t    }\n\t    Clip.prototype = {\n\t        constructor: Clip,\n\t        step: function (globalTime) {\n\t            // Set startTime on first step, or _startTime may has milleseconds different between clips\n\t            // PENDING\n\t            if (!this._initialized) {\n\t                this._startTime = globalTime + this._delay;\n\t                this._initialized = true;\n\t            }\n\t            var percent = (globalTime - this._startTime) / this._life;\n\t            // 还没开始\n\t            if (percent < 0) {\n\t                return;\n\t            }\n\t            percent = Math.min(percent, 1);\n\t            var easing = this.easing;\n\t            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t            var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n\t            this.fire('frame', schedule);\n\t            // 结束\n\t            if (percent == 1) {\n\t                if (this.loop) {\n\t                    this.restart(globalTime);\n\t                    // 重新开始周期\n\t                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n\t                    return 'restart';\n\t                }\n\t                // 动画完成将这个控制器标识为待删除\n\t                // 在Animation.update中进行批量删除\n\t                this._needsRemove = true;\n\t                return 'destroy';\n\t            }\n\t            return null;\n\t        },\n\t        restart: function (globalTime) {\n\t            var remainder = (globalTime - this._startTime) % this._life;\n\t            this._startTime = globalTime - remainder + this.gap;\n\t            this._needsRemove = false;\n\t        },\n\t        fire: function (eventType, arg) {\n\t            eventType = 'on' + eventType;\n\t            if (this[eventType]) {\n\t                this[eventType](this._target, arg);\n\t            }\n\t        }\n\t    };\n\t    return Clip;\n\t});\n\tdefine('echarts/coord/axisModelCreator', ['require', './axisDefault', 'zrender/core/util', '../model/Component', '../util/layout'], function (require) {\n\t    var axisDefault = require('./axisDefault');\n\t    var zrUtil = require('zrender/core/util');\n\t    var ComponentModel = require('../model/Component');\n\t    var layout = require('../util/layout');\n\t    // FIXME axisType is fixed ?\n\t    var AXIS_TYPES = [\n\t            'value',\n\t            'category',\n\t            'time',\n\t            'log'\n\t        ];\n\t    /**\n\t     * Generate sub axis model class\n\t     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n\t     * @param {module:echarts/model/Component} BaseAxisModelClass\n\t     * @param {Function} axisTypeDefaulter\n\t     * @param {Object} [extraDefaultOption]\n\t     */\n\t    return function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\t        zrUtil.each(AXIS_TYPES, function (axisType) {\n\t            BaseAxisModelClass.extend({\n\t                type: axisName + 'Axis.' + axisType,\n\t                mergeDefaultAndTheme: function (option, ecModel) {\n\t                    var layoutMode = this.layoutMode;\n\t                    var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};\n\t                    var themeModel = ecModel.getTheme();\n\t                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n\t                    zrUtil.merge(option, this.getDefaultOption());\n\t                    option.type = axisTypeDefaulter(axisName, option);\n\t                    if (layoutMode) {\n\t                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n\t                    }\n\t                },\n\t                defaultOption: zrUtil.mergeAll([\n\t                    {},\n\t                    axisDefault[axisType + 'Axis'],\n\t                    extraDefaultOption\n\t                ], true)\n\t            });\n\t        });\n\t        ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n\t    };\n\t});\n\tdefine('echarts/coord/axisModelCommonMixin', ['require', 'zrender/core/util', './axisHelper'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var axisHelper = require('./axisHelper');\n\t    function getName(obj) {\n\t        if (zrUtil.isObject(obj) && obj.value != null) {\n\t            return obj.value;\n\t        } else {\n\t            return obj;\n\t        }\n\t    }\n\t    /**\n\t     * Get categories\n\t     */\n\t    function getCategories() {\n\t        return this.get('type') === 'category' && zrUtil.map(this.get('data'), getName);\n\t    }\n\t    /**\n\t     * Format labels\n\t     * @return {Array.<string>}\n\t     */\n\t    function getFormattedLabels() {\n\t        return axisHelper.getFormattedLabels(this.axis, this.get('axisLabel.formatter'));\n\t    }\n\t    return {\n\t        getFormattedLabels: getFormattedLabels,\n\t        getCategories: getCategories\n\t    };\n\t});\n\tdefine('zrender/animation/easing', [], function () {\n\t    var easing = {\n\t            linear: function (k) {\n\t                return k;\n\t            },\n\t            quadraticIn: function (k) {\n\t                return k * k;\n\t            },\n\t            quadraticOut: function (k) {\n\t                return k * (2 - k);\n\t            },\n\t            quadraticInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * k * k;\n\t                }\n\t                return -0.5 * (--k * (k - 2) - 1);\n\t            },\n\t            cubicIn: function (k) {\n\t                return k * k * k;\n\t            },\n\t            cubicOut: function (k) {\n\t                return --k * k * k + 1;\n\t            },\n\t            cubicInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * k * k * k;\n\t                }\n\t                return 0.5 * ((k -= 2) * k * k + 2);\n\t            },\n\t            quarticIn: function (k) {\n\t                return k * k * k * k;\n\t            },\n\t            quarticOut: function (k) {\n\t                return 1 - --k * k * k * k;\n\t            },\n\t            quarticInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * k * k * k * k;\n\t                }\n\t                return -0.5 * ((k -= 2) * k * k * k - 2);\n\t            },\n\t            quinticIn: function (k) {\n\t                return k * k * k * k * k;\n\t            },\n\t            quinticOut: function (k) {\n\t                return --k * k * k * k * k + 1;\n\t            },\n\t            quinticInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * k * k * k * k * k;\n\t                }\n\t                return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t            },\n\t            sinusoidalIn: function (k) {\n\t                return 1 - Math.cos(k * Math.PI / 2);\n\t            },\n\t            sinusoidalOut: function (k) {\n\t                return Math.sin(k * Math.PI / 2);\n\t            },\n\t            sinusoidalInOut: function (k) {\n\t                return 0.5 * (1 - Math.cos(Math.PI * k));\n\t            },\n\t            exponentialIn: function (k) {\n\t                return k === 0 ? 0 : Math.pow(1024, k - 1);\n\t            },\n\t            exponentialOut: function (k) {\n\t                return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\t            },\n\t            exponentialInOut: function (k) {\n\t                if (k === 0) {\n\t                    return 0;\n\t                }\n\t                if (k === 1) {\n\t                    return 1;\n\t                }\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * Math.pow(1024, k - 1);\n\t                }\n\t                return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t            },\n\t            circularIn: function (k) {\n\t                return 1 - Math.sqrt(1 - k * k);\n\t            },\n\t            circularOut: function (k) {\n\t                return Math.sqrt(1 - --k * k);\n\t            },\n\t            circularInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t                }\n\t                return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t            },\n\t            elasticIn: function (k) {\n\t                var s;\n\t                var a = 0.1;\n\t                var p = 0.4;\n\t                if (k === 0) {\n\t                    return 0;\n\t                }\n\t                if (k === 1) {\n\t                    return 1;\n\t                }\n\t                if (!a || a < 1) {\n\t                    a = 1;\n\t                    s = p / 4;\n\t                } else {\n\t                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t                }\n\t                return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t            },\n\t            elasticOut: function (k) {\n\t                var s;\n\t                var a = 0.1;\n\t                var p = 0.4;\n\t                if (k === 0) {\n\t                    return 0;\n\t                }\n\t                if (k === 1) {\n\t                    return 1;\n\t                }\n\t                if (!a || a < 1) {\n\t                    a = 1;\n\t                    s = p / 4;\n\t                } else {\n\t                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t                }\n\t                return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n\t            },\n\t            elasticInOut: function (k) {\n\t                var s;\n\t                var a = 0.1;\n\t                var p = 0.4;\n\t                if (k === 0) {\n\t                    return 0;\n\t                }\n\t                if (k === 1) {\n\t                    return 1;\n\t                }\n\t                if (!a || a < 1) {\n\t                    a = 1;\n\t                    s = p / 4;\n\t                } else {\n\t                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t                }\n\t                if ((k *= 2) < 1) {\n\t                    return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t                }\n\t                return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t            },\n\t            backIn: function (k) {\n\t                var s = 1.70158;\n\t                return k * k * ((s + 1) * k - s);\n\t            },\n\t            backOut: function (k) {\n\t                var s = 1.70158;\n\t                return --k * k * ((s + 1) * k + s) + 1;\n\t            },\n\t            backInOut: function (k) {\n\t                var s = 1.70158 * 1.525;\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * (k * k * ((s + 1) * k - s));\n\t                }\n\t                return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t            },\n\t            bounceIn: function (k) {\n\t                return 1 - easing.bounceOut(1 - k);\n\t            },\n\t            bounceOut: function (k) {\n\t                if (k < 1 / 2.75) {\n\t                    return 7.5625 * k * k;\n\t                } else if (k < 2 / 2.75) {\n\t                    return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n\t                } else if (k < 2.5 / 2.75) {\n\t                    return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n\t                } else {\n\t                    return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n\t                }\n\t            },\n\t            bounceInOut: function (k) {\n\t                if (k < 0.5) {\n\t                    return easing.bounceIn(k * 2) * 0.5;\n\t                }\n\t                return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n\t            }\n\t        };\n\t    return easing;\n\t});\n\tdefine('echarts/coord/axisDefault', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var defaultOption = {\n\t            show: true,\n\t            zlevel: 0,\n\t            z: 0,\n\t            inverse: false,\n\t            name: '',\n\t            nameLocation: 'end',\n\t            nameRotate: null,\n\t            nameTruncate: {\n\t                maxWidth: null,\n\t                ellipsis: '...',\n\t                placeholder: '.'\n\t            },\n\t            nameTextStyle: {},\n\t            nameGap: 15,\n\t            silent: false,\n\t            triggerEvent: false,\n\t            tooltip: { show: false },\n\t            axisLine: {\n\t                show: true,\n\t                onZero: true,\n\t                lineStyle: {\n\t                    color: '#333',\n\t                    width: 1,\n\t                    type: 'solid'\n\t                }\n\t            },\n\t            axisTick: {\n\t                show: true,\n\t                inside: false,\n\t                length: 5,\n\t                lineStyle: { width: 1 }\n\t            },\n\t            axisLabel: {\n\t                show: true,\n\t                inside: false,\n\t                rotate: 0,\n\t                margin: 8,\n\t                textStyle: { fontSize: 12 }\n\t            },\n\t            splitLine: {\n\t                show: true,\n\t                lineStyle: {\n\t                    color: ['#ccc'],\n\t                    width: 1,\n\t                    type: 'solid'\n\t                }\n\t            },\n\t            splitArea: {\n\t                show: false,\n\t                areaStyle: {\n\t                    color: [\n\t                        'rgba(250,250,250,0.3)',\n\t                        'rgba(200,200,200,0.3)'\n\t                    ]\n\t                }\n\t            }\n\t        };\n\t    var categoryAxis = zrUtil.merge({\n\t            boundaryGap: true,\n\t            splitLine: { show: false },\n\t            axisTick: {\n\t                alignWithLabel: false,\n\t                interval: 'auto'\n\t            },\n\t            axisLabel: { interval: 'auto' }\n\t        }, defaultOption);\n\t    var valueAxis = zrUtil.merge({\n\t            boundaryGap: [\n\t                0,\n\t                0\n\t            ],\n\t            splitNumber: 5\n\t        }, defaultOption);\n\t    // FIXME\n\t    var timeAxis = zrUtil.defaults({\n\t            scale: true,\n\t            min: 'dataMin',\n\t            max: 'dataMax'\n\t        }, valueAxis);\n\t    var logAxis = zrUtil.defaults({ logBase: 10 }, valueAxis);\n\t    logAxis.scale = true;\n\t    return {\n\t        categoryAxis: categoryAxis,\n\t        valueAxis: valueAxis,\n\t        timeAxis: timeAxis,\n\t        logAxis: logAxis\n\t    };\n\t});\n\tdefine('zrender/config', [], function () {\n\t    var dpr = 1;\n\t    // If in browser environment\n\t    if (typeof window !== 'undefined') {\n\t        dpr = Math.max(window.devicePixelRatio || 1, 1);\n\t    }\n\t    /**\n\t     * config默认配置项\n\t     * @exports zrender/config\n\t     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t     */\n\t    var config = {\n\t            debugMode: 0,\n\t            devicePixelRatio: dpr\n\t        };\n\t    return config;\n\t});\n\tdefine('echarts/chart/helper/createListFromArray', ['require', '../../data/List', '../../data/helper/completeDimensions', 'zrender/core/util', '../../util/model', '../../CoordinateSystem'], function (require) {\n\t    'use strict';\n\t    var List = require('../../data/List');\n\t    var completeDimensions = require('../../data/helper/completeDimensions');\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../../util/model');\n\t    var CoordinateSystem = require('../../CoordinateSystem');\n\t    var getDataItemValue = modelUtil.getDataItemValue;\n\t    var converDataValue = modelUtil.converDataValue;\n\t    function firstDataNotNull(data) {\n\t        var i = 0;\n\t        while (i < data.length && data[i] == null) {\n\t            i++;\n\t        }\n\t        return data[i];\n\t    }\n\t    function ifNeedCompleteOrdinalData(data) {\n\t        var sampleItem = firstDataNotNull(data);\n\t        return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));\n\t    }\n\t    /**\n\t     * Helper function to create a list from option data\n\t     */\n\t    function createListFromArray(data, seriesModel, ecModel) {\n\t        // If data is undefined\n\t        data = data || [];\n\t        if (true) {\n\t            if (!zrUtil.isArray(data)) {\n\t                throw new Error('Invalid data.');\n\t            }\n\t        }\n\t        var coordSysName = seriesModel.get('coordinateSystem');\n\t        var creator = creators[coordSysName];\n\t        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n\t        // FIXME\n\t        var axesInfo = creator && creator(data, seriesModel, ecModel);\n\t        var dimensions = axesInfo && axesInfo.dimensions;\n\t        if (!dimensions) {\n\t            // Get dimensions from registered coordinate system\n\t            dimensions = registeredCoordSys && registeredCoordSys.dimensions || [\n\t                'x',\n\t                'y'\n\t            ];\n\t            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));\n\t        }\n\t        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\t        var list = new List(dimensions, seriesModel);\n\t        var nameList = createNameList(axesInfo, data);\n\t        var categories = {};\n\t        var dimValueGetter = categoryIndex >= 0 && ifNeedCompleteOrdinalData(data) ? function (itemOpt, dimName, dataIndex, dimIndex) {\n\t                // If any dataItem is like { value: 10 }\n\t                if (modelUtil.isDataItemOption(itemOpt)) {\n\t                    list.hasItemOption = true;\n\t                }\n\t                // Use dataIndex as ordinal value in categoryAxis\n\t                return dimIndex === categoryIndex ? dataIndex : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n\t            } : function (itemOpt, dimName, dataIndex, dimIndex) {\n\t                var value = getDataItemValue(itemOpt);\n\t                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n\t                // If any dataItem is like { value: 10 }\n\t                if (modelUtil.isDataItemOption(itemOpt)) {\n\t                    list.hasItemOption = true;\n\t                }\n\t                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n\t                if (categoryAxesModels && categoryAxesModels[dimName]) {\n\t                    // If given value is a category string\n\t                    if (typeof val === 'string') {\n\t                        // Lazy get categories\n\t                        categories[dimName] = categories[dimName] || categoryAxesModels[dimName].getCategories();\n\t                        val = zrUtil.indexOf(categories[dimName], val);\n\t                        if (val < 0 && !isNaN(val)) {\n\t                            // In case some one write '1', '2' istead of 1, 2\n\t                            val = +val;\n\t                        }\n\t                    }\n\t                }\n\t                return val;\n\t            };\n\t        list.hasItemOption = false;\n\t        list.initData(data, nameList, dimValueGetter);\n\t        return list;\n\t    }\n\t    function isStackable(axisType) {\n\t        return axisType !== 'category' && axisType !== 'time';\n\t    }\n\t    function getDimTypeByAxis(axisType) {\n\t        return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';\n\t    }\n\t    /**\n\t     * Creaters for each coord system.\n\t     */\n\t    var creators = {\n\t            cartesian2d: function (data, seriesModel, ecModel) {\n\t                var axesModels = zrUtil.map([\n\t                        'xAxis',\n\t                        'yAxis'\n\t                    ], function (name) {\n\t                        return ecModel.queryComponents({\n\t                            mainType: name,\n\t                            index: seriesModel.get(name + 'Index'),\n\t                            id: seriesModel.get(name + 'Id')\n\t                        })[0];\n\t                    });\n\t                var xAxisModel = axesModels[0];\n\t                var yAxisModel = axesModels[1];\n\t                if (true) {\n\t                    if (!xAxisModel) {\n\t                        throw new Error('xAxis \"' + zrUtil.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('xAxisId'), 0) + '\" not found');\n\t                    }\n\t                    if (!yAxisModel) {\n\t                        throw new Error('yAxis \"' + zrUtil.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('yAxisId'), 0) + '\" not found');\n\t                    }\n\t                }\n\t                var xAxisType = xAxisModel.get('type');\n\t                var yAxisType = yAxisModel.get('type');\n\t                var dimensions = [\n\t                        {\n\t                            name: 'x',\n\t                            type: getDimTypeByAxis(xAxisType),\n\t                            stackable: isStackable(xAxisType)\n\t                        },\n\t                        {\n\t                            name: 'y',\n\t                            type: getDimTypeByAxis(yAxisType),\n\t                            stackable: isStackable(yAxisType)\n\t                        }\n\t                    ];\n\t                var isXAxisCateogry = xAxisType === 'category';\n\t                var isYAxisCategory = yAxisType === 'category';\n\t                completeDimensions(dimensions, data, [\n\t                    'x',\n\t                    'y',\n\t                    'z'\n\t                ]);\n\t                var categoryAxesModels = {};\n\t                if (isXAxisCateogry) {\n\t                    categoryAxesModels.x = xAxisModel;\n\t                }\n\t                if (isYAxisCategory) {\n\t                    categoryAxesModels.y = yAxisModel;\n\t                }\n\t                return {\n\t                    dimensions: dimensions,\n\t                    categoryIndex: isXAxisCateogry ? 0 : isYAxisCategory ? 1 : -1,\n\t                    categoryAxesModels: categoryAxesModels\n\t                };\n\t            },\n\t            polar: function (data, seriesModel, ecModel) {\n\t                var polarModel = ecModel.queryComponents({\n\t                        mainType: 'polar',\n\t                        index: seriesModel.get('polarIndex'),\n\t                        id: seriesModel.get('polarId')\n\t                    })[0];\n\t                var angleAxisModel = polarModel.findAxisModel('angleAxis');\n\t                var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\t                if (true) {\n\t                    if (!angleAxisModel) {\n\t                        throw new Error('angleAxis option not found');\n\t                    }\n\t                    if (!radiusAxisModel) {\n\t                        throw new Error('radiusAxis option not found');\n\t                    }\n\t                }\n\t                var radiusAxisType = radiusAxisModel.get('type');\n\t                var angleAxisType = angleAxisModel.get('type');\n\t                var dimensions = [\n\t                        {\n\t                            name: 'radius',\n\t                            type: getDimTypeByAxis(radiusAxisType),\n\t                            stackable: isStackable(radiusAxisType)\n\t                        },\n\t                        {\n\t                            name: 'angle',\n\t                            type: getDimTypeByAxis(angleAxisType),\n\t                            stackable: isStackable(angleAxisType)\n\t                        }\n\t                    ];\n\t                var isAngleAxisCateogry = angleAxisType === 'category';\n\t                var isRadiusAxisCateogry = radiusAxisType === 'category';\n\t                completeDimensions(dimensions, data, [\n\t                    'radius',\n\t                    'angle',\n\t                    'value'\n\t                ]);\n\t                var categoryAxesModels = {};\n\t                if (isRadiusAxisCateogry) {\n\t                    categoryAxesModels.radius = radiusAxisModel;\n\t                }\n\t                if (isAngleAxisCateogry) {\n\t                    categoryAxesModels.angle = angleAxisModel;\n\t                }\n\t                return {\n\t                    dimensions: dimensions,\n\t                    categoryIndex: isAngleAxisCateogry ? 1 : isRadiusAxisCateogry ? 0 : -1,\n\t                    categoryAxesModels: categoryAxesModels\n\t                };\n\t            },\n\t            geo: function (data, seriesModel, ecModel) {\n\t                // TODO Region\n\t                // 多个散点图系列在同一个地区的时候\n\t                return {\n\t                    dimensions: completeDimensions([\n\t                        { name: 'lng' },\n\t                        { name: 'lat' }\n\t                    ], data, [\n\t                        'lng',\n\t                        'lat',\n\t                        'value'\n\t                    ])\n\t                };\n\t            }\n\t        };\n\t    function createNameList(result, data) {\n\t        var nameList = [];\n\t        var categoryDim = result && result.dimensions[result.categoryIndex];\n\t        var categoryAxisModel;\n\t        if (categoryDim) {\n\t            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n\t        }\n\t        if (categoryAxisModel) {\n\t            // FIXME Two category axis\n\t            var categories = categoryAxisModel.getCategories();\n\t            if (categories) {\n\t                var dataLen = data.length;\n\t                // Ordered data is given explicitly like\n\t                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n\t                // or given scatter data,\n\t                // pick the category\n\t                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n\t                    nameList = [];\n\t                    for (var i = 0; i < dataLen; i++) {\n\t                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n\t                    }\n\t                } else {\n\t                    nameList = categories.slice(0);\n\t                }\n\t            }\n\t        }\n\t        return nameList;\n\t    }\n\t    return createListFromArray;\n\t});\n\tdefine('zrender/core/curve', ['require', './vector'], function (require) {\n\t    'use strict';\n\t    var vec2 = require('./vector');\n\t    var v2Create = vec2.create;\n\t    var v2DistSquare = vec2.distSquare;\n\t    var mathPow = Math.pow;\n\t    var mathSqrt = Math.sqrt;\n\t    var EPSILON = 1e-8;\n\t    var EPSILON_NUMERIC = 0.0001;\n\t    var THREE_SQRT = mathSqrt(3);\n\t    var ONE_THIRD = 1 / 3;\n\t    // 临时变量\n\t    var _v0 = v2Create();\n\t    var _v1 = v2Create();\n\t    var _v2 = v2Create();\n\t    // var _v3 = vec2.create();\n\t    function isAroundZero(val) {\n\t        return val > -EPSILON && val < EPSILON;\n\t    }\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t    /**\n\t     * 计算三次贝塞尔值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n\t    }\n\t    /**\n\t     * 计算三次贝塞尔导数值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n\t    }\n\t    /**\n\t     * 计算三次贝塞尔方程根，使用盛金公式\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} val\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} 有效根数目\n\t     */\n\t    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n\t        // Evaluate roots of cubic functions\n\t        var a = p3 + 3 * (p1 - p2) - p0;\n\t        var b = 3 * (p2 - p1 * 2 + p0);\n\t        var c = 3 * (p1 - p0);\n\t        var d = p0 - val;\n\t        var A = b * b - 3 * a * c;\n\t        var B = b * c - 9 * a * d;\n\t        var C = c * c - 3 * b * d;\n\t        var n = 0;\n\t        if (isAroundZero(A) && isAroundZero(B)) {\n\t            if (isAroundZero(b)) {\n\t                roots[0] = 0;\n\t            } else {\n\t                var t1 = -c / b;\n\t                //t1, t2, t3, b is not zero\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        } else {\n\t            var disc = B * B - 4 * A * C;\n\t            if (isAroundZero(disc)) {\n\t                var K = B / A;\n\t                var t1 = -b / a + K;\n\t                // t1, a is not zero\n\t                var t2 = -K / 2;\n\t                // t2, t3\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            } else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n\t                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\t                if (Y1 < 0) {\n\t                    Y1 = -mathPow(-Y1, ONE_THIRD);\n\t                } else {\n\t                    Y1 = mathPow(Y1, ONE_THIRD);\n\t                }\n\t                if (Y2 < 0) {\n\t                    Y2 = -mathPow(-Y2, ONE_THIRD);\n\t                } else {\n\t                    Y2 = mathPow(Y2, ONE_THIRD);\n\t                }\n\t                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            } else {\n\t                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n\t                var theta = Math.acos(T) / 3;\n\t                var ASqrt = mathSqrt(A);\n\t                var tmp = Math.cos(theta);\n\t                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n\t                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t                if (t3 >= 0 && t3 <= 1) {\n\t                    roots[n++] = t3;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t    /**\n\t     * 计算三次贝塞尔方程极限值的位置\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {Array.<number>} extrema\n\t     * @return {number} 有效数目\n\t     */\n\t    function cubicExtrema(p0, p1, p2, p3, extrema) {\n\t        var b = 6 * p2 - 12 * p1 + 6 * p0;\n\t        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n\t        var c = 3 * p1 - 3 * p0;\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t            }\n\t        } else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                extrema[0] = -b / (2 * a);\n\t            } else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    extrema[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t    /**\n\t     * 细分三次贝塞尔曲线\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p23 = (p3 - p2) * t + p2;\n\t        var p012 = (p12 - p01) * t + p01;\n\t        var p123 = (p23 - p12) * t + p12;\n\t        var p0123 = (p123 - p012) * t + p012;\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t        out[3] = p0123;\n\t        // Seg1\n\t        out[4] = p0123;\n\t        out[5] = p123;\n\t        out[6] = p23;\n\t        out[7] = p3;\n\t    }\n\t    /**\n\t     * 投射点到三次贝塞尔曲线上，返回投射距离。\n\t     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} [out] 投射点\n\t     * @return {number}\n\t     */\n\t    function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t        var prev;\n\t        var next;\n\t        var d1;\n\t        var d2;\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t        // 先粗略估计一下可能的最小距离的 t 值\n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n\t            d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            prev = t - interval;\n\t            next = t + interval;\n\t            // t - interval\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\t            d1 = v2DistSquare(_v1, _v0);\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            } else {\n\t                // t + interval\n\t                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n\t                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n\t                d2 = v2DistSquare(_v2, _v0);\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                } else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = cubicAt(x0, x1, x2, x3, t);\n\t            out[1] = cubicAt(y0, y1, y2, y3, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t    /**\n\t     * 计算二次方贝塞尔值\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticAt(p0, p1, p2, t) {\n\t        var onet = 1 - t;\n\t        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n\t    }\n\t    /**\n\t     * 计算二次方贝塞尔导数值\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticDerivativeAt(p0, p1, p2, t) {\n\t        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n\t    }\n\t    /**\n\t     * 计算二次方贝塞尔方程根\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} 有效根数目\n\t     */\n\t    function quadraticRootAt(p0, p1, p2, val, roots) {\n\t        var a = p0 - 2 * p1 + p2;\n\t        var b = 2 * (p1 - p0);\n\t        var c = p0 - val;\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        } else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                var t1 = -b / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            } else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t    /**\n\t     * 计算二次贝塞尔方程极限值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @return {number}\n\t     */\n\t    function quadraticExtremum(p0, p1, p2) {\n\t        var divider = p0 + p2 - 2 * p1;\n\t        if (divider === 0) {\n\t            // p1 is center of p0 and p2\n\t            return 0.5;\n\t        } else {\n\t            return (p0 - p1) / divider;\n\t        }\n\t    }\n\t    /**\n\t     * 细分二次贝塞尔曲线\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function quadraticSubdivide(p0, p1, p2, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p012 = (p12 - p01) * t + p01;\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t        // Seg1\n\t        out[3] = p012;\n\t        out[4] = p12;\n\t        out[5] = p2;\n\t    }\n\t    /**\n\t     * 投射点到二次贝塞尔曲线上，返回投射距离。\n\t     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} out 投射点\n\t     * @return {number}\n\t     */\n\t    function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t        // 先粗略估计一下可能的最小距离的 t 值\n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = quadraticAt(x0, x1, x2, _t);\n\t            _v1[1] = quadraticAt(y0, y1, y2, _t);\n\t            var d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            var prev = t - interval;\n\t            var next = t + interval;\n\t            // t - interval\n\t            _v1[0] = quadraticAt(x0, x1, x2, prev);\n\t            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\t            var d1 = v2DistSquare(_v1, _v0);\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            } else {\n\t                // t + interval\n\t                _v2[0] = quadraticAt(x0, x1, x2, next);\n\t                _v2[1] = quadraticAt(y0, y1, y2, next);\n\t                var d2 = v2DistSquare(_v2, _v0);\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                } else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = quadraticAt(x0, x1, x2, t);\n\t            out[1] = quadraticAt(y0, y1, y2, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t    return {\n\t        cubicAt: cubicAt,\n\t        cubicDerivativeAt: cubicDerivativeAt,\n\t        cubicRootAt: cubicRootAt,\n\t        cubicExtrema: cubicExtrema,\n\t        cubicSubdivide: cubicSubdivide,\n\t        cubicProjectPoint: cubicProjectPoint,\n\t        quadraticAt: quadraticAt,\n\t        quadraticDerivativeAt: quadraticDerivativeAt,\n\t        quadraticRootAt: quadraticRootAt,\n\t        quadraticExtremum: quadraticExtremum,\n\t        quadraticSubdivide: quadraticSubdivide,\n\t        quadraticProjectPoint: quadraticProjectPoint\n\t    };\n\t});\n\tdefine('zrender/core/bbox', ['require', './vector', './curve'], function (require) {\n\t    var vec2 = require('./vector');\n\t    var curve = require('./curve');\n\t    var bbox = {};\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t    var start = vec2.create();\n\t    var end = vec2.create();\n\t    var extremity = vec2.create();\n\t    var PI2 = Math.PI * 2;\n\t    /**\n\t     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n\t     * @module zrender/core/bbox\n\t     * @param {Array<Object>} points 顶点数组\n\t     * @param {number} min\n\t     * @param {number} max\n\t     */\n\t    bbox.fromPoints = function (points, min, max) {\n\t        if (points.length === 0) {\n\t            return;\n\t        }\n\t        var p = points[0];\n\t        var left = p[0];\n\t        var right = p[0];\n\t        var top = p[1];\n\t        var bottom = p[1];\n\t        var i;\n\t        for (i = 1; i < points.length; i++) {\n\t            p = points[i];\n\t            left = mathMin(left, p[0]);\n\t            right = mathMax(right, p[0]);\n\t            top = mathMin(top, p[1]);\n\t            bottom = mathMax(bottom, p[1]);\n\t        }\n\t        min[0] = left;\n\t        min[1] = top;\n\t        max[0] = right;\n\t        max[1] = bottom;\n\t    };\n\t    /**\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n\t        min[0] = mathMin(x0, x1);\n\t        min[1] = mathMin(y0, y1);\n\t        max[0] = mathMax(x0, x1);\n\t        max[1] = mathMax(y0, y1);\n\t    };\n\t    var xDim = [];\n\t    var yDim = [];\n\t    /**\n\t     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromCubic = function (x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n\t        var cubicExtrema = curve.cubicExtrema;\n\t        var cubicAt = curve.cubicAt;\n\t        var i;\n\t        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\t        min[0] = Infinity;\n\t        min[1] = Infinity;\n\t        max[0] = -Infinity;\n\t        max[1] = -Infinity;\n\t        for (i = 0; i < n; i++) {\n\t            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n\t            min[0] = mathMin(x, min[0]);\n\t            max[0] = mathMax(x, max[0]);\n\t        }\n\t        n = cubicExtrema(y0, y1, y2, y3, yDim);\n\t        for (i = 0; i < n; i++) {\n\t            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n\t            min[1] = mathMin(y, min[1]);\n\t            max[1] = mathMax(y, max[1]);\n\t        }\n\t        min[0] = mathMin(x0, min[0]);\n\t        max[0] = mathMax(x0, max[0]);\n\t        min[0] = mathMin(x3, min[0]);\n\t        max[0] = mathMax(x3, max[0]);\n\t        min[1] = mathMin(y0, min[1]);\n\t        max[1] = mathMax(y0, max[1]);\n\t        min[1] = mathMin(y3, min[1]);\n\t        max[1] = mathMax(y3, max[1]);\n\t    };\n\t    /**\n\t     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromQuadratic = function (x0, y0, x1, y1, x2, y2, min, max) {\n\t        var quadraticExtremum = curve.quadraticExtremum;\n\t        var quadraticAt = curve.quadraticAt;\n\t        // Find extremities, where derivative in x dim or y dim is zero\n\t        var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n\t        var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n\t        var x = quadraticAt(x0, x1, x2, tx);\n\t        var y = quadraticAt(y0, y1, y2, ty);\n\t        min[0] = mathMin(x0, x2, x);\n\t        min[1] = mathMin(y0, y2, y);\n\t        max[0] = mathMax(x0, x2, x);\n\t        max[1] = mathMax(y0, y2, y);\n\t    };\n\t    /**\n\t     * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n\t     * @method\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {number} rx\n\t     * @param {number} ry\n\t     * @param {number} startAngle\n\t     * @param {number} endAngle\n\t     * @param {number} anticlockwise\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromArc = function (x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n\t        var vec2Min = vec2.min;\n\t        var vec2Max = vec2.max;\n\t        var diff = Math.abs(startAngle - endAngle);\n\t        if (diff % PI2 < 0.0001 && diff > 0.0001) {\n\t            // Is a circle\n\t            min[0] = x - rx;\n\t            min[1] = y - ry;\n\t            max[0] = x + rx;\n\t            max[1] = y + ry;\n\t            return;\n\t        }\n\t        start[0] = mathCos(startAngle) * rx + x;\n\t        start[1] = mathSin(startAngle) * ry + y;\n\t        end[0] = mathCos(endAngle) * rx + x;\n\t        end[1] = mathSin(endAngle) * ry + y;\n\t        vec2Min(min, start, end);\n\t        vec2Max(max, start, end);\n\t        // Thresh to [0, Math.PI * 2]\n\t        startAngle = startAngle % PI2;\n\t        if (startAngle < 0) {\n\t            startAngle = startAngle + PI2;\n\t        }\n\t        endAngle = endAngle % PI2;\n\t        if (endAngle < 0) {\n\t            endAngle = endAngle + PI2;\n\t        }\n\t        if (startAngle > endAngle && !anticlockwise) {\n\t            endAngle += PI2;\n\t        } else if (startAngle < endAngle && anticlockwise) {\n\t            startAngle += PI2;\n\t        }\n\t        if (anticlockwise) {\n\t            var tmp = endAngle;\n\t            endAngle = startAngle;\n\t            startAngle = tmp;\n\t        }\n\t        // var number = 0;\n\t        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\t        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n\t            if (angle > startAngle) {\n\t                extremity[0] = mathCos(angle) * rx + x;\n\t                extremity[1] = mathSin(angle) * ry + y;\n\t                vec2Min(min, extremity, min);\n\t                vec2Max(max, extremity, max);\n\t            }\n\t        }\n\t    };\n\t    return bbox;\n\t});\n\tdefine('echarts/data/DataDiffer', ['require'], function (require) {\n\t    'use strict';\n\t    function defaultKeyGetter(item) {\n\t        return item;\n\t    }\n\t    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n\t        this._old = oldArr;\n\t        this._new = newArr;\n\t        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n\t        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n\t    }\n\t    DataDiffer.prototype = {\n\t        constructor: DataDiffer,\n\t        add: function (func) {\n\t            this._add = func;\n\t            return this;\n\t        },\n\t        update: function (func) {\n\t            this._update = func;\n\t            return this;\n\t        },\n\t        remove: function (func) {\n\t            this._remove = func;\n\t            return this;\n\t        },\n\t        execute: function () {\n\t            var oldArr = this._old;\n\t            var newArr = this._new;\n\t            var oldKeyGetter = this._oldKeyGetter;\n\t            var newKeyGetter = this._newKeyGetter;\n\t            var oldDataIndexMap = {};\n\t            var newDataIndexMap = {};\n\t            var oldDataKeyArr = [];\n\t            var newDataKeyArr = [];\n\t            var i;\n\t            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n\t            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\t            // Travel by inverted order to make sure order consistency\n\t            // when duplicate keys exists (consider newDataIndex.pop() below).\n\t            // For performance consideration, these code below do not look neat.\n\t            for (i = 0; i < oldArr.length; i++) {\n\t                var key = oldDataKeyArr[i];\n\t                var idx = newDataIndexMap[key];\n\t                // idx can never be empty array here. see 'set null' logic below.\n\t                if (idx != null) {\n\t                    // Consider there is duplicate key (for example, use dataItem.name as key).\n\t                    // We should make sure every item in newArr and oldArr can be visited.\n\t                    var len = idx.length;\n\t                    if (len) {\n\t                        len === 1 && (newDataIndexMap[key] = null);\n\t                        idx = idx.unshift();\n\t                    } else {\n\t                        newDataIndexMap[key] = null;\n\t                    }\n\t                    this._update && this._update(idx, i);\n\t                } else {\n\t                    this._remove && this._remove(i);\n\t                }\n\t            }\n\t            for (var i = 0; i < newDataKeyArr.length; i++) {\n\t                var key = newDataKeyArr[i];\n\t                if (newDataIndexMap.hasOwnProperty(key)) {\n\t                    var idx = newDataIndexMap[key];\n\t                    if (idx == null) {\n\t                        continue;\n\t                    }\n\t                    // idx can never be empty array here. see 'set null' logic above.\n\t                    if (!idx.length) {\n\t                        this._add && this._add(idx);\n\t                    } else {\n\t                        for (var j = 0, len = idx.length; j < len; j++) {\n\t                            this._add && this._add(idx[j]);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t    function initIndexMap(arr, map, keyArr, keyGetter) {\n\t        for (var i = 0; i < arr.length; i++) {\n\t            var key = keyGetter(arr[i], i);\n\t            var existence = map[key];\n\t            if (existence == null) {\n\t                keyArr.push(key);\n\t                map[key] = i;\n\t            } else {\n\t                if (!existence.length) {\n\t                    map[key] = existence = [existence];\n\t                }\n\t                existence.push(i);\n\t            }\n\t        }\n\t    }\n\t    return DataDiffer;\n\t});\n\tdefine('echarts/data/helper/completeDimensions', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    /**\n\t     * Complete the dimensions array guessed from the data structure.\n\t     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n\t     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n\t     * @param  {Array.<string>} defaultNames    Default names to fill not necessary dimensions, like ['value']\n\t     * @param  {string} extraPrefix             Prefix of name when filling the left dimensions.\n\t     * @return {Array.<string>}\n\t     */\n\t    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n\t        if (!data) {\n\t            return dimensions;\n\t        }\n\t        var value0 = retrieveValue(data[0]);\n\t        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n\t        defaultNames = defaultNames || [];\n\t        extraPrefix = extraPrefix || 'extra';\n\t        for (var i = 0; i < dimSize; i++) {\n\t            if (!dimensions[i]) {\n\t                var name = defaultNames[i] || extraPrefix + (i - defaultNames.length);\n\t                dimensions[i] = guessOrdinal(data, i) ? {\n\t                    type: 'ordinal',\n\t                    name: name\n\t                } : name;\n\t            }\n\t        }\n\t        return dimensions;\n\t    }\n\t    // The rule should not be complex, otherwise user might not\n\t    // be able to known where the data is wrong.\n\t    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n\t            for (var i = 0, len = data.length; i < len; i++) {\n\t                var value = retrieveValue(data[i]);\n\t                if (!zrUtil.isArray(value)) {\n\t                    return false;\n\t                }\n\t                var value = value[dimIndex];\n\t                if (value != null && isFinite(value)) {\n\t                    return false;\n\t                } else if (zrUtil.isString(value) && value !== '-') {\n\t                    return true;\n\t                }\n\t            }\n\t            return false;\n\t        };\n\t    function retrieveValue(o) {\n\t        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value : o;\n\t    }\n\t    return completeDimensions;\n\t});\n\tdefine('zrender/contain/cubic', ['require', '../core/curve'], function (require) {\n\t    var curve = require('../core/curve');\n\t    return {\n\t        containStroke: function (x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n\t                return false;\n\t            }\n\t            var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/line', [], function () {\n\t    return {\n\t        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            var _a = 0;\n\t            var _b = x0;\n\t            // Quick reject\n\t            if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n\t                return false;\n\t            }\n\t            if (x0 !== x1) {\n\t                _a = (y0 - y1) / (x0 - x1);\n\t                _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n\t            } else {\n\t                return Math.abs(x - x0) <= _l / 2;\n\t            }\n\t            var tmp = _a * x - y + _b;\n\t            var _s = tmp * tmp / (_a * _a + 1);\n\t            return _s <= _l / 2 * _l / 2;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/quadratic', ['require', '../core/curve'], function (require) {\n\t    var curve = require('../core/curve');\n\t    return {\n\t        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n\t                return false;\n\t            }\n\t            var d = curve.quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/arc', ['require', './util'], function (require) {\n\t    var normalizeRadian = require('./util').normalizeRadian;\n\t    var PI2 = Math.PI * 2;\n\t    return {\n\t        containStroke: function (cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            x -= cx;\n\t            y -= cy;\n\t            var d = Math.sqrt(x * x + y * y);\n\t            if (d - _l > r || d + _l < r) {\n\t                return false;\n\t            }\n\t            if (Math.abs(startAngle - endAngle) % PI2 < 0.0001) {\n\t                // Is a circle\n\t                return true;\n\t            }\n\t            if (anticlockwise) {\n\t                var tmp = startAngle;\n\t                startAngle = normalizeRadian(endAngle);\n\t                endAngle = normalizeRadian(tmp);\n\t            } else {\n\t                startAngle = normalizeRadian(startAngle);\n\t                endAngle = normalizeRadian(endAngle);\n\t            }\n\t            if (startAngle > endAngle) {\n\t                endAngle += PI2;\n\t            }\n\t            var angle = Math.atan2(y, x);\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/util', ['require'], function (require) {\n\t    var PI2 = Math.PI * 2;\n\t    return {\n\t        normalizeRadian: function (angle) {\n\t            angle %= PI2;\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return angle;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/windingLine', [], function () {\n\t    return function windingLine(x0, y0, x1, y1, x, y) {\n\t        if (y > y0 && y > y1 || y < y0 && y < y1) {\n\t            return 0;\n\t        }\n\t        // Ignore horizontal line\n\t        if (y1 === y0) {\n\t            return 0;\n\t        }\n\t        var dir = y1 < y0 ? 1 : -1;\n\t        var t = (y - y0) / (y1 - y0);\n\t        // Avoid winding error when intersection point is the connect point of two line of polygon\n\t        if (t === 1 || t === 0) {\n\t            dir = y1 < y0 ? 0.5 : -0.5;\n\t        }\n\t        var x_ = t * (x1 - x0) + x0;\n\t        return x_ > x ? dir : 0;\n\t    };\n\t});\n\tdefine('echarts/chart/bar/barItemStyle', ['require', '../../model/mixin/makeStyleMapper'], function (require) {\n\t    var getBarItemStyle = require('../../model/mixin/makeStyleMapper')([\n\t            [\n\t                'fill',\n\t                'color'\n\t            ],\n\t            [\n\t                'stroke',\n\t                'borderColor'\n\t            ],\n\t            [\n\t                'lineWidth',\n\t                'borderWidth'\n\t            ],\n\t            [\n\t                'stroke',\n\t                'barBorderColor'\n\t            ],\n\t            [\n\t                'lineWidth',\n\t                'barBorderWidth'\n\t            ],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor']\n\t        ]);\n\t    return {\n\t        getBarItemStyle: function (excludes) {\n\t            var style = getBarItemStyle.call(this, excludes);\n\t            if (this.getBorderLineDash) {\n\t                var lineDash = this.getBorderLineDash();\n\t                lineDash && (style.lineDash = lineDash);\n\t            }\n\t            return style;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/core/LRU', ['require'], function (require) {\n\t    /**\n\t     * Simple double linked list. Compared with array, it has O(1) remove operation.\n\t     * @constructor\n\t     */\n\t    var LinkedList = function () {\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.head = null;\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.tail = null;\n\t        this._len = 0;\n\t    };\n\t    var linkedListProto = LinkedList.prototype;\n\t    /**\n\t     * Insert a new value at the tail\n\t     * @param  {} val\n\t     * @return {module:zrender/core/LRU~Entry}\n\t     */\n\t    linkedListProto.insert = function (val) {\n\t        var entry = new Entry(val);\n\t        this.insertEntry(entry);\n\t        return entry;\n\t    };\n\t    /**\n\t     * Insert an entry at the tail\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.insertEntry = function (entry) {\n\t        if (!this.head) {\n\t            this.head = this.tail = entry;\n\t        } else {\n\t            this.tail.next = entry;\n\t            entry.prev = this.tail;\n\t            this.tail = entry;\n\t        }\n\t        this._len++;\n\t    };\n\t    /**\n\t     * Remove entry.\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.remove = function (entry) {\n\t        var prev = entry.prev;\n\t        var next = entry.next;\n\t        if (prev) {\n\t            prev.next = next;\n\t        } else {\n\t            // Is head\n\t            this.head = next;\n\t        }\n\t        if (next) {\n\t            next.prev = prev;\n\t        } else {\n\t            // Is tail\n\t            this.tail = prev;\n\t        }\n\t        entry.next = entry.prev = null;\n\t        this._len--;\n\t    };\n\t    /**\n\t     * @return {number}\n\t     */\n\t    linkedListProto.len = function () {\n\t        return this._len;\n\t    };\n\t    /**\n\t     * @constructor\n\t     * @param {} val\n\t     */\n\t    var Entry = function (val) {\n\t        /**\n\t         * @type {}\n\t         */\n\t        this.value = val;\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.next;\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.prev;\n\t    };\n\t    /**\n\t     * LRU Cache\n\t     * @constructor\n\t     * @alias module:zrender/core/LRU\n\t     */\n\t    var LRU = function (maxSize) {\n\t        this._list = new LinkedList();\n\t        this._map = {};\n\t        this._maxSize = maxSize || 10;\n\t    };\n\t    var LRUProto = LRU.prototype;\n\t    /**\n\t     * @param  {string} key\n\t     * @param  {} value\n\t     */\n\t    LRUProto.put = function (key, value) {\n\t        var list = this._list;\n\t        var map = this._map;\n\t        if (map[key] == null) {\n\t            var len = list.len();\n\t            if (len >= this._maxSize && len > 0) {\n\t                // Remove the least recently used\n\t                var leastUsedEntry = list.head;\n\t                list.remove(leastUsedEntry);\n\t                delete map[leastUsedEntry.key];\n\t            }\n\t            var entry = list.insert(value);\n\t            entry.key = key;\n\t            map[key] = entry;\n\t        }\n\t    };\n\t    /**\n\t     * @param  {string} key\n\t     * @return {}\n\t     */\n\t    LRUProto.get = function (key) {\n\t        var entry = this._map[key];\n\t        var list = this._list;\n\t        if (entry != null) {\n\t            // Put the latest used entry in the tail\n\t            if (entry !== list.tail) {\n\t                list.remove(entry);\n\t                list.insertEntry(entry);\n\t            }\n\t            return entry.value;\n\t        }\n\t    };\n\t    /**\n\t     * Clear the cache\n\t     */\n\t    LRUProto.clear = function () {\n\t        this._list.clear();\n\t        this._map = {};\n\t    };\n\t    return LRU;\n\t});\n\tdefine('zrender/graphic/helper/poly', ['require', './smoothSpline', './smoothBezier'], function (require) {\n\t    var smoothSpline = require('./smoothSpline');\n\t    var smoothBezier = require('./smoothBezier');\n\t    return {\n\t        buildPath: function (ctx, shape, closePath) {\n\t            var points = shape.points;\n\t            var smooth = shape.smooth;\n\t            if (points && points.length >= 2) {\n\t                if (smooth && smooth !== 'spline') {\n\t                    var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    var len = points.length;\n\t                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n\t                        var cp1 = controlPoints[i * 2];\n\t                        var cp2 = controlPoints[i * 2 + 1];\n\t                        var p = points[(i + 1) % len];\n\t                        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n\t                    }\n\t                } else {\n\t                    if (smooth === 'spline') {\n\t                        points = smoothSpline(points, closePath);\n\t                    }\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    for (var i = 1, l = points.length; i < l; i++) {\n\t                        ctx.lineTo(points[i][0], points[i][1]);\n\t                    }\n\t                }\n\t                closePath && ctx.closePath();\n\t            }\n\t        }\n\t    };\n\t});\n\tdefine('zrender/graphic/helper/smoothSpline', ['require', '../../core/vector'], function (require) {\n\t    var vec2 = require('../../core/vector');\n\t    /**\n\t     * @inner\n\t     */\n\t    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t    }\n\t    /**\n\t     * @alias module:zrender/shape/util/smoothSpline\n\t     * @param {Array} points 线段顶点数组\n\t     * @param {boolean} isLoop\n\t     * @return {Array}\n\t     */\n\t    return function (points, isLoop) {\n\t        var len = points.length;\n\t        var ret = [];\n\t        var distance = 0;\n\t        for (var i = 1; i < len; i++) {\n\t            distance += vec2.distance(points[i - 1], points[i]);\n\t        }\n\t        var segs = distance / 2;\n\t        segs = segs < len ? len : segs;\n\t        for (var i = 0; i < segs; i++) {\n\t            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n\t            var idx = Math.floor(pos);\n\t            var w = pos - idx;\n\t            var p0;\n\t            var p1 = points[idx % len];\n\t            var p2;\n\t            var p3;\n\t            if (!isLoop) {\n\t                p0 = points[idx === 0 ? idx : idx - 1];\n\t                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n\t                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n\t            } else {\n\t                p0 = points[(idx - 1 + len) % len];\n\t                p2 = points[(idx + 1) % len];\n\t                p3 = points[(idx + 2) % len];\n\t            }\n\t            var w2 = w * w;\n\t            var w3 = w * w2;\n\t            ret.push([\n\t                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n\t                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n\t            ]);\n\t        }\n\t        return ret;\n\t    };\n\t});\n\tdefine('zrender/graphic/helper/smoothBezier', ['require', '../../core/vector'], function (require) {\n\t    var vec2 = require('../../core/vector');\n\t    var v2Min = vec2.min;\n\t    var v2Max = vec2.max;\n\t    var v2Scale = vec2.scale;\n\t    var v2Distance = vec2.distance;\n\t    var v2Add = vec2.add;\n\t    /**\n\t     * 贝塞尔平滑曲线\n\t     * @alias module:zrender/shape/util/smoothBezier\n\t     * @param {Array} points 线段顶点数组\n\t     * @param {number} smooth 平滑等级, 0-1\n\t     * @param {boolean} isLoop\n\t     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n\t     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n\t     *                           整个折线的包围盒做一个并集用来约束控制点。\n\t     * @param {Array} 计算出来的控制点数组\n\t     */\n\t    return function (points, smooth, isLoop, constraint) {\n\t        var cps = [];\n\t        var v = [];\n\t        var v1 = [];\n\t        var v2 = [];\n\t        var prevPoint;\n\t        var nextPoint;\n\t        var min, max;\n\t        if (constraint) {\n\t            min = [\n\t                Infinity,\n\t                Infinity\n\t            ];\n\t            max = [\n\t                -Infinity,\n\t                -Infinity\n\t            ];\n\t            for (var i = 0, len = points.length; i < len; i++) {\n\t                v2Min(min, min, points[i]);\n\t                v2Max(max, max, points[i]);\n\t            }\n\t            // 与指定的包围盒做并集\n\t            v2Min(min, min, constraint[0]);\n\t            v2Max(max, max, constraint[1]);\n\t        }\n\t        for (var i = 0, len = points.length; i < len; i++) {\n\t            var point = points[i];\n\t            if (isLoop) {\n\t                prevPoint = points[i ? i - 1 : len - 1];\n\t                nextPoint = points[(i + 1) % len];\n\t            } else {\n\t                if (i === 0 || i === len - 1) {\n\t                    cps.push(vec2.clone(points[i]));\n\t                    continue;\n\t                } else {\n\t                    prevPoint = points[i - 1];\n\t                    nextPoint = points[i + 1];\n\t                }\n\t            }\n\t            vec2.sub(v, nextPoint, prevPoint);\n\t            // use degree to scale the handle length\n\t            v2Scale(v, v, smooth);\n\t            var d0 = v2Distance(point, prevPoint);\n\t            var d1 = v2Distance(point, nextPoint);\n\t            var sum = d0 + d1;\n\t            if (sum !== 0) {\n\t                d0 /= sum;\n\t                d1 /= sum;\n\t            }\n\t            v2Scale(v1, v, -d0);\n\t            v2Scale(v2, v, d1);\n\t            var cp0 = v2Add([], point, v1);\n\t            var cp1 = v2Add([], point, v2);\n\t            if (constraint) {\n\t                v2Max(cp0, cp0, min);\n\t                v2Min(cp0, cp0, max);\n\t                v2Max(cp1, cp1, min);\n\t                v2Min(cp1, cp1, max);\n\t            }\n\t            cps.push(cp0);\n\t            cps.push(cp1);\n\t        }\n\t        if (isLoop) {\n\t            cps.push(cps.shift());\n\t        }\n\t        return cps;\n\t    };\n\t});\n\tdefine('zrender/graphic/helper/roundRect', ['require'], function (require) {\n\t    return {\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            var r = shape.r;\n\t            var r1;\n\t            var r2;\n\t            var r3;\n\t            var r4;\n\t            // Convert width and height to positive for better borderRadius\n\t            if (width < 0) {\n\t                x = x + width;\n\t                width = -width;\n\t            }\n\t            if (height < 0) {\n\t                y = y + height;\n\t                height = -height;\n\t            }\n\t            if (typeof r === 'number') {\n\t                r1 = r2 = r3 = r4 = r;\n\t            } else if (r instanceof Array) {\n\t                if (r.length === 1) {\n\t                    r1 = r2 = r3 = r4 = r[0];\n\t                } else if (r.length === 2) {\n\t                    r1 = r3 = r[0];\n\t                    r2 = r4 = r[1];\n\t                } else if (r.length === 3) {\n\t                    r1 = r[0];\n\t                    r2 = r4 = r[1];\n\t                    r3 = r[2];\n\t                } else {\n\t                    r1 = r[0];\n\t                    r2 = r[1];\n\t                    r3 = r[2];\n\t                    r4 = r[3];\n\t                }\n\t            } else {\n\t                r1 = r2 = r3 = r4 = 0;\n\t            }\n\t            var total;\n\t            if (r1 + r2 > width) {\n\t                total = r1 + r2;\n\t                r1 *= width / total;\n\t                r2 *= width / total;\n\t            }\n\t            if (r3 + r4 > width) {\n\t                total = r3 + r4;\n\t                r3 *= width / total;\n\t                r4 *= width / total;\n\t            }\n\t            if (r2 + r3 > height) {\n\t                total = r2 + r3;\n\t                r2 *= height / total;\n\t                r3 *= height / total;\n\t            }\n\t            if (r1 + r4 > height) {\n\t                total = r1 + r4;\n\t                r1 *= height / total;\n\t                r4 *= height / total;\n\t            }\n\t            ctx.moveTo(x + r1, y);\n\t            ctx.lineTo(x + width - r2, y);\n\t            r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);\n\t            ctx.lineTo(x + width, y + height - r3);\n\t            r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);\n\t            ctx.lineTo(x + r4, y + height);\n\t            r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);\n\t            ctx.lineTo(x, y + r1);\n\t            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n\t        }\n\t    };\n\t});\n\tdefine('zrender/Storage', ['require', './core/util', './core/env', './container/Group', './core/timsort'], function (require) {\n\t    'use strict';\n\t    var util = require('./core/util');\n\t    var env = require('./core/env');\n\t    var Group = require('./container/Group');\n\t    // Use timsort because in most case elements are partially sorted\n\t    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n\t    var timsort = require('./core/timsort');\n\t    function shapeCompareFunc(a, b) {\n\t        if (a.zlevel === b.zlevel) {\n\t            if (a.z === b.z) {\n\t                // if (a.z2 === b.z2) {\n\t                //     // FIXME Slow has renderidx compare\n\t                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n\t                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n\t                //     return a.__renderidx - b.__renderidx;\n\t                // }\n\t                return a.z2 - b.z2;\n\t            }\n\t            return a.z - b.z;\n\t        }\n\t        return a.zlevel - b.zlevel;\n\t    }\n\t    /**\n\t     * 内容仓库 (M)\n\t     * @alias module:zrender/Storage\n\t     * @constructor\n\t     */\n\t    var Storage = function () {\n\t        // 所有常规形状，id索引的map\n\t        this._elements = {};\n\t        this._roots = [];\n\t        this._displayList = [];\n\t        this._displayListLen = 0;\n\t    };\n\t    Storage.prototype = {\n\t        constructor: Storage,\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._roots.length; i++) {\n\t                this._roots[i].traverse(cb, context);\n\t            }\n\t        },\n\t        getDisplayList: function (update, includeIgnore) {\n\t            includeIgnore = includeIgnore || false;\n\t            if (update) {\n\t                this.updateDisplayList(includeIgnore);\n\t            }\n\t            return this._displayList;\n\t        },\n\t        updateDisplayList: function (includeIgnore) {\n\t            this._displayListLen = 0;\n\t            var roots = this._roots;\n\t            var displayList = this._displayList;\n\t            for (var i = 0, len = roots.length; i < len; i++) {\n\t                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n\t            }\n\t            displayList.length = this._displayListLen;\n\t            // for (var i = 0, len = displayList.length; i < len; i++) {\n\t            //     displayList[i].__renderidx = i;\n\t            // }\n\t            // displayList.sort(shapeCompareFunc);\n\t            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n\t        },\n\t        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\t            if (el.ignore && !includeIgnore) {\n\t                return;\n\t            }\n\t            el.beforeUpdate();\n\t            if (el.__dirty) {\n\t                el.update();\n\t            }\n\t            el.afterUpdate();\n\t            var clipPath = el.clipPath;\n\t            if (clipPath) {\n\t                // clipPath 的变换是基于 group 的变换\n\t                clipPath.parent = el;\n\t                clipPath.updateTransform();\n\t                // FIXME 效率影响\n\t                if (clipPaths) {\n\t                    clipPaths = clipPaths.slice();\n\t                    clipPaths.push(clipPath);\n\t                } else {\n\t                    clipPaths = [clipPath];\n\t                }\n\t            }\n\t            if (el.isGroup) {\n\t                var children = el._children;\n\t                for (var i = 0; i < children.length; i++) {\n\t                    var child = children[i];\n\t                    // Force to mark as dirty if group is dirty\n\t                    // FIXME __dirtyPath ?\n\t                    if (el.__dirty) {\n\t                        child.__dirty = true;\n\t                    }\n\t                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n\t                }\n\t                // Mark group clean here\n\t                el.__dirty = false;\n\t            } else {\n\t                el.__clipPaths = clipPaths;\n\t                this._displayList[this._displayListLen++] = el;\n\t            }\n\t        },\n\t        addRoot: function (el) {\n\t            // Element has been added\n\t            if (this._elements[el.id]) {\n\t                return;\n\t            }\n\t            if (el instanceof Group) {\n\t                el.addChildrenToStorage(this);\n\t            }\n\t            this.addToMap(el);\n\t            this._roots.push(el);\n\t        },\n\t        delRoot: function (elId) {\n\t            if (elId == null) {\n\t                // 不指定elId清空\n\t                for (var i = 0; i < this._roots.length; i++) {\n\t                    var root = this._roots[i];\n\t                    if (root instanceof Group) {\n\t                        root.delChildrenFromStorage(this);\n\t                    }\n\t                }\n\t                this._elements = {};\n\t                this._roots = [];\n\t                this._displayList = [];\n\t                this._displayListLen = 0;\n\t                return;\n\t            }\n\t            if (elId instanceof Array) {\n\t                for (var i = 0, l = elId.length; i < l; i++) {\n\t                    this.delRoot(elId[i]);\n\t                }\n\t                return;\n\t            }\n\t            var el;\n\t            if (typeof elId == 'string') {\n\t                el = this._elements[elId];\n\t            } else {\n\t                el = elId;\n\t            }\n\t            var idx = util.indexOf(this._roots, el);\n\t            if (idx >= 0) {\n\t                this.delFromMap(el.id);\n\t                this._roots.splice(idx, 1);\n\t                if (el instanceof Group) {\n\t                    el.delChildrenFromStorage(this);\n\t                }\n\t            }\n\t        },\n\t        addToMap: function (el) {\n\t            if (el instanceof Group) {\n\t                el.__storage = this;\n\t            }\n\t            el.dirty(false);\n\t            this._elements[el.id] = el;\n\t            return this;\n\t        },\n\t        get: function (elId) {\n\t            return this._elements[elId];\n\t        },\n\t        delFromMap: function (elId) {\n\t            var elements = this._elements;\n\t            var el = elements[elId];\n\t            if (el) {\n\t                delete elements[elId];\n\t                if (el instanceof Group) {\n\t                    el.__storage = null;\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t        dispose: function () {\n\t            this._elements = this._renderList = this._roots = null;\n\t        },\n\t        displayableSortFunc: shapeCompareFunc\n\t    };\n\t    return Storage;\n\t});\n\tdefine('zrender/Handler', ['require', './core/util', './mixin/Draggable', './mixin/Eventful'], function (require) {\n\t    'use strict';\n\t    var util = require('./core/util');\n\t    var Draggable = require('./mixin/Draggable');\n\t    var Eventful = require('./mixin/Eventful');\n\t    function makeEventPacket(eveType, target, event) {\n\t        return {\n\t            type: eveType,\n\t            event: event,\n\t            target: target,\n\t            cancelBubble: false,\n\t            offsetX: event.zrX,\n\t            offsetY: event.zrY,\n\t            gestureEvent: event.gestureEvent,\n\t            pinchX: event.pinchX,\n\t            pinchY: event.pinchY,\n\t            pinchScale: event.pinchScale,\n\t            wheelDelta: event.zrDelta\n\t        };\n\t    }\n\t    function EmptyProxy() {\n\t    }\n\t    EmptyProxy.prototype.dispose = function () {\n\t    };\n\t    var handlerNames = [\n\t            'click',\n\t            'dblclick',\n\t            'mousewheel',\n\t            'mouseout',\n\t            'mouseup',\n\t            'mousedown',\n\t            'mousemove'\n\t        ];\n\t    /**\n\t     * @alias module:zrender/Handler\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Eventful\n\t     * @param {HTMLElement} root Main HTML element for painting.\n\t     * @param {module:zrender/Storage} storage Storage instance.\n\t     * @param {module:zrender/Painter} painter Painter instance.\n\t     */\n\t    var Handler = function (storage, painter, proxy) {\n\t        Eventful.call(this);\n\t        this.storage = storage;\n\t        this.painter = painter;\n\t        proxy = proxy || new EmptyProxy();\n\t        /**\n\t         * Proxy of event. can be Dom, WebGLSurface, etc.\n\t         */\n\t        this.proxy = proxy;\n\t        // Attach handler\n\t        proxy.handler = this;\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._hovered;\n\t        /**\n\t         * @private\n\t         * @type {Date}\n\t         */\n\t        this._lastTouchMoment;\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastX;\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastY;\n\t        Draggable.call(this);\n\t        util.each(handlerNames, function (name) {\n\t            proxy.on && proxy.on(name, this[name], this);\n\t        }, this);\n\t    };\n\t    Handler.prototype = {\n\t        constructor: Handler,\n\t        mousemove: function (event) {\n\t            var x = event.zrX;\n\t            var y = event.zrY;\n\t            var hovered = this.findHover(x, y, null);\n\t            var lastHovered = this._hovered;\n\t            var proxy = this.proxy;\n\t            this._hovered = hovered;\n\t            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\t            // Mouse out on previous hovered element\n\t            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n\t                this.dispatchToElement(lastHovered, 'mouseout', event);\n\t            }\n\t            // Mouse moving on one element\n\t            this.dispatchToElement(hovered, 'mousemove', event);\n\t            // Mouse over on a new element\n\t            if (hovered && hovered !== lastHovered) {\n\t                this.dispatchToElement(hovered, 'mouseover', event);\n\t            }\n\t        },\n\t        mouseout: function (event) {\n\t            this.dispatchToElement(this._hovered, 'mouseout', event);\n\t            this.trigger('globalout', { event: event });\n\t        },\n\t        resize: function (event) {\n\t            this._hovered = null;\n\t        },\n\t        dispatch: function (eventName, eventArgs) {\n\t            var handler = this[eventName];\n\t            handler && handler.call(this, eventArgs);\n\t        },\n\t        dispose: function () {\n\t            this.proxy.dispose();\n\t            this.storage = this.proxy = this.painter = null;\n\t        },\n\t        setCursorStyle: function (cursorStyle) {\n\t            var proxy = this.proxy;\n\t            proxy.setCursor && proxy.setCursor(cursorStyle);\n\t        },\n\t        dispatchToElement: function (targetEl, eventName, event) {\n\t            var eventHandler = 'on' + eventName;\n\t            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\t            var el = targetEl;\n\t            while (el) {\n\t                el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\t                el.trigger(eventName, eventPacket);\n\t                el = el.parent;\n\t                if (eventPacket.cancelBubble) {\n\t                    break;\n\t                }\n\t            }\n\t            if (!eventPacket.cancelBubble) {\n\t                // 冒泡到顶级 zrender 对象\n\t                this.trigger(eventName, eventPacket);\n\t                // 分发事件到用户自定义层\n\t                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\t                this.painter && this.painter.eachOtherLayer(function (layer) {\n\t                    if (typeof layer[eventHandler] == 'function') {\n\t                        layer[eventHandler].call(layer, eventPacket);\n\t                    }\n\t                    if (layer.trigger) {\n\t                        layer.trigger(eventName, eventPacket);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t        findHover: function (x, y, exclude) {\n\t            var list = this.storage.getDisplayList();\n\t            for (var i = list.length - 1; i >= 0; i--) {\n\t                if (!list[i].silent && list[i] !== exclude && !list[i].ignore && isHover(list[i], x, y)) {\n\t                    return list[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t    // Common handlers\n\t    util.each([\n\t        'click',\n\t        'mousedown',\n\t        'mouseup',\n\t        'mousewheel',\n\t        'dblclick'\n\t    ], function (name) {\n\t        Handler.prototype[name] = function (event) {\n\t            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n\t            var hovered = this.findHover(event.zrX, event.zrY, null);\n\t            if (name === 'mousedown') {\n\t                this._downel = hovered;\n\t                // In case click triggered before mouseup\n\t                this._upel = hovered;\n\t            } else if (name === 'mosueup') {\n\t                this._upel = hovered;\n\t            } else if (name === 'click') {\n\t                if (this._downel !== this._upel) {\n\t                    return;\n\t                }\n\t            }\n\t            this.dispatchToElement(hovered, name, event);\n\t        };\n\t    });\n\t    function isHover(displayable, x, y) {\n\t        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n\t            var el = displayable;\n\t            while (el) {\n\t                // If ancestor is silent or clipped by ancestor\n\t                if (el.silent || el.clipPath && !el.clipPath.contain(x, y)) {\n\t                    return false;\n\t                }\n\t                el = el.parent;\n\t            }\n\t            return true;\n\t        }\n\t        return false;\n\t    }\n\t    util.mixin(Handler, Eventful);\n\t    util.mixin(Handler, Draggable);\n\t    return Handler;\n\t});\n\tdefine('zrender/animation/Animation', ['require', '../core/util', '../core/event', './requestAnimationFrame', './Animator'], function (require) {\n\t    'use strict';\n\t    var util = require('../core/util');\n\t    var Dispatcher = require('../core/event').Dispatcher;\n\t    var requestAnimationFrame = require('./requestAnimationFrame');\n\t    var Animator = require('./Animator');\n\t    /**\n\t     * @typedef {Object} IZRenderStage\n\t     * @property {Function} update\n\t     */\n\t    /**\n\t     * @alias module:zrender/animation/Animation\n\t     * @constructor\n\t     * @param {Object} [options]\n\t     * @param {Function} [options.onframe]\n\t     * @param {IZRenderStage} [options.stage]\n\t     * @example\n\t     *     var animation = new Animation();\n\t     *     var obj = {\n\t     *         x: 100,\n\t     *         y: 100\n\t     *     };\n\t     *     animation.animate(node.position)\n\t     *         .when(1000, {\n\t     *             x: 500,\n\t     *             y: 500\n\t     *         })\n\t     *         .when(2000, {\n\t     *             x: 100,\n\t     *             y: 100\n\t     *         })\n\t     *         .start('spline');\n\t     */\n\t    var Animation = function (options) {\n\t        options = options || {};\n\t        this.stage = options.stage || {};\n\t        this.onframe = options.onframe || function () {\n\t        };\n\t        // private properties\n\t        this._clips = [];\n\t        this._running = false;\n\t        this._time;\n\t        this._pausedTime;\n\t        this._pauseStart;\n\t        this._paused = false;\n\t        Dispatcher.call(this);\n\t    };\n\t    Animation.prototype = {\n\t        constructor: Animation,\n\t        addClip: function (clip) {\n\t            this._clips.push(clip);\n\t        },\n\t        addAnimator: function (animator) {\n\t            animator.animation = this;\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.addClip(clips[i]);\n\t            }\n\t        },\n\t        removeClip: function (clip) {\n\t            var idx = util.indexOf(this._clips, clip);\n\t            if (idx >= 0) {\n\t                this._clips.splice(idx, 1);\n\t            }\n\t        },\n\t        removeAnimator: function (animator) {\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.removeClip(clips[i]);\n\t            }\n\t            animator.animation = null;\n\t        },\n\t        _update: function () {\n\t            var time = new Date().getTime() - this._pausedTime;\n\t            var delta = time - this._time;\n\t            var clips = this._clips;\n\t            var len = clips.length;\n\t            var deferredEvents = [];\n\t            var deferredClips = [];\n\t            for (var i = 0; i < len; i++) {\n\t                var clip = clips[i];\n\t                var e = clip.step(time);\n\t                // Throw out the events need to be called after\n\t                // stage.update, like destroy\n\t                if (e) {\n\t                    deferredEvents.push(e);\n\t                    deferredClips.push(clip);\n\t                }\n\t            }\n\t            // Remove the finished clip\n\t            for (var i = 0; i < len;) {\n\t                if (clips[i]._needsRemove) {\n\t                    clips[i] = clips[len - 1];\n\t                    clips.pop();\n\t                    len--;\n\t                } else {\n\t                    i++;\n\t                }\n\t            }\n\t            len = deferredEvents.length;\n\t            for (var i = 0; i < len; i++) {\n\t                deferredClips[i].fire(deferredEvents[i]);\n\t            }\n\t            this._time = time;\n\t            this.onframe(delta);\n\t            this.trigger('frame', delta);\n\t            if (this.stage.update) {\n\t                this.stage.update();\n\t            }\n\t        },\n\t        _startLoop: function () {\n\t            var self = this;\n\t            this._running = true;\n\t            function step() {\n\t                if (self._running) {\n\t                    requestAnimationFrame(step);\n\t                    !self._paused && self._update();\n\t                }\n\t            }\n\t            requestAnimationFrame(step);\n\t        },\n\t        start: function () {\n\t            this._time = new Date().getTime();\n\t            this._pausedTime = 0;\n\t            this._startLoop();\n\t        },\n\t        stop: function () {\n\t            this._running = false;\n\t        },\n\t        pause: function () {\n\t            if (!this._paused) {\n\t                this._pauseStart = new Date().getTime();\n\t                this._paused = true;\n\t            }\n\t        },\n\t        resume: function () {\n\t            if (this._paused) {\n\t                this._pausedTime += new Date().getTime() - this._pauseStart;\n\t                this._paused = false;\n\t            }\n\t        },\n\t        clear: function () {\n\t            this._clips = [];\n\t        },\n\t        animate: function (target, options) {\n\t            options = options || {};\n\t            var animator = new Animator(target, options.loop, options.getter, options.setter);\n\t            return animator;\n\t        }\n\t    };\n\t    util.mixin(Animation, Dispatcher);\n\t    return Animation;\n\t});\n\tdefine('zrender/dom/HandlerProxy', ['require', '../core/event', '../core/util', '../mixin/Eventful', '../core/env', '../core/GestureMgr'], function (require) {\n\t    var eventTool = require('../core/event');\n\t    var zrUtil = require('../core/util');\n\t    var Eventful = require('../mixin/Eventful');\n\t    var env = require('../core/env');\n\t    var GestureMgr = require('../core/GestureMgr');\n\t    var addEventListener = eventTool.addEventListener;\n\t    var removeEventListener = eventTool.removeEventListener;\n\t    var normalizeEvent = eventTool.normalizeEvent;\n\t    var TOUCH_CLICK_DELAY = 300;\n\t    var mouseHandlerNames = [\n\t            'click',\n\t            'dblclick',\n\t            'mousewheel',\n\t            'mouseout',\n\t            'mouseup',\n\t            'mousedown',\n\t            'mousemove'\n\t        ];\n\t    var touchHandlerNames = [\n\t            'touchstart',\n\t            'touchend',\n\t            'touchmove'\n\t        ];\n\t    function eventNameFix(name) {\n\t        return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n\t    }\n\t    function processGesture(proxy, event, stage) {\n\t        var gestureMgr = proxy._gestureMgr;\n\t        stage === 'start' && gestureMgr.clear();\n\t        var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null), proxy.dom);\n\t        stage === 'end' && gestureMgr.clear();\n\t        if (gestureInfo) {\n\t            // eventTool.stop(event);\n\t            var type = gestureInfo.type;\n\t            event.gestureEvent = type;\n\t            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n\t        }\n\t    }\n\t    /**\n\t     * Prevent mouse event from being dispatched after Touch Events action\n\t     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n\t     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n\t     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n\t     * Result: Blocking Mouse Events for 700ms.\n\t     */\n\t    function setTouchTimer(instance) {\n\t        instance._touching = true;\n\t        clearTimeout(instance._touchTimer);\n\t        instance._touchTimer = setTimeout(function () {\n\t            instance._touching = false;\n\t        }, 700);\n\t    }\n\t    function useTouchEvent() {\n\t        return env.touchEventsSupported;\n\t    }\n\t    var domHandlers = {\n\t            mousemove: function (event) {\n\t                event = normalizeEvent(this.dom, event);\n\t                this.trigger('mousemove', event);\n\t            },\n\t            mouseout: function (event) {\n\t                event = normalizeEvent(this.dom, event);\n\t                var element = event.toElement || event.relatedTarget;\n\t                if (element != this.dom) {\n\t                    while (element && element.nodeType != 9) {\n\t                        // 忽略包含在root中的dom引起的mouseOut\n\t                        if (element === this.dom) {\n\t                            return;\n\t                        }\n\t                        element = element.parentNode;\n\t                    }\n\t                }\n\t                this.trigger('mouseout', event);\n\t            },\n\t            touchstart: function (event) {\n\t                // Default mouse behaviour should not be disabled here.\n\t                // For example, page may needs to be slided.\n\t                event = normalizeEvent(this.dom, event);\n\t                this._lastTouchMoment = new Date();\n\t                processGesture(this, event, 'start');\n\t                // 平板补充一次findHover\n\t                // this._mobileFindFixed(event);\n\t                // Trigger mousemove and mousedown\n\t                domHandlers.mousemove.call(this, event);\n\t                domHandlers.mousedown.call(this, event);\n\t                setTouchTimer(this);\n\t            },\n\t            touchmove: function (event) {\n\t                event = normalizeEvent(this.dom, event);\n\t                processGesture(this, event, 'change');\n\t                // Mouse move should always be triggered no matter whether\n\t                // there is gestrue event, because mouse move and pinch may\n\t                // be used at the same time.\n\t                domHandlers.mousemove.call(this, event);\n\t                setTouchTimer(this);\n\t            },\n\t            touchend: function (event) {\n\t                event = normalizeEvent(this.dom, event);\n\t                processGesture(this, event, 'end');\n\t                domHandlers.mouseup.call(this, event);\n\t                // click event should always be triggered no matter whether\n\t                // there is gestrue event. System click can not be prevented.\n\t                if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n\t                    domHandlers.click.call(this, event);\n\t                }\n\t                setTouchTimer(this);\n\t            }\n\t        };\n\t    // Common handlers\n\t    zrUtil.each([\n\t        'click',\n\t        'mousedown',\n\t        'mouseup',\n\t        'mousewheel',\n\t        'dblclick'\n\t    ], function (name) {\n\t        domHandlers[name] = function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t            this.trigger(name, event);\n\t        };\n\t    });\n\t    /**\n\t     * 为控制类实例初始化dom 事件处理函数\n\t     *\n\t     * @inner\n\t     * @param {module:zrender/Handler} instance 控制类实例\n\t     */\n\t    function initDomHandler(instance) {\n\t        for (var i = 0; i < touchHandlerNames.length; i++) {\n\t            var name = touchHandlerNames[i];\n\t            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t        }\n\t        for (var i = 0; i < mouseHandlerNames.length; i++) {\n\t            var name = mouseHandlerNames[i];\n\t            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n\t        }\n\t        function makeMouseHandler(fn, instance) {\n\t            return function () {\n\t                if (instance._touching) {\n\t                    return;\n\t                }\n\t                return fn.apply(instance, arguments);\n\t            };\n\t        }\n\t    }\n\t    function HandlerDomProxy(dom) {\n\t        Eventful.call(this);\n\t        this.dom = dom;\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._touching = false;\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._touchTimer;\n\t        /**\n\t         * @private\n\t         * @type {module:zrender/core/GestureMgr}\n\t         */\n\t        this._gestureMgr = new GestureMgr();\n\t        this._handlers = {};\n\t        initDomHandler(this);\n\t        if (useTouchEvent()) {\n\t            mountHandlers(touchHandlerNames, this);    // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n\t                                                       // addEventListener(root, 'mouseout', this._mouseoutHandler);\n\t        }\n\t        // Considering some devices that both enable touch and mouse event (like MS Surface\n\t        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n\t        // mouse event can not be handle in those devices.\n\t        mountHandlers(mouseHandlerNames, this);\n\t        function mountHandlers(handlerNames, instance) {\n\t            zrUtil.each(handlerNames, function (name) {\n\t                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n\t            }, instance);\n\t        }\n\t    }\n\t    var handlerDomProxyProto = HandlerDomProxy.prototype;\n\t    handlerDomProxyProto.dispose = function () {\n\t        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\t        for (var i = 0; i < handlerNames.length; i++) {\n\t            var name = handlerNames[i];\n\t            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n\t        }\n\t    };\n\t    handlerDomProxyProto.setCursor = function (cursorStyle) {\n\t        this.dom.style.cursor = cursorStyle || 'default';\n\t    };\n\t    zrUtil.mixin(HandlerDomProxy, Eventful);\n\t    return HandlerDomProxy;\n\t});\n\tdefine('zrender/Painter', ['require', './config', './core/util', './core/log', './core/BoundingRect', './core/timsort', './Layer', './animation/requestAnimationFrame', './graphic/Image'], function (require) {\n\t    'use strict';\n\t    var config = require('./config');\n\t    var util = require('./core/util');\n\t    var log = require('./core/log');\n\t    var BoundingRect = require('./core/BoundingRect');\n\t    var timsort = require('./core/timsort');\n\t    var Layer = require('./Layer');\n\t    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n\t    // PENDIGN\n\t    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n\t    //\n\t    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n\t    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t    function isLayerValid(layer) {\n\t        if (!layer) {\n\t            return false;\n\t        }\n\t        if (layer.isBuildin) {\n\t            return true;\n\t        }\n\t        if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n\t            return false;\n\t        }\n\t        return true;\n\t    }\n\t    function preProcessLayer(layer) {\n\t        layer.__unusedCount++;\n\t    }\n\t    function postProcessLayer(layer) {\n\t        if (layer.__unusedCount == 1) {\n\t            layer.clear();\n\t        }\n\t    }\n\t    var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t    var viewRect = new BoundingRect(0, 0, 0, 0);\n\t    function isDisplayableCulled(el, width, height) {\n\t        tmpRect.copy(el.getBoundingRect());\n\t        if (el.transform) {\n\t            tmpRect.applyTransform(el.transform);\n\t        }\n\t        viewRect.width = width;\n\t        viewRect.height = height;\n\t        return !tmpRect.intersect(viewRect);\n\t    }\n\t    function isClipPathChanged(clipPaths, prevClipPaths) {\n\t        if (clipPaths == prevClipPaths) {\n\t            // Can both be null or undefined\n\t            return false;\n\t        }\n\t        if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n\t            return true;\n\t        }\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            if (clipPaths[i] !== prevClipPaths[i]) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t    function doClip(clipPaths, ctx) {\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            var clipPath = clipPaths[i];\n\t            var path = clipPath.path;\n\t            clipPath.setTransform(ctx);\n\t            path.beginPath(ctx);\n\t            clipPath.buildPath(path, clipPath.shape);\n\t            ctx.clip();\n\t            // Transform back\n\t            clipPath.restoreTransform(ctx);\n\t        }\n\t    }\n\t    function createRoot(width, height) {\n\t        var domRoot = document.createElement('div');\n\t        var domRootStyle = domRoot.style;\n\t        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t        domRootStyle.position = 'relative';\n\t        domRootStyle.overflow = 'hidden';\n\t        domRootStyle.width = width + 'px';\n\t        domRootStyle.height = height + 'px';\n\t        return domRoot;\n\t    }\n\t    /**\n\t     * @alias module:zrender/Painter\n\t     * @constructor\n\t     * @param {HTMLElement} root 绘图容器\n\t     * @param {module:zrender/Storage} storage\n\t     * @param {Ojbect} opts\n\t     */\n\t    var Painter = function (root, storage, opts) {\n\t        // In node environment using node-canvas\n\t        var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === 'CANVAS';\n\t        opts = opts || {};\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._singleCanvas = singleCanvas;\n\t        /**\n\t         * 绘图容器\n\t         * @type {HTMLElement}\n\t         */\n\t        this.root = root;\n\t        var rootStyle = root.style;\n\t        if (rootStyle) {\n\t            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n\t            rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n\t            root.innerHTML = '';\n\t        }\n\t        /**\n\t         * @type {module:zrender/Storage}\n\t         */\n\t        this.storage = storage;\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        var zlevelList = this._zlevelList = [];\n\t        /**\n\t         * @type {Object.<string, module:zrender/Layer>}\n\t         * @private\n\t         */\n\t        var layers = this._layers = {};\n\t        /**\n\t         * @type {Object.<string, Object>}\n\t         * @type {private}\n\t         */\n\t        this._layerConfig = {};\n\t        if (!singleCanvas) {\n\t            this._width = this._getWidth();\n\t            this._height = this._getHeight();\n\t            var domRoot = this._domRoot = createRoot(this._width, this._height);\n\t            root.appendChild(domRoot);\n\t        } else {\n\t            // Use canvas width and height directly\n\t            var width = root.width;\n\t            var height = root.height;\n\t            this._width = width;\n\t            this._height = height;\n\t            // Create layer if only one given canvas\n\t            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\t            var mainLayer = new Layer(root, this, 1);\n\t            mainLayer.initContext();\n\t            // FIXME Use canvas width and height\n\t            // mainLayer.resize(width, height);\n\t            layers[0] = mainLayer;\n\t            zlevelList.push(0);\n\t        }\n\t        this.pathToImage = this._createPathToImage();\n\t        // Layers for progressive rendering\n\t        this._progressiveLayers = [];\n\t        /**\n\t         * @type {module:zrender/Layer}\n\t         * @private\n\t         */\n\t        this._hoverlayer;\n\t        this._hoverElements = [];\n\t    };\n\t    Painter.prototype = {\n\t        constructor: Painter,\n\t        isSingleCanvas: function () {\n\t            return this._singleCanvas;\n\t        },\n\t        getViewportRoot: function () {\n\t            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n\t        },\n\t        refresh: function (paintAll) {\n\t            var list = this.storage.getDisplayList(true);\n\t            var zlevelList = this._zlevelList;\n\t            this._paintList(list, paintAll);\n\t            // Paint custum layers\n\t            for (var i = 0; i < zlevelList.length; i++) {\n\t                var z = zlevelList[i];\n\t                var layer = this._layers[z];\n\t                if (!layer.isBuildin && layer.refresh) {\n\t                    layer.refresh();\n\t                }\n\t            }\n\t            this.refreshHover();\n\t            if (this._progressiveLayers.length) {\n\t                this._startProgessive();\n\t            }\n\t            return this;\n\t        },\n\t        addHover: function (el, hoverStyle) {\n\t            if (el.__hoverMir) {\n\t                return;\n\t            }\n\t            var elMirror = new el.constructor({\n\t                    style: el.style,\n\t                    shape: el.shape\n\t                });\n\t            elMirror.__from = el;\n\t            el.__hoverMir = elMirror;\n\t            elMirror.setStyle(hoverStyle);\n\t            this._hoverElements.push(elMirror);\n\t        },\n\t        removeHover: function (el) {\n\t            var elMirror = el.__hoverMir;\n\t            var hoverElements = this._hoverElements;\n\t            var idx = util.indexOf(hoverElements, elMirror);\n\t            if (idx >= 0) {\n\t                hoverElements.splice(idx, 1);\n\t            }\n\t            el.__hoverMir = null;\n\t        },\n\t        clearHover: function (el) {\n\t            var hoverElements = this._hoverElements;\n\t            for (var i = 0; i < hoverElements.length; i++) {\n\t                var from = hoverElements[i].__from;\n\t                if (from) {\n\t                    from.__hoverMir = null;\n\t                }\n\t            }\n\t            hoverElements.length = 0;\n\t        },\n\t        refreshHover: function () {\n\t            var hoverElements = this._hoverElements;\n\t            var len = hoverElements.length;\n\t            var hoverLayer = this._hoverlayer;\n\t            hoverLayer && hoverLayer.clear();\n\t            if (!len) {\n\t                return;\n\t            }\n\t            timsort(hoverElements, this.storage.displayableSortFunc);\n\t            // Use a extream large zlevel\n\t            // FIXME?\n\t            if (!hoverLayer) {\n\t                hoverLayer = this._hoverlayer = this.getLayer(100000);\n\t            }\n\t            var scope = {};\n\t            hoverLayer.ctx.save();\n\t            for (var i = 0; i < len;) {\n\t                var el = hoverElements[i];\n\t                var originalEl = el.__from;\n\t                // Original el is removed\n\t                // PENDING\n\t                if (!(originalEl && originalEl.__zr)) {\n\t                    hoverElements.splice(i, 1);\n\t                    originalEl.__hoverMir = null;\n\t                    len--;\n\t                    continue;\n\t                }\n\t                i++;\n\t                // Use transform\n\t                // FIXME style and shape ?\n\t                if (!originalEl.invisible) {\n\t                    el.transform = originalEl.transform;\n\t                    el.invTransform = originalEl.invTransform;\n\t                    el.__clipPaths = originalEl.__clipPaths;\n\t                    // el.\n\t                    this._doPaintEl(el, hoverLayer, true, scope);\n\t                }\n\t            }\n\t            hoverLayer.ctx.restore();\n\t        },\n\t        _startProgessive: function () {\n\t            var self = this;\n\t            if (!self._furtherProgressive) {\n\t                return;\n\t            }\n\t            // Use a token to stop progress steps triggered by\n\t            // previous zr.refresh calling.\n\t            var token = self._progressiveToken = +new Date();\n\t            self._progress++;\n\t            requestAnimationFrame(step);\n\t            function step() {\n\t                // In case refreshed or disposed\n\t                if (token === self._progressiveToken && self.storage) {\n\t                    self._doPaintList(self.storage.getDisplayList());\n\t                    if (self._furtherProgressive) {\n\t                        self._progress++;\n\t                        requestAnimationFrame(step);\n\t                    } else {\n\t                        self._progressiveToken = -1;\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        _clearProgressive: function () {\n\t            this._progressiveToken = -1;\n\t            this._progress = 0;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                layer.__dirty && layer.clear();\n\t            });\n\t        },\n\t        _paintList: function (list, paintAll) {\n\t            if (paintAll == null) {\n\t                paintAll = false;\n\t            }\n\t            this._updateLayerStatus(list);\n\t            this._clearProgressive();\n\t            this.eachBuildinLayer(preProcessLayer);\n\t            this._doPaintList(list, paintAll);\n\t            this.eachBuildinLayer(postProcessLayer);\n\t        },\n\t        _doPaintList: function (list, paintAll) {\n\t            var currentLayer;\n\t            var currentZLevel;\n\t            var ctx;\n\t            // var invTransform = [];\n\t            var scope;\n\t            var progressiveLayerIdx = 0;\n\t            var currentProgressiveLayer;\n\t            var width = this._width;\n\t            var height = this._height;\n\t            var layerProgress;\n\t            var frame = this._progress;\n\t            function flushProgressiveLayer(layer) {\n\t                var dpr = ctx.dpr || 1;\n\t                ctx.save();\n\t                ctx.globalAlpha = 1;\n\t                ctx.shadowBlur = 0;\n\t                // Avoid layer don't clear in next progressive frame\n\t                currentLayer.__dirty = true;\n\t                ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n\t                ctx.restore();\n\t            }\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\t                var elFrame = el.__frame;\n\t                // Flush at current context\n\t                // PENDING\n\t                if (elFrame < 0 && currentProgressiveLayer) {\n\t                    flushProgressiveLayer(currentProgressiveLayer);\n\t                    currentProgressiveLayer = null;\n\t                }\n\t                // Change draw layer\n\t                if (currentZLevel !== elZLevel) {\n\t                    if (ctx) {\n\t                        ctx.restore();\n\t                    }\n\t                    // Reset scope\n\t                    scope = {};\n\t                    // Only 0 zlevel if only has one canvas\n\t                    currentZLevel = elZLevel;\n\t                    currentLayer = this.getLayer(currentZLevel);\n\t                    if (!currentLayer.isBuildin) {\n\t                        log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n\t                    }\n\t                    ctx = currentLayer.ctx;\n\t                    ctx.save();\n\t                    // Reset the count\n\t                    currentLayer.__unusedCount = 0;\n\t                    if (currentLayer.__dirty || paintAll) {\n\t                        currentLayer.clear();\n\t                    }\n\t                }\n\t                if (!(currentLayer.__dirty || paintAll)) {\n\t                    continue;\n\t                }\n\t                if (elFrame >= 0) {\n\t                    // Progressive layer changed\n\t                    if (!currentProgressiveLayer) {\n\t                        currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n\t                        currentProgressiveLayer.ctx.save();\n\t                        currentProgressiveLayer.renderScope = {};\n\t                        if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n\t                            // flushProgressiveLayer(currentProgressiveLayer);\n\t                            // Quick jump all progressive elements\n\t                            // All progressive element are not dirty, jump over and flush directly\n\t                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n\t                            // currentProgressiveLayer = null;\n\t                            continue;\n\t                        }\n\t                        layerProgress = currentProgressiveLayer.__progress;\n\t                        if (!currentProgressiveLayer.__dirty) {\n\t                            // Keep rendering\n\t                            frame = layerProgress;\n\t                        }\n\t                        currentProgressiveLayer.__progress = frame + 1;\n\t                    }\n\t                    if (elFrame === frame) {\n\t                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n\t                    }\n\t                } else {\n\t                    this._doPaintEl(el, currentLayer, paintAll, scope);\n\t                }\n\t                el.__dirty = false;\n\t            }\n\t            if (currentProgressiveLayer) {\n\t                flushProgressiveLayer(currentProgressiveLayer);\n\t            }\n\t            // Restore the lastLayer ctx\n\t            ctx && ctx.restore();\n\t            // If still has clipping state\n\t            // if (scope.prevElClipPaths) {\n\t            //     ctx.restore();\n\t            // }\n\t            this._furtherProgressive = false;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                if (layer.__maxProgress >= layer.__progress) {\n\t                    this._furtherProgressive = true;\n\t                }\n\t            }, this);\n\t        },\n\t        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n\t            var ctx = currentLayer.ctx;\n\t            var m = el.transform;\n\t            if ((currentLayer.__dirty || forcePaint) && !el.invisible && el.style.opacity !== 0 && !(m && !m[0] && !m[3]) && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n\t                var clipPaths = el.__clipPaths;\n\t                // Optimize when clipping on group with several elements\n\t                if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n\t                    // If has previous clipping state, restore from it\n\t                    if (scope.prevElClipPaths) {\n\t                        scope.prevClipLayer.ctx.restore();\n\t                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\t                        // Reset prevEl since context has been restored\n\t                        scope.prevEl = null;\n\t                    }\n\t                    // New clipping state\n\t                    if (clipPaths) {\n\t                        ctx.save();\n\t                        doClip(clipPaths, ctx);\n\t                        scope.prevClipLayer = currentLayer;\n\t                        scope.prevElClipPaths = clipPaths;\n\t                    }\n\t                }\n\t                el.beforeBrush && el.beforeBrush(ctx);\n\t                el.brush(ctx, scope.prevEl || null);\n\t                scope.prevEl = el;\n\t                el.afterBrush && el.afterBrush(ctx);\n\t            }\n\t        },\n\t        getLayer: function (zlevel) {\n\t            if (this._singleCanvas) {\n\t                return this._layers[0];\n\t            }\n\t            var layer = this._layers[zlevel];\n\t            if (!layer) {\n\t                // Create a new layer\n\t                layer = new Layer('zr_' + zlevel, this, this.dpr);\n\t                layer.isBuildin = true;\n\t                if (this._layerConfig[zlevel]) {\n\t                    util.merge(layer, this._layerConfig[zlevel], true);\n\t                }\n\t                this.insertLayer(zlevel, layer);\n\t                // Context is created after dom inserted to document\n\t                // Or excanvas will get 0px clientWidth and clientHeight\n\t                layer.initContext();\n\t            }\n\t            return layer;\n\t        },\n\t        insertLayer: function (zlevel, layer) {\n\t            var layersMap = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var len = zlevelList.length;\n\t            var prevLayer = null;\n\t            var i = -1;\n\t            var domRoot = this._domRoot;\n\t            if (layersMap[zlevel]) {\n\t                log('ZLevel ' + zlevel + ' has been used already');\n\t                return;\n\t            }\n\t            // Check if is a valid layer\n\t            if (!isLayerValid(layer)) {\n\t                log('Layer of zlevel ' + zlevel + ' is not valid');\n\t                return;\n\t            }\n\t            if (len > 0 && zlevel > zlevelList[0]) {\n\t                for (i = 0; i < len - 1; i++) {\n\t                    if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n\t                        break;\n\t                    }\n\t                }\n\t                prevLayer = layersMap[zlevelList[i]];\n\t            }\n\t            zlevelList.splice(i + 1, 0, zlevel);\n\t            if (prevLayer) {\n\t                var prevDom = prevLayer.dom;\n\t                if (prevDom.nextSibling) {\n\t                    domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n\t                } else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            } else {\n\t                if (domRoot.firstChild) {\n\t                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n\t                } else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            }\n\t            layersMap[zlevel] = layer;\n\t        },\n\t        eachLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                cb.call(context, this._layers[z], z);\n\t            }\n\t        },\n\t        eachBuildinLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t        eachOtherLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (!layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t        getLayers: function () {\n\t            return this._layers;\n\t        },\n\t        _updateLayerStatus: function (list) {\n\t            var layers = this._layers;\n\t            var progressiveLayers = this._progressiveLayers;\n\t            var elCountsLastFrame = {};\n\t            var progressiveElCountsLastFrame = {};\n\t            this.eachBuildinLayer(function (layer, z) {\n\t                elCountsLastFrame[z] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                progressiveElCountsLastFrame[idx] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t            var progressiveLayerCount = 0;\n\t            var currentProgressiveLayer;\n\t            var lastProgressiveKey;\n\t            var frameCount = 0;\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n\t                var layer = layers[zlevel];\n\t                var elProgress = el.progressive;\n\t                if (layer) {\n\t                    layer.elCount++;\n\t                    layer.__dirty = layer.__dirty || el.__dirty;\n\t                }\n\t                /////// Update progressive\n\t                if (elProgress >= 0) {\n\t                    // Fix wrong progressive sequence problem.\n\t                    if (lastProgressiveKey !== elProgress) {\n\t                        lastProgressiveKey = elProgress;\n\t                        frameCount++;\n\t                    }\n\t                    var elFrame = el.__frame = frameCount - 1;\n\t                    if (!currentProgressiveLayer) {\n\t                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n\t                        currentProgressiveLayer = progressiveLayers[idx];\n\t                        if (!currentProgressiveLayer) {\n\t                            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n\t                            currentProgressiveLayer.initContext();\n\t                        }\n\t                        currentProgressiveLayer.__maxProgress = 0;\n\t                    }\n\t                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n\t                    currentProgressiveLayer.elCount++;\n\t                    currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n\t                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n\t                        // Should keep rendering this  layer because progressive rendering is not finished yet\n\t                        layer.__dirty = true;\n\t                    }\n\t                } else {\n\t                    el.__frame = -1;\n\t                    if (currentProgressiveLayer) {\n\t                        currentProgressiveLayer.__nextIdxNotProg = i;\n\t                        progressiveLayerCount++;\n\t                        currentProgressiveLayer = null;\n\t                    }\n\t                }\n\t            }\n\t            if (currentProgressiveLayer) {\n\t                progressiveLayerCount++;\n\t                currentProgressiveLayer.__nextIdxNotProg = i;\n\t            }\n\t            // 层中的元素数量有发生变化\n\t            this.eachBuildinLayer(function (layer, z) {\n\t                if (elCountsLastFrame[z] !== layer.elCount) {\n\t                    layer.__dirty = true;\n\t                }\n\t            });\n\t            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n\t                    el.__dirty = true;\n\t                }\n\t                if (layer.__dirty) {\n\t                    layer.__progress = 0;\n\t                }\n\t            });\n\t        },\n\t        clear: function () {\n\t            this.eachBuildinLayer(this._clearLayer);\n\t            return this;\n\t        },\n\t        _clearLayer: function (layer) {\n\t            layer.clear();\n\t        },\n\t        configLayer: function (zlevel, config) {\n\t            if (config) {\n\t                var layerConfig = this._layerConfig;\n\t                if (!layerConfig[zlevel]) {\n\t                    layerConfig[zlevel] = config;\n\t                } else {\n\t                    util.merge(layerConfig[zlevel], config, true);\n\t                }\n\t                var layer = this._layers[zlevel];\n\t                if (layer) {\n\t                    util.merge(layer, layerConfig[zlevel], true);\n\t                }\n\t            }\n\t        },\n\t        delLayer: function (zlevel) {\n\t            var layers = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var layer = layers[zlevel];\n\t            if (!layer) {\n\t                return;\n\t            }\n\t            layer.dom.parentNode.removeChild(layer.dom);\n\t            delete layers[zlevel];\n\t            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n\t        },\n\t        resize: function (width, height) {\n\t            var domRoot = this._domRoot;\n\t            // FIXME Why ?\n\t            domRoot.style.display = 'none';\n\t            width = width || this._getWidth();\n\t            height = height || this._getHeight();\n\t            domRoot.style.display = '';\n\t            // 优化没有实际改变的resize\n\t            if (this._width != width || height != this._height) {\n\t                domRoot.style.width = width + 'px';\n\t                domRoot.style.height = height + 'px';\n\t                for (var id in this._layers) {\n\t                    this._layers[id].resize(width, height);\n\t                }\n\t                this.refresh(true);\n\t            }\n\t            this._width = width;\n\t            this._height = height;\n\t            return this;\n\t        },\n\t        clearLayer: function (zlevel) {\n\t            var layer = this._layers[zlevel];\n\t            if (layer) {\n\t                layer.clear();\n\t            }\n\t        },\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t            this.root = this.storage = this._domRoot = this._layers = null;\n\t        },\n\t        getRenderedCanvas: function (opts) {\n\t            opts = opts || {};\n\t            if (this._singleCanvas) {\n\t                return this._layers[0].dom;\n\t            }\n\t            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n\t            imageLayer.initContext();\n\t            imageLayer.clearColor = opts.backgroundColor;\n\t            imageLayer.clear();\n\t            var displayList = this.storage.getDisplayList(true);\n\t            var scope = {};\n\t            for (var i = 0; i < displayList.length; i++) {\n\t                var el = displayList[i];\n\t                this._doPaintEl(el, imageLayer, true, scope);\n\t            }\n\t            return imageLayer.dom;\n\t        },\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t        _getWidth: function () {\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t            // FIXME Better way to get the width and height when element has not been append to the document\n\t            return (root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width)) - (parseInt10(stl.paddingLeft) || 0) - (parseInt10(stl.paddingRight) || 0) | 0;\n\t        },\n\t        _getHeight: function () {\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t            return (root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height)) - (parseInt10(stl.paddingTop) || 0) - (parseInt10(stl.paddingBottom) || 0) | 0;\n\t        },\n\t        _pathToImage: function (id, path, width, height, dpr) {\n\t            var canvas = document.createElement('canvas');\n\t            var ctx = canvas.getContext('2d');\n\t            canvas.width = width * dpr;\n\t            canvas.height = height * dpr;\n\t            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\t            var pathTransform = {\n\t                    position: path.position,\n\t                    rotation: path.rotation,\n\t                    scale: path.scale\n\t                };\n\t            path.position = [\n\t                0,\n\t                0,\n\t                0\n\t            ];\n\t            path.rotation = 0;\n\t            path.scale = [\n\t                1,\n\t                1\n\t            ];\n\t            if (path) {\n\t                path.brush(ctx);\n\t            }\n\t            var ImageShape = require('./graphic/Image');\n\t            var imgShape = new ImageShape({\n\t                    id: id,\n\t                    style: {\n\t                        x: 0,\n\t                        y: 0,\n\t                        image: canvas\n\t                    }\n\t                });\n\t            if (pathTransform.position != null) {\n\t                imgShape.position = path.position = pathTransform.position;\n\t            }\n\t            if (pathTransform.rotation != null) {\n\t                imgShape.rotation = path.rotation = pathTransform.rotation;\n\t            }\n\t            if (pathTransform.scale != null) {\n\t                imgShape.scale = path.scale = pathTransform.scale;\n\t            }\n\t            return imgShape;\n\t        },\n\t        _createPathToImage: function () {\n\t            var me = this;\n\t            return function (id, e, width, height) {\n\t                return me._pathToImage(id, e, width, height, me.dpr);\n\t            };\n\t        }\n\t    };\n\t    return Painter;\n\t});\n\tdefine('zrender/mixin/Draggable', ['require'], function (require) {\n\t    function Draggable() {\n\t        this.on('mousedown', this._dragStart, this);\n\t        this.on('mousemove', this._drag, this);\n\t        this.on('mouseup', this._dragEnd, this);\n\t        this.on('globalout', this._dragEnd, this);    // this._dropTarget = null;\n\t                                                      // this._draggingTarget = null;\n\t                                                      // this._x = 0;\n\t                                                      // this._y = 0;\n\t    }\n\t    Draggable.prototype = {\n\t        constructor: Draggable,\n\t        _dragStart: function (e) {\n\t            var draggingTarget = e.target;\n\t            if (draggingTarget && draggingTarget.draggable) {\n\t                this._draggingTarget = draggingTarget;\n\t                draggingTarget.dragging = true;\n\t                this._x = e.offsetX;\n\t                this._y = e.offsetY;\n\t                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n\t            }\n\t        },\n\t        _drag: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t            if (draggingTarget) {\n\t                var x = e.offsetX;\n\t                var y = e.offsetY;\n\t                var dx = x - this._x;\n\t                var dy = y - this._y;\n\t                this._x = x;\n\t                this._y = y;\n\t                draggingTarget.drift(dx, dy, e);\n\t                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\t                var dropTarget = this.findHover(x, y, draggingTarget);\n\t                var lastDropTarget = this._dropTarget;\n\t                this._dropTarget = dropTarget;\n\t                if (draggingTarget !== dropTarget) {\n\t                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n\t                    }\n\t                    if (dropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        _dragEnd: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t            if (draggingTarget) {\n\t                draggingTarget.dragging = false;\n\t            }\n\t            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\t            if (this._dropTarget) {\n\t                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n\t            }\n\t            this._draggingTarget = null;\n\t            this._dropTarget = null;\n\t        }\n\t    };\n\t    return Draggable;\n\t});\n\tdefine('zrender/core/event', ['require', '../mixin/Eventful'], function (require) {\n\t    'use strict';\n\t    var Eventful = require('../mixin/Eventful');\n\t    var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\n\t    function getBoundingClientRect(el) {\n\t        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n\t        return el.getBoundingClientRect ? el.getBoundingClientRect() : {\n\t            left: 0,\n\t            top: 0\n\t        };\n\t    }\n\t    function clientToLocal(el, e, out) {\n\t        // clientX/clientY is according to view port.\n\t        var box = getBoundingClientRect(el);\n\t        out = out || {};\n\t        out.zrX = e.clientX - box.left;\n\t        out.zrY = e.clientY - box.top;\n\t        return out;\n\t    }\n\t    /**\n\t     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标\n\t     */\n\t    function normalizeEvent(el, e) {\n\t        e = e || window.event;\n\t        if (e.zrX != null) {\n\t            return e;\n\t        }\n\t        var eventType = e.type;\n\t        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\t        if (!isTouch) {\n\t            clientToLocal(el, e, e);\n\t            e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n\t        } else {\n\t            var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n\t            touch && clientToLocal(el, touch, e);\n\t        }\n\t        return e;\n\t    }\n\t    function addEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.addEventListener(name, handler);\n\t        } else {\n\t            el.attachEvent('on' + name, handler);\n\t        }\n\t    }\n\t    function removeEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.removeEventListener(name, handler);\n\t        } else {\n\t            el.detachEvent('on' + name, handler);\n\t        }\n\t    }\n\t    /**\n\t     * 停止冒泡和阻止默认行为\n\t     * @memberOf module:zrender/core/event\n\t     * @method\n\t     * @param {Event} e : event对象\n\t     */\n\t    var stop = isDomLevel2 ? function (e) {\n\t            e.preventDefault();\n\t            e.stopPropagation();\n\t            e.cancelBubble = true;\n\t        } : function (e) {\n\t            e.returnValue = false;\n\t            e.cancelBubble = true;\n\t        };\n\t    return {\n\t        clientToLocal: clientToLocal,\n\t        normalizeEvent: normalizeEvent,\n\t        addEventListener: addEventListener,\n\t        removeEventListener: removeEventListener,\n\t        stop: stop,\n\t        Dispatcher: Eventful\n\t    };\n\t});\n\tdefine('zrender/animation/requestAnimationFrame', ['require'], function (require) {\n\t    return typeof window !== 'undefined' && (window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n\t        setTimeout(func, 16);\n\t    };\n\t});\n\tdefine('zrender/core/GestureMgr', ['require', './event'], function (require) {\n\t    'use strict';\n\t    var eventUtil = require('./event');\n\t    var GestureMgr = function () {\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._track = [];\n\t    };\n\t    GestureMgr.prototype = {\n\t        constructor: GestureMgr,\n\t        recognize: function (event, target, root) {\n\t            this._doTrack(event, target, root);\n\t            return this._recognize(event);\n\t        },\n\t        clear: function () {\n\t            this._track.length = 0;\n\t            return this;\n\t        },\n\t        _doTrack: function (event, target, root) {\n\t            var touches = event.touches;\n\t            if (!touches) {\n\t                return;\n\t            }\n\t            var trackItem = {\n\t                    points: [],\n\t                    touches: [],\n\t                    target: target,\n\t                    event: event\n\t                };\n\t            for (var i = 0, len = touches.length; i < len; i++) {\n\t                var touch = touches[i];\n\t                var pos = eventUtil.clientToLocal(root, touch);\n\t                trackItem.points.push([\n\t                    pos.zrX,\n\t                    pos.zrY\n\t                ]);\n\t                trackItem.touches.push(touch);\n\t            }\n\t            this._track.push(trackItem);\n\t        },\n\t        _recognize: function (event) {\n\t            for (var eventName in recognizers) {\n\t                if (recognizers.hasOwnProperty(eventName)) {\n\t                    var gestureInfo = recognizers[eventName](this._track, event);\n\t                    if (gestureInfo) {\n\t                        return gestureInfo;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t    function dist(pointPair) {\n\t        var dx = pointPair[1][0] - pointPair[0][0];\n\t        var dy = pointPair[1][1] - pointPair[0][1];\n\t        return Math.sqrt(dx * dx + dy * dy);\n\t    }\n\t    function center(pointPair) {\n\t        return [\n\t            (pointPair[0][0] + pointPair[1][0]) / 2,\n\t            (pointPair[0][1] + pointPair[1][1]) / 2\n\t        ];\n\t    }\n\t    var recognizers = {\n\t            pinch: function (track, event) {\n\t                var trackLen = track.length;\n\t                if (!trackLen) {\n\t                    return;\n\t                }\n\t                var pinchEnd = (track[trackLen - 1] || {}).points;\n\t                var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\t                if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n\t                    var pinchScale = dist(pinchEnd) / dist(pinchPre);\n\t                    !isFinite(pinchScale) && (pinchScale = 1);\n\t                    event.pinchScale = pinchScale;\n\t                    var pinchCenter = center(pinchEnd);\n\t                    event.pinchX = pinchCenter[0];\n\t                    event.pinchY = pinchCenter[1];\n\t                    return {\n\t                        type: 'pinch',\n\t                        target: track[0].target,\n\t                        event: event\n\t                    };\n\t                }\n\t            }    // Only pinch currently.\n\t        };\n\t    return GestureMgr;\n\t});\n\tdefine('zrender/Layer', ['require', './core/util', './config', './graphic/Style', './graphic/Pattern'], function (require) {\n\t    var util = require('./core/util');\n\t    var config = require('./config');\n\t    var Style = require('./graphic/Style');\n\t    var Pattern = require('./graphic/Pattern');\n\t    function returnFalse() {\n\t        return false;\n\t    }\n\t    /**\n\t     * 创建dom\n\t     *\n\t     * @inner\n\t     * @param {string} id dom id 待用\n\t     * @param {string} type dom type，such as canvas, div etc.\n\t     * @param {Painter} painter painter instance\n\t     * @param {number} number\n\t     */\n\t    function createDom(id, type, painter, dpr) {\n\t        var newDom = document.createElement(type);\n\t        var width = painter.getWidth();\n\t        var height = painter.getHeight();\n\t        var newDomStyle = newDom.style;\n\t        // 没append呢，请原谅我这样写，清晰~\n\t        newDomStyle.position = 'absolute';\n\t        newDomStyle.left = 0;\n\t        newDomStyle.top = 0;\n\t        newDomStyle.width = width + 'px';\n\t        newDomStyle.height = height + 'px';\n\t        newDom.width = width * dpr;\n\t        newDom.height = height * dpr;\n\t        // id不作为索引用，避免可能造成的重名，定义为私有属性\n\t        newDom.setAttribute('data-zr-dom-id', id);\n\t        return newDom;\n\t    }\n\t    /**\n\t     * @alias module:zrender/Layer\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @param {string} id\n\t     * @param {module:zrender/Painter} painter\n\t     * @param {number} [dpr]\n\t     */\n\t    var Layer = function (id, painter, dpr) {\n\t        var dom;\n\t        dpr = dpr || config.devicePixelRatio;\n\t        if (typeof id === 'string') {\n\t            dom = createDom(id, 'canvas', painter, dpr);\n\t        }    // Not using isDom because in node it will return false\n\t        else if (util.isObject(id)) {\n\t            dom = id;\n\t            id = dom.id;\n\t        }\n\t        this.id = id;\n\t        this.dom = dom;\n\t        var domStyle = dom.style;\n\t        if (domStyle) {\n\t            // Not in node\n\t            dom.onselectstart = returnFalse;\n\t            // 避免页面选中的尴尬\n\t            domStyle['-webkit-user-select'] = 'none';\n\t            domStyle['user-select'] = 'none';\n\t            domStyle['-webkit-touch-callout'] = 'none';\n\t            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n\t        }\n\t        this.domBack = null;\n\t        this.ctxBack = null;\n\t        this.painter = painter;\n\t        this.config = null;\n\t        // Configs\n\t        /**\n\t         * 每次清空画布的颜色\n\t         * @type {string}\n\t         * @default 0\n\t         */\n\t        this.clearColor = 0;\n\t        /**\n\t         * 是否开启动态模糊\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        this.motionBlur = false;\n\t        /**\n\t         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t         * @type {number}\n\t         * @default 0.7\n\t         */\n\t        this.lastFrameAlpha = 0.7;\n\t        /**\n\t         * Layer dpr\n\t         * @type {number}\n\t         */\n\t        this.dpr = dpr;\n\t    };\n\t    Layer.prototype = {\n\t        constructor: Layer,\n\t        elCount: 0,\n\t        __dirty: true,\n\t        initContext: function () {\n\t            this.ctx = this.dom.getContext('2d');\n\t            this.ctx.dpr = this.dpr;\n\t        },\n\t        createBackBuffer: function () {\n\t            var dpr = this.dpr;\n\t            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n\t            this.ctxBack = this.domBack.getContext('2d');\n\t            if (dpr != 1) {\n\t                this.ctxBack.scale(dpr, dpr);\n\t            }\n\t        },\n\t        resize: function (width, height) {\n\t            var dpr = this.dpr;\n\t            var dom = this.dom;\n\t            var domStyle = dom.style;\n\t            var domBack = this.domBack;\n\t            domStyle.width = width + 'px';\n\t            domStyle.height = height + 'px';\n\t            dom.width = width * dpr;\n\t            dom.height = height * dpr;\n\t            if (domBack) {\n\t                domBack.width = width * dpr;\n\t                domBack.height = height * dpr;\n\t                if (dpr != 1) {\n\t                    this.ctxBack.scale(dpr, dpr);\n\t                }\n\t            }\n\t        },\n\t        clear: function (clearAll) {\n\t            var dom = this.dom;\n\t            var ctx = this.ctx;\n\t            var width = dom.width;\n\t            var height = dom.height;\n\t            var clearColor = this.clearColor;\n\t            var haveMotionBLur = this.motionBlur && !clearAll;\n\t            var lastFrameAlpha = this.lastFrameAlpha;\n\t            var dpr = this.dpr;\n\t            if (haveMotionBLur) {\n\t                if (!this.domBack) {\n\t                    this.createBackBuffer();\n\t                }\n\t                this.ctxBack.globalCompositeOperation = 'copy';\n\t                this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n\t            }\n\t            ctx.clearRect(0, 0, width, height);\n\t            if (clearColor) {\n\t                var clearColorGradientOrPattern;\n\t                // Gradient\n\t                if (clearColor.colorStops) {\n\t                    // Cache canvas gradient\n\t                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n\t                        x: 0,\n\t                        y: 0,\n\t                        width: width,\n\t                        height: height\n\t                    });\n\t                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n\t                }    // Pattern\n\t                else if (clearColor.image) {\n\t                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n\t                }\n\t                ctx.save();\n\t                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n\t                ctx.fillRect(0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t            if (haveMotionBLur) {\n\t                var domBack = this.domBack;\n\t                ctx.save();\n\t                ctx.globalAlpha = lastFrameAlpha;\n\t                ctx.drawImage(domBack, 0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t        }\n\t    };\n\t    return Layer;\n\t});\n\tdefine('echarts/preprocessor/helper/compatStyle', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var POSSIBLE_STYLES = [\n\t            'areaStyle',\n\t            'lineStyle',\n\t            'nodeStyle',\n\t            'linkStyle',\n\t            'chordStyle',\n\t            'label',\n\t            'labelLine'\n\t        ];\n\t    function compatItemStyle(opt) {\n\t        var itemStyleOpt = opt && opt.itemStyle;\n\t        if (itemStyleOpt) {\n\t            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n\t                var normalItemStyleOpt = itemStyleOpt.normal;\n\t                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n\t                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n\t                    opt[styleName] = opt[styleName] || {};\n\t                    if (!opt[styleName].normal) {\n\t                        opt[styleName].normal = normalItemStyleOpt[styleName];\n\t                    } else {\n\t                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n\t                    }\n\t                    normalItemStyleOpt[styleName] = null;\n\t                }\n\t                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n\t                    opt[styleName] = opt[styleName] || {};\n\t                    if (!opt[styleName].emphasis) {\n\t                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n\t                    } else {\n\t                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n\t                    }\n\t                    emphasisItemStyleOpt[styleName] = null;\n\t                }\n\t            });\n\t        }\n\t    }\n\t    return function (seriesOpt) {\n\t        if (!seriesOpt) {\n\t            return;\n\t        }\n\t        compatItemStyle(seriesOpt);\n\t        compatItemStyle(seriesOpt.markPoint);\n\t        compatItemStyle(seriesOpt.markLine);\n\t        var data = seriesOpt.data;\n\t        if (data) {\n\t            for (var i = 0; i < data.length; i++) {\n\t                compatItemStyle(data[i]);\n\t            }\n\t            // mark point data\n\t            var markPoint = seriesOpt.markPoint;\n\t            if (markPoint && markPoint.data) {\n\t                var mpData = markPoint.data;\n\t                for (var i = 0; i < mpData.length; i++) {\n\t                    compatItemStyle(mpData[i]);\n\t                }\n\t            }\n\t            // mark line data\n\t            var markLine = seriesOpt.markLine;\n\t            if (markLine && markLine.data) {\n\t                var mlData = markLine.data;\n\t                for (var i = 0; i < mlData.length; i++) {\n\t                    if (zrUtil.isArray(mlData[i])) {\n\t                        compatItemStyle(mlData[i][0]);\n\t                        compatItemStyle(mlData[i][1]);\n\t                    } else {\n\t                        compatItemStyle(mlData[i]);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t});\n\tdefine('echarts/component/helper/selectableMixin', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    return {\n\t        updateSelectedMap: function (targetList) {\n\t            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n\t                targetMap[target.name] = target;\n\t                return targetMap;\n\t            }, {});\n\t        },\n\t        select: function (name) {\n\t            var targetMap = this._selectTargetMap;\n\t            var target = targetMap[name];\n\t            var selectedMode = this.get('selectedMode');\n\t            if (selectedMode === 'single') {\n\t                zrUtil.each(targetMap, function (target) {\n\t                    target.selected = false;\n\t                });\n\t            }\n\t            target && (target.selected = true);\n\t        },\n\t        unSelect: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            // var selectedMode = this.get('selectedMode');\n\t            // selectedMode !== 'single' && target && (target.selected = false);\n\t            target && (target.selected = false);\n\t        },\n\t        toggleSelected: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            if (target != null) {\n\t                this[target.selected ? 'unSelect' : 'select'](name);\n\t                return target.selected;\n\t            }\n\t        },\n\t        isSelected: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            return target && target.selected;\n\t        }\n\t    };\n\t});\n\tdefine('echarts/component/axis/AxisView', ['require', 'zrender/core/util', '../../util/graphic', './AxisBuilder', '../../echarts'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var graphic = require('../../util/graphic');\n\t    var AxisBuilder = require('./AxisBuilder');\n\t    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n\t    var getInterval = AxisBuilder.getInterval;\n\t    var axisBuilderAttrs = [\n\t            'axisLine',\n\t            'axisLabel',\n\t            'axisTick',\n\t            'axisName'\n\t        ];\n\t    var selfBuilderAttrs = [\n\t            'splitArea',\n\t            'splitLine'\n\t        ];\n\t    // function getAlignWithLabel(model, axisModel) {\n\t    //     var alignWithLabel = model.get('alignWithLabel');\n\t    //     if (alignWithLabel === 'auto') {\n\t    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n\t    //     }\n\t    //     return alignWithLabel;\n\t    // }\n\t    var AxisView = require('../../echarts').extendComponentView({\n\t            type: 'axis',\n\t            render: function (axisModel, ecModel) {\n\t                this.group.removeAll();\n\t                var oldAxisGroup = this._axisGroup;\n\t                this._axisGroup = new graphic.Group();\n\t                this.group.add(this._axisGroup);\n\t                if (!axisModel.get('show')) {\n\t                    return;\n\t                }\n\t                var gridModel = axisModel.findGridModel();\n\t                var layout = layoutAxis(gridModel, axisModel);\n\t                var axisBuilder = new AxisBuilder(axisModel, layout);\n\t                zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\t                this._axisGroup.add(axisBuilder.getGroup());\n\t                zrUtil.each(selfBuilderAttrs, function (name) {\n\t                    if (axisModel.get(name + '.show')) {\n\t                        this['_' + name](axisModel, gridModel, layout.labelInterval);\n\t                    }\n\t                }, this);\n\t                graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n\t            },\n\t            _splitLine: function (axisModel, gridModel, labelInterval) {\n\t                var axis = axisModel.axis;\n\t                var splitLineModel = axisModel.getModel('splitLine');\n\t                var lineStyleModel = splitLineModel.getModel('lineStyle');\n\t                var lineColors = lineStyleModel.get('color');\n\t                var lineInterval = getInterval(splitLineModel, labelInterval);\n\t                lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\t                var gridRect = gridModel.coordinateSystem.getRect();\n\t                var isHorizontal = axis.isHorizontal();\n\t                var lineCount = 0;\n\t                var ticksCoords = axis.getTicksCoords();\n\t                var ticks = axis.scale.getTicks();\n\t                var p1 = [];\n\t                var p2 = [];\n\t                // Simple optimization\n\t                // Batching the lines if color are the same\n\t                var lineStyle = lineStyleModel.getLineStyle();\n\t                for (var i = 0; i < ticksCoords.length; i++) {\n\t                    if (ifIgnoreOnTick(axis, i, lineInterval)) {\n\t                        continue;\n\t                    }\n\t                    var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\t                    if (isHorizontal) {\n\t                        p1[0] = tickCoord;\n\t                        p1[1] = gridRect.y;\n\t                        p2[0] = tickCoord;\n\t                        p2[1] = gridRect.y + gridRect.height;\n\t                    } else {\n\t                        p1[0] = gridRect.x;\n\t                        p1[1] = tickCoord;\n\t                        p2[0] = gridRect.x + gridRect.width;\n\t                        p2[1] = tickCoord;\n\t                    }\n\t                    var colorIndex = lineCount++ % lineColors.length;\n\t                    this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t                        anid: 'line_' + ticks[i],\n\t                        shape: {\n\t                            x1: p1[0],\n\t                            y1: p1[1],\n\t                            x2: p2[0],\n\t                            y2: p2[1]\n\t                        },\n\t                        style: zrUtil.defaults({ stroke: lineColors[colorIndex] }, lineStyle),\n\t                        silent: true\n\t                    })));\n\t                }\n\t            },\n\t            _splitArea: function (axisModel, gridModel, labelInterval) {\n\t                var axis = axisModel.axis;\n\t                var splitAreaModel = axisModel.getModel('splitArea');\n\t                var areaStyleModel = splitAreaModel.getModel('areaStyle');\n\t                var areaColors = areaStyleModel.get('color');\n\t                var gridRect = gridModel.coordinateSystem.getRect();\n\t                var ticksCoords = axis.getTicksCoords();\n\t                var ticks = axis.scale.getTicks();\n\t                var prevX = axis.toGlobalCoord(ticksCoords[0]);\n\t                var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\t                var count = 0;\n\t                var areaInterval = getInterval(splitAreaModel, labelInterval);\n\t                var areaStyle = areaStyleModel.getAreaStyle();\n\t                areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\t                for (var i = 1; i < ticksCoords.length; i++) {\n\t                    if (ifIgnoreOnTick(axis, i, areaInterval)) {\n\t                        continue;\n\t                    }\n\t                    var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\t                    var x;\n\t                    var y;\n\t                    var width;\n\t                    var height;\n\t                    if (axis.isHorizontal()) {\n\t                        x = prevX;\n\t                        y = gridRect.y;\n\t                        width = tickCoord - x;\n\t                        height = gridRect.height;\n\t                    } else {\n\t                        x = gridRect.x;\n\t                        y = prevY;\n\t                        width = gridRect.width;\n\t                        height = tickCoord - y;\n\t                    }\n\t                    var colorIndex = count++ % areaColors.length;\n\t                    this._axisGroup.add(new graphic.Rect({\n\t                        anid: 'area_' + ticks[i],\n\t                        shape: {\n\t                            x: x,\n\t                            y: y,\n\t                            width: width,\n\t                            height: height\n\t                        },\n\t                        style: zrUtil.defaults({ fill: areaColors[colorIndex] }, areaStyle),\n\t                        silent: true\n\t                    }));\n\t                    prevX = x + width;\n\t                    prevY = y + height;\n\t                }\n\t            }\n\t        });\n\t    AxisView.extend({ type: 'xAxis' });\n\t    AxisView.extend({ type: 'yAxis' });\n\t    /**\n\t     * @inner\n\t     */\n\t    function layoutAxis(gridModel, axisModel) {\n\t        var grid = gridModel.coordinateSystem;\n\t        var axis = axisModel.axis;\n\t        var layout = {};\n\t        var rawAxisPosition = axis.position;\n\t        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n\t        var axisDim = axis.dim;\n\t        // [left, right, top, bottom]\n\t        var rect = grid.getRect();\n\t        var rectBound = [\n\t                rect.x,\n\t                rect.x + rect.width,\n\t                rect.y,\n\t                rect.y + rect.height\n\t            ];\n\t        var axisOffset = axisModel.get('offset') || 0;\n\t        var posMap = {\n\t                x: {\n\t                    top: rectBound[2] - axisOffset,\n\t                    bottom: rectBound[3] + axisOffset\n\t                },\n\t                y: {\n\t                    left: rectBound[0] - axisOffset,\n\t                    right: rectBound[1] + axisOffset\n\t                }\n\t            };\n\t        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n\t        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\t        function getZero(dim, val) {\n\t            var theAxis = grid.getAxis(dim);\n\t            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n\t        }\n\t        // Axis position\n\t        layout.position = [\n\t            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n\t            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n\t        ];\n\t        // Axis rotation\n\t        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\t        // Tick and label direction, x y is axisDim\n\t        var dirMap = {\n\t                top: -1,\n\t                bottom: 1,\n\t                left: -1,\n\t                right: 1\n\t            };\n\t        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n\t        if (axis.onZero) {\n\t            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;\n\t        }\n\t        if (axisModel.getModel('axisTick').get('inside')) {\n\t            layout.tickDirection = -layout.tickDirection;\n\t        }\n\t        if (axisModel.getModel('axisLabel').get('inside')) {\n\t            layout.labelDirection = -layout.labelDirection;\n\t        }\n\t        // Special label rotation\n\t        var labelRotation = axisModel.getModel('axisLabel').get('rotate');\n\t        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n\t        // label interval when auto mode.\n\t        layout.labelInterval = axis.getLabelInterval();\n\t        // Over splitLine and splitArea\n\t        layout.z2 = 1;\n\t        return layout;\n\t    }\n\t});\n\tdefine('echarts/chart/pie/labelLayout', ['require', 'zrender/contain/text'], function (require) {\n\t    'use strict';\n\t    var textContain = require('zrender/contain/text');\n\t    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n\t        list.sort(function (a, b) {\n\t            return a.y - b.y;\n\t        });\n\t        // 压\n\t        function shiftDown(start, end, delta, dir) {\n\t            for (var j = start; j < end; j++) {\n\t                list[j].y += delta;\n\t                if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n\t                    shiftUp(j, delta / 2);\n\t                    return;\n\t                }\n\t            }\n\t            shiftUp(end - 1, delta / 2);\n\t        }\n\t        // 弹\n\t        function shiftUp(end, delta) {\n\t            for (var j = end; j >= 0; j--) {\n\t                list[j].y -= delta;\n\t                if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        function changeX(list, isDownList, cx, cy, r, dir) {\n\t            var lastDeltaX = dir > 0 ? isDownList ? Number.MAX_VALUE : 0 : isDownList ? Number.MAX_VALUE : 0;\n\t            // 上\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                // Not change x for center label\n\t                if (list[i].position === 'center') {\n\t                    continue;\n\t                }\n\t                var deltaY = Math.abs(list[i].y - cy);\n\t                var length = list[i].len;\n\t                var length2 = list[i].len2;\n\t                var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n\t                if (isDownList && deltaX >= lastDeltaX) {\n\t                    // 右下，左下\n\t                    deltaX = lastDeltaX - 10;\n\t                }\n\t                if (!isDownList && deltaX <= lastDeltaX) {\n\t                    // 右上，左上\n\t                    deltaX = lastDeltaX + 10;\n\t                }\n\t                list[i].x = cx + deltaX * dir;\n\t                lastDeltaX = deltaX;\n\t            }\n\t        }\n\t        var lastY = 0;\n\t        var delta;\n\t        var len = list.length;\n\t        var upList = [];\n\t        var downList = [];\n\t        for (var i = 0; i < len; i++) {\n\t            delta = list[i].y - lastY;\n\t            if (delta < 0) {\n\t                shiftDown(i, len, -delta, dir);\n\t            }\n\t            lastY = list[i].y + list[i].height;\n\t        }\n\t        if (viewHeight - lastY < 0) {\n\t            shiftUp(len - 1, lastY - viewHeight);\n\t        }\n\t        for (var i = 0; i < len; i++) {\n\t            if (list[i].y >= cy) {\n\t                downList.push(list[i]);\n\t            } else {\n\t                upList.push(list[i]);\n\t            }\n\t        }\n\t        changeX(upList, false, cx, cy, r, dir);\n\t        changeX(downList, true, cx, cy, r, dir);\n\t    }\n\t    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n\t        var leftList = [];\n\t        var rightList = [];\n\t        for (var i = 0; i < labelLayoutList.length; i++) {\n\t            if (labelLayoutList[i].x < cx) {\n\t                leftList.push(labelLayoutList[i]);\n\t            } else {\n\t                rightList.push(labelLayoutList[i]);\n\t            }\n\t        }\n\t        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n\t        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\t        for (var i = 0; i < labelLayoutList.length; i++) {\n\t            var linePoints = labelLayoutList[i].linePoints;\n\t            if (linePoints) {\n\t                var dist = linePoints[1][0] - linePoints[2][0];\n\t                if (labelLayoutList[i].x < cx) {\n\t                    linePoints[2][0] = labelLayoutList[i].x + 3;\n\t                } else {\n\t                    linePoints[2][0] = labelLayoutList[i].x - 3;\n\t                }\n\t                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n\t                linePoints[1][0] = linePoints[2][0] + dist;\n\t            }\n\t        }\n\t    }\n\t    return function (seriesModel, r, viewWidth, viewHeight) {\n\t        var data = seriesModel.getData();\n\t        var labelLayoutList = [];\n\t        var cx;\n\t        var cy;\n\t        var hasLabelRotate = false;\n\t        data.each(function (idx) {\n\t            var layout = data.getItemLayout(idx);\n\t            var itemModel = data.getItemModel(idx);\n\t            var labelModel = itemModel.getModel('label.normal');\n\t            // Use position in normal or emphasis\n\t            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\t            var labelLineModel = itemModel.getModel('labelLine.normal');\n\t            var labelLineLen = labelLineModel.get('length');\n\t            var labelLineLen2 = labelLineModel.get('length2');\n\t            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\t            var dx = Math.cos(midAngle);\n\t            var dy = Math.sin(midAngle);\n\t            var textX;\n\t            var textY;\n\t            var linePoints;\n\t            var textAlign;\n\t            cx = layout.cx;\n\t            cy = layout.cy;\n\t            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\t            if (labelPosition === 'center') {\n\t                textX = layout.cx;\n\t                textY = layout.cy;\n\t                textAlign = 'center';\n\t            } else {\n\t                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n\t                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\t                textX = x1 + dx * 3;\n\t                textY = y1 + dy * 3;\n\t                if (!isLabelInside) {\n\t                    // For roseType\n\t                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n\t                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n\t                    var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n\t                    var y3 = y2;\n\t                    textX = x3 + (dx < 0 ? -5 : 5);\n\t                    textY = y3;\n\t                    linePoints = [\n\t                        [\n\t                            x1,\n\t                            y1\n\t                        ],\n\t                        [\n\t                            x2,\n\t                            y2\n\t                        ],\n\t                        [\n\t                            x3,\n\t                            y3\n\t                        ]\n\t                    ];\n\t                }\n\t                textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n\t            }\n\t            var font = labelModel.getModel('textStyle').getFont();\n\t            var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n\t            var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n\t            var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n\t            hasLabelRotate = !!labelRotate;\n\t            layout.label = {\n\t                x: textX,\n\t                y: textY,\n\t                position: labelPosition,\n\t                height: textRect.height,\n\t                len: labelLineLen,\n\t                len2: labelLineLen2,\n\t                linePoints: linePoints,\n\t                textAlign: textAlign,\n\t                verticalAlign: 'middle',\n\t                font: font,\n\t                rotation: labelRotate\n\t            };\n\t            // Not layout the inside label\n\t            if (!isLabelInside) {\n\t                labelLayoutList.push(layout.label);\n\t            }\n\t        });\n\t        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n\t            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n\t        }\n\t    };\n\t});\n\tdefine('echarts/component/axis/AxisBuilder', ['require', 'zrender/core/util', '../../util/format', '../../util/graphic', '../../model/Model', '../../util/number', 'zrender/core/vector'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var formatUtil = require('../../util/format');\n\t    var graphic = require('../../util/graphic');\n\t    var Model = require('../../model/Model');\n\t    var numberUtil = require('../../util/number');\n\t    var remRadian = numberUtil.remRadian;\n\t    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n\t    var vec2 = require('zrender/core/vector');\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var retrieve = zrUtil.retrieve;\n\t    var PI = Math.PI;\n\t    function makeAxisEventDataBase(axisModel) {\n\t        var eventData = { componentType: axisModel.mainType };\n\t        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n\t        return eventData;\n\t    }\n\t    /**\n\t     * A final axis is translated and rotated from a \"standard axis\".\n\t     * So opt.position and opt.rotation is required.\n\t     *\n\t     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n\t     * for example: (0, 0) ------------> (0, 50)\n\t     *\n\t     * nameDirection or tickDirection or labelDirection is 1 means tick\n\t     * or label is below the standard axis, whereas is -1 means above\n\t     * the standard axis. labelOffset means offset between label and axis,\n\t     * which is useful when 'onZero', where axisLabel is in the grid and\n\t     * label in outside grid.\n\t     *\n\t     * Tips: like always,\n\t     * positive rotation represents anticlockwise, and negative rotation\n\t     * represents clockwise.\n\t     * The direction of position coordinate is the same as the direction\n\t     * of screen coordinate.\n\t     *\n\t     * Do not need to consider axis 'inverse', which is auto processed by\n\t     * axis extent.\n\t     *\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {Object} axisModel\n\t     * @param {Object} opt Standard axis parameters.\n\t     * @param {Array.<number>} opt.position [x, y]\n\t     * @param {number} opt.rotation by radian\n\t     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n\t     * @param {number} [opt.tickDirection=1] 1 or -1\n\t     * @param {number} [opt.labelDirection=1] 1 or -1\n\t     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n\t     * @param {string} [opt.axisLabelShow] default get from axisModel.\n\t     * @param {string} [opt.axisName] default get from axisModel.\n\t     * @param {number} [opt.axisNameAvailableWidth]\n\t     * @param {number} [opt.labelRotation] by degree, default get from axisModel.\n\t     * @param {number} [opt.labelInterval] Default label interval when label\n\t     *                                     interval from model is null or 'auto'.\n\t     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n\t     */\n\t    var AxisBuilder = function (axisModel, opt) {\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.opt = opt;\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.axisModel = axisModel;\n\t        // Default value\n\t        zrUtil.defaults(opt, {\n\t            labelOffset: 0,\n\t            nameDirection: 1,\n\t            tickDirection: 1,\n\t            labelDirection: 1,\n\t            silent: true\n\t        });\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.group = new graphic.Group();\n\t        // FIXME Not use a seperate text group?\n\t        var dumbGroup = new graphic.Group({\n\t                position: opt.position.slice(),\n\t                rotation: opt.rotation\n\t            });\n\t        // this.group.add(dumbGroup);\n\t        // this._dumbGroup = dumbGroup;\n\t        dumbGroup.updateTransform();\n\t        this._transform = dumbGroup.transform;\n\t        this._dumbGroup = dumbGroup;\n\t    };\n\t    AxisBuilder.prototype = {\n\t        constructor: AxisBuilder,\n\t        hasBuilder: function (name) {\n\t            return !!builders[name];\n\t        },\n\t        add: function (name) {\n\t            builders[name].call(this);\n\t        },\n\t        getGroup: function () {\n\t            return this.group;\n\t        }\n\t    };\n\t    var builders = {\n\t            axisLine: function () {\n\t                var opt = this.opt;\n\t                var axisModel = this.axisModel;\n\t                if (!axisModel.get('axisLine.show')) {\n\t                    return;\n\t                }\n\t                var extent = this.axisModel.axis.getExtent();\n\t                var matrix = this._transform;\n\t                var pt1 = [\n\t                        extent[0],\n\t                        0\n\t                    ];\n\t                var pt2 = [\n\t                        extent[1],\n\t                        0\n\t                    ];\n\t                if (matrix) {\n\t                    v2ApplyTransform(pt1, pt1, matrix);\n\t                    v2ApplyTransform(pt2, pt2, matrix);\n\t                }\n\t                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t                    anid: 'line',\n\t                    shape: {\n\t                        x1: pt1[0],\n\t                        y1: pt1[1],\n\t                        x2: pt2[0],\n\t                        y2: pt2[1]\n\t                    },\n\t                    style: zrUtil.extend({ lineCap: 'round' }, axisModel.getModel('axisLine.lineStyle').getLineStyle()),\n\t                    strokeContainThreshold: opt.strokeContainThreshold || 5,\n\t                    silent: true,\n\t                    z2: 1\n\t                })));\n\t            },\n\t            axisTick: function () {\n\t                var axisModel = this.axisModel;\n\t                if (!axisModel.get('axisTick.show')) {\n\t                    return;\n\t                }\n\t                var axis = axisModel.axis;\n\t                var tickModel = axisModel.getModel('axisTick');\n\t                var opt = this.opt;\n\t                var lineStyleModel = tickModel.getModel('lineStyle');\n\t                var tickLen = tickModel.get('length');\n\t                var tickInterval = getInterval(tickModel, opt.labelInterval);\n\t                var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n\t                var ticks = axis.scale.getTicks();\n\t                var pt1 = [];\n\t                var pt2 = [];\n\t                var matrix = this._transform;\n\t                for (var i = 0; i < ticksCoords.length; i++) {\n\t                    // Only ordinal scale support tick interval\n\t                    if (ifIgnoreOnTick(axis, i, tickInterval)) {\n\t                        continue;\n\t                    }\n\t                    var tickCoord = ticksCoords[i];\n\t                    pt1[0] = tickCoord;\n\t                    pt1[1] = 0;\n\t                    pt2[0] = tickCoord;\n\t                    pt2[1] = opt.tickDirection * tickLen;\n\t                    if (matrix) {\n\t                        v2ApplyTransform(pt1, pt1, matrix);\n\t                        v2ApplyTransform(pt2, pt2, matrix);\n\t                    }\n\t                    // Tick line, Not use group transform to have better line draw\n\t                    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t                        anid: 'tick_' + ticks[i],\n\t                        shape: {\n\t                            x1: pt1[0],\n\t                            y1: pt1[1],\n\t                            x2: pt2[0],\n\t                            y2: pt2[1]\n\t                        },\n\t                        style: zrUtil.defaults(lineStyleModel.getLineStyle(), { stroke: axisModel.get('axisLine.lineStyle.color') }),\n\t                        z2: 2,\n\t                        silent: true\n\t                    })));\n\t                }\n\t            },\n\t            axisLabel: function () {\n\t                var opt = this.opt;\n\t                var axisModel = this.axisModel;\n\t                var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\t                if (!show) {\n\t                    return;\n\t                }\n\t                var axis = axisModel.axis;\n\t                var labelModel = axisModel.getModel('axisLabel');\n\t                var textStyleModel = labelModel.getModel('textStyle');\n\t                var labelMargin = labelModel.get('margin');\n\t                var ticks = axis.scale.getTicks();\n\t                var labels = axisModel.getFormattedLabels();\n\t                // Special label rotate.\n\t                var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;\n\t                // To radian.\n\t                labelRotation = labelRotation * PI / 180;\n\t                var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);\n\t                var categoryData = axisModel.get('data');\n\t                var textEls = [];\n\t                var silent = isSilent(axisModel);\n\t                var triggerEvent = axisModel.get('triggerEvent');\n\t                for (var i = 0; i < ticks.length; i++) {\n\t                    if (ifIgnoreOnTick(axis, i, opt.labelInterval)) {\n\t                        continue;\n\t                    }\n\t                    var itemTextStyleModel = textStyleModel;\n\t                    if (categoryData && categoryData[i] && categoryData[i].textStyle) {\n\t                        itemTextStyleModel = new Model(categoryData[i].textStyle, textStyleModel, axisModel.ecModel);\n\t                    }\n\t                    var textColor = itemTextStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n\t                    var tickCoord = axis.dataToCoord(ticks[i]);\n\t                    var pos = [\n\t                            tickCoord,\n\t                            opt.labelOffset + opt.labelDirection * labelMargin\n\t                        ];\n\t                    var labelBeforeFormat = axis.scale.getLabel(ticks[i]);\n\t                    var textEl = new graphic.Text({\n\t                            anid: 'label_' + ticks[i],\n\t                            style: {\n\t                                text: labels[i],\n\t                                textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n\t                                textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,\n\t                                textFont: itemTextStyleModel.getFont(),\n\t                                fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor\n\t                            },\n\t                            position: pos,\n\t                            rotation: labelLayout.rotation,\n\t                            silent: silent,\n\t                            z2: 10\n\t                        });\n\t                    // Pack data for mouse event\n\t                    if (triggerEvent) {\n\t                        textEl.eventData = makeAxisEventDataBase(axisModel);\n\t                        textEl.eventData.targetType = 'axisLabel';\n\t                        textEl.eventData.value = labelBeforeFormat;\n\t                    }\n\t                    // FIXME\n\t                    this._dumbGroup.add(textEl);\n\t                    textEl.updateTransform();\n\t                    textEls.push(textEl);\n\t                    this.group.add(textEl);\n\t                    textEl.decomposeTransform();\n\t                }\n\t                function isTwoLabelOverlapped(current, next) {\n\t                    var firstRect = current && current.getBoundingRect().clone();\n\t                    var nextRect = next && next.getBoundingRect().clone();\n\t                    if (firstRect && nextRect) {\n\t                        firstRect.applyTransform(current.getLocalTransform());\n\t                        nextRect.applyTransform(next.getLocalTransform());\n\t                        return firstRect.intersect(nextRect);\n\t                    }\n\t                }\n\t                if (axis.type !== 'category') {\n\t                    // If min or max are user set, we need to check\n\t                    // If the tick on min(max) are overlap on their neighbour tick\n\t                    // If they are overlapped, we need to hide the min(max) tick label\n\t                    if (axisModel.getMin ? axisModel.getMin() : axisModel.get('min')) {\n\t                        var firstLabel = textEls[0];\n\t                        var nextLabel = textEls[1];\n\t                        if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n\t                            firstLabel.ignore = true;\n\t                        }\n\t                    }\n\t                    if (axisModel.getMax ? axisModel.getMax() : axisModel.get('max')) {\n\t                        var lastLabel = textEls[textEls.length - 1];\n\t                        var prevLabel = textEls[textEls.length - 2];\n\t                        if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n\t                            lastLabel.ignore = true;\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            axisName: function () {\n\t                var opt = this.opt;\n\t                var axisModel = this.axisModel;\n\t                var name = retrieve(opt.axisName, axisModel.get('name'));\n\t                if (!name) {\n\t                    return;\n\t                }\n\t                var nameLocation = axisModel.get('nameLocation');\n\t                var nameDirection = opt.nameDirection;\n\t                var textStyleModel = axisModel.getModel('nameTextStyle');\n\t                var gap = axisModel.get('nameGap') || 0;\n\t                var extent = this.axisModel.axis.getExtent();\n\t                var gapSignal = extent[0] > extent[1] ? -1 : 1;\n\t                var pos = [\n\t                        nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2,\n\t                        nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n\t                    ];\n\t                var labelLayout;\n\t                var nameRotation = axisModel.get('nameRotate');\n\t                if (nameRotation != null) {\n\t                    nameRotation = nameRotation * PI / 180;    // To radian.\n\t                }\n\t                var axisNameAvailableWidth;\n\t                if (nameLocation === 'middle') {\n\t                    labelLayout = innerTextLayout(opt, nameRotation != null ? nameRotation : opt.rotation, nameDirection);\n\t                } else {\n\t                    labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n\t                    axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\t                    if (axisNameAvailableWidth != null) {\n\t                        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n\t                        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n\t                    }\n\t                }\n\t                var textFont = textStyleModel.getFont();\n\t                var truncateOpt = axisModel.get('nameTruncate', true) || {};\n\t                var ellipsis = truncateOpt.ellipsis;\n\t                var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);\n\t                var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n\t                        minChar: 2,\n\t                        placeholder: truncateOpt.placeholder\n\t                    }) : name;\n\t                var tooltipOpt = axisModel.get('tooltip', true);\n\t                var mainType = axisModel.mainType;\n\t                var formatterParams = {\n\t                        componentType: mainType,\n\t                        name: name,\n\t                        $vars: ['name']\n\t                    };\n\t                formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\t                var textEl = new graphic.Text({\n\t                        anid: 'name',\n\t                        __fullText: name,\n\t                        __truncatedText: truncatedText,\n\t                        style: {\n\t                            text: truncatedText,\n\t                            textFont: textFont,\n\t                            fill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n\t                            textAlign: labelLayout.textAlign,\n\t                            textVerticalAlign: labelLayout.verticalAlign\n\t                        },\n\t                        position: pos,\n\t                        rotation: labelLayout.rotation,\n\t                        silent: isSilent(axisModel),\n\t                        z2: 1,\n\t                        tooltip: tooltipOpt && tooltipOpt.show ? zrUtil.extend({\n\t                            content: name,\n\t                            formatter: function () {\n\t                                return name;\n\t                            },\n\t                            formatterParams: formatterParams\n\t                        }, tooltipOpt) : null\n\t                    });\n\t                if (axisModel.get('triggerEvent')) {\n\t                    textEl.eventData = makeAxisEventDataBase(axisModel);\n\t                    textEl.eventData.targetType = 'axisName';\n\t                    textEl.eventData.name = name;\n\t                }\n\t                // FIXME\n\t                this._dumbGroup.add(textEl);\n\t                textEl.updateTransform();\n\t                this.group.add(textEl);\n\t                textEl.decomposeTransform();\n\t            }\n\t        };\n\t    /**\n\t     * @inner\n\t     */\n\t    function innerTextLayout(opt, textRotation, direction) {\n\t        var rotationDiff = remRadian(textRotation - opt.rotation);\n\t        var textAlign;\n\t        var verticalAlign;\n\t        if (isRadianAroundZero(rotationDiff)) {\n\t            // Label is parallel with axis line.\n\t            verticalAlign = direction > 0 ? 'top' : 'bottom';\n\t            textAlign = 'center';\n\t        } else if (isRadianAroundZero(rotationDiff - PI)) {\n\t            // Label is inverse parallel with axis line.\n\t            verticalAlign = direction > 0 ? 'bottom' : 'top';\n\t            textAlign = 'center';\n\t        } else {\n\t            verticalAlign = 'middle';\n\t            if (rotationDiff > 0 && rotationDiff < PI) {\n\t                textAlign = direction > 0 ? 'right' : 'left';\n\t            } else {\n\t                textAlign = direction > 0 ? 'left' : 'right';\n\t            }\n\t        }\n\t        return {\n\t            rotation: rotationDiff,\n\t            textAlign: textAlign,\n\t            verticalAlign: verticalAlign\n\t        };\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function endTextLayout(opt, textPosition, textRotate, extent) {\n\t        var rotationDiff = remRadian(textRotate - opt.rotation);\n\t        var textAlign;\n\t        var verticalAlign;\n\t        var inverse = extent[0] > extent[1];\n\t        var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\t        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n\t            verticalAlign = onLeft ? 'bottom' : 'top';\n\t            textAlign = 'center';\n\t        } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n\t            verticalAlign = onLeft ? 'top' : 'bottom';\n\t            textAlign = 'center';\n\t        } else {\n\t            verticalAlign = 'middle';\n\t            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n\t                textAlign = onLeft ? 'left' : 'right';\n\t            } else {\n\t                textAlign = onLeft ? 'right' : 'left';\n\t            }\n\t        }\n\t        return {\n\t            rotation: rotationDiff,\n\t            textAlign: textAlign,\n\t            verticalAlign: verticalAlign\n\t        };\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function isSilent(axisModel) {\n\t        var tooltipOpt = axisModel.get('tooltip');\n\t        return axisModel.get('silent') || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n\t    }\n\t    /**\n\t     * @static\n\t     */\n\t    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n\t            var rawTick;\n\t            var scale = axis.scale;\n\t            return scale.type === 'ordinal' && (typeof interval === 'function' ? (rawTick = scale.getTicks()[i], !interval(rawTick, scale.getLabel(rawTick))) : i % (interval + 1));\n\t        };\n\t    /**\n\t     * @static\n\t     */\n\t    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n\t            var interval = model.get('interval');\n\t            if (interval == null || interval == 'auto') {\n\t                interval = labelInterval;\n\t            }\n\t            return interval;\n\t        };\n\t    return AxisBuilder;\n\t});\n\tdefine('zrender', ['zrender/zrender'], function (zrender) { return zrender;});\n\tdefine('echarts', ['echarts/echarts'], function (echarts) { return echarts;});\n\tvar echarts = require('echarts');\n\t\n\techarts.graphic = require('echarts/util/graphic');\n\techarts.number = require('echarts/util/number');\n\techarts.format = require('echarts/util/format');\n\t\n\t\n\trequire('echarts/chart/bar');\n\t\n\trequire('echarts/chart/pie');\n\t\n\t\n\trequire('echarts/component/grid');\n\t\n\trequire('echarts/component/title');\n\t\n\t\n\t\n\t\n\treturn echarts;\n\t}));\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** 2.build.js\n **/","<template>\r\n    <div id=\"create\" v-if=\"!$loadingRouteData\">\r\n        <div class=\"quest\">\r\n            <div class=\"quest-title\">\r\n                <h2 v-text=\"questionnaire.title\" class=\"quest-title_preview\"></h2>\r\n            </div>\r\n            <div v-for=\"questItem in questionnaire.questItemList\" class=\"questItem-data\" track-by=\"$index\">\r\n                <div class=\"chart\" v-echarts=\"questItem\"></div>\r\n            </div>\r\n        </div>\r\n        <p class=\"preview-deadline\">问卷截止日期：{{new Date(questionnaire.deadline).toLocaleDateString()}}</p>\r\n    </div>\r\n</template>\r\n<script>\r\n    import echarts from '../echarts'\r\n\r\n    export default{\r\n        data() {\r\n            return {\r\n                typeMap: {\r\n                    radio: '单选',\r\n                    checkbox: '多选',\r\n                    textarea: '问答'\r\n                }\r\n            }\r\n        },\r\n        vuex: {\r\n            getters: {\r\n                questionnaire: state => state.currentQuestionnaire,\r\n                questionnaireList: state => state.questionnaireList\r\n            },\r\n            actions: {\r\n                setCurrentQuest({dispatch}, item) {\r\n                    dispatch(\"SET_QUEST\", item)\r\n                }\r\n            }\r\n        },\r\n        route: {\r\n            data({to, next}) {\r\n                let id = to.params.questId\r\n                if(!this.questionnaire) {\r\n                    this.questionnaireList.forEach(item => {\r\n                        if(parseInt(item.id) === parseInt(id)) {\r\n                            this.setCurrentQuest(item)\r\n                            return\r\n                        }\r\n                    })\r\n                }\r\n                // 渲染图表\r\n                next()\r\n            }\r\n        },\r\n        directives: {\r\n            'echarts': {\r\n                bind: function() {\r\n                    let self = this\r\n                    this.vm.$nextTick(function() {\r\n                        self.instance = echarts.init(self.el)\r\n                    })\r\n                },\r\n                update: function(newVal, oldVal) {\r\n                    let self = this\r\n                    let seriesData = []\r\n                    let option = {}\r\n                    // 如果不是文本类问题，则画柱状图；否则话饼图\r\n                    if(newVal.type !== 'textarea') {\r\n                        newVal.selections.forEach(item => {\r\n                            seriesData.push(parseInt(Math.random()*100))\r\n                        })\r\n                        option = {\r\n                            grid: {\r\n                                top: 40,\r\n                                bottom: 25\r\n                            },\r\n                            title: {\r\n                                text: self.vm.typeMap[newVal.type] + '.' +  newVal.title,\r\n                                textAlign: \"left\"\r\n                            },\r\n                            yAxis: {\r\n\r\n                            },\r\n                            xAxis: {\r\n                                data: newVal.selections\r\n                            },\r\n                            series:[{\r\n                                type: 'bar',\r\n                                data: seriesData\r\n                            }]\r\n                        }\r\n                    } else {\r\n                        seriesData.push(parseInt(Math.random()*100))\r\n                        seriesData.push(100 - seriesData[0])\r\n                        option = {\r\n                            title: {\r\n                                text: self.vm.typeMap[newVal.type] + '.' +  newVal.title,\r\n                                textAlign: \"left\"\r\n                            },\r\n                            series : [{\r\n                                type: 'pie',\r\n                                radius: \"60%\",\r\n                                data: [\r\n                                    {name: '有效回答', value: seriesData[0]},\r\n                                    {name: '无效回答', value: seriesData[1]}\r\n                                ]\r\n                            }]\r\n                        }\r\n                    }\r\n                    this.vm.$nextTick(function() {\r\n                        self.instance.setOption(option)\r\n                    })\r\n                    \r\n                },\r\n                unbind: function() {\r\n                    this.instance.dispose()\r\n                }\r\n            }\r\n        }\r\n    }\r\n</script>\r\n<style lang=\"less\">\r\n    #create{\r\n        .preview-deadline{\r\n            font-size: .14rem;\r\n            margin-top: .2rem;\r\n            text-align: center;\r\n        }\r\n        .quest-title_preview{\r\n            text-align: center;\r\n            letter-spacing: .05rem;\r\n            font-size: .28rem;\r\n            font-weight: bold;\r\n        }\r\n         .questItem-data{\r\n            margin: .1rem 0;\r\n            border: 1px solid #ccc;\r\n            border-radius: .03rem;\r\n        } \r\n        .chart{\r\n            min-height: 2rem;\r\n            width: 4rem;\r\n            margin: 0 auto;\r\n        }\r\n    }\r\n</style>\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** Data.vue?c8856686\n **/","exports = module.exports = require(\"./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"#create .preview-deadline{font-size:.14rem;margin-top:.2rem;text-align:center}#create .quest-title_preview{text-align:center;letter-spacing:.05rem;font-size:.28rem;font-weight:700}#create .questItem-data{margin:.1rem 0;border:1px solid #ccc;border-radius:.03rem}#create .chart{min-height:2rem;width:4rem;margin:0 auto}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/css-loader/0.23.1/css-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./~/.npminstall/less-loader/2.2.3/less-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./src/components/Data.vue\n ** module id = 24\n ** module chunks = 2\n **/","module.exports = \" <div id=create v-if=!$loadingRouteData> <div class=quest> <div class=quest-title> <h2 v-text=questionnaire.title class=quest-title_preview></h2> </div> <div v-for=\\\"questItem in questionnaire.questItemList\\\" class=questItem-data track-by=$index> <div class=chart v-echarts=questItem></div> </div> </div> <p class=preview-deadline>问卷截止日期：{{new Date(questionnaire.deadline).toLocaleDateString()}}</p> </div> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-html-loader/1.2.3/vue-html-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./src/components/Data.vue\n ** module id = 31\n ** module chunks = 2\n **/","var __vue_script__, __vue_template__\nrequire(\"!!vue-style-loader!css-loader!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!less!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Data.vue\")\n__vue_script__ = require(\"!!babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=script&index=0!./Data.vue\")\n__vue_template__ = require(\"!!vue-html-loader!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./Data.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/Data.vue\n ** module id = 38\n ** module chunks = 2\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Data.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/.npminstall/vue-style-loader/1.0.0/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Data.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Data.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-style-loader/1.0.0/vue-style-loader!./~/.npminstall/css-loader/0.23.1/css-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./~/.npminstall/less-loader/2.2.3/less-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./src/components/Data.vue\n ** module id = 44\n ** module chunks = 2\n **/","(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.echarts = factory();\n    }\n}(this, function () {var require, define;\n(function () {\n    var mods = {};\n\n    define = function (id, deps, factory) {\n        mods[id] = {\n            id: id,\n            deps: deps,\n            factory: factory,\n            defined: 0,\n            exports: {},\n            require: createRequire(id)\n        };\n    };\n\n    require = createRequire('');\n\n    function normalize(id, baseId) {\n        if (!baseId) {\n            return id;\n        }\n\n        if (id.indexOf('.') === 0) {\n            var basePath = baseId.split('/');\n            var namePath = id.split('/');\n            var baseLen = basePath.length - 1;\n            var nameLen = namePath.length;\n            var cutBaseTerms = 0;\n            var cutNameTerms = 0;\n\n            pathLoop: for (var i = 0; i < nameLen; i++) {\n                switch (namePath[i]) {\n                    case '..':\n                        if (cutBaseTerms < baseLen) {\n                            cutBaseTerms++;\n                            cutNameTerms++;\n                        }\n                        else {\n                            break pathLoop;\n                        }\n                        break;\n                    case '.':\n                        cutNameTerms++;\n                        break;\n                    default:\n                        break pathLoop;\n                }\n            }\n\n            basePath.length = baseLen - cutBaseTerms;\n            namePath = namePath.slice(cutNameTerms);\n\n            return basePath.concat(namePath).join('/');\n        }\n\n        return id;\n    }\n\n    function createRequire(baseId) {\n        var cacheMods = {};\n\n        function localRequire(id, callback) {\n            if (typeof id === 'string') {\n                var exports = cacheMods[id];\n                if (!exports) {\n                    exports = getModExports(normalize(id, baseId));\n                    cacheMods[id] = exports;\n                }\n\n                return exports;\n            }\n            else if (id instanceof Array) {\n                callback = callback || function () {};\n                callback.apply(this, getModsExports(id, callback, baseId));\n            }\n        };\n\n        return localRequire;\n    }\n\n    function getModsExports(ids, factory, baseId) {\n        var es = [];\n        var mod = mods[baseId];\n\n        for (var i = 0, l = Math.min(ids.length, factory.length); i < l; i++) {\n            var id = normalize(ids[i], baseId);\n            var arg;\n            switch (id) {\n                case 'require':\n                    arg = (mod && mod.require) || require;\n                    break;\n                case 'exports':\n                    arg = mod.exports;\n                    break;\n                case 'module':\n                    arg = mod;\n                    break;\n                default:\n                    arg = getModExports(id);\n            }\n            es.push(arg);\n        }\n\n        return es;\n    }\n\n    function getModExports(id) {\n        var mod = mods[id];\n        if (!mod) {\n            throw new Error('No ' + id);\n        }\n\n        if (!mod.defined) {\n            var factory = mod.factory;\n            var factoryReturn = factory.apply(\n                this,\n                getModsExports(mod.deps || [], factory, id)\n            );\n            if (typeof factoryReturn !== 'undefined') {\n                mod.exports = factoryReturn;\n            }\n            mod.defined = 1;\n        }\n\n        return mod.exports;\n    }\n}());\ndefine('echarts/chart/pie', ['require', 'zrender/core/util', '../echarts', './pie/PieSeries', './pie/PieView', '../action/createDataSelectAction', '../visual/dataColor', './pie/pieLayout', '../processor/dataFilter'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var echarts = require('../echarts');\n    require('./pie/PieSeries');\n    require('./pie/PieView');\n    require('../action/createDataSelectAction')('pie', [\n        {\n            type: 'pieToggleSelect',\n            event: 'pieselectchanged',\n            method: 'toggleSelected'\n        },\n        {\n            type: 'pieSelect',\n            event: 'pieselected',\n            method: 'select'\n        },\n        {\n            type: 'pieUnSelect',\n            event: 'pieunselected',\n            method: 'unSelect'\n        }\n    ]);\n    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'pie'));\n    echarts.registerLayout(zrUtil.curry(require('./pie/pieLayout'), 'pie'));\n    echarts.registerProcessor(zrUtil.curry(require('../processor/dataFilter'), 'pie'));\n});\ndefine('echarts/chart/bar', ['require', 'zrender/core/util', '../coord/cartesian/Grid', './bar/BarSeries', './bar/BarView', '../layout/barGrid', '../echarts', '../component/grid'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    require('../coord/cartesian/Grid');\n    require('./bar/BarSeries');\n    require('./bar/BarView');\n    var barLayoutGrid = require('../layout/barGrid');\n    var echarts = require('../echarts');\n    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n    // Visual coding for legend\n    echarts.registerVisual(function (ecModel) {\n        ecModel.eachSeriesByType('bar', function (seriesModel) {\n            var data = seriesModel.getData();\n            data.setVisual('legendSymbol', 'roundRect');\n        });\n    });\n    // In case developer forget to include grid component\n    require('../component/grid');\n});\ndefine('echarts/component/title', ['require', '../echarts', '../util/graphic', '../util/layout'], function (require) {\n    'use strict';\n    var echarts = require('../echarts');\n    var graphic = require('../util/graphic');\n    var layout = require('../util/layout');\n    // Model\n    echarts.extendComponentModel({\n        type: 'title',\n        layoutMode: {\n            type: 'box',\n            ignoreSize: true\n        },\n        defaultOption: {\n            zlevel: 0,\n            z: 6,\n            show: true,\n            text: '',\n            target: 'blank',\n            subtext: '',\n            subtarget: 'blank',\n            left: 0,\n            top: 0,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderColor: '#ccc',\n            borderWidth: 0,\n            padding: 5,\n            itemGap: 10,\n            textStyle: {\n                fontSize: 18,\n                fontWeight: 'bolder',\n                color: '#333'\n            },\n            subtextStyle: { color: '#aaa' }\n        }\n    });\n    // View\n    echarts.extendComponentView({\n        type: 'title',\n        render: function (titleModel, ecModel, api) {\n            this.group.removeAll();\n            if (!titleModel.get('show')) {\n                return;\n            }\n            var group = this.group;\n            var textStyleModel = titleModel.getModel('textStyle');\n            var subtextStyleModel = titleModel.getModel('subtextStyle');\n            var textAlign = titleModel.get('textAlign');\n            var textBaseline = titleModel.get('textBaseline');\n            var textEl = new graphic.Text({\n                    style: {\n                        text: titleModel.get('text'),\n                        textFont: textStyleModel.getFont(),\n                        fill: textStyleModel.getTextColor()\n                    },\n                    z2: 10\n                });\n            var textRect = textEl.getBoundingRect();\n            var subText = titleModel.get('subtext');\n            var subTextEl = new graphic.Text({\n                    style: {\n                        text: subText,\n                        textFont: subtextStyleModel.getFont(),\n                        fill: subtextStyleModel.getTextColor(),\n                        y: textRect.height + titleModel.get('itemGap'),\n                        textBaseline: 'top'\n                    },\n                    z2: 10\n                });\n            var link = titleModel.get('link');\n            var sublink = titleModel.get('sublink');\n            textEl.silent = !link;\n            subTextEl.silent = !sublink;\n            if (link) {\n                textEl.on('click', function () {\n                    window.open(link, '_' + titleModel.get('target'));\n                });\n            }\n            if (sublink) {\n                subTextEl.on('click', function () {\n                    window.open(sublink, '_' + titleModel.get('subtarget'));\n                });\n            }\n            group.add(textEl);\n            subText && group.add(subTextEl);\n            // If no subText, but add subTextEl, there will be an empty line.\n            var groupRect = group.getBoundingRect();\n            var layoutOption = titleModel.getBoxLayoutParams();\n            layoutOption.width = groupRect.width;\n            layoutOption.height = groupRect.height;\n            var layoutRect = layout.getLayoutRect(layoutOption, {\n                    width: api.getWidth(),\n                    height: api.getHeight()\n                }, titleModel.get('padding'));\n            // Adjust text align based on position\n            if (!textAlign) {\n                // Align left if title is on the left. center and right is same\n                textAlign = titleModel.get('left') || titleModel.get('right');\n                if (textAlign === 'middle') {\n                    textAlign = 'center';\n                }\n                // Adjust layout by text align\n                if (textAlign === 'right') {\n                    layoutRect.x += layoutRect.width;\n                } else if (textAlign === 'center') {\n                    layoutRect.x += layoutRect.width / 2;\n                }\n            }\n            if (!textBaseline) {\n                textBaseline = titleModel.get('top') || titleModel.get('bottom');\n                if (textBaseline === 'center') {\n                    textBaseline = 'middle';\n                }\n                if (textBaseline === 'bottom') {\n                    layoutRect.y += layoutRect.height;\n                } else if (textBaseline === 'middle') {\n                    layoutRect.y += layoutRect.height / 2;\n                }\n                textBaseline = textBaseline || 'top';\n            }\n            group.attr('position', [\n                layoutRect.x,\n                layoutRect.y\n            ]);\n            var alignStyle = {\n                    textAlign: textAlign,\n                    textVerticalAlign: textBaseline\n                };\n            textEl.setStyle(alignStyle);\n            subTextEl.setStyle(alignStyle);\n            // Render background\n            // Get groupRect again because textAlign has been changed\n            groupRect = group.getBoundingRect();\n            var padding = layoutRect.margin;\n            var style = titleModel.getItemStyle([\n                    'color',\n                    'opacity'\n                ]);\n            style.fill = titleModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                    shape: {\n                        x: groupRect.x - padding[3],\n                        y: groupRect.y - padding[0],\n                        width: groupRect.width + padding[1] + padding[3],\n                        height: groupRect.height + padding[0] + padding[2]\n                    },\n                    style: style,\n                    silent: true\n                });\n            graphic.subPixelOptimizeRect(rect);\n            group.add(rect);\n        }\n    });\n});\ndefine('echarts/component/grid', ['require', '../util/graphic', 'zrender/core/util', '../echarts', '../coord/cartesian/Grid', './axis'], function (require) {\n    'use strict';\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/core/util');\n    var echarts = require('../echarts');\n    require('../coord/cartesian/Grid');\n    require('./axis');\n    // Grid view\n    echarts.extendComponentView({\n        type: 'grid',\n        render: function (gridModel, ecModel) {\n            this.group.removeAll();\n            if (gridModel.get('show')) {\n                this.group.add(new graphic.Rect({\n                    shape: gridModel.coordinateSystem.getRect(),\n                    style: zrUtil.defaults({ fill: gridModel.get('backgroundColor') }, gridModel.getItemStyle()),\n                    silent: true\n                }));\n            }\n        }\n    });\n    echarts.registerPreprocessor(function (option) {\n        // Only create grid when need\n        if (option.xAxis && option.yAxis && !option.grid) {\n            option.grid = {};\n        }\n    });\n});\ndefine('echarts/scale/Time', ['require', 'zrender/core/util', '../util/number', '../util/format', './Interval'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var IntervalScale = require('./Interval');\n    var intervalScaleProto = IntervalScale.prototype;\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n    // FIXME 公用？\n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n        return lo;\n    };\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n            type: 'time',\n            getLabel: function (val) {\n                var stepLvl = this._stepLvl;\n                var date = new Date(val);\n                return formatUtil.formatTime(stepLvl[0], date);\n            },\n            niceExtent: function (approxTickNum, fixMin, fixMax) {\n                var extent = this._extent;\n                // If extent start and end are same, expand them\n                if (extent[0] === extent[1]) {\n                    // Expand extent\n                    extent[0] -= ONE_DAY;\n                    extent[1] += ONE_DAY;\n                }\n                // If there are no data and extent are [Infinity, -Infinity]\n                if (extent[1] === -Infinity && extent[0] === Infinity) {\n                    var d = new Date();\n                    extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                    extent[0] = extent[1] - ONE_DAY;\n                }\n                this.niceTicks(approxTickNum);\n                // var extent = this._extent;\n                var interval = this._interval;\n                if (!fixMin) {\n                    extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n                }\n                if (!fixMax) {\n                    extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n                }\n            },\n            niceTicks: function (approxTickNum) {\n                approxTickNum = approxTickNum || 10;\n                var extent = this._extent;\n                var span = extent[1] - extent[0];\n                var approxInterval = span / approxTickNum;\n                var scaleLevelsLen = scaleLevels.length;\n                var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n                var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n                var interval = level[2];\n                // Same with interval scale if span is much larger than 1 year\n                if (level[0] === 'year') {\n                    var yearSpan = span / interval;\n                    // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                    // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                    var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n                    interval *= yearStep;\n                }\n                var niceExtent = [\n                        mathCeil(extent[0] / interval) * interval,\n                        mathFloor(extent[1] / interval) * interval\n                    ];\n                this._stepLvl = level;\n                // Interval will be used in getTicks\n                this._interval = interval;\n                this._niceExtent = niceExtent;\n            },\n            parse: function (val) {\n                // val might be float.\n                return +numberUtil.parseDate(val);\n            }\n        });\n    zrUtil.each([\n        'contain',\n        'normalize'\n    ], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n    // Steps from d3\n    var scaleLevels = [\n            [\n                'hh:mm:ss',\n                1,\n                ONE_SECOND\n            ],\n            [\n                'hh:mm:ss',\n                5,\n                ONE_SECOND * 5\n            ],\n            [\n                'hh:mm:ss',\n                10,\n                ONE_SECOND * 10\n            ],\n            [\n                'hh:mm:ss',\n                15,\n                ONE_SECOND * 15\n            ],\n            [\n                'hh:mm:ss',\n                30,\n                ONE_SECOND * 30\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                1,\n                ONE_MINUTE\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                5,\n                ONE_MINUTE * 5\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                10,\n                ONE_MINUTE * 10\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                15,\n                ONE_MINUTE * 15\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                30,\n                ONE_MINUTE * 30\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                1,\n                ONE_HOUR\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                2,\n                ONE_HOUR * 2\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                6,\n                ONE_HOUR * 6\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                12,\n                ONE_HOUR * 12\n            ],\n            [\n                'MM-dd\\nyyyy',\n                1,\n                ONE_DAY\n            ],\n            [\n                'week',\n                7,\n                ONE_DAY * 7\n            ],\n            [\n                'month',\n                1,\n                ONE_DAY * 31\n            ],\n            [\n                'quarter',\n                3,\n                ONE_DAY * 380 / 4\n            ],\n            [\n                'half-year',\n                6,\n                ONE_DAY * 380 / 2\n            ],\n            [\n                'year',\n                1,\n                ONE_DAY * 380\n            ]\n        ];\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function () {\n        return new TimeScale();\n    };\n    return TimeScale;\n});\ndefine('echarts/echarts', ['require', 'zrender/core/env', './model/Global', './ExtensionAPI', './CoordinateSystem', './model/OptionManager', './model/Component', './model/Series', './view/Component', './view/Chart', './util/graphic', 'zrender', 'zrender/core/util', 'zrender/tool/color', 'zrender/mixin/Eventful', 'zrender/core/timsort', './visual/seriesColor', './preprocessor/backwardCompat', './loading/default', './data/List', './model/Model', './util/number', './util/format', 'zrender/core/matrix', 'zrender/core/vector'], function (require) {\n    var env = require('zrender/core/env');\n    var GlobalModel = require('./model/Global');\n    var ExtensionAPI = require('./ExtensionAPI');\n    var CoordinateSystemManager = require('./CoordinateSystem');\n    var OptionManager = require('./model/OptionManager');\n    var ComponentModel = require('./model/Component');\n    var SeriesModel = require('./model/Series');\n    var ComponentView = require('./view/Component');\n    var ChartView = require('./view/Chart');\n    var graphic = require('./util/graphic');\n    var zrender = require('zrender');\n    var zrUtil = require('zrender/core/util');\n    var colorTool = require('zrender/tool/color');\n    var Eventful = require('zrender/mixin/Eventful');\n    var timsort = require('zrender/core/timsort');\n    var each = zrUtil.each;\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    var PRIORITY_VISUAL_BRUSH = 5000;\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flag_in_main_process';\n    var HAS_GRADIENT_OR_PATTERN_BG = '_hasGradientOrPatternBg';\n    var OPTION_UPDATED = '_optionUpdated';\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts(dom, theme, opts) {\n        opts = opts || {};\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLDomElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio\n        });\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = zrUtil.clone(theme);\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = new ExtensionAPI(this);\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n        Eventful.call(this);\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n        // Init mouse events\n        this._initEvents();\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n        this._zr.animation.on('frame', this._onframe, this);\n    }\n    var echartsProto = ECharts.prototype;\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n            this[IN_MAIN_PROCESS] = true;\n            updateMethods.prepareAndUpdate.call(this);\n            this[IN_MAIN_PROCESS] = false;\n            this[OPTION_UPDATED] = false;\n        }\n    };\n    /**\n     * @return {HTMLDomElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n    /**\n     * @param {Object} option\n     * @param {boolean} notMerge\n     * @param {boolean} [lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (true) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n        this[IN_MAIN_PROCESS] = true;\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n        this._model.setOption(option, optionPreprocessorFuncs);\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = true;\n        } else {\n            updateMethods.prepareAndUpdate.call(this);\n            this._zr.refreshImmediately();\n            this[OPTION_UPDATED] = false;\n        }\n        this[IN_MAIN_PROCESS] = false;\n        this._flushPendingActions();\n    };\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({ mainType: componentType }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n        var url = this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = opts && opts.pixelRatio || 1;\n            for (var id in instances) {\n                var chart = instances[id];\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(zrUtil.clone(opts));\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            }\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                        style: {\n                            x: item.left * dpr - left,\n                            y: item.top * dpr - top,\n                            image: item.dom\n                        }\n                    });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        } else {\n            return this.getDataURL(opts);\n        }\n    };\n    var updateMethods = {\n            update: function (payload) {\n                // console.time && console.time('update');\n                var ecModel = this._model;\n                var api = this._api;\n                var coordSysMgr = this._coordSysMgr;\n                var zr = this._zr;\n                // update before setOption\n                if (!ecModel) {\n                    return;\n                }\n                // Fixme First time update ?\n                ecModel.restoreData();\n                // TODO\n                // Save total ecModel here for undo/redo (after restoring data and before processing data).\n                // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n                // Create new coordinate system each update\n                // In LineView may save the old coordinate system and use it to get the orignal point\n                coordSysMgr.create(this._model, this._api);\n                processData.call(this, ecModel, api);\n                stackSeriesData.call(this, ecModel);\n                coordSysMgr.update(ecModel, api);\n                doVisualEncoding.call(this, ecModel, payload);\n                doRender.call(this, ecModel, payload);\n                // Set background\n                var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n                var painter = zr.painter;\n                // TODO all use clearColor ?\n                if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                    zr.configLayer(0, { clearColor: backgroundColor });\n                } else {\n                    // In IE8\n                    if (!env.canvasSupported) {\n                        var colorArr = colorTool.parse(backgroundColor);\n                        backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                        if (colorArr[3] === 0) {\n                            backgroundColor = 'transparent';\n                        }\n                    }\n                    if (backgroundColor.colorStops || backgroundColor.image) {\n                        // Gradient background\n                        // FIXME Fixed layer？\n                        zr.configLayer(0, { clearColor: backgroundColor });\n                        this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n                        this._dom.style.background = 'transparent';\n                    } else {\n                        if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                            zr.configLayer(0, { clearColor: null });\n                        }\n                        this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n                        this._dom.style.background = backgroundColor;\n                    }\n                }    // console.time && console.timeEnd('update');\n            },\n            updateView: function (payload) {\n                var ecModel = this._model;\n                // update before setOption\n                if (!ecModel) {\n                    return;\n                }\n                ecModel.eachSeries(function (seriesModel) {\n                    seriesModel.getData().clearAllVisual();\n                });\n                doVisualEncoding.call(this, ecModel, payload);\n                invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n            },\n            updateVisual: function (payload) {\n                var ecModel = this._model;\n                // update before setOption\n                if (!ecModel) {\n                    return;\n                }\n                ecModel.eachSeries(function (seriesModel) {\n                    seriesModel.getData().clearAllVisual();\n                });\n                doVisualEncoding.call(this, ecModel, payload);\n                invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n            },\n            updateLayout: function (payload) {\n                var ecModel = this._model;\n                // update before setOption\n                if (!ecModel) {\n                    return;\n                }\n                doLayout.call(this, ecModel, payload);\n                invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n            },\n            highlight: function (payload) {\n                toggleHighlight.call(this, 'highlight', payload);\n            },\n            downplay: function (payload) {\n                toggleHighlight.call(this, 'downplay', payload);\n            },\n            prepareAndUpdate: function (payload) {\n                var ecModel = this._model;\n                prepareView.call(this, 'component', ecModel);\n                prepareView.call(this, 'chart', ecModel);\n                updateMethods.update.call(this, payload);\n            }\n        };\n    /**\n     * @param {Object} payload\n     * @private\n     */\n    function toggleHighlight(method, payload) {\n        var ecModel = this._model;\n        // dispatchAction before setOption\n        if (!ecModel) {\n            return;\n        }\n        ecModel.eachComponent({\n            mainType: 'series',\n            query: payload\n        }, function (seriesModel, index) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            if (chartView && chartView.__alive) {\n                chartView[method](seriesModel, ecModel, this._api, payload);\n            }\n        }, this);\n    }\n    /**\n     * Resize the chart\n     */\n    echartsProto.resize = function () {\n        if (true) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n        this[IN_MAIN_PROCESS] = true;\n        this._zr.resize();\n        var optionChanged = this._model && this._model.resetOption('media');\n        updateMethods[optionChanged ? 'prepareAndUpdate' : 'update'].call(this);\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n        this[IN_MAIN_PROCESS] = false;\n        this._flushPendingActions();\n    };\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (true) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n        zr.add(el);\n    };\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {boolean} [silent=false] Whether trigger event.\n     */\n    echartsProto.dispatchAction = function (payload, silent) {\n        var actionWrap = actions[payload.type];\n        if (!actionWrap) {\n            return;\n        }\n        var actionInfo = actionWrap.actionInfo;\n        var updateMethod = actionInfo.update || 'update';\n        // if (__DEV__) {\n        //     zrUtil.assert(\n        //         !this[IN_MAIN_PROCESS],\n        //         '`dispatchAction` should not be called during main process.'\n        //         + 'unless updateMathod is \"none\".'\n        //     );\n        // }\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n        this[IN_MAIN_PROCESS] = true;\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighlightOrDownplay = payload.type === 'highlight' || payload.type === 'downplay';\n        for (var i = 0; i < payloads.length; i++) {\n            var batchItem = payloads[i];\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n            // Highlight and downplay are special.\n            isHighlightOrDownplay && updateMethods[updateMethod].call(this, batchItem);\n        }\n        if (updateMethod !== 'none' && !isHighlightOrDownplay) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            } else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payload.type,\n                batch: eventObjBatch\n            };\n        } else {\n            eventObj = eventObjBatch[0];\n        }\n        this[IN_MAIN_PROCESS] = false;\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n        this._flushPendingActions();\n    };\n    echartsProto._flushPendingActions = function () {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            this.dispatchAction(payload);\n        }\n    };\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n            updateZ(componentModel, component);\n        }, this);\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n            updateZ(seriesModel, chart);\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n    }\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            } else {\n                model = componentType;\n            }\n            // Consider: id same and type changed.\n            var viewId = model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = ComponentModel.parseClassType(model.type);\n                var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                } else {\n                    // Error\n                    return;\n                }\n            }\n            model.__viewId = viewId;\n            view.__alive = true;\n            view.__id = viewId;\n            view.__model = model;\n        }, this);\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n            } else {\n                i++;\n            }\n        }\n    }\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                if (previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            visual.func(ecModel, api, payload);\n        });\n    }\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n            updateZ(componentModel, componentView);\n        }, this);\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n            chartView.group.silent = !!seriesModel.get('silent');\n            updateZ(seriesModel, chartView);\n            updateProgressiveAndBlend(seriesModel, chartView);\n        }, this);\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n    var MOUSE_EVENT_NAMES = [\n            'click',\n            'dblclick',\n            'mouseover',\n            'mouseout',\n            'mousemove',\n            'mousedown',\n            'mouseup',\n            'globalout'\n        ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    var params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }    // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    this.trigger(eveName, el.eventData);\n                }\n            }, this);\n        }, this);\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (true) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n        var api = this._api;\n        var ecModel = this._model;\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n        // Dispose after all views disposed\n        this._zr.dispose();\n        delete instances[this.id];\n    };\n    zrUtil.mixin(ECharts, Eventful);\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ? Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (true) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var actions = [];\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n    var instances = {};\n    var connectedGroups = {};\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n            version: '3.2.3',\n            dependencies: { zrender: '3.1.3' }\n        };\n    function enableConnect(chart) {\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n                    for (var id in instances) {\n                        var otherChart = instances[id];\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    }\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n    }\n    /**\n     * @param {HTMLDomElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (true) {\n            // Check version\n            if (zrender.version.replace('.', '') - 0 < echarts.dependencies.zrender.replace('.', '') - 0) {\n                throw new Error('ZRender ' + zrender.version + ' is too old for ECharts ' + echarts.version + '. Current version need ZRender ' + echarts.dependencies.zrender + '+');\n            }\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n        enableConnect(chart);\n        return chart;\n    };\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || 'g_' + groupIdBase++;\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n    /**\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (zrUtil.isDom(chart)) {\n            chart = echarts.getInstanceByDom(chart);\n        } else if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        if (chart instanceof ECharts && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n    /**\n     * @param  {HTMLDomElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        return instances[key];\n    };\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (true) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo) ? actionInfo.type : [\n                actionInfo,\n                actionInfo = { event: eventName }\n            ][0];\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n        if (!actions[actionType]) {\n            actions[actionType] = {\n                action: action,\n                actionInfo: actionInfo\n            };\n        }\n        eventActionMap[eventName] = actionType;\n    };\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (true) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (true) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n    var parseClassType = ComponentModel.parseClassType;\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts, superClass) {\n        var Clazz = ComponentModel;\n        if (superClass) {\n            var classType = parseClassType(superClass);\n            Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts, superClass) {\n        var Clazz = ComponentView;\n        if (superClass) {\n            var classType = parseClassType(superClass);\n            Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts, superClass) {\n        var Clazz = SeriesModel;\n        if (superClass) {\n            superClass = 'series.' + superClass.replace('series.', '');\n            var classType = parseClassType(superClass);\n            Clazz = SeriesModel.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts, superClass) {\n        var Clazz = ChartView;\n        if (superClass) {\n            superClass.replace('series.', '');\n            var classType = parseClassType(superClass);\n            Clazz = ChartView.getClass(classType.main, true);\n        }\n        return Clazz.extend(opts);\n    };\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, require('./visual/seriesColor'));\n    echarts.registerPreprocessor(require('./preprocessor/backwardCompat'));\n    echarts.registerLoading('default', require('./loading/default'));\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n    // --------\n    // Exports\n    // --------\n    //\n    echarts.List = require('./data/List');\n    echarts.Model = require('./model/Model');\n    echarts.graphic = require('./util/graphic');\n    echarts.number = require('./util/number');\n    echarts.format = require('./util/format');\n    echarts.matrix = require('zrender/core/matrix');\n    echarts.vector = require('zrender/core/vector');\n    echarts.color = require('zrender/tool/color');\n    echarts.util = {};\n    each([\n        'map',\n        'each',\n        'filter',\n        'indexOf',\n        'inherits',\n        'reduce',\n        'filter',\n        'bind',\n        'curry',\n        'isArray',\n        'isString',\n        'isObject',\n        'isFunction',\n        'extend',\n        'defaults'\n    ], function (name) {\n        echarts.util[name] = zrUtil[name];\n    });\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n    return echarts;\n});\ndefine('echarts/scale/Log', ['require', 'zrender/core/util', './Scale', '../util/number', './Interval'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var Scale = require('./Scale');\n    var numberUtil = require('../util/number');\n    // Use some method of IntervalScale\n    var IntervalScale = require('./Interval');\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n    var mathLog = Math.log;\n    var LogScale = Scale.extend({\n            type: 'log',\n            base: 10,\n            getTicks: function () {\n                return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                    return numberUtil.round(mathPow(this.base, val));\n                }, this);\n            },\n            getLabel: intervalScaleProto.getLabel,\n            scale: function (val) {\n                val = scaleProto.scale.call(this, val);\n                return mathPow(this.base, val);\n            },\n            setExtent: function (start, end) {\n                var base = this.base;\n                start = mathLog(start) / mathLog(base);\n                end = mathLog(end) / mathLog(base);\n                intervalScaleProto.setExtent.call(this, start, end);\n            },\n            getExtent: function () {\n                var base = this.base;\n                var extent = scaleProto.getExtent.call(this);\n                extent[0] = mathPow(base, extent[0]);\n                extent[1] = mathPow(base, extent[1]);\n                return extent;\n            },\n            unionExtent: function (extent) {\n                var base = this.base;\n                extent[0] = mathLog(extent[0]) / mathLog(base);\n                extent[1] = mathLog(extent[1]) / mathLog(base);\n                scaleProto.unionExtent.call(this, extent);\n            },\n            niceTicks: function (approxTickNum) {\n                approxTickNum = approxTickNum || 10;\n                var extent = this._extent;\n                var span = extent[1] - extent[0];\n                if (span === Infinity || span <= 0) {\n                    return;\n                }\n                var interval = numberUtil.quantity(span);\n                var err = approxTickNum / span * interval;\n                // Filter ticks to get closer to the desired count.\n                if (err <= 0.5) {\n                    interval *= 10;\n                }\n                // Interval should be integer\n                while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                    interval *= 10;\n                }\n                var niceExtent = [\n                        numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                        numberUtil.round(mathFloor(extent[1] / interval) * interval)\n                    ];\n                this._interval = interval;\n                this._niceExtent = niceExtent;\n            },\n            niceExtent: intervalScaleProto.niceExtent\n        });\n    zrUtil.each([\n        'contain',\n        'normalize'\n    ], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n    LogScale.create = function () {\n        return new LogScale();\n    };\n    return LogScale;\n});\ndefine('echarts/chart/pie/PieView', ['require', '../../util/graphic', 'zrender/core/util', '../../view/Chart'], function (require) {\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/core/util');\n    /**\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n        var data = seriesModel.getData();\n        var dataIndex = this.dataIndex;\n        var name = data.getName(dataIndex);\n        var selectedOffset = seriesModel.get('selectedOffset');\n        api.dispatchAction({\n            type: 'pieToggleSelect',\n            from: uid,\n            name: name,\n            seriesId: seriesModel.id\n        });\n        data.each(function (idx) {\n            toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n        });\n    }\n    /**\n     * @param {module:zrender/graphic/Sector} el\n     * @param {Object} layout\n     * @param {boolean} isSelected\n     * @param {number} selectedOffset\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n        var dx = Math.cos(midAngle);\n        var dy = Math.sin(midAngle);\n        var offset = isSelected ? selectedOffset : 0;\n        var position = [\n                dx * offset,\n                dy * offset\n            ];\n        hasAnimation ? el.animate().when(200, { position: position }).start('bounceOut') : el.attr('position', position);\n    }\n    /**\n     * Piece of pie including Sector, Label, LabelLine\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     */\n    function PiePiece(data, idx) {\n        graphic.Group.call(this);\n        var sector = new graphic.Sector({ z2: 2 });\n        var polyline = new graphic.Polyline();\n        var text = new graphic.Text();\n        this.add(sector);\n        this.add(polyline);\n        this.add(text);\n        this.updateData(data, idx, true);\n        // Hover to change label and labelLine\n        function onEmphasis() {\n            polyline.ignore = polyline.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        function onNormal() {\n            polyline.ignore = polyline.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n        this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n    }\n    var piePieceProto = PiePiece.prototype;\n    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n        var textStyleModel = labelModel.getModel('textStyle');\n        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n        return {\n            fill: textStyleModel.getTextColor() || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n            opacity: data.getItemVisual(idx, 'opacity'),\n            textFont: textStyleModel.getFont(),\n            text: zrUtil.retrieve(data.hostModel.getFormattedLabel(idx, state), data.getName(idx))\n        };\n    }\n    piePieceProto.updateData = function (data, idx, firstCreate) {\n        var sector = this.childAt(0);\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var sectorShape = zrUtil.extend({}, layout);\n        sectorShape.label = null;\n        if (firstCreate) {\n            sector.setShape(sectorShape);\n            sector.shape.endAngle = layout.startAngle;\n            graphic.updateProps(sector, { shape: { endAngle: layout.endAngle } }, seriesModel, idx);\n        } else {\n            graphic.updateProps(sector, { shape: sectorShape }, seriesModel, idx);\n        }\n        // Update common style\n        var itemStyleModel = itemModel.getModel('itemStyle');\n        var visualColor = data.getItemVisual(idx, 'color');\n        sector.useStyle(zrUtil.defaults({\n            lineJoin: 'bevel',\n            fill: visualColor\n        }, itemStyleModel.getModel('normal').getItemStyle()));\n        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n        // Toggle selected\n        toggleItemSelected(this, data.getItemLayout(idx), itemModel.get('selected'), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n        function onEmphasis() {\n            // Sector may has animation of updating data. Force to move to the last frame\n            // Or it may stopped on the wrong shape\n            sector.stopAnimation(true);\n            sector.animateTo({ shape: { r: layout.r + 10 } }, 300, 'elasticOut');\n        }\n        function onNormal() {\n            sector.stopAnimation(true);\n            sector.animateTo({ shape: { r: layout.r } }, 300, 'elasticOut');\n        }\n        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n        if (itemModel.get('hoverAnimation') && seriesModel.ifEnableAnimation()) {\n            sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n        }\n        this._updateLabel(data, idx);\n        graphic.setHoverStyle(this);\n    };\n    piePieceProto._updateLabel = function (data, idx) {\n        var labelLine = this.childAt(1);\n        var labelText = this.childAt(2);\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var visualColor = data.getItemVisual(idx, 'color');\n        graphic.updateProps(labelLine, {\n            shape: {\n                points: labelLayout.linePoints || [\n                    [\n                        labelLayout.x,\n                        labelLayout.y\n                    ],\n                    [\n                        labelLayout.x,\n                        labelLayout.y\n                    ],\n                    [\n                        labelLayout.x,\n                        labelLayout.y\n                    ]\n                ]\n            }\n        }, seriesModel, idx);\n        graphic.updateProps(labelText, {\n            style: {\n                x: labelLayout.x,\n                y: labelLayout.y\n            }\n        }, seriesModel, idx);\n        labelText.attr({\n            style: {\n                textVerticalAlign: labelLayout.verticalAlign,\n                textAlign: labelLayout.textAlign,\n                textFont: labelLayout.font\n            },\n            rotation: labelLayout.rotation,\n            origin: [\n                labelLayout.x,\n                labelLayout.y\n            ],\n            z2: 10\n        });\n        var labelModel = itemModel.getModel('label.normal');\n        var labelHoverModel = itemModel.getModel('label.emphasis');\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n        labelText.hoverIgnore = !labelHoverModel.get('show');\n        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n        // Default use item visual color\n        labelLine.setStyle({\n            stroke: visualColor,\n            opacity: data.getItemVisual(idx, 'opacity')\n        });\n        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n        var smooth = labelLineModel.get('smooth');\n        if (smooth && smooth === true) {\n            smooth = 0.4;\n        }\n        labelLine.setShape({ smooth: smooth });\n    };\n    zrUtil.inherits(PiePiece, graphic.Group);\n    // Pie view\n    var Pie = require('../../view/Chart').extend({\n            type: 'pie',\n            init: function () {\n                var sectorGroup = new graphic.Group();\n                this._sectorGroup = sectorGroup;\n            },\n            render: function (seriesModel, ecModel, api, payload) {\n                if (payload && payload.from === this.uid) {\n                    return;\n                }\n                var data = seriesModel.getData();\n                var oldData = this._data;\n                var group = this.group;\n                var hasAnimation = ecModel.get('animation');\n                var isFirstRender = !oldData;\n                var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n                var selectedMode = seriesModel.get('selectedMode');\n                data.diff(oldData).add(function (idx) {\n                    var piePiece = new PiePiece(data, idx);\n                    if (isFirstRender) {\n                        piePiece.eachChild(function (child) {\n                            child.stopAnimation(true);\n                        });\n                    }\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    data.setItemGraphicEl(idx, piePiece);\n                    group.add(piePiece);\n                }).update(function (newIdx, oldIdx) {\n                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n                    piePiece.updateData(data, newIdx);\n                    piePiece.off('click');\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    group.add(piePiece);\n                    data.setItemGraphicEl(newIdx, piePiece);\n                }).remove(function (idx) {\n                    var piePiece = oldData.getItemGraphicEl(idx);\n                    group.remove(piePiece);\n                }).execute();\n                if (hasAnimation && isFirstRender && data.count() > 0) {\n                    var shape = data.getItemLayout(0);\n                    var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n                    var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n                    group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n                }\n                this._data = data;\n            },\n            _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n                var clipPath = new graphic.Sector({\n                        shape: {\n                            cx: cx,\n                            cy: cy,\n                            r0: 0,\n                            r: r,\n                            startAngle: startAngle,\n                            endAngle: startAngle,\n                            clockwise: clockwise\n                        }\n                    });\n                graphic.initProps(clipPath, { shape: { endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2 } }, seriesModel, cb);\n                return clipPath;\n            }\n        });\n    return Pie;\n});\ndefine('echarts/chart/pie/PieSeries', ['require', '../../data/List', 'zrender/core/util', '../../util/model', '../../data/helper/completeDimensions', '../../component/helper/selectableMixin', '../../echarts'], function (require) {\n    'use strict';\n    var List = require('../../data/List');\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../../util/model');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var dataSelectableMixin = require('../../component/helper/selectableMixin');\n    var PieSeries = require('../../echarts').extendSeriesModel({\n            type: 'series.pie',\n            init: function (option) {\n                PieSeries.superApply(this, 'init', arguments);\n                // Enable legend selection for each data item\n                // Use a function instead of direct access because data reference may changed\n                this.legendDataProvider = function () {\n                    return this._dataBeforeProcessed;\n                };\n                this.updateSelectedMap(option.data);\n                this._defaultLabelLine(option);\n            },\n            mergeOption: function (newOption) {\n                PieSeries.superCall(this, 'mergeOption', newOption);\n                this.updateSelectedMap(this.option.data);\n            },\n            getInitialData: function (option, ecModel) {\n                var dimensions = completeDimensions(['value'], option.data);\n                var list = new List(dimensions, this);\n                list.initData(option.data);\n                return list;\n            },\n            getDataParams: function (dataIndex) {\n                var data = this._data;\n                var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n                var sum = data.getSum('value');\n                // FIXME toFixed?\n                //\n                // Percent is 0 if sum is 0\n                params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n                params.$vars.push('percent');\n                return params;\n            },\n            _defaultLabelLine: function (option) {\n                // Extend labelLine emphasis\n                modelUtil.defaultEmphasis(option.labelLine, ['show']);\n                var labelLineNormalOpt = option.labelLine.normal;\n                var labelLineEmphasisOpt = option.labelLine.emphasis;\n                // Not show label line if `label.normal.show = false`\n                labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.normal.show;\n                labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.label.emphasis.show;\n            },\n            defaultOption: {\n                zlevel: 0,\n                z: 2,\n                legendHoverLink: true,\n                hoverAnimation: true,\n                center: [\n                    '50%',\n                    '50%'\n                ],\n                radius: [\n                    0,\n                    '75%'\n                ],\n                clockwise: true,\n                startAngle: 90,\n                minAngle: 0,\n                selectedOffset: 10,\n                avoidLabelOverlap: true,\n                label: {\n                    normal: {\n                        rotate: false,\n                        show: true,\n                        position: 'outer'\n                    },\n                    emphasis: {}\n                },\n                labelLine: {\n                    normal: {\n                        show: true,\n                        length: 15,\n                        length2: 15,\n                        smooth: false,\n                        lineStyle: {\n                            width: 1,\n                            type: 'solid'\n                        }\n                    }\n                },\n                itemStyle: {\n                    normal: { borderWidth: 1 },\n                    emphasis: {}\n                },\n                animationEasing: 'cubicOut',\n                data: []\n            }\n        });\n    zrUtil.mixin(PieSeries, dataSelectableMixin);\n    return PieSeries;\n});\ndefine('echarts/action/createDataSelectAction', ['require', '../echarts', 'zrender/core/util'], function (require) {\n    var echarts = require('../echarts');\n    var zrUtil = require('zrender/core/util');\n    return function (seriesType, actionInfos) {\n        zrUtil.each(actionInfos, function (actionInfo) {\n            actionInfo.update = 'updateView';\n            /**\n             * @payload\n             * @property {string} seriesName\n             * @property {string} name\n             */\n            echarts.registerAction(actionInfo, function (payload, ecModel) {\n                var selected = {};\n                ecModel.eachComponent({\n                    mainType: 'series',\n                    subType: seriesType,\n                    query: payload\n                }, function (seriesModel) {\n                    if (seriesModel[actionInfo.method]) {\n                        seriesModel[actionInfo.method](payload.name);\n                    }\n                    var data = seriesModel.getData();\n                    // Create selected map\n                    data.each(function (idx) {\n                        var name = data.getName(idx);\n                        selected[name] = seriesModel.isSelected(name) || false;\n                    });\n                });\n                return {\n                    name: payload.name,\n                    selected: selected\n                };\n            });\n        });\n    };\n});\ndefine('zrender/core/util', ['require'], function (require) {\n    // 用于处理merge时无法遍历Date等对象的问题\n    var BUILTIN_OBJECT = {\n            '[object Function]': 1,\n            '[object RegExp]': 1,\n            '[object Date]': 1,\n            '[object Error]': 1,\n            '[object CanvasGradient]': 1,\n            '[object CanvasPattern]': 1,\n            '[object Image]': 1\n        };\n    var objToString = Object.prototype.toString;\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n    /**\n     * @param {*} source\n     * @return {*} 拷贝后的新对象\n     */\n    function clone(source) {\n        if (typeof source == 'object' && source !== null) {\n            var result = source;\n            if (source instanceof Array) {\n                result = [];\n                for (var i = 0, len = source.length; i < len; i++) {\n                    result[i] = clone(source[i]);\n                }\n            } else if (!isBuildInObject(source) && !isDom(source)) {\n                result = {};\n                for (var key in source) {\n                    if (source.hasOwnProperty(key)) {\n                        result[key] = clone(source[key]);\n                    }\n                }\n            }\n            return result;\n        }\n        return source;\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n                if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuildInObject(sourceProp) && !isBuildInObject(targetProp)) {\n                    // 如果需要递归覆盖，就递归调用merge\n                    merge(targetProp, sourceProp, overwrite);\n                } else if (overwrite || !(key in target)) {\n                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n                    // NOTE，在 target[key] 不存在的时候也是直接覆盖\n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n        return target;\n    }\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n    /**\n     * 查询数组中元素的index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    /**\n     * 构造类继承关系\n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz 源类\n     * @param {Function} baseClazz 基类\n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {\n        }\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n        defaults(target, source, overlay);\n    }\n    /**\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (!data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n    /**\n     * 数组或对象遍历\n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        } else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        } else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n    /**\n     * 数组映射\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        } else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        } else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n    /**\n     * 数组过滤\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        } else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n    /**\n     * 数组项查找\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || !!value && type == 'object';\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuildInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return value && value.nodeType === 1 && typeof value.nodeName == 'string';\n    }\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n    var util = {\n            inherits: inherits,\n            mixin: mixin,\n            clone: clone,\n            merge: merge,\n            mergeAll: mergeAll,\n            extend: extend,\n            defaults: defaults,\n            getContext: getContext,\n            createCanvas: createCanvas,\n            indexOf: indexOf,\n            slice: slice,\n            find: find,\n            isArrayLike: isArrayLike,\n            each: each,\n            map: map,\n            reduce: reduce,\n            filter: filter,\n            bind: bind,\n            curry: curry,\n            isArray: isArray,\n            isString: isString,\n            isObject: isObject,\n            isFunction: isFunction,\n            isBuildInObject: isBuildInObject,\n            isDom: isDom,\n            retrieve: retrieve,\n            assert: assert,\n            noop: function () {\n            }\n        };\n    return util;\n});\ndefine('echarts/visual/dataColor', ['require'], function (require) {\n    return function (seriesType, ecModel) {\n        // Pie and funnel may use diferrent scope\n        var paletteScope = {};\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var dataAll = seriesModel.getRawData();\n            var idxMap = {};\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                var data = seriesModel.getData();\n                data.each(function (idx) {\n                    var rawIdx = data.getRawIndex(idx);\n                    idxMap[rawIdx] = idx;\n                });\n                dataAll.each(function (rawIdx) {\n                    // FIXME Performance\n                    var itemModel = dataAll.getItemModel(rawIdx);\n                    var filteredIdx = idxMap[rawIdx];\n                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n                    var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n                    if (!singleDataColor) {\n                        var color = itemModel.get('itemStyle.normal.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n                        // Legend may use the visual info in data before processed\n                        dataAll.setItemVisual(rawIdx, 'color', color);\n                        // Data is not filtered\n                        if (filteredIdx != null) {\n                            data.setItemVisual(filteredIdx, 'color', color);\n                        }\n                    } else {\n                        // Set data all color for legend\n                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n                    }\n                });\n            }\n        });\n    };\n});\ndefine('echarts/chart/pie/pieLayout', ['require', '../../util/number', './labelLayout', 'zrender/core/util'], function (require) {\n    var numberUtil = require('../../util/number');\n    var parsePercent = numberUtil.parsePercent;\n    var labelLayout = require('./labelLayout');\n    var zrUtil = require('zrender/core/util');\n    var PI2 = Math.PI * 2;\n    var RADIAN = Math.PI / 180;\n    return function (seriesType, ecModel, api, payload) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var center = seriesModel.get('center');\n            var radius = seriesModel.get('radius');\n            if (!zrUtil.isArray(radius)) {\n                radius = [\n                    0,\n                    radius\n                ];\n            }\n            if (!zrUtil.isArray(center)) {\n                center = [\n                    center,\n                    center\n                ];\n            }\n            var width = api.getWidth();\n            var height = api.getHeight();\n            var size = Math.min(width, height);\n            var cx = parsePercent(center[0], width);\n            var cy = parsePercent(center[1], height);\n            var r0 = parsePercent(radius[0], size / 2);\n            var r = parsePercent(radius[1], size / 2);\n            var data = seriesModel.getData();\n            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n            var minAngle = seriesModel.get('minAngle') * RADIAN;\n            var sum = data.getSum('value');\n            // Sum may be 0\n            var unitRadian = Math.PI / (sum || data.count()) * 2;\n            var clockwise = seriesModel.get('clockwise');\n            var roseType = seriesModel.get('roseType');\n            // [0...max]\n            var extent = data.getDataExtent('value');\n            extent[0] = 0;\n            // In the case some sector angle is smaller than minAngle\n            var restAngle = PI2;\n            var valueSumLargerThanMinAngle = 0;\n            var currentAngle = startAngle;\n            var dir = clockwise ? 1 : -1;\n            data.each('value', function (value, idx) {\n                var angle;\n                // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n                if (roseType !== 'area') {\n                    angle = sum === 0 ? unitRadian : value * unitRadian;\n                } else {\n                    angle = PI2 / (data.count() || 1);\n                }\n                if (angle < minAngle) {\n                    angle = minAngle;\n                    restAngle -= minAngle;\n                } else {\n                    valueSumLargerThanMinAngle += value;\n                }\n                var endAngle = currentAngle + dir * angle;\n                data.setItemLayout(idx, {\n                    angle: angle,\n                    startAngle: currentAngle,\n                    endAngle: endAngle,\n                    clockwise: clockwise,\n                    cx: cx,\n                    cy: cy,\n                    r0: r0,\n                    r: roseType ? numberUtil.linearMap(value, extent, [\n                        r0,\n                        r\n                    ]) : r\n                });\n                currentAngle = endAngle;\n            }, true);\n            // Some sector is constrained by minAngle\n            // Rest sectors needs recalculate angle\n            if (restAngle < PI2) {\n                // Average the angle if rest angle is not enough after all angles is\n                // Constrained by minAngle\n                if (restAngle <= 0.001) {\n                    var angle = PI2 / data.count();\n                    data.each(function (idx) {\n                        var layout = data.getItemLayout(idx);\n                        layout.startAngle = startAngle + dir * idx * angle;\n                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n                    });\n                } else {\n                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n                    currentAngle = startAngle;\n                    data.each('value', function (value, idx) {\n                        var layout = data.getItemLayout(idx);\n                        var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n                        layout.startAngle = currentAngle;\n                        layout.endAngle = currentAngle + dir * angle;\n                        currentAngle += angle;\n                    });\n                }\n            }\n            labelLayout(seriesModel, r, width, height);\n        });\n    };\n});\ndefine('echarts/processor/dataFilter', [], function () {\n    return function (seriesType, ecModel) {\n        var legendModels = ecModel.findComponents({ mainType: 'legend' });\n        if (!legendModels || !legendModels.length) {\n            return;\n        }\n        ecModel.eachSeriesByType(seriesType, function (series) {\n            var data = series.getData();\n            data.filterSelf(function (idx) {\n                var name = data.getName(idx);\n                // If in any legend component the status is not selected.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(name)) {\n                        return false;\n                    }\n                }\n                return true;\n            }, this);\n        }, this);\n    };\n});\ndefine('echarts/coord/cartesian/Grid', ['require', 'exports', '../../util/layout', '../../coord/axisHelper', 'zrender/core/util', './Cartesian2D', './Axis2D', './GridModel', '../../CoordinateSystem'], function (require, factory) {\n    var layout = require('../../util/layout');\n    var axisHelper = require('../../coord/axisHelper');\n    var zrUtil = require('zrender/core/util');\n    var Cartesian2D = require('./Cartesian2D');\n    var Axis2D = require('./Axis2D');\n    var each = zrUtil.each;\n    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n    var niceScaleExtent = axisHelper.niceScaleExtent;\n    // 依赖 GridModel, AxisModel 做预处理\n    require('./GridModel');\n    /**\n     * Check if the axis is used in the specified grid\n     * @inner\n     */\n    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n        return axisModel.findGridModel() === gridModel;\n    }\n    function getLabelUnionRect(axis) {\n        var axisModel = axis.model;\n        var labels = axisModel.getFormattedLabels();\n        var rect;\n        var step = 1;\n        var labelCount = labels.length;\n        if (labelCount > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.ceil(labelCount / 40);\n        }\n        for (var i = 0; i < labelCount; i += step) {\n            if (!axis.isLabelIgnored(i)) {\n                var singleRect = axisModel.getTextRect(labels[i]);\n                // FIXME consider label rotate\n                rect ? rect.union(singleRect) : rect = singleRect;\n            }\n        }\n        return rect;\n    }\n    function Grid(gridModel, ecModel, api) {\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n         * @private\n         */\n        this._coordsMap = {};\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n         * @private\n         */\n        this._coordsList = [];\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesMap = {};\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesList = [];\n        this._initCartesian(gridModel, ecModel, api);\n        this._model = gridModel;\n    }\n    var gridProto = Grid.prototype;\n    gridProto.type = 'grid';\n    gridProto.getRect = function () {\n        return this._rect;\n    };\n    gridProto.update = function (ecModel, api) {\n        var axesMap = this._axesMap;\n        this._updateScale(ecModel, this._model);\n        function ifAxisCanNotOnZero(otherAxisDim) {\n            var axes = axesMap[otherAxisDim];\n            for (var idx in axes) {\n                var axis = axes[idx];\n                if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        each(axesMap.x, function (xAxis) {\n            niceScaleExtent(xAxis, xAxis.model);\n        });\n        each(axesMap.y, function (yAxis) {\n            niceScaleExtent(yAxis, yAxis.model);\n        });\n        // Fix configuration\n        each(axesMap.x, function (xAxis) {\n            // onZero can not be enabled in these two situations\n            // 1. When any other axis is a category axis\n            // 2. When any other axis not across 0 point\n            if (ifAxisCanNotOnZero('y')) {\n                xAxis.onZero = false;\n            }\n        });\n        each(axesMap.y, function (yAxis) {\n            if (ifAxisCanNotOnZero('x')) {\n                yAxis.onZero = false;\n            }\n        });\n        // Resize again if containLabel is enabled\n        // FIXME It may cause getting wrong grid size in data processing stage\n        this.resize(this._model, api);\n    };\n    /**\n     * Resize the grid\n     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    gridProto.resize = function (gridModel, api) {\n        var gridRect = layout.getLayoutRect(gridModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        this._rect = gridRect;\n        var axesList = this._axesList;\n        adjustAxes();\n        // Minus label size\n        if (gridModel.get('containLabel')) {\n            each(axesList, function (axis) {\n                if (!axis.model.get('axisLabel.inside')) {\n                    var labelUnionRect = getLabelUnionRect(axis);\n                    if (labelUnionRect) {\n                        var dim = axis.isHorizontal() ? 'height' : 'width';\n                        var margin = axis.model.get('axisLabel.margin');\n                        gridRect[dim] -= labelUnionRect[dim] + margin;\n                        if (axis.position === 'top') {\n                            gridRect.y += labelUnionRect.height + margin;\n                        } else if (axis.position === 'left') {\n                            gridRect.x += labelUnionRect.width + margin;\n                        }\n                    }\n                }\n            });\n            adjustAxes();\n        }\n        function adjustAxes() {\n            each(axesList, function (axis) {\n                var isHorizontal = axis.isHorizontal();\n                var extent = isHorizontal ? [\n                        0,\n                        gridRect.width\n                    ] : [\n                        0,\n                        gridRect.height\n                    ];\n                var idx = axis.inverse ? 1 : 0;\n                axis.setExtent(extent[idx], extent[1 - idx]);\n                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n            });\n        }\n    };\n    /**\n     * @param {string} axisType\n     * @param {ndumber} [axisIndex]\n     */\n    gridProto.getAxis = function (axisType, axisIndex) {\n        var axesMapOnDim = this._axesMap[axisType];\n        if (axesMapOnDim != null) {\n            if (axisIndex == null) {\n                // Find first axis\n                for (var name in axesMapOnDim) {\n                    return axesMapOnDim[name];\n                }\n            }\n            return axesMapOnDim[axisIndex];\n        }\n    };\n    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n        if (xAxisIndex != null && yAxisIndex != null) {\n            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n            return this._coordsMap[key];\n        } else {\n            // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n                if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n                    return coordList[i];\n                }\n            }\n        }\n    };\n    /**\n     * Initialize cartesian coordinate systems\n     * @private\n     */\n    gridProto._initCartesian = function (gridModel, ecModel, api) {\n        var axisPositionUsed = {\n                left: false,\n                right: false,\n                top: false,\n                bottom: false\n            };\n        var axesMap = {\n                x: {},\n                y: {}\n            };\n        var axesCount = {\n                x: 0,\n                y: 0\n            };\n        /// Create axis\n        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n        if (!axesCount.x || !axesCount.y) {\n            // Roll back when there no either x or y axis\n            this._axesMap = {};\n            this._axesList = [];\n            return;\n        }\n        this._axesMap = axesMap;\n        /// Create cartesian2d\n        each(axesMap.x, function (xAxis, xAxisIndex) {\n            each(axesMap.y, function (yAxis, yAxisIndex) {\n                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n                var cartesian = new Cartesian2D(key);\n                cartesian.grid = this;\n                this._coordsMap[key] = cartesian;\n                this._coordsList.push(cartesian);\n                cartesian.addAxis(xAxis);\n                cartesian.addAxis(yAxis);\n            }, this);\n        }, this);\n        function createAxisCreator(axisType) {\n            return function (axisModel, idx) {\n                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n                    return;\n                }\n                var axisPosition = axisModel.get('position');\n                if (axisType === 'x') {\n                    // Fix position\n                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n                        // Default bottom of X\n                        axisPosition = 'bottom';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n                        }\n                    }\n                } else {\n                    // Fix position\n                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n                        // Default left of Y\n                        axisPosition = 'left';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n                        }\n                    }\n                }\n                axisPositionUsed[axisPosition] = true;\n                var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [\n                        0,\n                        0\n                    ], axisModel.get('type'), axisPosition);\n                var isCategory = axis.type === 'category';\n                axis.onBand = isCategory && axisModel.get('boundaryGap');\n                axis.inverse = axisModel.get('inverse');\n                axis.onZero = axisModel.get('axisLine.onZero');\n                // Inject axis into axisModel\n                axisModel.axis = axis;\n                // Inject axisModel into axis\n                axis.model = axisModel;\n                // Inject grid info axis\n                axis.grid = this;\n                // Index of axis, can be used as key\n                axis.index = idx;\n                this._axesList.push(axis);\n                axesMap[axisType][idx] = axis;\n                axesCount[axisType]++;\n            };\n        }\n    };\n    /**\n     * Update cartesian properties from series\n     * @param  {module:echarts/model/Option} option\n     * @private\n     */\n    gridProto._updateScale = function (ecModel, gridModel) {\n        // Reset scale\n        zrUtil.each(this._axesList, function (axis) {\n            axis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeries(function (seriesModel) {\n            if (isCartesian2D(seriesModel)) {\n                var axesModels = findAxesModels(seriesModel, ecModel);\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n                    return;\n                }\n                var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n                var data = seriesModel.getData();\n                var xAxis = cartesian.getAxis('x');\n                var yAxis = cartesian.getAxis('y');\n                if (data.type === 'list') {\n                    unionExtent(data, xAxis, seriesModel);\n                    unionExtent(data, yAxis, seriesModel);\n                }\n            }\n        }, this);\n        function unionExtent(data, axis, seriesModel) {\n            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n                axis.scale.unionExtent(data.getDataExtent(dim, axis.scale.type !== 'ordinal'));\n            });\n        }\n    };\n    /**\n     * @inner\n     */\n    function updateAxisTransfrom(axis, coordBase) {\n        var axisExtent = axis.getExtent();\n        var axisExtentSum = axisExtent[0] + axisExtent[1];\n        // Fast transform\n        axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n            return coord + coordBase;\n        } : function (coord) {\n            return axisExtentSum - coord + coordBase;\n        };\n        axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n            return coord - coordBase;\n        } : function (coord) {\n            return axisExtentSum - coord + coordBase;\n        };\n    }\n    var axesTypes = [\n            'xAxis',\n            'yAxis'\n        ];\n    /**\n     * @inner\n     */\n    function findAxesModels(seriesModel, ecModel) {\n        return zrUtil.map(axesTypes, function (axisType) {\n            var axisModel = ecModel.queryComponents({\n                    mainType: axisType,\n                    index: seriesModel.get(axisType + 'Index'),\n                    id: seriesModel.get(axisType + 'Id')\n                })[0];\n            if (true) {\n                if (!axisModel) {\n                    throw new Error(axisType + ' \"' + zrUtil.retrieve(seriesModel.get(axisType + 'Index'), seriesModel.get(axisType + 'Id'), 0) + '\" not found');\n                }\n            }\n            return axisModel;\n        });\n    }\n    /**\n     * @inner\n     */\n    function isCartesian2D(seriesModel) {\n        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n    }\n    Grid.create = function (ecModel, api) {\n        var grids = [];\n        ecModel.eachComponent('grid', function (gridModel, idx) {\n            var grid = new Grid(gridModel, ecModel, api);\n            grid.name = 'grid_' + idx;\n            grid.resize(gridModel, api);\n            gridModel.coordinateSystem = grid;\n            grids.push(grid);\n        });\n        // Inject the coordinateSystems into seriesModel\n        ecModel.eachSeries(function (seriesModel) {\n            if (!isCartesian2D(seriesModel)) {\n                return;\n            }\n            var axesModels = findAxesModels(seriesModel, ecModel);\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n            var gridModel = xAxisModel.findGridModel();\n            if (true) {\n                if (!gridModel) {\n                    throw new Error('Grid \"' + zrUtil.retrieve(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '\" not found');\n                }\n                if (xAxisModel.findGridModel() !== yAxisModel.findGridModel()) {\n                    throw new Error('xAxis and yAxis must use the same grid');\n                }\n            }\n            var grid = gridModel.coordinateSystem;\n            seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        });\n        return grids;\n    };\n    // For deciding which dimensions to use when creating list data\n    Grid.dimensions = Cartesian2D.prototype.dimensions;\n    require('../../CoordinateSystem').register('cartesian2d', Grid);\n    return Grid;\n});\ndefine('echarts/chart/bar/BarSeries', ['require', '../../model/Series', '../helper/createListFromArray'], function (require) {\n    'use strict';\n    var SeriesModel = require('../../model/Series');\n    var createListFromArray = require('../helper/createListFromArray');\n    return SeriesModel.extend({\n        type: 'series.bar',\n        dependencies: [\n            'grid',\n            'polar'\n        ],\n        getInitialData: function (option, ecModel) {\n            if (true) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'cartesian2d') {\n                    throw new Error('Bar only support cartesian2d coordinateSystem');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n        getMarkerPosition: function (value) {\n            var coordSys = this.coordinateSystem;\n            if (coordSys) {\n                // PENDING if clamp ?\n                var pt = coordSys.dataToPoint(value, true);\n                var data = this.getData();\n                var offset = data.getLayout('offset');\n                var size = data.getLayout('size');\n                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n                pt[offsetIndex] += offset + size / 2;\n                return pt;\n            }\n            return [\n                NaN,\n                NaN\n            ];\n        },\n        brushSelector: 'rect',\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n            barMinHeight: 0,\n            itemStyle: {\n                normal: {},\n                emphasis: {}\n            }\n        }\n    });\n});\ndefine('echarts/chart/bar/BarView', ['require', 'zrender/core/util', '../../util/graphic', '../../model/Model', './barItemStyle', '../../echarts'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var graphic = require('../../util/graphic');\n    zrUtil.extend(require('../../model/Model').prototype, require('./barItemStyle'));\n    function fixLayoutWithLineWidth(layout, lineWidth) {\n        var signX = layout.width > 0 ? 1 : -1;\n        var signY = layout.height > 0 ? 1 : -1;\n        // In case width or height are too small.\n        lineWidth = Math.min(lineWidth, Math.abs(layout.width), Math.abs(layout.height));\n        layout.x += signX * lineWidth / 2;\n        layout.y += signY * lineWidth / 2;\n        layout.width -= signX * lineWidth;\n        layout.height -= signY * lineWidth;\n    }\n    return require('../../echarts').extendChartView({\n        type: 'bar',\n        render: function (seriesModel, ecModel, api) {\n            var coordinateSystemType = seriesModel.get('coordinateSystem');\n            if (coordinateSystemType === 'cartesian2d') {\n                this._renderOnCartesian(seriesModel, ecModel, api);\n            }\n            return this.group;\n        },\n        _renderOnCartesian: function (seriesModel, ecModel, api) {\n            var group = this.group;\n            var data = seriesModel.getData();\n            var oldData = this._data;\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var isHorizontal = baseAxis.isHorizontal();\n            var enableAnimation = seriesModel.get('animation');\n            var barBorderWidthQuery = [\n                    'itemStyle',\n                    'normal',\n                    'barBorderWidth'\n                ];\n            function createRect(dataIndex, isUpdate) {\n                var layout = data.getItemLayout(dataIndex);\n                var lineWidth = data.getItemModel(dataIndex).get(barBorderWidthQuery) || 0;\n                fixLayoutWithLineWidth(layout, lineWidth);\n                var rect = new graphic.Rect({ shape: zrUtil.extend({}, layout) });\n                // Animation\n                if (enableAnimation) {\n                    var rectShape = rect.shape;\n                    var animateProperty = isHorizontal ? 'height' : 'width';\n                    var animateTarget = {};\n                    rectShape[animateProperty] = 0;\n                    animateTarget[animateProperty] = layout[animateProperty];\n                    graphic[isUpdate ? 'updateProps' : 'initProps'](rect, { shape: animateTarget }, seriesModel, dataIndex);\n                }\n                return rect;\n            }\n            data.diff(oldData).add(function (dataIndex) {\n                // 空数据\n                if (!data.hasValue(dataIndex)) {\n                    return;\n                }\n                var rect = createRect(dataIndex);\n                data.setItemGraphicEl(dataIndex, rect);\n                group.add(rect);\n            }).update(function (newIndex, oldIndex) {\n                var rect = oldData.getItemGraphicEl(oldIndex);\n                // 空数据\n                if (!data.hasValue(newIndex)) {\n                    group.remove(rect);\n                    return;\n                }\n                if (!rect) {\n                    rect = createRect(newIndex, true);\n                }\n                var layout = data.getItemLayout(newIndex);\n                var lineWidth = data.getItemModel(newIndex).get(barBorderWidthQuery) || 0;\n                fixLayoutWithLineWidth(layout, lineWidth);\n                graphic.updateProps(rect, { shape: layout }, seriesModel, newIndex);\n                data.setItemGraphicEl(newIndex, rect);\n                // Add back\n                group.add(rect);\n            }).remove(function (idx) {\n                var rect = oldData.getItemGraphicEl(idx);\n                if (rect) {\n                    // Not show text when animating\n                    rect.style.text = '';\n                    graphic.updateProps(rect, { shape: { width: 0 } }, seriesModel, idx, function () {\n                        group.remove(rect);\n                    });\n                }\n            }).execute();\n            this._updateStyle(seriesModel, data, isHorizontal);\n            this._data = data;\n        },\n        _updateStyle: function (seriesModel, data, isHorizontal) {\n            function setLabel(style, model, color, labelText, labelPositionOutside) {\n                graphic.setText(style, model, color);\n                style.text = labelText;\n                if (style.textPosition === 'outside') {\n                    style.textPosition = labelPositionOutside;\n                }\n            }\n            data.eachItemGraphicEl(function (rect, idx) {\n                var itemModel = data.getItemModel(idx);\n                var color = data.getItemVisual(idx, 'color');\n                var opacity = data.getItemVisual(idx, 'opacity');\n                var layout = data.getItemLayout(idx);\n                var itemStyleModel = itemModel.getModel('itemStyle.normal');\n                var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n                rect.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n                rect.useStyle(zrUtil.defaults({\n                    fill: color,\n                    opacity: opacity\n                }, itemStyleModel.getBarItemStyle()));\n                var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n                var labelModel = itemModel.getModel('label.normal');\n                var hoverLabelModel = itemModel.getModel('label.emphasis');\n                var rectStyle = rect.style;\n                if (labelModel.get('show')) {\n                    setLabel(rectStyle, labelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'normal'), seriesModel.getRawValue(idx)), labelPositionOutside);\n                } else {\n                    rectStyle.text = '';\n                }\n                if (hoverLabelModel.get('show')) {\n                    setLabel(hoverStyle, hoverLabelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'emphasis'), seriesModel.getRawValue(idx)), labelPositionOutside);\n                } else {\n                    hoverStyle.text = '';\n                }\n                graphic.setHoverStyle(rect, hoverStyle);\n            });\n        },\n        remove: function (ecModel, api) {\n            var group = this.group;\n            if (ecModel.get('animation')) {\n                if (this._data) {\n                    this._data.eachItemGraphicEl(function (el) {\n                        // Not show text when animating\n                        el.style.text = '';\n                        graphic.updateProps(el, { shape: { width: 0 } }, ecModel, el.dataIndex, function () {\n                            group.remove(el);\n                        });\n                    });\n                }\n            } else {\n                group.removeAll();\n            }\n        }\n    });\n});\ndefine('echarts/layout/barGrid', ['require', 'zrender/core/util', '../util/number'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var numberUtil = require('../util/number');\n    var parsePercent = numberUtil.parsePercent;\n    function getSeriesStackId(seriesModel) {\n        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n    }\n    function getAxisKey(axis) {\n        return axis.dim + axis.index;\n    }\n    function calBarWidthAndOffset(barSeries, api) {\n        // Columns info on each category axis. Key is cartesian name\n        var columnsMap = {};\n        zrUtil.each(barSeries, function (seriesModel, idx) {\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var axisExtent = baseAxis.getExtent();\n            var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n                    bandWidth: bandWidth,\n                    remainedWidth: bandWidth,\n                    autoWidthCount: 0,\n                    categoryGap: '20%',\n                    gap: '30%',\n                    stacks: {}\n                };\n            var stacks = columnsOnAxis.stacks;\n            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n            var stackId = getSeriesStackId(seriesModel);\n            if (!stacks[stackId]) {\n                columnsOnAxis.autoWidthCount++;\n            }\n            stacks[stackId] = stacks[stackId] || {\n                width: 0,\n                maxWidth: 0\n            };\n            var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n            var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n            var barGap = seriesModel.get('barGap');\n            var barCategoryGap = seriesModel.get('barCategoryGap');\n            // TODO\n            if (barWidth && !stacks[stackId].width) {\n                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n                stacks[stackId].width = barWidth;\n                columnsOnAxis.remainedWidth -= barWidth;\n            }\n            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n            barGap != null && (columnsOnAxis.gap = barGap);\n            barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n        });\n        var result = {};\n        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n            result[coordSysName] = {};\n            var stacks = columnsOnAxis.stacks;\n            var bandWidth = columnsOnAxis.bandWidth;\n            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n            var remainedWidth = columnsOnAxis.remainedWidth;\n            var autoWidthCount = columnsOnAxis.autoWidthCount;\n            var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n            // Find if any auto calculated bar exceeded maxBarWidth\n            zrUtil.each(stacks, function (column, stack) {\n                var maxWidth = column.maxWidth;\n                if (!column.width && maxWidth && maxWidth < autoWidth) {\n                    maxWidth = Math.min(maxWidth, remainedWidth);\n                    remainedWidth -= maxWidth;\n                    column.width = maxWidth;\n                    autoWidthCount--;\n                }\n            });\n            // Recalculate width again\n            autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n            var widthSum = 0;\n            var lastColumn;\n            zrUtil.each(stacks, function (column, idx) {\n                if (!column.width) {\n                    column.width = autoWidth;\n                }\n                lastColumn = column;\n                widthSum += column.width * (1 + barGapPercent);\n            });\n            if (lastColumn) {\n                widthSum -= lastColumn.width * barGapPercent;\n            }\n            var offset = -widthSum / 2;\n            zrUtil.each(stacks, function (column, stackId) {\n                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n                    offset: offset,\n                    width: column.width\n                };\n                offset += column.width * (1 + barGapPercent);\n            });\n        });\n        return result;\n    }\n    /**\n     * @param {string} seriesType\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function barLayoutGrid(seriesType, ecModel, api) {\n        var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n                return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n            }));\n        var lastStackCoords = {};\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var stackId = getSeriesStackId(seriesModel);\n            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n            var columnOffset = columnLayoutInfo.offset;\n            var columnWidth = columnLayoutInfo.width;\n            var valueAxis = cartesian.getOtherAxis(baseAxis);\n            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n            var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];\n            var coords = cartesian.dataToPoints(data, true);\n            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n            data.setLayout({\n                offset: columnOffset,\n                size: columnWidth\n            });\n            data.each(valueAxis.dim, function (value, idx) {\n                // 空数据\n                if (isNaN(value)) {\n                    return;\n                }\n                if (!lastStackCoords[stackId][idx]) {\n                    lastStackCoords[stackId][idx] = {\n                        p: valueAxisStart,\n                        n: valueAxisStart\n                    };\n                }\n                var sign = value >= 0 ? 'p' : 'n';\n                var coord = coords[idx];\n                var lastCoord = lastStackCoords[stackId][idx][sign];\n                var x, y, width, height;\n                if (valueAxis.isHorizontal()) {\n                    x = lastCoord;\n                    y = coord[1] + columnOffset;\n                    width = coord[0] - lastCoord;\n                    height = columnWidth;\n                    if (Math.abs(width) < barMinHeight) {\n                        width = (width < 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += width;\n                } else {\n                    x = coord[0] + columnOffset;\n                    y = lastCoord;\n                    width = columnWidth;\n                    height = coord[1] - lastCoord;\n                    if (Math.abs(height) < barMinHeight) {\n                        // Include zero to has a positive bar\n                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += height;\n                }\n                data.setItemLayout(idx, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }, true);\n        }, this);\n    }\n    return barLayoutGrid;\n});\ndefine('echarts/util/graphic', ['require', 'zrender/core/util', 'zrender/tool/path', 'zrender/graphic/Path', 'zrender/tool/color', 'zrender/core/matrix', 'zrender/core/vector', 'zrender/graphic/Gradient', 'zrender/container/Group', 'zrender/graphic/Image', 'zrender/graphic/Text', 'zrender/graphic/shape/Circle', 'zrender/graphic/shape/Sector', 'zrender/graphic/shape/Ring', 'zrender/graphic/shape/Polygon', 'zrender/graphic/shape/Polyline', 'zrender/graphic/shape/Rect', 'zrender/graphic/shape/Line', 'zrender/graphic/shape/BezierCurve', 'zrender/graphic/shape/Arc', 'zrender/graphic/CompoundPath', 'zrender/graphic/LinearGradient', 'zrender/graphic/RadialGradient', 'zrender/core/BoundingRect'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var pathTool = require('zrender/tool/path');\n    var round = Math.round;\n    var Path = require('zrender/graphic/Path');\n    var colorTool = require('zrender/tool/color');\n    var matrix = require('zrender/core/matrix');\n    var vector = require('zrender/core/vector');\n    var Gradient = require('zrender/graphic/Gradient');\n    var graphic = {};\n    graphic.Group = require('zrender/container/Group');\n    graphic.Image = require('zrender/graphic/Image');\n    graphic.Text = require('zrender/graphic/Text');\n    graphic.Circle = require('zrender/graphic/shape/Circle');\n    graphic.Sector = require('zrender/graphic/shape/Sector');\n    graphic.Ring = require('zrender/graphic/shape/Ring');\n    graphic.Polygon = require('zrender/graphic/shape/Polygon');\n    graphic.Polyline = require('zrender/graphic/shape/Polyline');\n    graphic.Rect = require('zrender/graphic/shape/Rect');\n    graphic.Line = require('zrender/graphic/shape/Line');\n    graphic.BezierCurve = require('zrender/graphic/shape/BezierCurve');\n    graphic.Arc = require('zrender/graphic/shape/Arc');\n    graphic.CompoundPath = require('zrender/graphic/CompoundPath');\n    graphic.LinearGradient = require('zrender/graphic/LinearGradient');\n    graphic.RadialGradient = require('zrender/graphic/RadialGradient');\n    graphic.BoundingRect = require('zrender/core/BoundingRect');\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                } else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n            this.resizePath(path, rect);\n        }\n        return path;\n    };\n    graphic.mergePath = pathTool.mergePath, graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n        var pathRect = path.getBoundingRect();\n        var m = pathRect.calculateTransform(rect);\n        path.applyTransform(m);\n    };\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x, originWidth === 0 ? 0 : 1);\n        shape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y, originHeight === 0 ? 0 : 1);\n        return param;\n    };\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                if (hoverStyle.hasOwnProperty(name)) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n            el.__normalStl = normalStyle;\n            el.__hoverStlDirty = false;\n        }\n    }\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n        cacheElementStl(el);\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        } else {\n            el.setStyle(el.__hoverStl);\n            el.z2 += 1;\n        }\n        el.__isHover = true;\n    }\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        } else {\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n        el.__isHover = false;\n    }\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group' ? el.traverse(function (child) {\n            if (child.type !== 'group') {\n                doSingleEnterHover(child);\n            }\n        }) : doSingleEnterHover(el);\n    }\n    function doLeaveHover(el) {\n        el.type === 'group' ? el.traverse(function (child) {\n            if (child.type !== 'group') {\n                doSingleLeaveHover(child);\n            }\n        }) : doSingleLeaveHover(el);\n    }\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n    /**\n     * @inner\n     */\n    function onElementMouseOver() {\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n    /**\n     * @inner\n     */\n    function onElementMouseOut() {\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n    /**\n     * Set hover style of element\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     */\n    graphic.setHoverStyle = function (el, hoverStyle) {\n        el.type === 'group' ? el.traverse(function (child) {\n            if (child.type !== 'group') {\n                setElementHoverStl(child, hoverStyle);\n            }\n        }) : setElementHoverStl(el, hoverStyle);\n        // Remove previous bound handlers\n        el.on('mouseover', onElementMouseOver).on('mouseout', onElementMouseOut);\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis).on('normal', leaveEmphasis);\n    };\n    /**\n     * Set text option in the style\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string} color\n     */\n    graphic.setText = function (textStyle, labelModel, color) {\n        var labelPosition = labelModel.getShallow('position') || 'inside';\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n        var textStyleModel = labelModel.getModel('textStyle');\n        zrUtil.extend(textStyle, {\n            textDistance: labelModel.getShallow('distance') || 5,\n            textFont: textStyleModel.getFont(),\n            textPosition: labelPosition,\n            textFill: textStyleModel.getTextColor() || labelColor\n        });\n    };\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        var animationEnabled = animatableModel && (animatableModel.ifEnableAnimation ? animatableModel.ifEnableAnimation() : animatableModel.getShallow('animation'));\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel && animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel && animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel && animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(dataIndex);\n            }\n            duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb) : (el.attr(props), cb && cb());\n        } else {\n            el.attr(props);\n            cb && cb();\n        }\n    }\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n        return mat;\n    };\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} vertex [x, y]\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (vertex, transform, invert) {\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], vertex, transform);\n    };\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);\n        var vertex = [\n                direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n                direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n            ];\n        vertex = graphic.applyTransform(vertex, transform, invert);\n        return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n    };\n    /**\n     * Apply group transition animation from g1 to g2\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                    position: vector.clone(el.position),\n                    rotation: el.rotation\n                };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }    // else {\n                     //     if (el.previousProps) {\n                     //         graphic.updateProps\n                     //     }\n                     // }\n            }\n        });\n    };\n    return graphic;\n});\ndefine('echarts/component/axis', ['require', '../coord/cartesian/AxisModel', './axis/AxisView'], function (require) {\n    'use strict';\n    require('../coord/cartesian/AxisModel');\n    require('./axis/AxisView');\n});\ndefine('echarts/util/layout', ['require', 'zrender/core/util', 'zrender/core/BoundingRect', './number', './format'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var BoundingRect = require('zrender/core/BoundingRect');\n    var numberUtil = require('./number');\n    var formatUtil = require('./format');\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n    var layout = {};\n    var LOCATION_PARAMS = [\n            'left',\n            'right',\n            'top',\n            'bottom',\n            'width',\n            'height'\n        ];\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                } else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            } else {\n                var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                } else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n            if (child.newline) {\n                return;\n            }\n            position[0] = x;\n            position[1] = y;\n            orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n        });\n    }\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n        margin = formatUtil.normalizeCssArray(margin || 0);\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (positionInfo, containerRect, margin) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n        // If width and height are not given\n        // 1. Graph should not exceeds the container\n        // 2. Aspect must be keeped\n        // 3. Graph should take the space as more as possible\n        if (isNaN(width) && isNaN(height)) {\n            if (aspect > containerWidth / containerHeight) {\n                width = containerWidth * 0.8;\n            } else {\n                height = containerHeight * 0.8;\n            }\n        }\n        if (aspect != null) {\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n        case 'center':\n            left = containerWidth / 2 - width / 2 - margin[3];\n            break;\n        case 'right':\n            left = containerWidth - width - horizontalMargin;\n            break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n        case 'middle':\n        case 'center':\n            top = containerHeight / 2 - height / 2 - margin[0];\n            break;\n        case 'bottom':\n            top = containerHeight - height - verticalMargin;\n            break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - top - (bottom || 0);\n        }\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n    /**\n     * Position group of component in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     */\n    layout.positionGroup = function (group, positionInfo, containerRect, margin) {\n        var groupRect = group.getBoundingRect();\n        positionInfo = zrUtil.extend(zrUtil.clone(positionInfo), {\n            width: groupRect.width,\n            height: groupRect.height\n        });\n        positionInfo = layout.getLayoutRect(positionInfo, containerRect, margin);\n        group.attr('position', [\n            positionInfo.x - groupRect.x,\n            positionInfo.y - groupRect.y\n        ]);\n    };\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n        var hNames = [\n                'width',\n                'left',\n                'right'\n            ];\n        // Order by priority.\n        var vNames = [\n                'height',\n                'top',\n                'bottom'\n            ];\n        // Order by priority.\n        var hResult = merge(hNames);\n        var vResult = merge(vNames);\n        copy(hNames, targetOption, hResult);\n        copy(vNames, targetOption, vResult);\n        function merge(names) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = opt.ignoreSize ? 1 : 2;\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }    // Case: newOption: {width: ..., right: ...},\n                 // Than we can make sure user only want those two, and ignore\n                 // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            } else {\n                // Chose another param from targetOption by priority.\n                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n    return layout;\n});\ndefine('echarts/util/number', ['require'], function (require) {\n    var number = {};\n    var RADIAN_EPSILON = 0.0001;\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n        if (subDomain === 0) {\n            return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;\n        }\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                } else if (val >= domain[1]) {\n                    return range[1];\n                }\n            } else {\n                if (val >= domain[0]) {\n                    return range[0];\n                } else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        } else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function (percent, all) {\n        switch (percent) {\n        case 'center':\n        case 'middle':\n            percent = '50%';\n            break;\n        case 'left':\n        case 'top':\n            percent = '0%';\n            break;\n        case 'right':\n        case 'bottom':\n            percent = '100%';\n            break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n            return parseFloat(percent);\n        }\n        return percent == null ? NaN : +percent;\n    };\n    /**\n     * Fix rounding error of float numbers\n     * @param {number} x\n     * @return {number}\n     */\n    number.round = function (x, precision) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // PENDING\n        return +(+x).toFixed(precision);\n    };\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n        var dotIndex = str.indexOf('.');\n        if (dotIndex < 0) {\n            return 0;\n        }\n        return str.length - 1 - dotIndex;\n    };\n    /**\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number}  precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        return Math.max(-dataQuantity + sizeQuantity, 0);\n    };\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n    /**\n     * @param {string|Date|number} value\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        } else if (typeof value === 'string') {\n            // Treat as ISO format. See issue #3623\n            var ret = new Date(value);\n            if (isNaN(+ret)) {\n                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local\n                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));\n            }\n            return ret;\n        }\n        return new Date(Math.round(value));\n    };\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));\n    };\n    // \"Nice Numbers for Graph Labels\" of Graphic Gems\n    /**\n     * find a “nice” number approximately equal to x. Round the number if round = true, take ceiling if round = false\n     * The primary observation is that the “nicest” numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     * @param  {number} val\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exp10 = number.quantity(val);\n        var f = val / exp10;\n        // between 1 and 10\n        var nf;\n        if (round) {\n            if (f < 1.5) {\n                nf = 1;\n            } else if (f < 2.5) {\n                nf = 2;\n            } else if (f < 4) {\n                nf = 3;\n            } else if (f < 7) {\n                nf = 5;\n            } else {\n                nf = 10;\n            }\n        } else {\n            if (f < 1) {\n                nf = 1;\n            } else if (f < 2) {\n                nf = 2;\n            } else if (f < 3) {\n                nf = 3;\n            } else if (f < 5) {\n                nf = 5;\n            } else {\n                nf = 10;\n            }\n        }\n        return nf * exp10;\n    };\n    return number;\n});\ndefine('echarts/util/format', ['require', 'zrender/core/util', './number', 'zrender/contain/text'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var numberUtil = require('./number');\n    var textContain = require('zrender/contain/text');\n    var formatUtil = {};\n    /**\n     * 每三位默认加,格式化\n     * @type {string|number} x\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g, '$1,') + (x.length > 1 ? '.' + x[1] : '');\n    };\n    /**\n     * @param {string} str\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str) {\n        return str.toLowerCase().replace(/-(.)/g, function (match, group1) {\n            return group1.toUpperCase();\n        });\n    };\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     */\n    formatUtil.normalizeCssArray = function (val) {\n        var len = val.length;\n        if (typeof val === 'number') {\n            return [\n                val,\n                val,\n                val,\n                val\n            ];\n        } else if (len === 2) {\n            // vertical | horizontal\n            return [\n                val[0],\n                val[1],\n                val[0],\n                val[1]\n            ];\n        } else if (len === 3) {\n            // top | horizontal | bottom\n            return [\n                val[0],\n                val[1],\n                val[2],\n                val[1]\n            ];\n        }\n        return val;\n    };\n    formatUtil.encodeHTML = function (source) {\n        return String(source).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;');\n    };\n    var TPL_VAR_ALIAS = [\n            'a',\n            'b',\n            'c',\n            'd',\n            'e',\n            'f',\n            'g'\n        ];\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n    /**\n     * Template formatter\n     * @param  {string} tpl\n     * @param  {Array.<Object>|Object} paramsList\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), paramsList[seriesIdx][$vars[k]]);\n            }\n        }\n        return tpl;\n    };\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? '0' + str : str;\n    };\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value) {\n        if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {\n            tpl = 'MM-dd\\nyyyy';\n        }\n        var date = numberUtil.parseDate(value);\n        var y = date.getFullYear();\n        var M = date.getMonth() + 1;\n        var d = date.getDate();\n        var h = date.getHours();\n        var m = date.getMinutes();\n        var s = date.getSeconds();\n        tpl = tpl.replace('MM', s2d(M)).toLowerCase().replace('yyyy', y).replace('yy', y % 100).replace('dd', s2d(d)).replace('d', d).replace('hh', s2d(h)).replace('h', h).replace('mm', s2d(m)).replace('m', m).replace('ss', s2d(s)).replace('s', s);\n        return tpl;\n    };\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n    formatUtil.truncateText = textContain.truncateText;\n    return formatUtil;\n});\ndefine('echarts/scale/Interval', ['require', '../util/number', '../util/format', './Scale'], function (require) {\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var Scale = require('./Scale');\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n            type: 'interval',\n            _interval: 0,\n            setExtent: function (start, end) {\n                var thisExtent = this._extent;\n                //start,end may be a Number like '25',so...\n                if (!isNaN(start)) {\n                    thisExtent[0] = parseFloat(start);\n                }\n                if (!isNaN(end)) {\n                    thisExtent[1] = parseFloat(end);\n                }\n            },\n            unionExtent: function (other) {\n                var extent = this._extent;\n                other[0] < extent[0] && (extent[0] = other[0]);\n                other[1] > extent[1] && (extent[1] = other[1]);\n                // unionExtent may called by it's sub classes\n                IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n            },\n            getInterval: function () {\n                if (!this._interval) {\n                    this.niceTicks();\n                }\n                return this._interval;\n            },\n            setInterval: function (interval) {\n                this._interval = interval;\n                // Dropped auto calculated niceExtent and use user setted extent\n                // We assume user wan't to set both interval, min, max to get a better result\n                this._niceExtent = this._extent.slice();\n            },\n            getTicks: function () {\n                if (!this._interval) {\n                    this.niceTicks();\n                }\n                var interval = this._interval;\n                var extent = this._extent;\n                var ticks = [];\n                // Consider this case: using dataZoom toolbox, zoom and zoom.\n                var safeLimit = 10000;\n                if (interval) {\n                    var niceExtent = this._niceExtent;\n                    var precision = getPrecisionSafe(interval) + 2;\n                    if (extent[0] < niceExtent[0]) {\n                        ticks.push(extent[0]);\n                    }\n                    var tick = niceExtent[0];\n                    while (tick <= niceExtent[1]) {\n                        ticks.push(tick);\n                        // Avoid rounding error\n                        tick = roundingErrorFix(tick + interval, precision);\n                        if (ticks.length > safeLimit) {\n                            return [];\n                        }\n                    }\n                    if (extent[1] > niceExtent[1]) {\n                        ticks.push(extent[1]);\n                    }\n                }\n                return ticks;\n            },\n            getTicksLabels: function () {\n                var labels = [];\n                var ticks = this.getTicks();\n                for (var i = 0; i < ticks.length; i++) {\n                    labels.push(this.getLabel(ticks[i]));\n                }\n                return labels;\n            },\n            getLabel: function (data) {\n                return formatUtil.addCommas(data);\n            },\n            niceTicks: function (splitNumber) {\n                splitNumber = splitNumber || 5;\n                var extent = this._extent;\n                var span = extent[1] - extent[0];\n                if (!isFinite(span)) {\n                    return;\n                }\n                // User may set axis min 0 and data are all negative\n                // FIXME If it needs to reverse ?\n                if (span < 0) {\n                    span = -span;\n                    extent.reverse();\n                }\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceSpan = numberUtil.nice(span, false);\n                var step = roundingErrorFix(numberUtil.nice(span / splitNumber, true), Math.max(getPrecisionSafe(extent[0]), getPrecisionSafe(extent[1])) + 2);\n                var precision = getPrecisionSafe(step) + 2;\n                // Niced extent inside original extent\n                var niceExtent = [\n                        roundingErrorFix(mathCeil(extent[0] / step) * step, precision),\n                        roundingErrorFix(mathFloor(extent[1] / step) * step, precision)\n                    ];\n                this._interval = step;\n                this._niceExtent = niceExtent;\n            },\n            niceExtent: function (splitNumber, fixMin, fixMax) {\n                var extent = this._extent;\n                // If extent start and end are same, expand them\n                if (extent[0] === extent[1]) {\n                    if (extent[0] !== 0) {\n                        // Expand extent\n                        var expandSize = extent[0];\n                        // In the fowllowing case\n                        //      Axis has been fixed max 100\n                        //      Plus data are all 100 and axis extent are [100, 100].\n                        // Extend to the both side will cause expanded max is larger than fixed max.\n                        // So only expand to the smaller side.\n                        if (!fixMax) {\n                            extent[1] += expandSize / 2;\n                            extent[0] -= expandSize / 2;\n                        } else {\n                            extent[0] -= expandSize / 2;\n                        }\n                    } else {\n                        extent[1] = 1;\n                    }\n                }\n                var span = extent[1] - extent[0];\n                // If there are no data and extent are [Infinity, -Infinity]\n                if (!isFinite(span)) {\n                    extent[0] = 0;\n                    extent[1] = 1;\n                }\n                this.niceTicks(splitNumber);\n                // var extent = this._extent;\n                var interval = this._interval;\n                if (!fixMin) {\n                    extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);\n                }\n                if (!fixMax) {\n                    extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);\n                }\n            }\n        });\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n    return IntervalScale;\n});\ndefine('zrender/core/env', [], function () {\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            canvasSupported: true\n        };\n    } else {\n        env = detect(navigator.userAgent);\n    }\n    return env;\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/) || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/);\n        // IE 12 and 12+\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox)\n            browser.firefox = true, browser.version = firefox[1];\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            canvasSupported: document.createElement('canvas').getContext ? true : false,\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            pointerEventsSupported: 'onpointerdown' in window && (browser.edge || browser.ie && browser.version >= 10)\n        };\n    }\n});\ndefine('echarts/ExtensionAPI', ['require', 'zrender/core/util'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var echartsAPIList = [\n            'getDom',\n            'getZr',\n            'getWidth',\n            'getHeight',\n            'dispatchAction',\n            'isDisposed',\n            'on',\n            'off',\n            'getDataURL',\n            'getConnectedDataURL',\n            'getModel',\n            'getOption'\n        ];\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n    return ExtensionAPI;\n});\ndefine('echarts/model/Global', ['require', 'zrender/core/util', '../util/model', './Model', './Component', './globalDefault', './mixin/colorPalette'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../util/model');\n    var Model = require('./Model');\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n    var ComponentModel = require('./Component');\n    var globalDefault = require('./globalDefault');\n    var OPTION_INNER_KEY = '\u0000_ec_inner';\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n            constructor: GlobalModel,\n            init: function (option, parentModel, theme, optionManager) {\n                theme = theme || {};\n                this.option = null;\n                // Mark as not initialized.\n                /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n                this._theme = new Model(theme);\n                /**\n             * @type {module:echarts/model/OptionManager}\n             */\n                this._optionManager = optionManager;\n            },\n            setOption: function (option, optionPreprocessorFuncs) {\n                zrUtil.assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');\n                this._optionManager.setOption(option, optionPreprocessorFuncs);\n                this.resetOption();\n            },\n            resetOption: function (type) {\n                var optionChanged = false;\n                var optionManager = this._optionManager;\n                if (!type || type === 'recreate') {\n                    var baseOption = optionManager.mountOption(type === 'recreate');\n                    if (!this.option || type === 'recreate') {\n                        initBase.call(this, baseOption);\n                    } else {\n                        this.restoreData();\n                        this.mergeOption(baseOption);\n                    }\n                    optionChanged = true;\n                }\n                if (type === 'timeline' || type === 'media') {\n                    this.restoreData();\n                }\n                if (!type || type === 'recreate' || type === 'timeline') {\n                    var timelineOption = optionManager.getTimelineOption(this);\n                    timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n                }\n                if (!type || type === 'recreate' || type === 'media') {\n                    var mediaOptions = optionManager.getMediaOption(this, this._api);\n                    if (mediaOptions.length) {\n                        each(mediaOptions, function (mediaOption) {\n                            this.mergeOption(mediaOption, optionChanged = true);\n                        }, this);\n                    }\n                }\n                return optionChanged;\n            },\n            mergeOption: function (newOption) {\n                var option = this.option;\n                var componentsMap = this._componentsMap;\n                var newCptTypes = [];\n                // 如果不存在对应的 component model 则直接 merge\n                each(newOption, function (componentOption, mainType) {\n                    if (componentOption == null) {\n                        return;\n                    }\n                    if (!ComponentModel.hasClass(mainType)) {\n                        option[mainType] = option[mainType] == null ? zrUtil.clone(componentOption) : zrUtil.merge(option[mainType], componentOption, true);\n                    } else {\n                        newCptTypes.push(mainType);\n                    }\n                });\n                // FIXME OPTION 同步是否要改回原来的\n                ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n                this._seriesIndices = this._seriesIndices || [];\n                function visitComponent(mainType, dependencies) {\n                    var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n                    var mapResult = modelUtil.mappingToExists(componentsMap[mainType], newCptOptionList);\n                    makeKeyInfo(mainType, mapResult);\n                    var dependentModels = getComponentsByTypes(componentsMap, dependencies);\n                    option[mainType] = [];\n                    componentsMap[mainType] = [];\n                    each(mapResult, function (resultItem, index) {\n                        var componentModel = resultItem.exist;\n                        var newCptOption = resultItem.option;\n                        zrUtil.assert(isObject(newCptOption) || componentModel, 'Empty component definition');\n                        // Consider where is no new option and should be merged using {},\n                        // see removeEdgeAndAdd in topologicalTravel and\n                        // ComponentModel.getAllClassMainTypes.\n                        if (!newCptOption) {\n                            componentModel.mergeOption({}, this);\n                            componentModel.optionUpdated({}, false);\n                        } else {\n                            var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\n                            if (componentModel && componentModel instanceof ComponentModelClass) {\n                                componentModel.mergeOption(newCptOption, this);\n                                componentModel.optionUpdated(newCptOption, false);\n                            } else {\n                                // PENDING Global as parent ?\n                                var extraOpt = zrUtil.extend({\n                                        dependentModels: dependentModels,\n                                        componentIndex: index\n                                    }, resultItem.keyInfo);\n                                componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);\n                                componentModel.init(newCptOption, this, this, extraOpt);\n                                // Call optionUpdated after init.\n                                // newCptOption has been used as componentModel.option\n                                // and may be merged with theme and default, so pass null\n                                // to avoid confusion.\n                                componentModel.optionUpdated(null, true);\n                            }\n                        }\n                        componentsMap[mainType][index] = componentModel;\n                        option[mainType][index] = componentModel.option;\n                    }, this);\n                    // Backup series for filtering.\n                    if (mainType === 'series') {\n                        this._seriesIndices = createSeriesIndices(componentsMap.series);\n                    }\n                }\n            },\n            getOption: function () {\n                var option = zrUtil.clone(this.option);\n                each(option, function (opts, mainType) {\n                    if (ComponentModel.hasClass(mainType)) {\n                        var opts = modelUtil.normalizeToArray(opts);\n                        for (var i = opts.length - 1; i >= 0; i--) {\n                            // Remove options with inner id.\n                            if (modelUtil.isIdInner(opts[i])) {\n                                opts.splice(i, 1);\n                            }\n                        }\n                        option[mainType] = opts;\n                    }\n                });\n                delete option[OPTION_INNER_KEY];\n                return option;\n            },\n            getTheme: function () {\n                return this._theme;\n            },\n            getComponent: function (mainType, idx) {\n                var list = this._componentsMap[mainType];\n                if (list) {\n                    return list[idx || 0];\n                }\n            },\n            queryComponents: function (condition) {\n                var mainType = condition.mainType;\n                if (!mainType) {\n                    return [];\n                }\n                var index = condition.index;\n                var id = condition.id;\n                var name = condition.name;\n                var cpts = this._componentsMap[mainType];\n                if (!cpts || !cpts.length) {\n                    return [];\n                }\n                var result;\n                if (index != null) {\n                    if (!isArray(index)) {\n                        index = [index];\n                    }\n                    result = filter(map(index, function (idx) {\n                        return cpts[idx];\n                    }), function (val) {\n                        return !!val;\n                    });\n                } else if (id != null) {\n                    var isIdArray = isArray(id);\n                    result = filter(cpts, function (cpt) {\n                        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;\n                    });\n                } else if (name != null) {\n                    var isNameArray = isArray(name);\n                    result = filter(cpts, function (cpt) {\n                        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;\n                    });\n                } else {\n                    // Return all components with mainType\n                    result = cpts;\n                }\n                return filterBySubType(result, condition);\n            },\n            findComponents: function (condition) {\n                var query = condition.query;\n                var mainType = condition.mainType;\n                var queryCond = getQueryCond(query);\n                var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap[mainType];\n                return doFilter(filterBySubType(result, condition));\n                function getQueryCond(q) {\n                    var indexAttr = mainType + 'Index';\n                    var idAttr = mainType + 'Id';\n                    var nameAttr = mainType + 'Name';\n                    return q && (q.hasOwnProperty(indexAttr) || q.hasOwnProperty(idAttr) || q.hasOwnProperty(nameAttr)) ? {\n                        mainType: mainType,\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    } : null;\n                }\n                function doFilter(res) {\n                    return condition.filter ? filter(res, condition.filter) : res;\n                }\n            },\n            eachComponent: function (mainType, cb, context) {\n                var componentsMap = this._componentsMap;\n                if (typeof mainType === 'function') {\n                    context = cb;\n                    cb = mainType;\n                    each(componentsMap, function (components, componentType) {\n                        each(components, function (component, index) {\n                            cb.call(context, componentType, component, index);\n                        });\n                    });\n                } else if (zrUtil.isString(mainType)) {\n                    each(componentsMap[mainType], cb, context);\n                } else if (isObject(mainType)) {\n                    var queryResult = this.findComponents(mainType);\n                    each(queryResult, cb, context);\n                }\n            },\n            getSeriesByName: function (name) {\n                var series = this._componentsMap.series;\n                return filter(series, function (oneSeries) {\n                    return oneSeries.name === name;\n                });\n            },\n            getSeriesByIndex: function (seriesIndex) {\n                return this._componentsMap.series[seriesIndex];\n            },\n            getSeriesByType: function (subType) {\n                var series = this._componentsMap.series;\n                return filter(series, function (oneSeries) {\n                    return oneSeries.subType === subType;\n                });\n            },\n            getSeries: function () {\n                return this._componentsMap.series.slice();\n            },\n            eachSeries: function (cb, context) {\n                assertSeriesInitialized(this);\n                each(this._seriesIndices, function (rawSeriesIndex) {\n                    var series = this._componentsMap.series[rawSeriesIndex];\n                    cb.call(context, series, rawSeriesIndex);\n                }, this);\n            },\n            eachRawSeries: function (cb, context) {\n                each(this._componentsMap.series, cb, context);\n            },\n            eachSeriesByType: function (subType, cb, context) {\n                assertSeriesInitialized(this);\n                each(this._seriesIndices, function (rawSeriesIndex) {\n                    var series = this._componentsMap.series[rawSeriesIndex];\n                    if (series.subType === subType) {\n                        cb.call(context, series, rawSeriesIndex);\n                    }\n                }, this);\n            },\n            eachRawSeriesByType: function (subType, cb, context) {\n                return each(this.getSeriesByType(subType), cb, context);\n            },\n            isSeriesFiltered: function (seriesModel) {\n                assertSeriesInitialized(this);\n                return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n            },\n            filterSeries: function (cb, context) {\n                assertSeriesInitialized(this);\n                var filteredSeries = filter(this._componentsMap.series, cb, context);\n                this._seriesIndices = createSeriesIndices(filteredSeries);\n            },\n            restoreData: function () {\n                var componentsMap = this._componentsMap;\n                this._seriesIndices = createSeriesIndices(componentsMap.series);\n                var componentTypes = [];\n                each(componentsMap, function (components, componentType) {\n                    componentTypes.push(componentType);\n                });\n                ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {\n                    each(componentsMap[componentType], function (component) {\n                        component.restoreData();\n                    });\n                });\n            }\n        });\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        for (var name in theme) {\n            // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理\n            if (!ComponentModel.hasClass(name)) {\n                if (typeof theme[name] === 'object') {\n                    option[name] = !option[name] ? zrUtil.clone(theme[name]) : zrUtil.merge(option[name], theme[name], false);\n                } else {\n                    if (option[name] == null) {\n                        option[name] = theme[name];\n                    }\n                }\n            }\n        }\n    }\n    function initBase(baseOption) {\n        baseOption = baseOption;\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n        /**\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = {};\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n        mergeTheme(baseOption, this._theme.option);\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n        this.mergeOption(baseOption);\n    }\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap[type] || []).slice();\n        });\n        return ret;\n    }\n    /**\n     * @inner\n     */\n    function makeKeyInfo(mainType, mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n        // Ensure that each id is distinct.\n        var idMap = {};\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && (idMap[existCpt.id] = item);\n        });\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n            zrUtil.assert(!opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item, 'id duplicates: ' + (opt && opt.id));\n            opt && opt.id != null && (idMap[opt.id] = item);\n            // Complete subType\n            if (isObject(opt)) {\n                var subType = determineSubType(mainType, opt, item.exist);\n                item.keyInfo = {\n                    mainType: mainType,\n                    subType: subType\n                };\n            }\n        });\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n            if (!isObject(opt)) {\n                return;\n            }\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name : '\u0000-';\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            } else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            } else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\u0000' + keyInfo.name + '\u0000' + idNum++;\n                } while (idMap[keyInfo.id]);\n            }\n            idMap[keyInfo.id] = item;\n        });\n    }\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType : ComponentModel.determineSubType(mainType, newCptOption);\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {\n            return cpt.subType === condition.subType;\n        }) : components;\n    }\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (true) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Series has not been initialized yet.');\n            }\n        }\n    }\n    zrUtil.mixin(GlobalModel, require('./mixin/colorPalette'));\n    return GlobalModel;\n});\ndefine('echarts/model/OptionManager', ['require', 'zrender/core/util', '../util/model', './Component'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n    var QUERY_REG = /^(min|max)?(.+)$/;\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n    OptionManager.prototype = {\n        constructor: OptionManager,\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n            // FIXME\n            // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);\n            this._newBaseOption = newParsedOption.baseOption;\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            } else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n            // TODO\n            // 如果没有reset功能则不clone。\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n            return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);\n        },\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);\n                }\n            }\n            return option;\n        },\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n            // FIXME\n            // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\n                });\n            }\n            // Otherwise return nothing.\n            this._currentMediaIndices = indices;\n            return result;\n        }\n    };\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    } else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n        // Preprocess.\n        each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {\n            return media.option;\n        })), function (option) {\n            each(optionPreprocessorFuncs, function (preProcess) {\n                preProcess(option, isNew);\n            });\n        });\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n                width: ecWidth,\n                height: ecHeight,\n                aspectratio: ecWidth / ecHeight\n            };\n        var applicatable = true;\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n        return applicatable;\n    }\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        } else if (operator === 'max') {\n            return real <= expect;\n        } else {\n            // Equals\n            return real === expect;\n        }\n    }\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n            var oldCptOpt = oldOption[mainType];\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            } else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;\n                });\n            }\n        });\n    }\n    return OptionManager;\n});\ndefine('echarts/CoordinateSystem', ['require'], function (require) {\n    'use strict';\n    var coordinateSystemCreators = {};\n    function CoordinateSystemManager() {\n        this._coordinateSystems = [];\n    }\n    CoordinateSystemManager.prototype = {\n        constructor: CoordinateSystemManager,\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            for (var type in coordinateSystemCreators) {\n                var list = coordinateSystemCreators[type].create(ecModel, api);\n                list && (coordinateSystems = coordinateSystems.concat(list));\n            }\n            this._coordinateSystems = coordinateSystems;\n        },\n        update: function (ecModel, api) {\n            var coordinateSystems = this._coordinateSystems;\n            for (var i = 0; i < coordinateSystems.length; i++) {\n                // FIXME MUST have\n                coordinateSystems[i].update && coordinateSystems[i].update(ecModel, api);\n            }\n        }\n    };\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n    return CoordinateSystemManager;\n});\ndefine('echarts/model/Series', ['require', 'zrender/core/util', '../util/format', '../util/model', './Component', './mixin/colorPalette', 'zrender/core/env'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var formatUtil = require('../util/format');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var colorPaletteMixin = require('./mixin/colorPalette');\n    var env = require('zrender/core/env');\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n    var SeriesModel = ComponentModel.extend({\n            type: 'series.__base__',\n            seriesIndex: 0,\n            coordinateSystem: null,\n            defaultOption: null,\n            legendDataProvider: null,\n            visualColorAccessPath: 'itemStyle.normal.color',\n            init: function (option, parentModel, ecModel, extraOpt) {\n                /**\n             * @type {number}\n             * @readOnly\n             */\n                this.seriesIndex = this.componentIndex;\n                this.mergeDefaultAndTheme(option, ecModel);\n                /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n                this._dataBeforeProcessed = this.getInitialData(option, ecModel);\n                // If we reverse the order (make this._data firstly, and then make\n                // this._dataBeforeProcessed by cloneShallow), cloneShallow will\n                // cause this._data.graph.data !== this._data when using\n                // module:echarts/data/Graph or module:echarts/data/Tree.\n                // See module:echarts/data/helper/linkList\n                this._data = this._dataBeforeProcessed.cloneShallow();\n            },\n            mergeDefaultAndTheme: function (option, ecModel) {\n                zrUtil.merge(option, ecModel.getTheme().get(this.subType));\n                zrUtil.merge(option, this.getDefaultOption());\n                // Default label emphasis `position` and `show`\n                // FIXME Set label in mergeOption\n                modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n                this.fillDataTextStyle(option.data);\n            },\n            mergeOption: function (newSeriesOption, ecModel) {\n                newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n                this.fillDataTextStyle(newSeriesOption.data);\n                var data = this.getInitialData(newSeriesOption, ecModel);\n                // TODO Merge data?\n                if (data) {\n                    this._data = data;\n                    this._dataBeforeProcessed = data.cloneShallow();\n                }\n            },\n            fillDataTextStyle: function (data) {\n                // Default data label emphasis `position` and `show`\n                // FIXME Tree structure data ?\n                // FIXME Performance ?\n                if (data) {\n                    for (var i = 0; i < data.length; i++) {\n                        if (data[i] && data[i].label) {\n                            modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n                        }\n                    }\n                }\n            },\n            getInitialData: function () {\n            },\n            getData: function (dataType) {\n                return dataType == null ? this._data : this._data.getLinkedData(dataType);\n            },\n            setData: function (data) {\n                this._data = data;\n            },\n            getRawData: function () {\n                return this._dataBeforeProcessed;\n            },\n            coordDimToDataDim: function (coordDim) {\n                return [coordDim];\n            },\n            dataDimToCoordDim: function (dataDim) {\n                return dataDim;\n            },\n            getBaseAxis: function () {\n                var coordSys = this.coordinateSystem;\n                return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n            },\n            formatTooltip: function (dataIndex, multipleSeries, dataType) {\n                function formatArrayValue(value) {\n                    return zrUtil.map(value, function (val, idx) {\n                        var dimInfo = data.getDimensionInfo(idx);\n                        var dimType = dimInfo && dimInfo.type;\n                        if (dimType === 'ordinal') {\n                            return val;\n                        } else if (dimType === 'time') {\n                            return multipleSeries ? '' : formatUtil.formatTime('yyyy/mm/dd hh:mm:ss', val);\n                        } else {\n                            return addCommas(val);\n                        }\n                    }).filter(function (val) {\n                        return !!val;\n                    }).join(', ');\n                }\n                var data = this._data;\n                var value = this.getRawValue(dataIndex);\n                var formattedValue = zrUtil.isArray(value) ? formatArrayValue(value) : addCommas(value);\n                var name = data.getName(dataIndex);\n                var color = data.getItemVisual(dataIndex, 'color');\n                var colorEl = '<span style=\"display:inline-block;margin-right:5px;' + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '\"></span>';\n                var seriesName = this.name;\n                // FIXME\n                if (seriesName === '\u0000-') {\n                    // Not show '-'\n                    seriesName = '';\n                }\n                return !multipleSeries ? (seriesName && encodeHTML(seriesName) + '<br />') + colorEl + (name ? encodeHTML(name) + ' : ' + formattedValue : formattedValue) : colorEl + encodeHTML(this.name) + ' : ' + formattedValue;\n            },\n            ifEnableAnimation: function () {\n                if (env.node) {\n                    return false;\n                }\n                var animationEnabled = this.getShallow('animation');\n                if (animationEnabled) {\n                    if (this.getData().count() > this.getShallow('animationThreshold')) {\n                        animationEnabled = false;\n                    }\n                }\n                return animationEnabled;\n            },\n            restoreData: function () {\n                this._data = this._dataBeforeProcessed.cloneShallow();\n            },\n            getColorFromPalette: function (name, scope) {\n                var ecModel = this.ecModel;\n                // PENDING\n                var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n                if (!color) {\n                    color = ecModel.getColorFromPalette(name, scope);\n                }\n                return color;\n            },\n            getAxisTooltipDataIndex: null\n        });\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n    return SeriesModel;\n});\ndefine('echarts/model/Component', ['require', './Model', 'zrender/core/util', '../util/component', '../util/clazz', '../util/layout', './mixin/boxLayout'], function (require) {\n    var Model = require('./Model');\n    var zrUtil = require('zrender/core/util');\n    var arrayPush = Array.prototype.push;\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var layout = require('../util/layout');\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n            type: 'component',\n            id: '',\n            name: '',\n            mainType: '',\n            subType: '',\n            componentIndex: 0,\n            defaultOption: null,\n            ecModel: null,\n            dependentModels: [],\n            uid: null,\n            layoutMode: null,\n            $constructor: function (option, parentModel, ecModel, extraOpt) {\n                Model.call(this, option, parentModel, ecModel, extraOpt);\n                // Set dependentModels, componentIndex, name, id, mainType, subType.\n                zrUtil.extend(this, extraOpt);\n                this.uid = componentUtil.getUID('componentModel');\n            },\n            init: function (option, parentModel, ecModel, extraOpt) {\n                this.mergeDefaultAndTheme(option, ecModel);\n            },\n            mergeDefaultAndTheme: function (option, ecModel) {\n                var layoutMode = this.layoutMode;\n                var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};\n                var themeModel = ecModel.getTheme();\n                zrUtil.merge(option, themeModel.get(this.mainType));\n                zrUtil.merge(option, this.getDefaultOption());\n                if (layoutMode) {\n                    layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                }\n            },\n            mergeOption: function (option) {\n                zrUtil.merge(this.option, option, true);\n                var layoutMode = this.layoutMode;\n                if (layoutMode) {\n                    layout.mergeLayoutParam(this.option, option, layoutMode);\n                }\n            },\n            optionUpdated: function (newCptOption, isInit) {\n            },\n            getDefaultOption: function () {\n                if (!this.hasOwnProperty('__defaultOption')) {\n                    var optList = [];\n                    var Class = this.constructor;\n                    while (Class) {\n                        var opt = Class.prototype.defaultOption;\n                        opt && optList.push(opt);\n                        Class = Class.superClass;\n                    }\n                    var defaultOption = {};\n                    for (var i = optList.length - 1; i >= 0; i--) {\n                        defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                    }\n                    this.__defaultOption = defaultOption;\n                }\n                return this.__defaultOption;\n            }\n        });\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n    //         this.uid = componentUtil.getUID('componentModel');\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(ComponentModel, { registerWhenExtend: true });\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n    zrUtil.mixin(ComponentModel, require('./mixin/boxLayout'));\n    return ComponentModel;\n});\ndefine('echarts/view/Component', ['require', 'zrender/container/Group', '../util/component', '../util/clazz'], function (require) {\n    var Group = require('zrender/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n    Component.prototype = {\n        constructor: Component,\n        init: function (ecModel, api) {\n        },\n        render: function (componentModel, ecModel, api, payload) {\n        },\n        dispose: function () {\n        }\n    };\n    var componentProto = Component.prototype;\n    componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function (seriesModel, ecModel, api, payload) {\n    };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, { registerWhenExtend: true });\n    return Component;\n});\ndefine('echarts/view/Chart', ['require', 'zrender/container/Group', '../util/component', '../util/clazz'], function (require) {\n    var Group = require('zrender/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    function Chart() {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n    Chart.prototype = {\n        type: 'chart',\n        init: function (ecModel, api) {\n        },\n        render: function (seriesModel, ecModel, api, payload) {\n        },\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n        dispose: function () {\n        }\n    };\n    var chartProto = Chart.prototype;\n    chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function (seriesModel, ecModel, api, payload) {\n        this.render(seriesModel, ecModel, api, payload);\n    };\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = payload && payload.dataIndex;\n        var name = payload && payload.name;\n        if (dataIndex != null) {\n            var dataIndices = dataIndex instanceof Array ? dataIndex : [dataIndex];\n            for (var i = 0, len = dataIndices.length; i < len; i++) {\n                elSetState(data.getItemGraphicEl(dataIndices[i]), state);\n            }\n        } else if (name) {\n            var names = name instanceof Array ? name : [name];\n            for (var i = 0, len = names.length; i < len; i++) {\n                var dataIndex = data.indexOfName(names[i]);\n                elSetState(data.getItemGraphicEl(dataIndex), state);\n            }\n        } else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart);\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, { registerWhenExtend: true });\n    return Chart;\n});\ndefine('zrender/zrender', ['require', './core/guid', './core/env', './Handler', './Storage', './animation/Animation', './dom/HandlerProxy', './Painter'], function (require) {\n    var guid = require('./core/guid');\n    var env = require('./core/env');\n    var Handler = require('./Handler');\n    var Storage = require('./Storage');\n    var Animation = require('./animation/Animation');\n    var HandlerProxy = require('./dom/HandlerProxy');\n    var useVML = !env.canvasSupported;\n    var painterCtors = { canvas: require('./Painter') };\n    var instances = {};\n    // ZRender实例map索引\n    var zrender = {};\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.1.3';\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function (dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        } else {\n            for (var key in instances) {\n                instances[key].dispose();\n            }\n            instances = {};\n        }\n        return zrender;\n    };\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n    function delInstance(id) {\n        delete instances[id];\n    }\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     */\n    var ZRender = function (id, dom, opts) {\n        opts = opts || {};\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n        /**\n         * @type {string}\n         */\n        this.id = id;\n        var self = this;\n        var storage = new Storage();\n        var rendererType = opts.renderer;\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        } else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n        this.storage = storage;\n        this.painter = painter;\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy);\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: function () {\n                    if (self._needsRefresh) {\n                        self.refreshImmediately();\n                    }\n                    if (self._needsRefreshHover) {\n                        self.refreshHoverImmediately();\n                    }\n                }\n            }\n        });\n        this.animation.start();\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n        // 修改 storage.delFromMap, 每次删除元素之前删除动画\n        // FIXME 有点ugly\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n            oldDelFromMap.call(storage, elId);\n            el && el.removeSelfFromZr(self);\n        };\n        storage.addToMap = function (el) {\n            oldAddToMap.call(storage, el);\n            el.addSelfToZr(self);\n        };\n    };\n    ZRender.prototype = {\n        constructor: ZRender,\n        getId: function () {\n            return this.id;\n        },\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n        refresh: function () {\n            this._needsRefresh = true;\n        },\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n        resize: function () {\n            this.painter.resize();\n            this.handler.resize();\n        },\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n        getWidth: function () {\n            return this.painter.getWidth();\n        },\n        getHeight: function () {\n            return this.painter.getHeight();\n        },\n        pathToImage: function (e, width, height) {\n            var id = guid();\n            return this.painter.pathToImage(id, e, width, height);\n        },\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n        on: function (eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n        off: function (eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n        dispose: function () {\n            this.animation.stop();\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n            this.animation = this.storage = this.painter = this.handler = null;\n            delInstance(this.id);\n        }\n    };\n    return zrender;\n});\ndefine('zrender/mixin/Eventful', ['require'], function (require) {\n    var arrySlice = Array.prototype.slice;\n    /**\n     * 事件分发器\n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n    Eventful.prototype = {\n        constructor: Eventful,\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n            if (!handler || !event) {\n                return this;\n            }\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n            return this;\n        },\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n            if (!handler || !event) {\n                return this;\n            }\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n            return this;\n        },\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n        off: function (event, handler) {\n            var _h = this._$handlers;\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            } else {\n                delete _h[event];\n            }\n            return this;\n        },\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                    case 1:\n                        _h[i]['h'].call(_h[i]['ctx']);\n                        break;\n                    case 2:\n                        _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                        break;\n                    case 3:\n                        _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                        break;\n                    default:\n                        // have more than 2 given arguments\n                        _h[i]['h'].apply(_h[i]['ctx'], args);\n                        break;\n                    }\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    } else {\n                        i++;\n                    }\n                }\n            }\n            return this;\n        },\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                    case 1:\n                        _h[i]['h'].call(ctx);\n                        break;\n                    case 2:\n                        _h[i]['h'].call(ctx, args[1]);\n                        break;\n                    case 3:\n                        _h[i]['h'].call(ctx, args[1], args[2]);\n                        break;\n                    default:\n                        // have more than 2 given arguments\n                        _h[i]['h'].apply(ctx, args);\n                        break;\n                    }\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    } else {\n                        i++;\n                    }\n                }\n            }\n            return this;\n        }\n    };\n    // 对象可以通过 onxxxx 绑定事件\n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n    return Eventful;\n});\ndefine('zrender/tool/color', ['require'], function (require) {\n    var kCSSColorTable = {\n            'transparent': [\n                0,\n                0,\n                0,\n                0\n            ],\n            'aliceblue': [\n                240,\n                248,\n                255,\n                1\n            ],\n            'antiquewhite': [\n                250,\n                235,\n                215,\n                1\n            ],\n            'aqua': [\n                0,\n                255,\n                255,\n                1\n            ],\n            'aquamarine': [\n                127,\n                255,\n                212,\n                1\n            ],\n            'azure': [\n                240,\n                255,\n                255,\n                1\n            ],\n            'beige': [\n                245,\n                245,\n                220,\n                1\n            ],\n            'bisque': [\n                255,\n                228,\n                196,\n                1\n            ],\n            'black': [\n                0,\n                0,\n                0,\n                1\n            ],\n            'blanchedalmond': [\n                255,\n                235,\n                205,\n                1\n            ],\n            'blue': [\n                0,\n                0,\n                255,\n                1\n            ],\n            'blueviolet': [\n                138,\n                43,\n                226,\n                1\n            ],\n            'brown': [\n                165,\n                42,\n                42,\n                1\n            ],\n            'burlywood': [\n                222,\n                184,\n                135,\n                1\n            ],\n            'cadetblue': [\n                95,\n                158,\n                160,\n                1\n            ],\n            'chartreuse': [\n                127,\n                255,\n                0,\n                1\n            ],\n            'chocolate': [\n                210,\n                105,\n                30,\n                1\n            ],\n            'coral': [\n                255,\n                127,\n                80,\n                1\n            ],\n            'cornflowerblue': [\n                100,\n                149,\n                237,\n                1\n            ],\n            'cornsilk': [\n                255,\n                248,\n                220,\n                1\n            ],\n            'crimson': [\n                220,\n                20,\n                60,\n                1\n            ],\n            'cyan': [\n                0,\n                255,\n                255,\n                1\n            ],\n            'darkblue': [\n                0,\n                0,\n                139,\n                1\n            ],\n            'darkcyan': [\n                0,\n                139,\n                139,\n                1\n            ],\n            'darkgoldenrod': [\n                184,\n                134,\n                11,\n                1\n            ],\n            'darkgray': [\n                169,\n                169,\n                169,\n                1\n            ],\n            'darkgreen': [\n                0,\n                100,\n                0,\n                1\n            ],\n            'darkgrey': [\n                169,\n                169,\n                169,\n                1\n            ],\n            'darkkhaki': [\n                189,\n                183,\n                107,\n                1\n            ],\n            'darkmagenta': [\n                139,\n                0,\n                139,\n                1\n            ],\n            'darkolivegreen': [\n                85,\n                107,\n                47,\n                1\n            ],\n            'darkorange': [\n                255,\n                140,\n                0,\n                1\n            ],\n            'darkorchid': [\n                153,\n                50,\n                204,\n                1\n            ],\n            'darkred': [\n                139,\n                0,\n                0,\n                1\n            ],\n            'darksalmon': [\n                233,\n                150,\n                122,\n                1\n            ],\n            'darkseagreen': [\n                143,\n                188,\n                143,\n                1\n            ],\n            'darkslateblue': [\n                72,\n                61,\n                139,\n                1\n            ],\n            'darkslategray': [\n                47,\n                79,\n                79,\n                1\n            ],\n            'darkslategrey': [\n                47,\n                79,\n                79,\n                1\n            ],\n            'darkturquoise': [\n                0,\n                206,\n                209,\n                1\n            ],\n            'darkviolet': [\n                148,\n                0,\n                211,\n                1\n            ],\n            'deeppink': [\n                255,\n                20,\n                147,\n                1\n            ],\n            'deepskyblue': [\n                0,\n                191,\n                255,\n                1\n            ],\n            'dimgray': [\n                105,\n                105,\n                105,\n                1\n            ],\n            'dimgrey': [\n                105,\n                105,\n                105,\n                1\n            ],\n            'dodgerblue': [\n                30,\n                144,\n                255,\n                1\n            ],\n            'firebrick': [\n                178,\n                34,\n                34,\n                1\n            ],\n            'floralwhite': [\n                255,\n                250,\n                240,\n                1\n            ],\n            'forestgreen': [\n                34,\n                139,\n                34,\n                1\n            ],\n            'fuchsia': [\n                255,\n                0,\n                255,\n                1\n            ],\n            'gainsboro': [\n                220,\n                220,\n                220,\n                1\n            ],\n            'ghostwhite': [\n                248,\n                248,\n                255,\n                1\n            ],\n            'gold': [\n                255,\n                215,\n                0,\n                1\n            ],\n            'goldenrod': [\n                218,\n                165,\n                32,\n                1\n            ],\n            'gray': [\n                128,\n                128,\n                128,\n                1\n            ],\n            'green': [\n                0,\n                128,\n                0,\n                1\n            ],\n            'greenyellow': [\n                173,\n                255,\n                47,\n                1\n            ],\n            'grey': [\n                128,\n                128,\n                128,\n                1\n            ],\n            'honeydew': [\n                240,\n                255,\n                240,\n                1\n            ],\n            'hotpink': [\n                255,\n                105,\n                180,\n                1\n            ],\n            'indianred': [\n                205,\n                92,\n                92,\n                1\n            ],\n            'indigo': [\n                75,\n                0,\n                130,\n                1\n            ],\n            'ivory': [\n                255,\n                255,\n                240,\n                1\n            ],\n            'khaki': [\n                240,\n                230,\n                140,\n                1\n            ],\n            'lavender': [\n                230,\n                230,\n                250,\n                1\n            ],\n            'lavenderblush': [\n                255,\n                240,\n                245,\n                1\n            ],\n            'lawngreen': [\n                124,\n                252,\n                0,\n                1\n            ],\n            'lemonchiffon': [\n                255,\n                250,\n                205,\n                1\n            ],\n            'lightblue': [\n                173,\n                216,\n                230,\n                1\n            ],\n            'lightcoral': [\n                240,\n                128,\n                128,\n                1\n            ],\n            'lightcyan': [\n                224,\n                255,\n                255,\n                1\n            ],\n            'lightgoldenrodyellow': [\n                250,\n                250,\n                210,\n                1\n            ],\n            'lightgray': [\n                211,\n                211,\n                211,\n                1\n            ],\n            'lightgreen': [\n                144,\n                238,\n                144,\n                1\n            ],\n            'lightgrey': [\n                211,\n                211,\n                211,\n                1\n            ],\n            'lightpink': [\n                255,\n                182,\n                193,\n                1\n            ],\n            'lightsalmon': [\n                255,\n                160,\n                122,\n                1\n            ],\n            'lightseagreen': [\n                32,\n                178,\n                170,\n                1\n            ],\n            'lightskyblue': [\n                135,\n                206,\n                250,\n                1\n            ],\n            'lightslategray': [\n                119,\n                136,\n                153,\n                1\n            ],\n            'lightslategrey': [\n                119,\n                136,\n                153,\n                1\n            ],\n            'lightsteelblue': [\n                176,\n                196,\n                222,\n                1\n            ],\n            'lightyellow': [\n                255,\n                255,\n                224,\n                1\n            ],\n            'lime': [\n                0,\n                255,\n                0,\n                1\n            ],\n            'limegreen': [\n                50,\n                205,\n                50,\n                1\n            ],\n            'linen': [\n                250,\n                240,\n                230,\n                1\n            ],\n            'magenta': [\n                255,\n                0,\n                255,\n                1\n            ],\n            'maroon': [\n                128,\n                0,\n                0,\n                1\n            ],\n            'mediumaquamarine': [\n                102,\n                205,\n                170,\n                1\n            ],\n            'mediumblue': [\n                0,\n                0,\n                205,\n                1\n            ],\n            'mediumorchid': [\n                186,\n                85,\n                211,\n                1\n            ],\n            'mediumpurple': [\n                147,\n                112,\n                219,\n                1\n            ],\n            'mediumseagreen': [\n                60,\n                179,\n                113,\n                1\n            ],\n            'mediumslateblue': [\n                123,\n                104,\n                238,\n                1\n            ],\n            'mediumspringgreen': [\n                0,\n                250,\n                154,\n                1\n            ],\n            'mediumturquoise': [\n                72,\n                209,\n                204,\n                1\n            ],\n            'mediumvioletred': [\n                199,\n                21,\n                133,\n                1\n            ],\n            'midnightblue': [\n                25,\n                25,\n                112,\n                1\n            ],\n            'mintcream': [\n                245,\n                255,\n                250,\n                1\n            ],\n            'mistyrose': [\n                255,\n                228,\n                225,\n                1\n            ],\n            'moccasin': [\n                255,\n                228,\n                181,\n                1\n            ],\n            'navajowhite': [\n                255,\n                222,\n                173,\n                1\n            ],\n            'navy': [\n                0,\n                0,\n                128,\n                1\n            ],\n            'oldlace': [\n                253,\n                245,\n                230,\n                1\n            ],\n            'olive': [\n                128,\n                128,\n                0,\n                1\n            ],\n            'olivedrab': [\n                107,\n                142,\n                35,\n                1\n            ],\n            'orange': [\n                255,\n                165,\n                0,\n                1\n            ],\n            'orangered': [\n                255,\n                69,\n                0,\n                1\n            ],\n            'orchid': [\n                218,\n                112,\n                214,\n                1\n            ],\n            'palegoldenrod': [\n                238,\n                232,\n                170,\n                1\n            ],\n            'palegreen': [\n                152,\n                251,\n                152,\n                1\n            ],\n            'paleturquoise': [\n                175,\n                238,\n                238,\n                1\n            ],\n            'palevioletred': [\n                219,\n                112,\n                147,\n                1\n            ],\n            'papayawhip': [\n                255,\n                239,\n                213,\n                1\n            ],\n            'peachpuff': [\n                255,\n                218,\n                185,\n                1\n            ],\n            'peru': [\n                205,\n                133,\n                63,\n                1\n            ],\n            'pink': [\n                255,\n                192,\n                203,\n                1\n            ],\n            'plum': [\n                221,\n                160,\n                221,\n                1\n            ],\n            'powderblue': [\n                176,\n                224,\n                230,\n                1\n            ],\n            'purple': [\n                128,\n                0,\n                128,\n                1\n            ],\n            'red': [\n                255,\n                0,\n                0,\n                1\n            ],\n            'rosybrown': [\n                188,\n                143,\n                143,\n                1\n            ],\n            'royalblue': [\n                65,\n                105,\n                225,\n                1\n            ],\n            'saddlebrown': [\n                139,\n                69,\n                19,\n                1\n            ],\n            'salmon': [\n                250,\n                128,\n                114,\n                1\n            ],\n            'sandybrown': [\n                244,\n                164,\n                96,\n                1\n            ],\n            'seagreen': [\n                46,\n                139,\n                87,\n                1\n            ],\n            'seashell': [\n                255,\n                245,\n                238,\n                1\n            ],\n            'sienna': [\n                160,\n                82,\n                45,\n                1\n            ],\n            'silver': [\n                192,\n                192,\n                192,\n                1\n            ],\n            'skyblue': [\n                135,\n                206,\n                235,\n                1\n            ],\n            'slateblue': [\n                106,\n                90,\n                205,\n                1\n            ],\n            'slategray': [\n                112,\n                128,\n                144,\n                1\n            ],\n            'slategrey': [\n                112,\n                128,\n                144,\n                1\n            ],\n            'snow': [\n                255,\n                250,\n                250,\n                1\n            ],\n            'springgreen': [\n                0,\n                255,\n                127,\n                1\n            ],\n            'steelblue': [\n                70,\n                130,\n                180,\n                1\n            ],\n            'tan': [\n                210,\n                180,\n                140,\n                1\n            ],\n            'teal': [\n                0,\n                128,\n                128,\n                1\n            ],\n            'thistle': [\n                216,\n                191,\n                216,\n                1\n            ],\n            'tomato': [\n                255,\n                99,\n                71,\n                1\n            ],\n            'turquoise': [\n                64,\n                224,\n                208,\n                1\n            ],\n            'violet': [\n                238,\n                130,\n                238,\n                1\n            ],\n            'wheat': [\n                245,\n                222,\n                179,\n                1\n            ],\n            'white': [\n                255,\n                255,\n                255,\n                1\n            ],\n            'whitesmoke': [\n                245,\n                245,\n                245,\n                1\n            ],\n            'yellow': [\n                255,\n                255,\n                0,\n                1\n            ],\n            'yellowgreen': [\n                154,\n                205,\n                50,\n                1\n            ]\n        };\n    function clampCssByte(i) {\n        // Clamp to integer 0 .. 255.\n        i = Math.round(i);\n        // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n    function clampCssAngle(i) {\n        // Clamp to integer 0 .. 360.\n        i = Math.round(i);\n        // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n    function clampCssFloat(f) {\n        // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n    function parseCssInt(str) {\n        // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n    function parseCssFloat(str) {\n        // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        } else if (h > 1) {\n            h -= 1;\n        }\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n        }\n        return m1;\n    }\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n    /**\n     * @param {string} colorStr\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr) {\n        if (!colorStr) {\n            return;\n        }\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            return kCSSColorTable[str].slice();    // dup.\n        }\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);\n                // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 4095)) {\n                    return;    // Covers NaN.\n                }\n                return [\n                    (iv & 3840) >> 4 | (iv & 3840) >> 8,\n                    iv & 240 | (iv & 240) >> 4,\n                    iv & 15 | (iv & 15) << 4,\n                    1\n                ];\n            } else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);\n                // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 16777215)) {\n                    return;    // Covers NaN.\n                }\n                return [\n                    (iv & 16711680) >> 16,\n                    (iv & 65280) >> 8,\n                    iv & 255,\n                    1\n                ];\n            }\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;\n            // To allow case fallthrough.\n            switch (fname) {\n            case 'rgba':\n                if (params.length !== 4) {\n                    return;\n                }\n                alpha = parseCssFloat(params.pop());\n            // jshint ignore:line\n            // Fall through.\n            case 'rgb':\n                if (params.length !== 3) {\n                    return;\n                }\n                return [\n                    parseCssInt(params[0]),\n                    parseCssInt(params[1]),\n                    parseCssInt(params[2]),\n                    alpha\n                ];\n            case 'hsla':\n                if (params.length !== 4) {\n                    return;\n                }\n                params[3] = parseCssFloat(params[3]);\n                return hsla2rgba(params);\n            case 'hsl':\n                if (params.length !== 3) {\n                    return;\n                }\n                return hsla2rgba(params);\n            default:\n                return;\n            }\n        }\n        return;\n    }\n    /**\n     * @param {Array.<number>} hsla\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla) {\n        var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;\n        // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n        var rgba = [\n                clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n                clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n                clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n            ];\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n        return rgba;\n    }\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n        var vMin = Math.min(R, G, B);\n        // Min. value of RGB\n        var vMax = Math.max(R, G, B);\n        // Max. value of RGB\n        var delta = vMax - vMin;\n        // Delta RGB value\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        } else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            } else {\n                S = delta / (2 - vMax - vMin);\n            }\n            var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n            var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n            var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            } else if (G === vMax) {\n                H = 1 / 3 + deltaR - deltaB;\n            } else if (B === vMax) {\n                H = 2 / 3 + deltaG - deltaR;\n            }\n            if (H < 0) {\n                H += 1;\n            }\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n        var hsla = [\n                H * 360,\n                S,\n                L\n            ];\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n        return hsla;\n    }\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                } else {\n                    colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n        }\n    }\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>}\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n            return;\n        }\n        out = out || [\n            0,\n            0,\n            0,\n            0\n        ];\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n            return;\n        }\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n        var color = stringify([\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ], 'rgba');\n        return fullOutput ? {\n            color: color,\n            leftIndex: leftIndex,\n            rightIndex: rightIndex,\n            value: value\n        } : color;\n    }\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n    /**\n     * @param {Array.<string>} colors Color list.\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color.\n     */\n    function stringify(arrColor, type) {\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n    return {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n});\ndefine('zrender/core/timsort', [], function () {\n    var DEFAULT_MIN_MERGE = 32;\n    var DEFAULT_MIN_GALLOPING = 7;\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n    function minRunLength(n) {\n        var r = 0;\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n        return n + r;\n    }\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n        if (runHi === hi) {\n            return 1;\n        }\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n            reverseRun(array, lo, runHi);\n        } else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n        return runHi - lo;\n    }\n    function reverseRun(array, lo, hi) {\n        hi--;\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n        for (; start < hi; start++) {\n            var pivot = array[start];\n            var left = lo;\n            var right = start;\n            var mid;\n            while (left < right) {\n                mid = left + right >>> 1;\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            var n = start - left;\n            switch (n) {\n            case 3:\n                array[left + 3] = array[left + 2];\n            case 2:\n                array[left + 2] = array[left + 1];\n            case 1:\n                array[left + 1] = array[left];\n                break;\n            default:\n                while (n > 0) {\n                    array[left + n] = array[left + n - 1];\n                    n--;\n                }\n            }\n            array[left] = pivot;\n        }\n    }\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            lastOffset += hint;\n            offset += hint;\n        } else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            } else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        } else {\n            maxOffset = length - hint;\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            lastOffset += hint;\n            offset += hint;\n        }\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            } else {\n                lastOffset = m + 1;\n            }\n        }\n        return offset;\n    }\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n        length = array.length;\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n        var tmp = [];\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n        runStart = [];\n        runLength = [];\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                } else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n                mergeAt(n);\n            }\n        }\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n            runLength[i] = length1 + length2;\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n            stackSize--;\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n            if (length1 === 0) {\n                return;\n            }\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n            if (length2 === 0) {\n                return;\n            }\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            } else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n            array[dest++] = array[cursor2++];\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    } else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n                if (exit) {\n                    break;\n                }\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = array[cursor2++];\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n                if (exit) {\n                    break;\n                }\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n                _minGallop += 2;\n            }\n            minGallop = _minGallop;\n            minGallop < 1 && (minGallop = 1);\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            } else if (length1 === 0) {\n                throw new Error();    // throw new Error('mergeLow preconditions were not respected');\n            } else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n        function mergeHigh(start1, length1, start2, length2) {\n            var i = 0;\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n            array[dest--] = array[cursor1--];\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n                return;\n            }\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n                array[dest] = tmp[cursor2];\n                return;\n            }\n            var _minGallop = minGallop;\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    } else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n                if (exit) {\n                    break;\n                }\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest--] = tmp[cursor2--];\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest--] = array[cursor1--];\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n                if (exit) {\n                    break;\n                }\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n                _minGallop += 2;\n            }\n            minGallop = _minGallop;\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n                array[dest] = tmp[cursor2];\n            } else if (length2 === 0) {\n                throw new Error();    // throw new Error('mergeHigh preconditions were not respected');\n            } else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n        var remaining = hi - lo;\n        if (remaining < 2) {\n            return;\n        }\n        var runLength = 0;\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n        var ts = new TimSort(array, compare);\n        var minRun = minRunLength(remaining);\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n        ts.forceMergeRuns();\n    }\n    return sort;\n});\ndefine('echarts/visual/seriesColor', ['require', 'zrender/graphic/Gradient'], function (require) {\n    var Gradient = require('zrender/graphic/Gradient');\n    return function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) || seriesModel.getColorFromPalette(seriesModel.get('name'));\n            // Default color\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(idx, 'color', color(seriesModel.getDataParams(idx)));\n                    });\n                }\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n});\ndefine('echarts/preprocessor/backwardCompat', ['require', 'zrender/core/util', './helper/compatStyle'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var compatStyle = require('./helper/compatStyle');\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n    var LAYOUT_PROPERTIES = [\n            [\n                'x',\n                'left'\n            ],\n            [\n                'y',\n                'top'\n            ],\n            [\n                'x2',\n                'right'\n            ],\n            [\n                'y2',\n                'bottom'\n            ]\n        ];\n    var COMPATITABLE_COMPONENTS = [\n            'grid',\n            'geo',\n            'parallel',\n            'legend',\n            'toolbox',\n            'title',\n            'visualMap',\n            'dataZoom',\n            'timeline'\n        ];\n    var COMPATITABLE_SERIES = [\n            'bar',\n            'boxplot',\n            'candlestick',\n            'chord',\n            'effectScatter',\n            'funnel',\n            'gauge',\n            'lines',\n            'graph',\n            'heatmap',\n            'line',\n            'map',\n            'parallel',\n            'pie',\n            'radar',\n            'sankey',\n            'scatter',\n            'treemap'\n        ];\n    var each = zrUtil.each;\n    return function (option) {\n        each(option.series, function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n            var seriesType = seriesOpt.type;\n            compatStyle(seriesOpt);\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n});\ndefine('echarts/loading/default', ['require', '../util/graphic', 'zrender/core/util'], function (require) {\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/core/util');\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    return function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n                style: { fill: opts.maskColor },\n                zlevel: opts.zlevel,\n                z: 10000\n            });\n        var arc = new graphic.Arc({\n                shape: {\n                    startAngle: -PI / 2,\n                    endAngle: -PI / 2 + 0.1,\n                    r: 10\n                },\n                style: {\n                    stroke: opts.color,\n                    lineCap: 'round',\n                    lineWidth: 5\n                },\n                zlevel: opts.zlevel,\n                z: 10001\n            });\n        var labelRect = new graphic.Rect({\n                style: {\n                    fill: 'none',\n                    text: opts.text,\n                    textPosition: 'right',\n                    textDistance: 10,\n                    textFill: opts.textColor\n                },\n                zlevel: opts.zlevel,\n                z: 10001\n            });\n        arc.animateShape(true).when(1000, { endAngle: PI * 3 / 2 }).start('circularInOut');\n        arc.animateShape(true).when(1000, { startAngle: PI * 3 / 2 }).delay(300).start('circularInOut');\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n});\ndefine('zrender/core/matrix', [], function () {\n    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n    /**\n     * 3x2矩阵操作类\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n            create: function () {\n                var out = new ArrayCtor(6);\n                matrix.identity(out);\n                return out;\n            },\n            identity: function (out) {\n                out[0] = 1;\n                out[1] = 0;\n                out[2] = 0;\n                out[3] = 1;\n                out[4] = 0;\n                out[5] = 0;\n                return out;\n            },\n            copy: function (out, m) {\n                out[0] = m[0];\n                out[1] = m[1];\n                out[2] = m[2];\n                out[3] = m[3];\n                out[4] = m[4];\n                out[5] = m[5];\n                return out;\n            },\n            mul: function (out, m1, m2) {\n                // Consider matrix.mul(m, m2, m);\n                // where out is the same as m2.\n                // So use temp variable to escape error.\n                var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n                var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n                var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n                var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n                var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n                var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n                out[0] = out0;\n                out[1] = out1;\n                out[2] = out2;\n                out[3] = out3;\n                out[4] = out4;\n                out[5] = out5;\n                return out;\n            },\n            translate: function (out, a, v) {\n                out[0] = a[0];\n                out[1] = a[1];\n                out[2] = a[2];\n                out[3] = a[3];\n                out[4] = a[4] + v[0];\n                out[5] = a[5] + v[1];\n                return out;\n            },\n            rotate: function (out, a, rad) {\n                var aa = a[0];\n                var ac = a[2];\n                var atx = a[4];\n                var ab = a[1];\n                var ad = a[3];\n                var aty = a[5];\n                var st = Math.sin(rad);\n                var ct = Math.cos(rad);\n                out[0] = aa * ct + ab * st;\n                out[1] = -aa * st + ab * ct;\n                out[2] = ac * ct + ad * st;\n                out[3] = -ac * st + ct * ad;\n                out[4] = ct * atx + st * aty;\n                out[5] = ct * aty - st * atx;\n                return out;\n            },\n            scale: function (out, a, v) {\n                var vx = v[0];\n                var vy = v[1];\n                out[0] = a[0] * vx;\n                out[1] = a[1] * vy;\n                out[2] = a[2] * vx;\n                out[3] = a[3] * vy;\n                out[4] = a[4] * vx;\n                out[5] = a[5] * vy;\n                return out;\n            },\n            invert: function (out, a) {\n                var aa = a[0];\n                var ac = a[2];\n                var atx = a[4];\n                var ab = a[1];\n                var ad = a[3];\n                var aty = a[5];\n                var det = aa * ad - ab * ac;\n                if (!det) {\n                    return null;\n                }\n                det = 1 / det;\n                out[0] = ad * det;\n                out[1] = -ab * det;\n                out[2] = -ac * det;\n                out[3] = aa * det;\n                out[4] = (ac * aty - ad * atx) * det;\n                out[5] = (ab * atx - aa * aty) * det;\n                return out;\n            }\n        };\n    return matrix;\n});\ndefine('echarts/model/Model', ['require', 'zrender/core/util', '../util/clazz', './mixin/lineStyle', './mixin/areaStyle', './mixin/textStyle', './mixin/itemStyle'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var clazzUtil = require('../util/clazz');\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;    // Simple optimization\n                                 // if (this.init) {\n                                 //     if (arguments.length <= 4) {\n                                 //         this.init(option, parentModel, ecModel, extraOpt);\n                                 //     }\n                                 //     else {\n                                 //         this.init.apply(this, arguments);\n                                 //     }\n                                 // }\n    }\n    Model.prototype = {\n        constructor: Model,\n        init: null,\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n        get: function (path, ignoreParent) {\n            if (!path) {\n                return this.option;\n            }\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n            var obj = this.option;\n            var parentModel = this.parentModel;\n            for (var i = 0; i < path.length; i++) {\n                // Ignore empty\n                if (!path[i]) {\n                    continue;\n                }\n                // obj could be number/string/... (like 0)\n                obj = obj && typeof obj === 'object' ? obj[path[i]] : null;\n                if (obj == null) {\n                    break;\n                }\n            }\n            if (obj == null && parentModel && !ignoreParent) {\n                obj = parentModel.get(path);\n            }\n            return obj;\n        },\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n            var val = option == null ? option : option[key];\n            var parentModel = this.parentModel;\n            if (val == null && parentModel && !ignoreParent) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n        getModel: function (path, parentModel) {\n            var obj = this.get(path, true);\n            var thisParentModel = this.parentModel;\n            var model = new Model(obj, parentModel || thisParentModel && thisParentModel.getModel(path), this.ecModel);\n            return model;\n        },\n        isEmpty: function () {\n            return this.option == null;\n        },\n        restoreData: function () {\n        },\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        }\n    };\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n    var mixin = zrUtil.mixin;\n    mixin(Model, require('./mixin/lineStyle'));\n    mixin(Model, require('./mixin/areaStyle'));\n    mixin(Model, require('./mixin/textStyle'));\n    mixin(Model, require('./mixin/itemStyle'));\n    return Model;\n});\ndefine('echarts/data/List', ['require', '../model/Model', './DataDiffer', 'zrender/core/util', '../util/model'], function (require) {\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED ? Array : globalObj.Int32Array;\n    var dataCtors = {\n            'float': Float64Array,\n            'int': Int32Array,\n            'ordinal': Array,\n            'number': Array,\n            'time': Array\n        };\n    var Model = require('../model/Model');\n    var DataDiffer = require('./DataDiffer');\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../util/model');\n    var isObject = zrUtil.isObject;\n    var TRANSFERABLE_PROPERTIES = [\n            'stackedOn',\n            'hasItemOption',\n            '_nameList',\n            '_idList',\n            '_rawData'\n        ];\n    var transferProperties = function (a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n        a.__wrappedMethods = b.__wrappedMethods;\n    };\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string>} dimensions\n     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n        dimensions = dimensions || [\n            'x',\n            'y'\n        ];\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    stackable: false,\n                    type: 'number'\n                };\n            } else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n            }\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n    var listProto = List.prototype;\n    listProto.type = 'list';\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n        if (true) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n        this._rawData = data;\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n        var dimensions = this.dimensions;\n        var size = data.length;\n        var dimensionInfoMap = this._dimensionInfos;\n        var idList = [];\n        var nameRepeatCount = {};\n        nameList = nameList || [];\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(value instanceof Array ? value[dimIndex] : value, dimensionInfoMap[dimName]);\n        };\n        for (var idx = 0; idx < data.length; idx++) {\n            var dataItem = data[idx];\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n            }\n            indices.push(idx);\n        }\n        // Use the name in option and create id\n        for (var i = 0; i < data.length; i++) {\n            if (!nameList[i]) {\n                if (data[i] && data[i].name != null) {\n                    nameList[i] = data[i].name;\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = data[i] && data[i].id;\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n        // If value not exists\n        if (dataIndex == null) {\n            return NaN;\n        }\n        var value = storage[dim] && storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if (value >= 0 && stackedValue > 0 || value <= 0 && stackedValue < 0) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n        return values;\n    };\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (dimensionInfos[dimensions[i]].type !== 'ordinal' && isNaN(this.get(dimensions[i], idx))) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getDataExtent = function (dim, stack) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = dimInfo && dimInfo.stackable && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + !!stack];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                value < min && (min = value);\n                value > max && (max = value);\n            }\n            return this._extent[dim + !!stack] = [\n                min,\n                max\n            ];\n        } else {\n            return [\n                Infinity,\n                -Infinity\n            ];\n        }\n    };\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            } else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            } else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {number}\n     */\n    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n        var nearestIdx = -1;\n        if (dimData) {\n            var minDist = Number.MAX_VALUE;\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var diff = value - this.get(dim, i, stack);\n                var dist = Math.abs(diff);\n                if (diff <= maxDistance && (dist < minDist || dist === minDist && diff > 0)) {\n                    minDist = dist;\n                    nearestIdx = i;\n                }\n            }\n        }\n        return nearestIdx;\n    };\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData[this.getRawIndex(idx)];\n    };\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || this.getRawIndex(idx) + '';\n    };\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n        context = context || this;\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n            case 0:\n                cb.call(context, i);\n                break;\n            case 1:\n                cb.call(context, this.get(dims[0], i, stack), i);\n                break;\n            case 2:\n                cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                break;\n            default:\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dims[k], i, stack);\n                }\n                // Index\n                value[k] = i;\n                cb.apply(context, value);\n            }\n        }\n    };\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n        dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n        context = context || this;\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (dimSize === 1) {\n                keep = cb.call(context, this.get(dimensions[0], i, stack), i);\n            } else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n        this.indices = newIndices;\n        // Reset data extent\n        this._extent = {};\n        return this;\n    };\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel);\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(originalStorage[dim].length);\n            } else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n        var storage = list._storage;\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n        return list;\n    };\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n        return list;\n    };\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n    };\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        return new DataDiffer(otherList ? otherList.indices : [], this.indices, function (idx) {\n            return otherIdList[idx] || idx + '';\n        }, function (idx) {\n            return idList[idx] || idx + '';\n        });\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n    /**\n     * Set layout property.\n     * @param {string} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n    };\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} ignoreParent\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n        this._graphicEls[idx] = el;\n    };\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n        // FIXME\n        list._storage = this._storage;\n        transferProperties(list, this);\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n        return list;\n    };\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = [\n        'cloneShallow',\n        'downSample',\n        'map'\n    ];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n    return List;\n});\ndefine('zrender/core/vector', [], function () {\n    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * 二维向量类\n     * @exports zrender/tool/vector\n     */\n    var vector = {\n            create: function (x, y) {\n                var out = new ArrayCtor(2);\n                if (x == null) {\n                    x = 0;\n                }\n                if (y == null) {\n                    y = 0;\n                }\n                out[0] = x;\n                out[1] = y;\n                return out;\n            },\n            copy: function (out, v) {\n                out[0] = v[0];\n                out[1] = v[1];\n                return out;\n            },\n            clone: function (v) {\n                var out = new ArrayCtor(2);\n                out[0] = v[0];\n                out[1] = v[1];\n                return out;\n            },\n            set: function (out, a, b) {\n                out[0] = a;\n                out[1] = b;\n                return out;\n            },\n            add: function (out, v1, v2) {\n                out[0] = v1[0] + v2[0];\n                out[1] = v1[1] + v2[1];\n                return out;\n            },\n            scaleAndAdd: function (out, v1, v2, a) {\n                out[0] = v1[0] + v2[0] * a;\n                out[1] = v1[1] + v2[1] * a;\n                return out;\n            },\n            sub: function (out, v1, v2) {\n                out[0] = v1[0] - v2[0];\n                out[1] = v1[1] - v2[1];\n                return out;\n            },\n            len: function (v) {\n                return Math.sqrt(this.lenSquare(v));\n            },\n            lenSquare: function (v) {\n                return v[0] * v[0] + v[1] * v[1];\n            },\n            mul: function (out, v1, v2) {\n                out[0] = v1[0] * v2[0];\n                out[1] = v1[1] * v2[1];\n                return out;\n            },\n            div: function (out, v1, v2) {\n                out[0] = v1[0] / v2[0];\n                out[1] = v1[1] / v2[1];\n                return out;\n            },\n            dot: function (v1, v2) {\n                return v1[0] * v2[0] + v1[1] * v2[1];\n            },\n            scale: function (out, v, s) {\n                out[0] = v[0] * s;\n                out[1] = v[1] * s;\n                return out;\n            },\n            normalize: function (out, v) {\n                var d = vector.len(v);\n                if (d === 0) {\n                    out[0] = 0;\n                    out[1] = 0;\n                } else {\n                    out[0] = v[0] / d;\n                    out[1] = v[1] / d;\n                }\n                return out;\n            },\n            distance: function (v1, v2) {\n                return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n            },\n            distanceSquare: function (v1, v2) {\n                return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n            },\n            negate: function (out, v) {\n                out[0] = -v[0];\n                out[1] = -v[1];\n                return out;\n            },\n            lerp: function (out, v1, v2, t) {\n                out[0] = v1[0] + t * (v2[0] - v1[0]);\n                out[1] = v1[1] + t * (v2[1] - v1[1]);\n                return out;\n            },\n            applyTransform: function (out, v, m) {\n                var x = v[0];\n                var y = v[1];\n                out[0] = m[0] * x + m[2] * y + m[4];\n                out[1] = m[1] * x + m[3] * y + m[5];\n                return out;\n            },\n            min: function (out, v1, v2) {\n                out[0] = Math.min(v1[0], v2[0]);\n                out[1] = Math.min(v1[1], v2[1]);\n                return out;\n            },\n            max: function (out, v1, v2) {\n                out[0] = Math.max(v1[0], v2[0]);\n                out[1] = Math.max(v1[1], v2[1]);\n                return out;\n            }\n        };\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n    return vector;\n});\ndefine('echarts/scale/Scale', ['require', '../util/clazz'], function (require) {\n    var clazzUtil = require('../util/clazz');\n    function Scale() {\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [\n            Infinity,\n            -Infinity\n        ];\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n        this.init && this.init.apply(this, arguments);\n    }\n    var scaleProto = Scale.prototype;\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);    // not setExtent because in log axis it may transformed to power\n                                                           // this.setExtent(extent[0], extent[1]);\n    };\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, { registerWhenExtend: true });\n    return Scale;\n});\ndefine('echarts/coord/axisHelper', ['require', '../scale/Ordinal', '../scale/Interval', '../scale/Time', '../scale/Log', '../scale/Scale', '../util/number', 'zrender/core/util', 'zrender/contain/text'], function (require) {\n    var OrdinalScale = require('../scale/Ordinal');\n    var IntervalScale = require('../scale/Interval');\n    require('../scale/Time');\n    require('../scale/Log');\n    var Scale = require('../scale/Scale');\n    var numberUtil = require('../util/number');\n    var zrUtil = require('zrender/core/util');\n    var textContain = require('zrender/contain/text');\n    var axisHelper = {};\n    /**\n     * Get axis scale extent before niced.\n     */\n    axisHelper.getScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var originalExtent = scale.getExtent();\n        var span = originalExtent[1] - originalExtent[0];\n        if (scale.type === 'ordinal') {\n            // If series has no data, scale extent may be wrong\n            if (!isFinite(span)) {\n                return [\n                    0,\n                    0\n                ];\n            } else {\n                return originalExtent;\n            }\n        }\n        var min = model.getMin ? model.getMin() : model.get('min');\n        var max = model.getMax ? model.getMax() : model.get('max');\n        var crossZero = model.getNeedCrossZero ? model.getNeedCrossZero() : !model.get('scale');\n        var boundaryGap = model.get('boundaryGap');\n        if (!zrUtil.isArray(boundaryGap)) {\n            boundaryGap = [\n                boundaryGap || 0,\n                boundaryGap || 0\n            ];\n        }\n        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n        var fixMin = true;\n        var fixMax = true;\n        // Add boundary gap\n        if (min == null) {\n            min = originalExtent[0] - boundaryGap[0] * span;\n            fixMin = false;\n        }\n        if (max == null) {\n            max = originalExtent[1] + boundaryGap[1] * span;\n            fixMax = false;\n        }\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n        // Evaluate if axis needs cross zero\n        if (crossZero) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n        return [\n            min,\n            max\n        ];\n    };\n    axisHelper.niceScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var extent = axisHelper.getScaleExtent(axis, model);\n        var fixMin = (model.getMin ? model.getMin() : model.get('min')) != null;\n        var fixMax = (model.getMax ? model.getMax() : model.get('max')) != null;\n        var splitNumber = model.get('splitNumber');\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent(splitNumber, fixMin, fixMax);\n        // Use minInterval to constraint the calculated interval.\n        // If calculated interval is less than minInterval. increase the interval quantity until\n        // it is larger than minInterval.\n        // For example:\n        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n        //  an integer axis.\n        var minInterval = model.get('minInterval');\n        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n            var interval = scale.getInterval();\n            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n            // while (interval < minInterval) {\n            //     var quantity = numberUtil.quantity(interval);\n            //     interval = quantity * 10;\n            //     scaleQuantity *= 10;\n            // }\n            extent = scale.getExtent();\n            scale.setExtent(intervalScale * extent[0], extent[1] * intervalScale);\n            scale.niceExtent(splitNumber);\n        }\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function (model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n            // Buildin scale\n            case 'category':\n                return new OrdinalScale(model.getCategories(), [\n                    Infinity,\n                    -Infinity\n                ]);\n            case 'value':\n                return new IntervalScale();\n            // Extended scale, like time and log\n            default:\n                return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !(min > 0 && max > 0 || min < 0 && max < 0);\n    };\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // 不同角的axis和label，不只是horizontal和vertical.\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(labels[i], font, 'center', 'top');\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }    // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            } else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val);\n                };\n            }(labelFormatter);\n            return zrUtil.map(labels, labelFormatter);\n        } else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(axis.type === 'category' ? scale.getLabel(tick) : tick, idx);\n            }, this);\n        } else {\n            return labels;\n        }\n    };\n    return axisHelper;\n});\ndefine('echarts/coord/cartesian/Cartesian2D', ['require', 'zrender/core/util', './Cartesian'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var Cartesian = require('./Cartesian');\n    function Cartesian2D(name) {\n        Cartesian.call(this, name);\n    }\n    Cartesian2D.prototype = {\n        constructor: Cartesian2D,\n        type: 'cartesian2d',\n        dimensions: [\n            'x',\n            'y'\n        ],\n        getBaseAxis: function () {\n            return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n        },\n        containPoint: function (point) {\n            var axisX = this.getAxis('x');\n            var axisY = this.getAxis('y');\n            return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n        },\n        containData: function (data) {\n            return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n        },\n        dataToPoints: function (data, stack) {\n            return data.mapArray([\n                'x',\n                'y'\n            ], function (x, y) {\n                return this.dataToPoint([\n                    x,\n                    y\n                ]);\n            }, stack, this);\n        },\n        dataToPoint: function (data, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n            ];\n        },\n        pointToData: function (point, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n            ];\n        },\n        getOtherAxis: function (axis) {\n            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n        }\n    };\n    zrUtil.inherits(Cartesian2D, Cartesian);\n    return Cartesian2D;\n});\ndefine('echarts/coord/cartesian/Axis2D', ['require', 'zrender/core/util', '../Axis', './axisLabelInterval'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var Axis = require('../Axis');\n    var axisLabelInterval = require('./axisLabelInterval');\n    /**\n     * Extend axis 2d\n     * @constructor module:echarts/coord/cartesian/Axis2D\n     * @extends {module:echarts/coord/cartesian/Axis}\n     * @param {string} dim\n     * @param {*} scale\n     * @param {Array.<number>} coordExtent\n     * @param {string} axisType\n     * @param {string} position\n     */\n    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n        Axis.call(this, dim, scale, coordExtent);\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = axisType || 'value';\n        /**\n         * Axis position\n         *  - 'top'\n         *  - 'bottom'\n         *  - 'left'\n         *  - 'right'\n         */\n        this.position = position || 'bottom';\n    };\n    Axis2D.prototype = {\n        constructor: Axis2D,\n        index: 0,\n        onZero: false,\n        model: null,\n        isHorizontal: function () {\n            var position = this.position;\n            return position === 'top' || position === 'bottom';\n        },\n        getGlobalExtent: function () {\n            var ret = this.getExtent();\n            ret[0] = this.toGlobalCoord(ret[0]);\n            ret[1] = this.toGlobalCoord(ret[1]);\n            return ret;\n        },\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                labelInterval = this._labelInterval = axisLabelInterval(this);\n            }\n            return labelInterval;\n        },\n        isLabelIgnored: function (idx) {\n            if (this.type === 'category') {\n                var labelInterval = this.getLabelInterval();\n                return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);\n            }\n        },\n        toLocalCoord: null,\n        toGlobalCoord: null\n    };\n    zrUtil.inherits(Axis2D, Axis);\n    return Axis2D;\n});\ndefine('echarts/coord/cartesian/GridModel', ['require', './AxisModel', '../../model/Component'], function (require) {\n    'use strict';\n    require('./AxisModel');\n    var ComponentModel = require('../../model/Component');\n    return ComponentModel.extend({\n        type: 'grid',\n        dependencies: [\n            'xAxis',\n            'yAxis'\n        ],\n        layoutMode: 'box',\n        coordinateSystem: null,\n        defaultOption: {\n            show: false,\n            zlevel: 0,\n            z: 0,\n            left: '10%',\n            top: 60,\n            right: '10%',\n            bottom: 60,\n            containLabel: false,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderWidth: 1,\n            borderColor: '#ccc'\n        }\n    });\n});\ndefine('zrender/tool/path', ['require', '../graphic/Path', '../core/PathProxy', './transformPath', '../core/matrix'], function (require) {\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n    var transformPath = require('./transformPath');\n    var matrix = require('../core/matrix');\n    // command chars\n    var cc = [\n            'm',\n            'M',\n            'l',\n            'L',\n            'v',\n            'V',\n            'h',\n            'H',\n            'z',\n            'Z',\n            'c',\n            'C',\n            'q',\n            'Q',\n            't',\n            'T',\n            's',\n            'S',\n            'a',\n            'A'\n        ];\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n    var vMag = function (v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function (u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function (u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n    };\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180);\n        var xp = mathCos(psi) * (x1 - x2) / 2 + mathSin(psi) * (y1 - y2) / 2;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2 + mathCos(psi) * (y1 - y2) / 2;\n        var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n        var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n        var cx = (x1 + x2) / 2 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n        var theta = vAngle([\n                1,\n                0\n            ], [\n                (xp - cxp) / rx,\n                (yp - cyp) / ry\n            ]);\n        var u = [\n                (xp - cxp) / rx,\n                (yp - cyp) / ry\n            ];\n        var v = [\n                (-1 * xp - cxp) / rx,\n                (-1 * yp - cyp) / ry\n            ];\n        var dTheta = vAngle(u, v);\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n        // command string\n        var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n                var x1 = cpx;\n                var y1 = cpy;\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                case 'l':\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'L':\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'm':\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.M;\n                    path.addData(cmd, cpx, cpy);\n                    c = 'l';\n                    break;\n                case 'M':\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.M;\n                    path.addData(cmd, cpx, cpy);\n                    c = 'L';\n                    break;\n                case 'h':\n                    cpx += p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'H':\n                    cpx = p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'v':\n                    cpy += p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'V':\n                    cpy = p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'C':\n                    cmd = CMD.C;\n                    path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n                    cpx = p[off - 2];\n                    cpy = p[off - 1];\n                    break;\n                case 'c':\n                    cmd = CMD.C;\n                    path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n                    cpx += p[off - 2];\n                    cpy += p[off - 1];\n                    break;\n                case 'S':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.C) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cmd = CMD.C;\n                    x1 = p[off++];\n                    y1 = p[off++];\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                    break;\n                case 's':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.C) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cmd = CMD.C;\n                    x1 = cpx + p[off++];\n                    y1 = cpy + p[off++];\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                    break;\n                case 'Q':\n                    x1 = p[off++];\n                    y1 = p[off++];\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, x1, y1, cpx, cpy);\n                    break;\n                case 'q':\n                    x1 = p[off++] + cpx;\n                    y1 = p[off++] + cpy;\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, x1, y1, cpx, cpy);\n                    break;\n                case 'T':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.Q) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                    break;\n                case 't':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.Q) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                    break;\n                case 'A':\n                    rx = p[off++];\n                    ry = p[off++];\n                    psi = p[off++];\n                    fa = p[off++];\n                    fs = p[off++];\n                    x1 = cpx, y1 = cpy;\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.A;\n                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n                    break;\n                case 'a':\n                    rx = p[off++];\n                    ry = p[off++];\n                    psi = p[off++];\n                    fa = p[off++];\n                    fs = p[off++];\n                    x1 = cpx, y1 = cpy;\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.A;\n                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n                    break;\n                }\n            }\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n            prevCmd = cmd;\n        }\n        path.toStatic();\n        return path;\n    }\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        var transform;\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            path.setData(pathProxy.data);\n            transform && transformPath(path, transform);\n            // Svg and vml renderer don't have context\n            var ctx = path.getContext();\n            if (ctx) {\n                path.rebuildPath(ctx);\n            }\n        };\n        opts.applyTransform = function (m) {\n            if (!transform) {\n                transform = matrix.create();\n            }\n            matrix.mul(transform, m, transform);\n            this.dirty(true);\n        };\n        return opts;\n    }\n    return {\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (pathEl.__dirty) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n            var pathBundle = new Path(opts);\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n            return pathBundle;\n        }\n    };\n});\ndefine('zrender/graphic/Path', ['require', './Displayable', '../core/util', '../core/PathProxy', '../contain/path', './Pattern'], function (require) {\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n    var Pattern = require('./Pattern');\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n    var abs = Math.abs;\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = new PathProxy();\n    }\n    Path.prototype = {\n        constructor: Path,\n        type: 'path',\n        __dirtyPath: true,\n        strokeContainThreshold: 5,\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!fill.colorStops;\n            var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n            var hasFillPattern = hasFill && !!fill.image;\n            var hasStrokePattern = hasStroke && !!stroke.image;\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n            if (this.__dirty) {\n                var rect = this.getBoundingRect();\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            } else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            } else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n            var ctxLineDash = !!ctx.setLineDash;\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n                path = this.path.beginPath(ctx);\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n                this.buildPath(path, this.shape, false);\n                // Clear path dirty flag\n                this.__dirtyPath = false;\n            } else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n            hasFill && path.fill(ctx);\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n            hasStroke && path.stroke(ctx);\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n            this.restoreTransform(ctx);\n            // Draw rect text\n            if (style.text || style.text === 0) {\n                // var rect = this.getBoundingRect();\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n        buildPath: function (ctx, shapeCfg, inBundle) {\n        },\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n            return rect;\n        },\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            } else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        shape[name] = key[name];\n                    }\n                } else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n        }\n    };\n    /**\n     * 扩展一个 Path element, 比如星形，圆等。\n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n            defaults.init && defaults.init.call(this, opts);\n        };\n        zrUtil.inherits(Sub, Path);\n        // FIXME 不能 extend position, rotation 等引用对象\n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n        return Sub;\n    };\n    zrUtil.inherits(Path, Displayable);\n    return Path;\n});\ndefine('zrender/graphic/Gradient', ['require'], function (require) {\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n        this.colorStops = colorStops || [];\n    };\n    Gradient.prototype = {\n        constructor: Gradient,\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n                offset: offset,\n                color: color\n            });\n        }\n    };\n    return Gradient;\n});\ndefine('zrender/container/Group', ['require', '../core/util', '../Element', '../core/BoundingRect'], function (require) {\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n        opts = opts || {};\n        Element.call(this, opts);\n        for (var key in opts) {\n            this[key] = opts[key];\n        }\n        this._children = [];\n        this.__storage = null;\n        this.__dirty = true;\n    };\n    Group.prototype = {\n        constructor: Group,\n        isGroup: true,\n        type: 'group',\n        silent: false,\n        children: function () {\n            return this._children.slice();\n        },\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n            }\n        },\n        childCount: function () {\n            return this._children.length;\n        },\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n                this._children.push(child);\n                this._doAdd(child);\n            }\n            return this;\n        },\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n            return this;\n        },\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n            child.parent = this;\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n            zr && zr.refresh();\n        },\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n            child.parent = null;\n            if (storage) {\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n            zr && zr.refresh();\n            return this;\n        },\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromMap(child.id);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n            return this;\n        },\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            // TODO Transform\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                } else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n    zrUtil.inherits(Group, Element);\n    return Group;\n});\ndefine('zrender/graphic/Text', ['require', './Displayable', '../core/util', '../contain/text'], function (require) {\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var textContain = require('../contain/text');\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n    Text.prototype = {\n        constructor: Text,\n        type: 'text',\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n            if (text) {\n                this.setTransform(ctx);\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(text, font, style.textAlign, 'top');\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                    case 'middle':\n                        y -= rect.height / 2 - rect.lineHeight / 2;\n                        break;\n                    case 'bottom':\n                        y -= rect.height - rect.lineHeight / 2;\n                        break;\n                    default:\n                        y += rect.lineHeight / 2;\n                    }\n                } else {\n                    textBaseline = style.textBaseline;\n                }\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n                var lineHeight = textContain.measureText('国', ctx.font).width;\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n                this.restoreTransform(ctx);\n            }\n        },\n        getBoundingRect: function () {\n            if (!this._rect) {\n                var style = this.style;\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(style.text + '', style.textFont || style.font, style.textAlign, textVerticalAlign ? 'top' : style.textBaseline);\n                switch (textVerticalAlign) {\n                case 'middle':\n                    rect.y -= rect.height / 2;\n                    break;\n                case 'bottom':\n                    rect.y -= rect.height;\n                    break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                this._rect = rect;\n            }\n            return this._rect;\n        }\n    };\n    zrUtil.inherits(Text, Displayable);\n    return Text;\n});\ndefine('zrender/graphic/Image', ['require', './Displayable', '../core/BoundingRect', '../core/util', '../core/LRU'], function (require) {\n    var Displayable = require('./Displayable');\n    var BoundingRect = require('../core/BoundingRect');\n    var zrUtil = require('../core/util');\n    var LRU = require('../core/LRU');\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n    ZImage.prototype = {\n        constructor: ZImage,\n        type: 'image',\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }    // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                } else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n            if (image) {\n                // 图片已经加载完成\n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n                var width = style.width || image.width;\n                var height = style.height || image.height;\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // 图片加载失败\n                if (!image.width || !image.height) {\n                    return;\n                }\n                // 设置transform\n                this.setTransform(ctx);\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n                } else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n                } else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n                // 如果没设置宽和高的话自动根据图片宽高设置\n                if (style.width == null) {\n                    style.width = width;\n                }\n                if (style.height == null) {\n                    style.height = height;\n                }\n                this.restoreTransform(ctx);\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n            }\n        },\n        getBoundingRect: function () {\n            var style = this.style;\n            if (!this._rect) {\n                this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n            }\n            return this._rect;\n        }\n    };\n    zrUtil.inherits(ZImage, Displayable);\n    return ZImage;\n});\ndefine('zrender/graphic/shape/Circle', ['require', '../Path'], function (require) {\n    'use strict';\n    return require('../Path').extend({\n        type: 'circle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n        buildPath: function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Ring', ['require', '../Path'], function (require) {\n    return require('../Path').extend({\n        type: 'ring',\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Sector', ['require', '../Path'], function (require) {\n    return require('../Path').extend({\n        type: 'sector',\n        shape: {\n            cx: 0,\n            cy: 0,\n            r0: 0,\n            r: 0,\n            startAngle: 0,\n            endAngle: Math.PI * 2,\n            clockwise: true\n        },\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n            ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n            ctx.closePath();\n        }\n    });\n});\ndefine('zrender/graphic/shape/Rect', ['require', '../helper/roundRect', '../Path'], function (require) {\n    var roundRectHelper = require('../helper/roundRect');\n    return require('../Path').extend({\n        type: 'rect',\n        shape: {\n            r: 0,\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            } else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n});\ndefine('zrender/graphic/shape/Polygon', ['require', '../helper/poly', '../Path'], function (require) {\n    var polyHelper = require('../helper/poly');\n    return require('../Path').extend({\n        type: 'polygon',\n        shape: {\n            points: null,\n            smooth: false,\n            smoothConstraint: null\n        },\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Polyline', ['require', '../helper/poly', '../Path'], function (require) {\n    var polyHelper = require('../helper/poly');\n    return require('../Path').extend({\n        type: 'polyline',\n        shape: {\n            points: null,\n            smooth: false,\n            smoothConstraint: null\n        },\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Line', ['require', '../Path'], function (require) {\n    return require('../Path').extend({\n        type: 'line',\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            percent: 1\n        },\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n            ctx.moveTo(x1, y1);\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n});\ndefine('zrender/graphic/shape/BezierCurve', ['require', '../../core/curve', '../../core/vector', '../Path'], function (require) {\n    'use strict';\n    var curveTool = require('../../core/curve');\n    var vec2 = require('../../core/vector');\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n    var out = [];\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        } else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    return require('../Path').extend({\n        type: 'bezier-curve',\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            percent: 1\n        },\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n            ctx.moveTo(x1, y1);\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(x1, cpx1, x2, percent, out);\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(y1, cpy1, y2, percent, out);\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n                ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n            } else {\n                if (percent < 1) {\n                    cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n            }\n        },\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Arc', ['require', '../Path'], function (require) {\n    return require('../Path').extend({\n        type: 'arc',\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            startAngle: 0,\n            endAngle: Math.PI * 2,\n            clockwise: true\n        },\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n});\ndefine('zrender/graphic/RadialGradient', ['require', '../core/util', './Gradient'], function (require) {\n    'use strict';\n    var zrUtil = require('../core/util');\n    var Gradient = require('./Gradient');\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        this.x = x == null ? 0.5 : x;\n        this.y = y == null ? 0.5 : y;\n        this.r = r == null ? 0.5 : r;\n        // Can be cloned\n        this.type = 'radial';\n        // If use global coord\n        this.global = globalCoord || false;\n        Gradient.call(this, colorStops);\n    };\n    RadialGradient.prototype = { constructor: RadialGradient };\n    zrUtil.inherits(RadialGradient, Gradient);\n    return RadialGradient;\n});\ndefine('zrender/graphic/LinearGradient', ['require', '../core/util', './Gradient'], function (require) {\n    'use strict';\n    var zrUtil = require('../core/util');\n    var Gradient = require('./Gradient');\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        this.x = x == null ? 0 : x;\n        this.y = y == null ? 0 : y;\n        this.x2 = x2 == null ? 1 : x2;\n        this.y2 = y2 == null ? 0 : y2;\n        // Can be cloned\n        this.type = 'linear';\n        // If use global coord\n        this.global = globalCoord || false;\n        Gradient.call(this, colorStops);\n    };\n    LinearGradient.prototype = { constructor: LinearGradient };\n    zrUtil.inherits(LinearGradient, Gradient);\n    return LinearGradient;\n});\ndefine('zrender/graphic/CompoundPath', ['require', './Path'], function (require) {\n    var Path = require('./Path');\n    return Path.extend({\n        type: 'compound',\n        shape: { paths: null },\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n});\ndefine('zrender/core/BoundingRect', ['require', './vector', './matrix'], function (require) {\n    'use strict';\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathAbs = Math.abs;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n    BoundingRect.prototype = {\n        constructor: BoundingRect,\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n            this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n            this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n            this.x = x;\n            this.y = y;\n        },\n        applyTransform: function () {\n            var min = [];\n            var max = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                min[0] = this.x;\n                min[1] = this.y;\n                max[0] = this.x + this.width;\n                max[1] = this.y + this.height;\n                v2ApplyTransform(min, min, m);\n                v2ApplyTransform(max, max, m);\n                this.x = mathMin(min[0], max[0]);\n                this.y = mathMin(min[1], max[1]);\n                this.width = mathAbs(max[0] - min[0]);\n                this.height = mathAbs(max[1] - min[1]);\n            };\n        }(),\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n            var m = matrix.create();\n            // 矩阵右乘\n            matrix.translate(m, m, [\n                -a.x,\n                -a.y\n            ]);\n            matrix.scale(m, m, [\n                sx,\n                sy\n            ]);\n            matrix.translate(m, m, [\n                b.x,\n                b.y\n            ]);\n            return m;\n        },\n        intersect: function (b) {\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n            return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n        },\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        }\n    };\n    return BoundingRect;\n});\ndefine('zrender/contain/text', ['require', '../core/util', '../core/BoundingRect'], function (require) {\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n    var retrieve = util.retrieve;\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText 可以被覆盖以兼容不支持 Canvas 的环境\n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n        return width;\n    }\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n        var width = getTextWidth(text, textFont);\n        // FIXME 高度计算比较粗暴\n        var lineHeight = getTextWidth('国', textFont);\n        var height = textLineLen * lineHeight;\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n        switch (textBaseline) {\n        case 'bottom':\n        case 'alphabetic':\n            rect.y -= lineHeight;\n            break;\n        case 'middle':\n            rect.y -= lineHeight / 2;\n            break;    // case 'hanging':\n                      // case 'top':\n        }\n        // FIXME Right to left language\n        switch (textAlign) {\n        case 'end':\n        case 'right':\n            rect.x -= rect.width;\n            break;\n        case 'center':\n            rect.x -= rect.width / 2;\n            break;    // case 'start':\n                      // case 'left':\n        }\n        return rect;\n    }\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n        var x = rect.x;\n        var y = rect.y;\n        var height = rect.height;\n        var width = rect.width;\n        var textHeight = textRect.height;\n        var halfHeight = height / 2 - textHeight / 2;\n        var textAlign = 'left';\n        switch (textPosition) {\n        case 'left':\n            x -= distance;\n            y += halfHeight;\n            textAlign = 'right';\n            break;\n        case 'right':\n            x += distance + width;\n            y += halfHeight;\n            textAlign = 'left';\n            break;\n        case 'top':\n            x += width / 2;\n            y -= distance + textHeight;\n            textAlign = 'center';\n            break;\n        case 'bottom':\n            x += width / 2;\n            y += height + distance;\n            textAlign = 'center';\n            break;\n        case 'inside':\n            x += width / 2;\n            y += halfHeight;\n            textAlign = 'center';\n            break;\n        case 'insideLeft':\n            x += distance;\n            y += halfHeight;\n            textAlign = 'left';\n            break;\n        case 'insideRight':\n            x += width - distance;\n            y += halfHeight;\n            textAlign = 'right';\n            break;\n        case 'insideTop':\n            x += width / 2;\n            y += distance;\n            textAlign = 'center';\n            break;\n        case 'insideBottom':\n            x += width / 2;\n            y += height - textHeight - distance;\n            textAlign = 'center';\n            break;\n        case 'insideTopLeft':\n            x += distance;\n            y += distance;\n            textAlign = 'left';\n            break;\n        case 'insideTopRight':\n            x += width - distance;\n            y += distance;\n            textAlign = 'right';\n            break;\n        case 'insideBottomLeft':\n            x += distance;\n            y += height - textHeight - distance;\n            break;\n        case 'insideBottomRight':\n            x += width - distance;\n            y += height - textHeight - distance;\n            textAlign = 'right';\n            break;\n        }\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'top'\n        };\n    }\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n        options = options || {};\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('国', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1);\n        // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n        contentWidth = containerWidth - ellipsisWidth;\n        var textLines = (text + '').split('\\n');\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n                var subLength = j === 0 ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n            textLines[i] = textLine;\n        }\n        return textLines.join('\\n');\n    }\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n    var textContain = {\n            getWidth: getTextWidth,\n            getBoundingRect: getTextRect,\n            adjustTextPositionOnRect: adjustTextPositionOnRect,\n            truncateText: truncateText,\n            measureText: function (text, textFont) {\n                var ctx = util.getContext();\n                ctx.font = textFont || '12px sans-serif';\n                return ctx.measureText(text);\n            }\n        };\n    return textContain;\n});\ndefine('echarts/util/model', ['require', './format', './number', '../model/Model', 'zrender/core/util'], function (require) {\n    var formatUtil = require('./format');\n    var nubmerUtil = require('./number');\n    var Model = require('../model/Model');\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = {};\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array ? value : value == null ? [] : [value];\n    };\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             textStyle: {\n     *                 fontSize: 18\n     *             }\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n    modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n            // Default emphasis option from normal\n            zrUtil.each(subOpts, function (subOptName) {\n                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n                if (val != null) {\n                    emphasisOpt[subOptName] = val;\n                }\n            });\n        }\n    };\n    modelUtil.LABEL_OPTIONS = [\n        'position',\n        'show',\n        'textStyle',\n        'distance',\n        'formatter'\n    ];\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return zrUtil.isObject(dataItem) && !(dataItem instanceof Array);    // // markLine data can be array\n                                                                             // && !(dataItem[0] && zrUtil.isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {\n            value = +nubmerUtil.parseDate(value);\n        }\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return value == null || value === '' ? NaN : +value;    // If string (like '-'), using '+' parse to NaN\n    };\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n            var seriesIndex = this.seriesIndex;\n            var seriesName = this.name;\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: seriesIndex,\n                seriesName: seriesName,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: data.getItemVisual(dataIndex, 'color'),\n                $vars: [\n                    'seriesName',\n                    'name',\n                    'value'\n                ]\n            };\n        },\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && params.value instanceof Array) {\n                params.value = params.value[dimIndex];\n            }\n            var formatter = itemModel.get([\n                    'label',\n                    status,\n                    'formatter'\n                ]);\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            } else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return zrUtil.isObject(dataItem) && !(dataItem instanceof Array) ? dataItem.value : dataItem;\n            }\n        },\n        formatTooltip: zrUtil.noop\n    };\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n        var result = zrUtil.map(exists || [], function (obj, index) {\n                return { exist: obj };\n            });\n        // Mapping by id or name if specified.\n        zrUtil.each(newCptOptions, function (cptOption, index) {\n            if (!zrUtil.isObject(cptOption)) {\n                return;\n            }\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option && cptOption.id != null && result[i].exist.id === cptOption.id + '') {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option && (exist.id == null || cptOption.id == null) && cptOption.name != null && !modelUtil.isIdInner(cptOption) && !modelUtil.isIdInner(exist) && exist.name === cptOption.name + '') {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n        // Otherwise mapping by index.\n        zrUtil.each(newCptOptions, function (cptOption, index) {\n            if (!zrUtil.isObject(cptOption)) {\n                return;\n            }\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option && !modelUtil.isIdInner(exist) && cptOption.id == null) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n            if (i >= result.length) {\n                result.push({ option: cptOption });\n            }\n        });\n        return result;\n    };\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return zrUtil.isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\u0000_ec_\u0000') === 0;\n    };\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n        return [\n            mapToArray(mapA),\n            mapToArray(mapB)\n        ];\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    } else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    } else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({\n                            seriesId: i,\n                            dataIndex: dataIndices\n                        });\n                    }\n                }\n            }\n            return result;\n        }\n    };\n    return modelUtil;\n});\ndefine('echarts/model/globalDefault', [], function () {\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    return {\n        color: [\n            '#c23531',\n            '#2f4554',\n            '#61a0a8',\n            '#d48265',\n            '#91c7ae',\n            '#749f83',\n            '#ca8622',\n            '#bda29a',\n            '#6e7074',\n            '#546570',\n            '#c4ccd3'\n        ],\n        textStyle: {\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n        blendMode: null,\n        animation: true,\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n        animationThreshold: 2000,\n        progressiveThreshold: 3000,\n        progressive: 400,\n        hoverLayerThreshold: 3000\n    };\n});\ndefine('echarts/model/mixin/colorPalette', [], function () {\n    return {\n        clearColorPalette: function () {\n            this._colorIdx = 0;\n            this._colorNameMap = {};\n        },\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = scope._colorIdx || 0;\n            var colorNameMap = scope._colorNameMap || (scope._colorNameMap = {});\n            if (colorNameMap[name]) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            scope._colorIdx = (colorIdx + 1) % colorPalette.length;\n            return color;\n        }\n    };\n});\ndefine('zrender/core/PathProxy', ['require', './curve', './vector', './bbox', './BoundingRect', '../config'], function (require) {\n    'use strict';\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n    var dpr = require('../config').devicePixelRatio;\n    var CMD = {\n            M: 1,\n            L: 2,\n            C: 3,\n            Q: 4,\n            A: 5,\n            Z: 6,\n            R: 7\n        };\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n    var hasTypedArray = typeof Float32Array != 'undefined';\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function () {\n        /**\n         * Path data. Stored as flat array\n         * @type {Array.<Object>}\n         */\n        this.data = [];\n        this._len = 0;\n        this._ctx = null;\n        this._xi = 0;\n        this._yi = 0;\n        this._x0 = 0;\n        this._y0 = 0;\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        this._ux = 0;\n        this._uy = 0;\n    };\n    /**\n     * 快速计算Path包围盒（并不是最小包围盒）\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n        constructor: PathProxy,\n        _lineDash: null,\n        _dashOffset: 0,\n        _dashIdx: 0,\n        _dashSum: 0,\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n        getContext: function () {\n            return this._ctx;\n        },\n        beginPath: function (ctx) {\n            this._ctx = ctx;\n            ctx && ctx.beginPath();\n            ctx && (this.dpr = ctx.dpr);\n            // Reset\n            this._len = 0;\n            if (this._lineDash) {\n                this._lineDash = null;\n                this._dashOffset = 0;\n            }\n            return this;\n        },\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n            this._x0 = x;\n            this._y0 = y;\n            this._xi = x;\n            this._yi = y;\n            return this;\n        },\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy || this._len < 5;\n            this.addData(CMD.L, x, y);\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n            return this;\n        },\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n            this._xi = mathCos(endAngle) * r + cx;\n            this._xi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n        closePath: function () {\n            this.addData(CMD.Z);\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n                this._dashIdx = 0;\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n        len: function () {\n            return this._len;\n        },\n        setData: function (data) {\n            var len = data.length;\n            if (!(this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n            this._len = len;\n        },\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && this.data instanceof Float32Array) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n        addData: function (cmd) {\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                // 因为之前的数组已经转换成静态的 Float32Array\n                // 所以不够用时需要扩展一个新的动态数组\n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n            this._prevCmd = cmd;\n        },\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n        _needsDash: function () {\n            return this._lineDash;\n        },\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n            while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n            var x;\n            var y;\n            var tmpLen = 0;\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n            while (t <= 1) {\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n                t += lineDash[idx] / bezierLen;\n                idx = (idx + 1) % nDash;\n            }\n            // Finish the last segment and calculate the new offset\n            idx % 2 !== 0 && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = data[i];\n                    yi = data[i + 1];\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                case CMD.M:\n                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                    // 在 closePath 的时候使用\n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    min2[0] = x0;\n                    min2[1] = y0;\n                    max2[0] = x0;\n                    max2[1] = y0;\n                    break;\n                case CMD.L:\n                    bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc 判断的开销比较大\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var startAngle = data[i++];\n                    var endAngle = data[i++] + startAngle;\n                    // TODO Arc 旋转\n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    if (i == 1) {\n                        // 直接使用 arc 命令\n                        // 第一个命令起点还未定义\n                        x0 = mathCos(startAngle) * rx + cx;\n                        y0 = mathSin(startAngle) * ry + cy;\n                    }\n                    bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n                    xi = mathCos(endAngle) * rx + cx;\n                    yi = mathSin(endAngle) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    // Use fromLine\n                    bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                    break;\n                case CMD.Z:\n                    xi = x0;\n                    yi = y0;\n                    break;\n                }\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n            return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n        },\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = d[i];\n                    yi = d[i + 1];\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                case CMD.M:\n                    x0 = xi = d[i++];\n                    y0 = yi = d[i++];\n                    ctx.moveTo(xi, yi);\n                    break;\n                case CMD.L:\n                    x = d[i++];\n                    y = d[i++];\n                    // Not draw too small seg between\n                    if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                        ctx.lineTo(x, y);\n                        xi = x;\n                        yi = y;\n                    }\n                    break;\n                case CMD.C:\n                    ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n                    xi = d[i - 2];\n                    yi = d[i - 1];\n                    break;\n                case CMD.Q:\n                    ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                    xi = d[i - 2];\n                    yi = d[i - 1];\n                    break;\n                case CMD.A:\n                    var cx = d[i++];\n                    var cy = d[i++];\n                    var rx = d[i++];\n                    var ry = d[i++];\n                    var theta = d[i++];\n                    var dTheta = d[i++];\n                    var psi = d[i++];\n                    var fs = d[i++];\n                    var r = rx > ry ? rx : ry;\n                    var scaleX = rx > ry ? 1 : rx / ry;\n                    var scaleY = rx > ry ? ry / rx : 1;\n                    var isEllipse = Math.abs(rx - ry) > 0.001;\n                    var endAngle = theta + dTheta;\n                    if (isEllipse) {\n                        ctx.translate(cx, cy);\n                        ctx.rotate(psi);\n                        ctx.scale(scaleX, scaleY);\n                        ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                        ctx.scale(1 / scaleX, 1 / scaleY);\n                        ctx.rotate(-psi);\n                        ctx.translate(-cx, -cy);\n                    } else {\n                        ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                    }\n                    if (i == 1) {\n                        // 直接使用 arc 命令\n                        // 第一个命令起点还未定义\n                        x0 = mathCos(theta) * rx + cx;\n                        y0 = mathSin(theta) * ry + cy;\n                    }\n                    xi = mathCos(endAngle) * rx + cx;\n                    yi = mathSin(endAngle) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = d[i];\n                    y0 = yi = d[i + 1];\n                    ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                    break;\n                case CMD.Z:\n                    ctx.closePath();\n                    xi = x0;\n                    yi = y0;\n                }\n            }\n        }\n    };\n    PathProxy.CMD = CMD;\n    return PathProxy;\n});\ndefine('zrender/tool/transformPath', ['require', '../core/PathProxy', '../core/vector'], function (require) {\n    var CMD = require('../core/PathProxy').CMD;\n    var vec2 = require('../core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n    var points = [\n            [],\n            [],\n            []\n        ];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n            switch (cmd) {\n            case M:\n                nPoint = 1;\n                break;\n            case L:\n                nPoint = 1;\n                break;\n            case C:\n                nPoint = 3;\n                break;\n            case Q:\n                nPoint = 2;\n                break;\n            case A:\n                var x = m[4];\n                var y = m[5];\n                var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                // cx\n                data[i++] += x;\n                // cy\n                data[i++] += y;\n                // Scale rx and ry\n                // FIXME Assume psi is 0 here\n                data[i++] *= sx;\n                data[i++] *= sy;\n                // Start angle\n                data[i++] += angle;\n                // end angle\n                data[i++] += angle;\n                // FIXME psi\n                i += 2;\n                j = i;\n                break;\n            case R:\n                // x0, y0\n                p[0] = data[i++];\n                p[1] = data[i++];\n                v2ApplyTransform(p, p, m);\n                data[j++] = p[0];\n                data[j++] = p[1];\n                // x1, y1\n                p[0] += data[i++];\n                p[1] += data[i++];\n                v2ApplyTransform(p, p, m);\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n    return transformPath;\n});\ndefine('echarts/util/clazz', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var clazz = {};\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    /**\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n            var ret = {\n                    main: '',\n                    sub: ''\n                };\n            if (componentType) {\n                componentType = componentType.split(TYPE_DELIMITER);\n                ret.main = componentType[0] || '';\n                ret.sub = componentType[1] || '';\n            }\n            return ret;\n        };\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass) {\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                } else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n            zrUtil.extend(ExtendedClass.prototype, proto);\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n            return ExtendedClass;\n        };\n    };\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                componentType = parseClassType(componentType);\n                if (!componentType.sub) {\n                    if (true) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                } else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\n            var Clazz = storage[componentTypeMain];\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error('Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.');\n            }\n            return Clazz;\n        };\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n            var result = [];\n            var obj = storage[componentType.main];\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            } else {\n                result.push(obj);\n            }\n            return result;\n        };\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n        entity.parseClassType = parseClassType;\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n        return entity;\n    };\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n    };\n    return clazz;\n});\ndefine('zrender/graphic/Displayable', ['require', '../core/util', './Style', '../Element', './mixin/RectText'], function (require) {\n    var zrUtil = require('../core/util');\n    var Style = require('./Style');\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n        opts = opts || {};\n        Element.call(this, opts);\n        // Extend properties\n        for (var name in opts) {\n            if (opts.hasOwnProperty(name) && name !== 'style') {\n                this[name] = opts[name];\n            }\n        }\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];    // FIXME Stateful must be mixined after style is setted\n                                  // Stateful.call(this, opts);\n    }\n    Displayable.prototype = {\n        constructor: Displayable,\n        type: 'displayable',\n        __dirty: true,\n        invisible: false,\n        z: 0,\n        z2: 0,\n        zlevel: 0,\n        draggable: false,\n        dragging: false,\n        silent: false,\n        culling: false,\n        cursor: 'pointer',\n        rectHover: false,\n        progressive: -1,\n        beforeBrush: function (ctx) {\n        },\n        afterBrush: function (ctx) {\n        },\n        brush: function (ctx, prevEl) {\n        },\n        getBoundingRect: function () {\n        },\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n        dirty: function () {\n            this.__dirty = true;\n            this._rect = null;\n            this.__zr && this.__zr.refresh();\n        },\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            } else {\n                this.style.set(value);\n            }\n        },\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n    zrUtil.inherits(Displayable, Element);\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n    return Displayable;\n});\ndefine('zrender/contain/path', ['require', '../core/PathProxy', './line', './cubic', './quadratic', './arc', './util', '../core/curve', './windingLine'], function (require) {\n    'use strict';\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n    var windingLine = require('./windingLine');\n    var containStroke = line.containStroke;\n    var PI2 = Math.PI * 2;\n    var EPSILON = 0.0001;\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n    // 临时数组\n    var roots = [\n            -1,\n            -1,\n            -1\n        ];\n    var extrema = [\n            -1,\n            -1\n        ];\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        } else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = t === 0 || t === 1 ? 0.5 : 1;\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) {\n                    // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // 分成三段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    } else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    } else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                } else {\n                    // 分成两段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    } else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        } else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {\n                        // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    } else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            } else {\n                // Remove one endpoint.\n                var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {\n                    // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n    // TODO\n    // Arc 旋转\n    function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 0.0001) {\n            return 0;\n        }\n        if (diff % PI2 < 0.0001) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        } else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }    // 如果被任何一个 subpath 包含\n                     // if (w !== 0) {\n                     //     return true;\n                     // }\n            }\n            if (i == 1) {\n                // 如果第一个命令是 L, C, Q\n                // 则 previous point 同绘制命令的第一个 point\n                //\n                // 第一个命令为 Arc 的情况下会在后面特殊处理\n                xi = data[i];\n                yi = data[i + 1];\n                x0 = xi;\n                y0 = yi;\n            }\n            switch (cmd) {\n            case CMD.M:\n                // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                // 在 closePath 的时候使用\n                x0 = data[i++];\n                y0 = data[i++];\n                xi = x0;\n                yi = y0;\n                break;\n            case CMD.L:\n                if (isStroke) {\n                    if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n                    w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                }\n                xi = data[i++];\n                yi = data[i++];\n                break;\n            case CMD.C:\n                if (isStroke) {\n                    if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n                }\n                xi = data[i++];\n                yi = data[i++];\n                break;\n            case CMD.Q:\n                if (isStroke) {\n                    if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n                }\n                xi = data[i++];\n                yi = data[i++];\n                break;\n            case CMD.A:\n                // TODO Arc 判断的开销比较大\n                var cx = data[i++];\n                var cy = data[i++];\n                var rx = data[i++];\n                var ry = data[i++];\n                var theta = data[i++];\n                var dTheta = data[i++];\n                // TODO Arc 旋转\n                var psi = data[i++];\n                var anticlockwise = 1 - data[i++];\n                var x1 = Math.cos(theta) * rx + cx;\n                var y1 = Math.sin(theta) * ry + cy;\n                // 不是直接使用 arc 命令\n                if (i > 1) {\n                    w += windingLine(xi, yi, x1, y1, x, y);\n                } else {\n                    // 第一个命令起点还未定义\n                    x0 = x1;\n                    y0 = y1;\n                }\n                // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n                var _x = (x - cx) * ry / rx + cx;\n                if (isStroke) {\n                    if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n                        return true;\n                    }\n                } else {\n                    w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n                }\n                xi = Math.cos(theta + dTheta) * rx + cx;\n                yi = Math.sin(theta + dTheta) * ry + cy;\n                break;\n            case CMD.R:\n                x0 = xi = data[i++];\n                y0 = yi = data[i++];\n                var width = data[i++];\n                var height = data[i++];\n                var x1 = x0 + width;\n                var y1 = y0 + height;\n                if (isStroke) {\n                    if (containStroke(x0, y0, x1, y0, lineWidth, x, y) || containStroke(x1, y0, x1, y1, lineWidth, x, y) || containStroke(x1, y1, x0, y1, lineWidth, x, y) || containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    // FIXME Clockwise ?\n                    w += windingLine(x1, y0, x1, y1, x, y);\n                    w += windingLine(x0, y1, x0, y0, x, y);\n                }\n                break;\n            case CMD.Z:\n                if (isStroke) {\n                    if (containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    // Close a subpath\n                    w += windingLine(xi, yi, x0, y0, x, y);    // 如果被任何一个 subpath 包含\n                                                               // FIXME subpaths may overlap\n                                                               // if (w !== 0) {\n                                                               //     return true;\n                                                               // }\n                }\n                xi = x0;\n                yi = y0;\n                break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n    return {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n});\ndefine('echarts/model/mixin/lineStyle', ['require', './makeStyleMapper'], function (require) {\n    var getLineStyle = require('./makeStyleMapper')([\n            [\n                'lineWidth',\n                'width'\n            ],\n            [\n                'stroke',\n                'color'\n            ],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]);\n    return {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n        getLineDash: function () {\n            var lineType = this.get('type');\n            return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [\n                5,\n                5\n            ] : [\n                2,\n                2\n            ];\n        }\n    };\n});\ndefine('echarts/scale/Ordinal', ['require', 'zrender/core/util', './Scale'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var Scale = require('./Scale');\n    var scaleProto = Scale.prototype;\n    var OrdinalScale = Scale.extend({\n            type: 'ordinal',\n            init: function (data, extent) {\n                this._data = data;\n                this._extent = extent || [\n                    0,\n                    data.length - 1\n                ];\n            },\n            parse: function (val) {\n                return typeof val === 'string' ? zrUtil.indexOf(this._data, val) : Math.round(val);\n            },\n            contain: function (rank) {\n                rank = this.parse(rank);\n                return scaleProto.contain.call(this, rank) && this._data[rank] != null;\n            },\n            normalize: function (val) {\n                return scaleProto.normalize.call(this, this.parse(val));\n            },\n            scale: function (val) {\n                return Math.round(scaleProto.scale.call(this, val));\n            },\n            getTicks: function () {\n                var ticks = [];\n                var extent = this._extent;\n                var rank = extent[0];\n                while (rank <= extent[1]) {\n                    ticks.push(rank);\n                    rank++;\n                }\n                return ticks;\n            },\n            getLabel: function (n) {\n                return this._data[n];\n            },\n            count: function () {\n                return this._extent[1] - this._extent[0] + 1;\n            },\n            niceTicks: zrUtil.noop,\n            niceExtent: zrUtil.noop\n        });\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n    return OrdinalScale;\n});\ndefine('zrender/graphic/Pattern', ['require'], function (require) {\n    var Pattern = function (image, repeat) {\n        this.image = image;\n        this.repeat = repeat;\n        // Can be cloned\n        this.type = 'pattern';\n    };\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n        return this._canvasPattern || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n    };\n    return Pattern;\n});\ndefine('echarts/model/mixin/areaStyle', ['require', './makeStyleMapper'], function (require) {\n    return {\n        getAreaStyle: require('./makeStyleMapper')([\n            [\n                'fill',\n                'color'\n            ],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['opacity'],\n            ['shadowColor']\n        ])\n    };\n});\ndefine('echarts/model/mixin/textStyle', ['require', 'zrender/contain/text'], function (require) {\n    var textContain = require('zrender/contain/text');\n    function getShallow(model, path) {\n        return model && model.getShallow(path);\n    }\n    return {\n        getTextColor: function () {\n            var ecModel = this.ecModel;\n            return this.getShallow('color') || ecModel && ecModel.get('textStyle.color');\n        },\n        getFont: function () {\n            var ecModel = this.ecModel;\n            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n            return [\n                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n            ].join(' ');\n        },\n        getTextRect: function (text) {\n            var textStyle = this.get('textStyle') || {};\n            return textContain.getBoundingRect(text, this.getFont(), textStyle.align, textStyle.baseline);\n        },\n        truncateText: function (text, containerWidth, ellipsis, options) {\n            return textContain.truncateText(text, containerWidth, this.getFont(), ellipsis, options);\n        }\n    };\n});\ndefine('echarts/model/mixin/itemStyle', ['require', './makeStyleMapper'], function (require) {\n    var getItemStyle = require('./makeStyleMapper')([\n            [\n                'fill',\n                'color'\n            ],\n            [\n                'stroke',\n                'borderColor'\n            ],\n            [\n                'lineWidth',\n                'borderWidth'\n            ],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]);\n    return {\n        getItemStyle: function (excludes) {\n            var style = getItemStyle.call(this, excludes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [\n                5,\n                5\n            ] : [\n                1,\n                1\n            ];\n        }\n    };\n});\ndefine('zrender/graphic/Style', ['require'], function (require) {\n    var STYLE_COMMON_PROPS = [\n            [\n                'shadowBlur',\n                0\n            ],\n            [\n                'shadowOffsetX',\n                0\n            ],\n            [\n                'shadowOffsetY',\n                0\n            ],\n            [\n                'shadowColor',\n                '#000'\n            ],\n            [\n                'lineCap',\n                'butt'\n            ],\n            [\n                'lineJoin',\n                'miter'\n            ],\n            [\n                'miterLimit',\n                10\n            ]\n        ];\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n    function createLinearGradient(ctx, obj, rect) {\n        // var size =\n        var x = obj.x;\n        var x2 = obj.x2;\n        var y = obj.y;\n        var y2 = obj.y2;\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n        return canvasGradient;\n    }\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n        var x = obj.x;\n        var y = obj.y;\n        var r = obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n        return canvasGradient;\n    }\n    Style.prototype = {\n        constructor: Style,\n        fill: '#000000',\n        stroke: null,\n        opacity: 1,\n        lineDash: null,\n        lineDashOffset: 0,\n        shadowBlur: 0,\n        shadowOffsetX: 0,\n        shadowOffsetY: 0,\n        lineWidth: 1,\n        strokeNoScale: false,\n        text: null,\n        textFill: '#000',\n        textStroke: null,\n        textPosition: 'inside',\n        textBaseline: null,\n        textAlign: null,\n        textVerticalAlign: null,\n        textDistance: 5,\n        textShadowBlur: 0,\n        textShadowOffsetX: 0,\n        textShadowOffsetY: 0,\n        textTransform: false,\n        textRotation: 0,\n        blend: null,\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n            if (firstDraw || style.fill !== prevStyle.fill) {\n                ctx.fillStyle = style.fill;\n            }\n            if (firstDraw || style.stroke !== prevStyle.stroke) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if (firstDraw || style.opacity !== prevStyle.opacity) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n            if (firstDraw || style.blend !== prevStyle.blend) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n            }\n        },\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name) && (overwrite || !target.hasOwnProperty(name))) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            } else {\n                this.extendFrom(obj, true);\n            }\n        },\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n            }\n            return canvasGradient;\n        }\n    };\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n    return Style;\n});\ndefine('zrender/graphic/mixin/RectText', ['require', '../../contain/text', '../../core/BoundingRect'], function (require) {\n    var textContain = require('../../contain/text');\n    var BoundingRect = require('../../core/BoundingRect');\n    var tmpRect = new BoundingRect();\n    var RectText = function () {\n    };\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n    RectText.prototype = {\n        constructor: RectText,\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n            // FIXME\n            ctx.save();\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            } else {\n                this.setTransform(ctx);\n            }\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                    case 'middle':\n                        y -= textRect.height / 2 - textRect.lineHeight / 2;\n                        break;\n                    case 'bottom':\n                        y -= textRect.height - textRect.lineHeight / 2;\n                        break;\n                    default:\n                        y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            } else {\n                var res = textContain.adjustTextPositionOnRect(textPosition, rect, textRect, distance);\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n            var textLines = text.split('\\n');\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n            for (var i = 0; i < textLines.length; i++) {\n                textFill && ctx.fillText(textLines[i], x, y);\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n            ctx.restore();\n        }\n    };\n    return RectText;\n});\ndefine('zrender/Element', ['require', './core/guid', './mixin/Eventful', './mixin/Transformable', './mixin/Animatable', './core/util'], function (require) {\n    'use strict';\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n        /**\n         * 画布元素ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n    Element.prototype = {\n        type: 'element',\n        name: '',\n        __zr: null,\n        ignore: false,\n        clipPath: null,\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n            case 'horizontal':\n                dy = 0;\n                break;\n            case 'vertical':\n                dx = 0;\n                break;\n            }\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [\n                    1,\n                    0,\n                    0,\n                    1,\n                    0,\n                    0\n                ];\n            }\n            m[4] += dx;\n            m[5] += dy;\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n        beforeUpdate: function () {\n        },\n        afterUpdate: function () {\n        },\n        update: function () {\n            this.updateTransform();\n        },\n        traverse: function (cb, context) {\n        },\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            } else {\n                this[key] = value;\n            }\n        },\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            } else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n            this.dirty(false);\n            return this;\n        },\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n            this.dirty(false);\n        },\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n                this.dirty(false);\n            }\n        },\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // 添加动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // 移除动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n    return Element;\n});\ndefine('echarts/model/mixin/makeStyleMapper', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    return function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n                properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n});\ndefine('echarts/coord/cartesian/Cartesian', ['require', 'zrender/core/util'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    function dimAxisMapper(dim) {\n        return this._axes[dim];\n    }\n    /**\n     * @alias module:echarts/coord/Cartesian\n     * @constructor\n     */\n    var Cartesian = function (name) {\n        this._axes = {};\n        this._dimList = [];\n        /**\n         * @type {string}\n         */\n        this.name = name || '';\n    };\n    Cartesian.prototype = {\n        constructor: Cartesian,\n        type: 'cartesian',\n        getAxis: function (dim) {\n            return this._axes[dim];\n        },\n        getAxes: function () {\n            return zrUtil.map(this._dimList, dimAxisMapper, this);\n        },\n        getAxesByScale: function (scaleType) {\n            scaleType = scaleType.toLowerCase();\n            return zrUtil.filter(this.getAxes(), function (axis) {\n                return axis.scale.type === scaleType;\n            });\n        },\n        addAxis: function (axis) {\n            var dim = axis.dim;\n            this._axes[dim] = axis;\n            this._dimList.push(dim);\n        },\n        dataToCoord: function (val) {\n            return this._dataCoordConvert(val, 'dataToCoord');\n        },\n        coordToData: function (val) {\n            return this._dataCoordConvert(val, 'coordToData');\n        },\n        _dataCoordConvert: function (input, method) {\n            var dimList = this._dimList;\n            var output = input instanceof Array ? [] : {};\n            for (var i = 0; i < dimList.length; i++) {\n                var dim = dimList[i];\n                var axis = this._axes[dim];\n                output[dim] = axis[method](input[dim]);\n            }\n            return output;\n        }\n    };\n    return Cartesian;\n});\ndefine('zrender/core/guid', [], function () {\n    var idStart = 2311;\n    return function () {\n        return idStart++;\n    };\n});\ndefine('zrender/mixin/Transformable', ['require', '../core/matrix', '../core/vector'], function (require) {\n    'use strict';\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n    var EPSILON = 0.00005;\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * 平移\n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [\n                0,\n                0\n            ];\n        }\n        if (opts.rotation == null) {\n            /**\n             * 旋转\n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * 缩放\n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [\n                1,\n                1\n            ];\n        }\n        /**\n         * 旋转和缩放的原点\n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n    /**\n     * 判断是否需要有坐标变换\n     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n    };\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n        m = m || matrix.create();\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        } else {\n            mIdentity(m);\n        }\n        // 应用父节点变换\n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            } else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // 保存这个变换矩阵\n        this.transform = m;\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n    transformableProto.getLocalTransform = function (m) {\n        m = m || [];\n        mIdentity(m);\n        var origin = this.origin;\n        var scale = this.scale;\n        var rotation = this.rotation;\n        var position = this.position;\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n        m[4] += position[0];\n        m[5] += position[1];\n        return m;\n    };\n    /**\n     * 将自己的transform应用到context上\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        } else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n    transformableProto.restoreTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    };\n    var tmpTransform = [];\n    /**\n     * 分解`transform`矩阵到`position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [\n                1,\n                1\n            ];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [\n            sx,\n            sy\n        ];\n    };\n    /**\n     * 变换坐标位置到 shape 的局部坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [\n                x,\n                y\n            ];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n    /**\n     * 变换局部坐标位置到全局坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [\n                x,\n                y\n            ];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n    return Transformable;\n});\ndefine('zrender/mixin/Animatable', ['require', '../animation/Animator', '../core/util', '../core/log'], function (require) {\n    'use strict';\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n    Animatable.prototype = {\n        constructor: Animatable,\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            } else {\n                target = el;\n            }\n            if (!target) {\n                log('Property \"' + path + '\" is not existed in element ' + el.id);\n                return;\n            }\n            var animators = el.animators;\n            var animator = new Animator(target, loop);\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            }).done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n            animators.push(animator);\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n            return animator;\n        },\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n            return this;\n        },\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }    // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }    // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }    // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }    // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i].done(done).start(easing);\n            }\n        },\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n                    } else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                } else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    } else {\n                        // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n            if (propertyCount > 0) {\n                this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n            }\n            return this;\n        }\n    };\n    return Animatable;\n});\ndefine('echarts/util/component', ['require', 'zrender/core/util', './clazz'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var clazz = require('./clazz');\n    var parseClassType = clazz.parseClassType;\n    var base = 0;\n    var componentUtil = {};\n    var DELIMITER = '_';\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [\n            type || '',\n            base++,\n            Math.random()\n        ].join(DELIMITER);\n    };\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n        var subTypeDefaulters = {};\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n        return entity;\n    };\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);\n            }\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n            zrUtil.each(fullNameList, function (name) {\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n            return {\n                graph: graph,\n                noEntryList: noEntryList\n            };\n        }\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {\n                    predecessor: [],\n                    successor: []\n                };\n            }\n            return graph[name];\n        }\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n    return componentUtil;\n});\ndefine('echarts/model/mixin/boxLayout', ['require'], function (require) {\n    return {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n});\ndefine('echarts/coord/Axis', ['require', '../util/number', 'zrender/core/util'], function (require) {\n    var numberUtil = require('../util/number');\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = require('zrender/core/util');\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n    var normalizedExtent = [\n            0,\n            1\n        ];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [\n            0,\n            0\n        ];\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n    };\n    Axis.prototype = {\n        constructor: Axis,\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n        getExtent: function () {\n            var ret = this._extent.slice();\n            return ret;\n        },\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);\n        },\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n            return this.scale.scale(t);\n        },\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            } else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n            return Math.abs(size) / len;\n        }\n    };\n    return Axis;\n});\ndefine('echarts/coord/cartesian/axisLabelInterval', ['require', 'zrender/core/util', '../axisHelper'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var axisHelper = require('../axisHelper');\n    return function (axis) {\n        var axisModel = axis.model;\n        var labelModel = axisModel.getModel('axisLabel');\n        var labelInterval = labelModel.get('interval');\n        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n            return labelInterval === 'auto' ? 0 : labelInterval;\n        }\n        return axisHelper.getAxisLabelInterval(zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis), axisModel.getFormattedLabels(), labelModel.getModel('textStyle').getFont(), axis.isHorizontal());\n    };\n});\ndefine('zrender/core/log', ['require', '../config'], function (require) {\n    var config = require('../config');\n    /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n         */\n    return function () {\n        if (config.debugMode === 0) {\n            return;\n        } else if (config.debugMode == 1) {\n            for (var k in arguments) {\n                throw new Error(arguments[k]);\n            }\n        } else if (config.debugMode > 1) {\n            for (var k in arguments) {\n                console.log(arguments[k]);\n            }\n        }\n    };    /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>' \n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n});\ndefine('zrender/animation/Animator', ['require', './Clip', '../tool/color', '../core/util'], function (require) {\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n    var arraySlice = Array.prototype.slice;\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        } else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n                }\n            }\n        }\n    }\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            } else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            } else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        } else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n            }\n        } else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n                }\n            }\n        }\n    }\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n    }\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n            return arraySlice.call(value);\n        }\n        return value;\n    }\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n    function createTrackClip(animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n        // For vertices morphing\n        var arrDim = isValueArray && isArrayLike(firstVal[0]) ? 2 : 1;\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function (a, b) {\n            return a.time - b.time;\n        });\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n            // Check if value is equal, deep check if value is array\n            if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                } else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            } else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n        if (isValueColor) {\n            var rgba = [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n        }\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            } else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            } else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n            var range = kfPercents[frame + 1] - kfPercents[frame];\n            if (range === 0) {\n                return;\n            } else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n                } else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n                        value = rgba2String(rgba);\n                    } else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    } else {\n                        value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n                    }\n                    setter(target, propName, value);\n                }\n            } else {\n                if (isValueArray) {\n                    interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n                } else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n                        value = rgba2String(rgba);\n                    } else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    } else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(target, propName, value);\n                }\n            }\n        };\n        var clip = new Clip({\n                target: animator._target,\n                life: trackMaxTime,\n                loop: animator._loop,\n                delay: animator._delay,\n                onframe: onframe,\n                ondestroy: oneTrackDone\n            });\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n        return clip;\n    }\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function (target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n        this._loop = loop || false;\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n        this._clipCount = 0;\n        this._delay = 0;\n        this._doneList = [];\n        this._onframeList = [];\n        this._clipList = [];\n    };\n    Animator.prototype = {\n        when: function (time, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        start: function (easing) {\n            var self = this;\n            var clipCount = 0;\n            var oneTrackDone = function () {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n            var lastClip;\n            for (var propName in this._tracks) {\n                var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName);\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n                    lastClip = clip;\n                }\n            }\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        done: function (cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n    return Animator;\n});\ndefine('echarts/coord/cartesian/AxisModel', ['require', '../../model/Component', 'zrender/core/util', '../axisModelCreator', '../axisModelCommonMixin'], function (require) {\n    'use strict';\n    var ComponentModel = require('../../model/Component');\n    var zrUtil = require('zrender/core/util');\n    var axisModelCreator = require('../axisModelCreator');\n    var AxisModel = ComponentModel.extend({\n            type: 'cartesian2dAxis',\n            axis: null,\n            init: function () {\n                AxisModel.superApply(this, 'init', arguments);\n                this._resetRange();\n            },\n            mergeOption: function () {\n                AxisModel.superApply(this, 'mergeOption', arguments);\n                this._resetRange();\n            },\n            restoreData: function () {\n                AxisModel.superApply(this, 'restoreData', arguments);\n                this._resetRange();\n            },\n            setRange: function (rangeStart, rangeEnd) {\n                this.option.rangeStart = rangeStart;\n                this.option.rangeEnd = rangeEnd;\n            },\n            getMin: function () {\n                var option = this.option;\n                return option.rangeStart != null ? option.rangeStart : option.min;\n            },\n            getMax: function () {\n                var option = this.option;\n                return option.rangeEnd != null ? option.rangeEnd : option.max;\n            },\n            getNeedCrossZero: function () {\n                var option = this.option;\n                return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;\n            },\n            findGridModel: function () {\n                return this.ecModel.queryComponents({\n                    mainType: 'grid',\n                    index: this.get('gridIndex'),\n                    id: this.get('gridId')\n                })[0];\n            },\n            _resetRange: function () {\n                // rangeStart and rangeEnd is readonly.\n                this.option.rangeStart = this.option.rangeEnd = null;\n            }\n        });\n    function getAxisType(axisDim, option) {\n        // Default axis with data is category axis\n        return option.type || (option.data ? 'category' : 'value');\n    }\n    zrUtil.merge(AxisModel.prototype, require('../axisModelCommonMixin'));\n    var extraOption = { offset: 0 };\n    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n    return AxisModel;\n});\ndefine('zrender/animation/Clip', ['require', './easing'], function (require) {\n    var easingFuncs = require('./easing');\n    function Clip(options) {\n        this._target = options.target;\n        // 生命周期\n        this._life = options.life || 1000;\n        // 延时\n        this._delay = options.delay || 0;\n        // 开始时间\n        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n        this._initialized = false;\n        // 是否循环\n        this.loop = options.loop == null ? false : options.loop;\n        this.gap = options.gap || 0;\n        this.easing = options.easing || 'Linear';\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n    }\n    Clip.prototype = {\n        constructor: Clip,\n        step: function (globalTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n            var percent = (globalTime - this._startTime) / this._life;\n            // 还没开始\n            if (percent < 0) {\n                return;\n            }\n            percent = Math.min(percent, 1);\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n            this.fire('frame', schedule);\n            // 结束\n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart(globalTime);\n                    // 重新开始周期\n                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n                    return 'restart';\n                }\n                // 动画完成将这个控制器标识为待删除\n                // 在Animation.update中进行批量删除\n                this._needsRemove = true;\n                return 'destroy';\n            }\n            return null;\n        },\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n            this._needsRemove = false;\n        },\n        fire: function (eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        }\n    };\n    return Clip;\n});\ndefine('echarts/coord/axisModelCreator', ['require', './axisDefault', 'zrender/core/util', '../model/Component', '../util/layout'], function (require) {\n    var axisDefault = require('./axisDefault');\n    var zrUtil = require('zrender/core/util');\n    var ComponentModel = require('../model/Component');\n    var layout = require('../util/layout');\n    // FIXME axisType is fixed ?\n    var AXIS_TYPES = [\n            'value',\n            'category',\n            'time',\n            'log'\n        ];\n    /**\n     * Generate sub axis model class\n     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n     * @param {module:echarts/model/Component} BaseAxisModelClass\n     * @param {Function} axisTypeDefaulter\n     * @param {Object} [extraDefaultOption]\n     */\n    return function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n        zrUtil.each(AXIS_TYPES, function (axisType) {\n            BaseAxisModelClass.extend({\n                type: axisName + 'Axis.' + axisType,\n                mergeDefaultAndTheme: function (option, ecModel) {\n                    var layoutMode = this.layoutMode;\n                    var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};\n                    var themeModel = ecModel.getTheme();\n                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n                    zrUtil.merge(option, this.getDefaultOption());\n                    option.type = axisTypeDefaulter(axisName, option);\n                    if (layoutMode) {\n                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                    }\n                },\n                defaultOption: zrUtil.mergeAll([\n                    {},\n                    axisDefault[axisType + 'Axis'],\n                    extraDefaultOption\n                ], true)\n            });\n        });\n        ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n    };\n});\ndefine('echarts/coord/axisModelCommonMixin', ['require', 'zrender/core/util', './axisHelper'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var axisHelper = require('./axisHelper');\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        } else {\n            return obj;\n        }\n    }\n    /**\n     * Get categories\n     */\n    function getCategories() {\n        return this.get('type') === 'category' && zrUtil.map(this.get('data'), getName);\n    }\n    /**\n     * Format labels\n     * @return {Array.<string>}\n     */\n    function getFormattedLabels() {\n        return axisHelper.getFormattedLabels(this.axis, this.get('axisLabel.formatter'));\n    }\n    return {\n        getFormattedLabels: getFormattedLabels,\n        getCategories: getCategories\n    };\n});\ndefine('zrender/animation/easing', [], function () {\n    var easing = {\n            linear: function (k) {\n                return k;\n            },\n            quadraticIn: function (k) {\n                return k * k;\n            },\n            quadraticOut: function (k) {\n                return k * (2 - k);\n            },\n            quadraticInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k;\n                }\n                return -0.5 * (--k * (k - 2) - 1);\n            },\n            cubicIn: function (k) {\n                return k * k * k;\n            },\n            cubicOut: function (k) {\n                return --k * k * k + 1;\n            },\n            cubicInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k * k;\n                }\n                return 0.5 * ((k -= 2) * k * k + 2);\n            },\n            quarticIn: function (k) {\n                return k * k * k * k;\n            },\n            quarticOut: function (k) {\n                return 1 - --k * k * k * k;\n            },\n            quarticInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k * k * k;\n                }\n                return -0.5 * ((k -= 2) * k * k * k - 2);\n            },\n            quinticIn: function (k) {\n                return k * k * k * k * k;\n            },\n            quinticOut: function (k) {\n                return --k * k * k * k * k + 1;\n            },\n            quinticInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k * k * k * k;\n                }\n                return 0.5 * ((k -= 2) * k * k * k * k + 2);\n            },\n            sinusoidalIn: function (k) {\n                return 1 - Math.cos(k * Math.PI / 2);\n            },\n            sinusoidalOut: function (k) {\n                return Math.sin(k * Math.PI / 2);\n            },\n            sinusoidalInOut: function (k) {\n                return 0.5 * (1 - Math.cos(Math.PI * k));\n            },\n            exponentialIn: function (k) {\n                return k === 0 ? 0 : Math.pow(1024, k - 1);\n            },\n            exponentialOut: function (k) {\n                return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n            },\n            exponentialInOut: function (k) {\n                if (k === 0) {\n                    return 0;\n                }\n                if (k === 1) {\n                    return 1;\n                }\n                if ((k *= 2) < 1) {\n                    return 0.5 * Math.pow(1024, k - 1);\n                }\n                return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n            },\n            circularIn: function (k) {\n                return 1 - Math.sqrt(1 - k * k);\n            },\n            circularOut: function (k) {\n                return Math.sqrt(1 - --k * k);\n            },\n            circularInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return -0.5 * (Math.sqrt(1 - k * k) - 1);\n                }\n                return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n            },\n            elasticIn: function (k) {\n                var s;\n                var a = 0.1;\n                var p = 0.4;\n                if (k === 0) {\n                    return 0;\n                }\n                if (k === 1) {\n                    return 1;\n                }\n                if (!a || a < 1) {\n                    a = 1;\n                    s = p / 4;\n                } else {\n                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n                }\n                return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n            },\n            elasticOut: function (k) {\n                var s;\n                var a = 0.1;\n                var p = 0.4;\n                if (k === 0) {\n                    return 0;\n                }\n                if (k === 1) {\n                    return 1;\n                }\n                if (!a || a < 1) {\n                    a = 1;\n                    s = p / 4;\n                } else {\n                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n                }\n                return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n            },\n            elasticInOut: function (k) {\n                var s;\n                var a = 0.1;\n                var p = 0.4;\n                if (k === 0) {\n                    return 0;\n                }\n                if (k === 1) {\n                    return 1;\n                }\n                if (!a || a < 1) {\n                    a = 1;\n                    s = p / 4;\n                } else {\n                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n                }\n                if ((k *= 2) < 1) {\n                    return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n                }\n                return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n            },\n            backIn: function (k) {\n                var s = 1.70158;\n                return k * k * ((s + 1) * k - s);\n            },\n            backOut: function (k) {\n                var s = 1.70158;\n                return --k * k * ((s + 1) * k + s) + 1;\n            },\n            backInOut: function (k) {\n                var s = 1.70158 * 1.525;\n                if ((k *= 2) < 1) {\n                    return 0.5 * (k * k * ((s + 1) * k - s));\n                }\n                return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n            },\n            bounceIn: function (k) {\n                return 1 - easing.bounceOut(1 - k);\n            },\n            bounceOut: function (k) {\n                if (k < 1 / 2.75) {\n                    return 7.5625 * k * k;\n                } else if (k < 2 / 2.75) {\n                    return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n                } else if (k < 2.5 / 2.75) {\n                    return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n                } else {\n                    return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n                }\n            },\n            bounceInOut: function (k) {\n                if (k < 0.5) {\n                    return easing.bounceIn(k * 2) * 0.5;\n                }\n                return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n            }\n        };\n    return easing;\n});\ndefine('echarts/coord/axisDefault', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var defaultOption = {\n            show: true,\n            zlevel: 0,\n            z: 0,\n            inverse: false,\n            name: '',\n            nameLocation: 'end',\n            nameRotate: null,\n            nameTruncate: {\n                maxWidth: null,\n                ellipsis: '...',\n                placeholder: '.'\n            },\n            nameTextStyle: {},\n            nameGap: 15,\n            silent: false,\n            triggerEvent: false,\n            tooltip: { show: false },\n            axisLine: {\n                show: true,\n                onZero: true,\n                lineStyle: {\n                    color: '#333',\n                    width: 1,\n                    type: 'solid'\n                }\n            },\n            axisTick: {\n                show: true,\n                inside: false,\n                length: 5,\n                lineStyle: { width: 1 }\n            },\n            axisLabel: {\n                show: true,\n                inside: false,\n                rotate: 0,\n                margin: 8,\n                textStyle: { fontSize: 12 }\n            },\n            splitLine: {\n                show: true,\n                lineStyle: {\n                    color: ['#ccc'],\n                    width: 1,\n                    type: 'solid'\n                }\n            },\n            splitArea: {\n                show: false,\n                areaStyle: {\n                    color: [\n                        'rgba(250,250,250,0.3)',\n                        'rgba(200,200,200,0.3)'\n                    ]\n                }\n            }\n        };\n    var categoryAxis = zrUtil.merge({\n            boundaryGap: true,\n            splitLine: { show: false },\n            axisTick: {\n                alignWithLabel: false,\n                interval: 'auto'\n            },\n            axisLabel: { interval: 'auto' }\n        }, defaultOption);\n    var valueAxis = zrUtil.merge({\n            boundaryGap: [\n                0,\n                0\n            ],\n            splitNumber: 5\n        }, defaultOption);\n    // FIXME\n    var timeAxis = zrUtil.defaults({\n            scale: true,\n            min: 'dataMin',\n            max: 'dataMax'\n        }, valueAxis);\n    var logAxis = zrUtil.defaults({ logBase: 10 }, valueAxis);\n    logAxis.scale = true;\n    return {\n        categoryAxis: categoryAxis,\n        valueAxis: valueAxis,\n        timeAxis: timeAxis,\n        logAxis: logAxis\n    };\n});\ndefine('zrender/config', [], function () {\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config默认配置项\n     * @exports zrender/config\n     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n     */\n    var config = {\n            debugMode: 0,\n            devicePixelRatio: dpr\n        };\n    return config;\n});\ndefine('echarts/chart/helper/createListFromArray', ['require', '../../data/List', '../../data/helper/completeDimensions', 'zrender/core/util', '../../util/model', '../../CoordinateSystem'], function (require) {\n    'use strict';\n    var List = require('../../data/List');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../../util/model');\n    var CoordinateSystem = require('../../CoordinateSystem');\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n        if (true) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = registeredCoordSys && registeredCoordSys.dimensions || [\n                'x',\n                'y'\n            ];\n            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));\n        }\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n        var list = new List(dimensions, seriesModel);\n        var nameList = createNameList(axesInfo, data);\n        var categories = {};\n        var dimValueGetter = categoryIndex >= 0 && ifNeedCompleteOrdinalData(data) ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex ? dataIndex : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            } : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName] || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n        return list;\n    }\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';\n    }\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n            cartesian2d: function (data, seriesModel, ecModel) {\n                var axesModels = zrUtil.map([\n                        'xAxis',\n                        'yAxis'\n                    ], function (name) {\n                        return ecModel.queryComponents({\n                            mainType: name,\n                            index: seriesModel.get(name + 'Index'),\n                            id: seriesModel.get(name + 'Id')\n                        })[0];\n                    });\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n                if (true) {\n                    if (!xAxisModel) {\n                        throw new Error('xAxis \"' + zrUtil.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('xAxisId'), 0) + '\" not found');\n                    }\n                    if (!yAxisModel) {\n                        throw new Error('yAxis \"' + zrUtil.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('yAxisId'), 0) + '\" not found');\n                    }\n                }\n                var xAxisType = xAxisModel.get('type');\n                var yAxisType = yAxisModel.get('type');\n                var dimensions = [\n                        {\n                            name: 'x',\n                            type: getDimTypeByAxis(xAxisType),\n                            stackable: isStackable(xAxisType)\n                        },\n                        {\n                            name: 'y',\n                            type: getDimTypeByAxis(yAxisType),\n                            stackable: isStackable(yAxisType)\n                        }\n                    ];\n                var isXAxisCateogry = xAxisType === 'category';\n                var isYAxisCategory = yAxisType === 'category';\n                completeDimensions(dimensions, data, [\n                    'x',\n                    'y',\n                    'z'\n                ]);\n                var categoryAxesModels = {};\n                if (isXAxisCateogry) {\n                    categoryAxesModels.x = xAxisModel;\n                }\n                if (isYAxisCategory) {\n                    categoryAxesModels.y = yAxisModel;\n                }\n                return {\n                    dimensions: dimensions,\n                    categoryIndex: isXAxisCateogry ? 0 : isYAxisCategory ? 1 : -1,\n                    categoryAxesModels: categoryAxesModels\n                };\n            },\n            polar: function (data, seriesModel, ecModel) {\n                var polarModel = ecModel.queryComponents({\n                        mainType: 'polar',\n                        index: seriesModel.get('polarIndex'),\n                        id: seriesModel.get('polarId')\n                    })[0];\n                var angleAxisModel = polarModel.findAxisModel('angleAxis');\n                var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n                if (true) {\n                    if (!angleAxisModel) {\n                        throw new Error('angleAxis option not found');\n                    }\n                    if (!radiusAxisModel) {\n                        throw new Error('radiusAxis option not found');\n                    }\n                }\n                var radiusAxisType = radiusAxisModel.get('type');\n                var angleAxisType = angleAxisModel.get('type');\n                var dimensions = [\n                        {\n                            name: 'radius',\n                            type: getDimTypeByAxis(radiusAxisType),\n                            stackable: isStackable(radiusAxisType)\n                        },\n                        {\n                            name: 'angle',\n                            type: getDimTypeByAxis(angleAxisType),\n                            stackable: isStackable(angleAxisType)\n                        }\n                    ];\n                var isAngleAxisCateogry = angleAxisType === 'category';\n                var isRadiusAxisCateogry = radiusAxisType === 'category';\n                completeDimensions(dimensions, data, [\n                    'radius',\n                    'angle',\n                    'value'\n                ]);\n                var categoryAxesModels = {};\n                if (isRadiusAxisCateogry) {\n                    categoryAxesModels.radius = radiusAxisModel;\n                }\n                if (isAngleAxisCateogry) {\n                    categoryAxesModels.angle = angleAxisModel;\n                }\n                return {\n                    dimensions: dimensions,\n                    categoryIndex: isAngleAxisCateogry ? 1 : isRadiusAxisCateogry ? 0 : -1,\n                    categoryAxesModels: categoryAxesModels\n                };\n            },\n            geo: function (data, seriesModel, ecModel) {\n                // TODO Region\n                // 多个散点图系列在同一个地区的时候\n                return {\n                    dimensions: completeDimensions([\n                        { name: 'lng' },\n                        { name: 'lat' }\n                    ], data, [\n                        'lng',\n                        'lat',\n                        'value'\n                    ])\n                };\n            }\n        };\n    function createNameList(result, data) {\n        var nameList = [];\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                } else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n        return nameList;\n    }\n    return createListFromArray;\n});\ndefine('zrender/core/curve', ['require', './vector'], function (require) {\n    'use strict';\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 0.0001;\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n    // 临时变量\n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * 计算三次贝塞尔值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n    }\n    /**\n     * 计算三次贝塞尔导数值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n    }\n    /**\n     * 计算三次贝塞尔方程根，使用盛金公式\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1 - p0);\n        var d = p0 - val;\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n        var n = 0;\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            } else {\n                var t1 = -c / b;\n                //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        } else {\n            var disc = B * B - 4 * A * C;\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;\n                // t1, a is not zero\n                var t2 = -K / 2;\n                // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            } else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                } else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                } else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            } else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n    /**\n     * 计算三次贝塞尔方程极限值的位置\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} 有效数目\n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n            }\n        } else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            } else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n    /**\n     * 细分三次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n    /**\n     * 投射点到三次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] 投射点\n     * @return {number}\n     */\n    function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n        _v0[0] = x;\n        _v0[1] = y;\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n            d1 = v2DistSquare(_v1, _v0);\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            } else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                } else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n    /**\n     * 计算二次方贝塞尔值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n    /**\n     * 计算二次方贝塞尔导数值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n    /**\n     * 计算二次方贝塞尔方程根\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        } else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            } else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n    /**\n     * 计算二次贝塞尔方程极限值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        } else {\n            return (p0 - p1) / divider;\n        }\n    }\n    /**\n     * 细分二次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n    /**\n     * 投射点到二次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out 投射点\n     * @return {number}\n     */\n    function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        _v0[0] = x;\n        _v0[1] = y;\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n            var d1 = v2DistSquare(_v1, _v0);\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            } else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                } else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n    return {\n        cubicAt: cubicAt,\n        cubicDerivativeAt: cubicDerivativeAt,\n        cubicRootAt: cubicRootAt,\n        cubicExtrema: cubicExtrema,\n        cubicSubdivide: cubicSubdivide,\n        cubicProjectPoint: cubicProjectPoint,\n        quadraticAt: quadraticAt,\n        quadraticDerivativeAt: quadraticDerivativeAt,\n        quadraticRootAt: quadraticRootAt,\n        quadraticExtremum: quadraticExtremum,\n        quadraticSubdivide: quadraticSubdivide,\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n});\ndefine('zrender/core/bbox', ['require', './vector', './curve'], function (require) {\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n    var PI2 = Math.PI * 2;\n    /**\n     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points 顶点数组\n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function (points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n    var xDim = [];\n    var yDim = [];\n    /**\n     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function (x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n    /**\n     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function (x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n        var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n    /**\n     * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff % PI2 < 0.0001 && diff > 0.0001) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % PI2;\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % PI2;\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        } else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n    return bbox;\n});\ndefine('echarts/data/DataDiffer', ['require'], function (require) {\n    'use strict';\n    function defaultKeyGetter(item) {\n        return item;\n    }\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n        this._old = oldArr;\n        this._new = newArr;\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    }\n    DataDiffer.prototype = {\n        constructor: DataDiffer,\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n            var oldKeyGetter = this._oldKeyGetter;\n            var newKeyGetter = this._newKeyGetter;\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    } else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                } else {\n                    this._remove && this._remove(i);\n                }\n            }\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    } else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    function initIndexMap(arr, map, keyArr, keyGetter) {\n        for (var i = 0; i < arr.length; i++) {\n            var key = keyGetter(arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            } else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n    return DataDiffer;\n});\ndefine('echarts/data/helper/completeDimensions', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    /**\n     * Complete the dimensions array guessed from the data structure.\n     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n     * @param  {Array.<string>} defaultNames    Default names to fill not necessary dimensions, like ['value']\n     * @param  {string} extraPrefix             Prefix of name when filling the left dimensions.\n     * @return {Array.<string>}\n     */\n    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n        if (!data) {\n            return dimensions;\n        }\n        var value0 = retrieveValue(data[0]);\n        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n        defaultNames = defaultNames || [];\n        extraPrefix = extraPrefix || 'extra';\n        for (var i = 0; i < dimSize; i++) {\n            if (!dimensions[i]) {\n                var name = defaultNames[i] || extraPrefix + (i - defaultNames.length);\n                dimensions[i] = guessOrdinal(data, i) ? {\n                    type: 'ordinal',\n                    name: name\n                } : name;\n            }\n        }\n        return dimensions;\n    }\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                var value = retrieveValue(data[i]);\n                if (!zrUtil.isArray(value)) {\n                    return false;\n                }\n                var value = value[dimIndex];\n                if (value != null && isFinite(value)) {\n                    return false;\n                } else if (zrUtil.isString(value) && value !== '-') {\n                    return true;\n                }\n            }\n            return false;\n        };\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value : o;\n    }\n    return completeDimensions;\n});\ndefine('zrender/contain/cubic', ['require', '../core/curve'], function (require) {\n    var curve = require('../core/curve');\n    return {\n        containStroke: function (x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n            return d <= _l / 2;\n        }\n    };\n});\ndefine('zrender/contain/line', [], function () {\n    return {\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n                return false;\n            }\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n            } else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n});\ndefine('zrender/contain/quadratic', ['require', '../core/curve'], function (require) {\n    var curve = require('../core/curve');\n    return {\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n            return d <= _l / 2;\n        }\n    };\n});\ndefine('zrender/contain/arc', ['require', './util'], function (require) {\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n    return {\n        containStroke: function (cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n            if (d - _l > r || d + _l < r) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 0.0001) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n        }\n    };\n});\ndefine('zrender/contain/util', ['require'], function (require) {\n    var PI2 = Math.PI * 2;\n    return {\n        normalizeRadian: function (angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n});\ndefine('zrender/contain/windingLine', [], function () {\n    return function windingLine(x0, y0, x1, y1, x, y) {\n        if (y > y0 && y > y1 || y < y0 && y < y1) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n        var x_ = t * (x1 - x0) + x0;\n        return x_ > x ? dir : 0;\n    };\n});\ndefine('echarts/chart/bar/barItemStyle', ['require', '../../model/mixin/makeStyleMapper'], function (require) {\n    var getBarItemStyle = require('../../model/mixin/makeStyleMapper')([\n            [\n                'fill',\n                'color'\n            ],\n            [\n                'stroke',\n                'borderColor'\n            ],\n            [\n                'lineWidth',\n                'borderWidth'\n            ],\n            [\n                'stroke',\n                'barBorderColor'\n            ],\n            [\n                'lineWidth',\n                'barBorderWidth'\n            ],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]);\n    return {\n        getBarItemStyle: function (excludes) {\n            var style = getBarItemStyle.call(this, excludes);\n            if (this.getBorderLineDash) {\n                var lineDash = this.getBorderLineDash();\n                lineDash && (style.lineDash = lineDash);\n            }\n            return style;\n        }\n    };\n});\ndefine('zrender/core/LRU', ['require'], function (require) {\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function () {\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n        this._len = 0;\n    };\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function (val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function (entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        } else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function (entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        } else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        } else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function () {\n        return this._len;\n    };\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function (val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function (maxSize) {\n        this._list = new LinkedList();\n        this._map = {};\n        this._maxSize = maxSize || 10;\n    };\n    var LRUProto = LRU.prototype;\n    /**\n     * @param  {string} key\n     * @param  {} value\n     */\n    LRUProto.put = function (key, value) {\n        var list = this._list;\n        var map = this._map;\n        if (map[key] == null) {\n            var len = list.len();\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n            }\n            var entry = list.insert(value);\n            entry.key = key;\n            map[key] = entry;\n        }\n    };\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function (key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n            return entry.value;\n        }\n    };\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function () {\n        this._list.clear();\n        this._map = {};\n    };\n    return LRU;\n});\ndefine('zrender/graphic/helper/poly', ['require', './smoothSpline', './smoothBezier'], function (require) {\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n    return {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n                    }\n                } else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n                closePath && ctx.closePath();\n            }\n        }\n    };\n});\ndefine('zrender/graphic/helper/smoothSpline', ['require', '../../core/vector'], function (require) {\n    var vec2 = require('../../core/vector');\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n    }\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points 线段顶点数组\n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    return function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n            var w = pos - idx;\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            } else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n            var w2 = w * w;\n            var w3 = w * w2;\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n});\ndefine('zrender/graphic/helper/smoothBezier', ['require', '../../core/vector'], function (require) {\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n    /**\n     * 贝塞尔平滑曲线\n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points 线段顶点数组\n     * @param {number} smooth 平滑等级, 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n     *                           整个折线的包围盒做一个并集用来约束控制点。\n     * @param {Array} 计算出来的控制点数组\n     */\n    return function (points, smooth, isLoop, constraint) {\n        var cps = [];\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n        var min, max;\n        if (constraint) {\n            min = [\n                Infinity,\n                Infinity\n            ];\n            max = [\n                -Infinity,\n                -Infinity\n            ];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // 与指定的包围盒做并集\n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            } else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                } else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n            vec2.sub(v, nextPoint, prevPoint);\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n        return cps;\n    };\n});\ndefine('zrender/graphic/helper/roundRect', ['require'], function (require) {\n    return {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            } else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                } else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                } else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                } else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            } else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n});\ndefine('zrender/Storage', ['require', './core/util', './core/env', './container/Group', './core/timsort'], function (require) {\n    'use strict';\n    var util = require('./core/util');\n    var env = require('./core/env');\n    var Group = require('./container/Group');\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = require('./core/timsort');\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     * 内容仓库 (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        // 所有常规形状，id索引的map\n        this._elements = {};\n        this._roots = [];\n        this._displayList = [];\n        this._displayListLen = 0;\n    };\n    Storage.prototype = {\n        constructor: Storage,\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n            el.beforeUpdate();\n            if (el.__dirty) {\n                el.update();\n            }\n            el.afterUpdate();\n            var clipPath = el.clipPath;\n            if (clipPath) {\n                // clipPath 的变换是基于 group 的变换\n                clipPath.parent = el;\n                clipPath.updateTransform();\n                // FIXME 效率影响\n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                    clipPaths.push(clipPath);\n                } else {\n                    clipPaths = [clipPath];\n                }\n            }\n            if (el.isGroup) {\n                var children = el._children;\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n                // Mark group clean here\n                el.__dirty = false;\n            } else {\n                el.__clipPaths = clipPaths;\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n        addRoot: function (el) {\n            // Element has been added\n            if (this._elements[el.id]) {\n                return;\n            }\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n            this.addToMap(el);\n            this._roots.push(el);\n        },\n        delRoot: function (elId) {\n            if (elId == null) {\n                // 不指定elId清空\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n                this._elements = {};\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n                return;\n            }\n            if (elId instanceof Array) {\n                for (var i = 0, l = elId.length; i < l; i++) {\n                    this.delRoot(elId[i]);\n                }\n                return;\n            }\n            var el;\n            if (typeof elId == 'string') {\n                el = this._elements[elId];\n            } else {\n                el = elId;\n            }\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromMap(el.id);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n        addToMap: function (el) {\n            if (el instanceof Group) {\n                el.__storage = this;\n            }\n            el.dirty(false);\n            this._elements[el.id] = el;\n            return this;\n        },\n        get: function (elId) {\n            return this._elements[elId];\n        },\n        delFromMap: function (elId) {\n            var elements = this._elements;\n            var el = elements[elId];\n            if (el) {\n                delete elements[elId];\n                if (el instanceof Group) {\n                    el.__storage = null;\n                }\n            }\n            return this;\n        },\n        dispose: function () {\n            this._elements = this._renderList = this._roots = null;\n        },\n        displayableSortFunc: shapeCompareFunc\n    };\n    return Storage;\n});\ndefine('zrender/Handler', ['require', './core/util', './mixin/Draggable', './mixin/Eventful'], function (require) {\n    'use strict';\n    var util = require('./core/util');\n    var Draggable = require('./mixin/Draggable');\n    var Eventful = require('./mixin/Eventful');\n    function makeEventPacket(eveType, target, event) {\n        return {\n            type: eveType,\n            event: event,\n            target: target,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta\n        };\n    }\n    function EmptyProxy() {\n    }\n    EmptyProxy.prototype.dispose = function () {\n    };\n    var handlerNames = [\n            'click',\n            'dblclick',\n            'mousewheel',\n            'mouseout',\n            'mouseup',\n            'mousedown',\n            'mousemove'\n        ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {HTMLElement} root Main HTML element for painting.\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     */\n    var Handler = function (storage, painter, proxy) {\n        Eventful.call(this);\n        this.storage = storage;\n        this.painter = painter;\n        proxy = proxy || new EmptyProxy();\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n        // Attach handler\n        proxy.handler = this;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._hovered;\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n        Draggable.call(this);\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n    Handler.prototype = {\n        constructor: Handler,\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n            var hovered = this.findHover(x, y, null);\n            var lastHovered = this._hovered;\n            var proxy = this.proxy;\n            this._hovered = hovered;\n            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n            // Mouse out on previous hovered element\n            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n            // Mouse over on a new element\n            if (hovered && hovered !== lastHovered) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n            this.trigger('globalout', { event: event });\n        },\n        resize: function (event) {\n            this._hovered = null;\n        },\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n        dispose: function () {\n            this.proxy.dispose();\n            this.storage = this.proxy = this.painter = null;\n        },\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n        dispatchToElement: function (targetEl, eventName, event) {\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetEl, event);\n            var el = targetEl;\n            while (el) {\n                el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n                el.trigger(eventName, eventPacket);\n                el = el.parent;\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n            if (!eventPacket.cancelBubble) {\n                // 冒泡到顶级 zrender 对象\n                this.trigger(eventName, eventPacket);\n                // 分发事件到用户自定义层\n                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof layer[eventHandler] == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n        findHover: function (x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            for (var i = list.length - 1; i >= 0; i--) {\n                if (!list[i].silent && list[i] !== exclude && !list[i].ignore && isHover(list[i], x, y)) {\n                    return list[i];\n                }\n            }\n        }\n    };\n    // Common handlers\n    util.each([\n        'click',\n        'mousedown',\n        'mouseup',\n        'mousewheel',\n        'dblclick'\n    ], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY, null);\n            if (name === 'mousedown') {\n                this._downel = hovered;\n                // In case click triggered before mouseup\n                this._upel = hovered;\n            } else if (name === 'mosueup') {\n                this._upel = hovered;\n            } else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            while (el) {\n                // If ancestor is silent or clipped by ancestor\n                if (el.silent || el.clipPath && !el.clipPath.contain(x, y)) {\n                    return false;\n                }\n                el = el.parent;\n            }\n            return true;\n        }\n        return false;\n    }\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n    return Handler;\n});\ndefine('zrender/animation/Animation', ['require', '../core/util', '../core/event', './requestAnimationFrame', './Animator'], function (require) {\n    'use strict';\n    var util = require('../core/util');\n    var Dispatcher = require('../core/event').Dispatcher;\n    var requestAnimationFrame = require('./requestAnimationFrame');\n    var Animator = require('./Animator');\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n        options = options || {};\n        this.stage = options.stage || {};\n        this.onframe = options.onframe || function () {\n        };\n        // private properties\n        this._clips = [];\n        this._running = false;\n        this._time;\n        this._pausedTime;\n        this._pauseStart;\n        this._paused = false;\n        Dispatcher.call(this);\n    };\n    Animation.prototype = {\n        constructor: Animation,\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        removeClip: function (clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n        _update: function () {\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                } else {\n                    i++;\n                }\n            }\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n            this._time = time;\n            this.onframe(delta);\n            this.trigger('frame', delta);\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n        _startLoop: function () {\n            var self = this;\n            this._running = true;\n            function step() {\n                if (self._running) {\n                    requestAnimationFrame(step);\n                    !self._paused && self._update();\n                }\n            }\n            requestAnimationFrame(step);\n        },\n        start: function () {\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n            this._startLoop();\n        },\n        stop: function () {\n            this._running = false;\n        },\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += new Date().getTime() - this._pauseStart;\n                this._paused = false;\n            }\n        },\n        clear: function () {\n            this._clips = [];\n        },\n        animate: function (target, options) {\n            options = options || {};\n            var animator = new Animator(target, options.loop, options.getter, options.setter);\n            return animator;\n        }\n    };\n    util.mixin(Animation, Dispatcher);\n    return Animation;\n});\ndefine('zrender/dom/HandlerProxy', ['require', '../core/event', '../core/util', '../mixin/Eventful', '../core/env', '../core/GestureMgr'], function (require) {\n    var eventTool = require('../core/event');\n    var zrUtil = require('../core/util');\n    var Eventful = require('../mixin/Eventful');\n    var env = require('../core/env');\n    var GestureMgr = require('../core/GestureMgr');\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n    var TOUCH_CLICK_DELAY = 300;\n    var mouseHandlerNames = [\n            'click',\n            'dblclick',\n            'mousewheel',\n            'mouseout',\n            'mouseup',\n            'mousedown',\n            'mousemove'\n        ];\n    var touchHandlerNames = [\n            'touchstart',\n            'touchend',\n            'touchmove'\n        ];\n    function eventNameFix(name) {\n        return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n    }\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n        stage === 'start' && gestureMgr.clear();\n        var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null), proxy.dom);\n        stage === 'end' && gestureMgr.clear();\n        if (gestureInfo) {\n            // eventTool.stop(event);\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n        }\n    }\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n    function useTouchEvent() {\n        return env.touchEventsSupported;\n    }\n    var domHandlers = {\n            mousemove: function (event) {\n                event = normalizeEvent(this.dom, event);\n                this.trigger('mousemove', event);\n            },\n            mouseout: function (event) {\n                event = normalizeEvent(this.dom, event);\n                var element = event.toElement || event.relatedTarget;\n                if (element != this.dom) {\n                    while (element && element.nodeType != 9) {\n                        // 忽略包含在root中的dom引起的mouseOut\n                        if (element === this.dom) {\n                            return;\n                        }\n                        element = element.parentNode;\n                    }\n                }\n                this.trigger('mouseout', event);\n            },\n            touchstart: function (event) {\n                // Default mouse behaviour should not be disabled here.\n                // For example, page may needs to be slided.\n                event = normalizeEvent(this.dom, event);\n                this._lastTouchMoment = new Date();\n                processGesture(this, event, 'start');\n                // 平板补充一次findHover\n                // this._mobileFindFixed(event);\n                // Trigger mousemove and mousedown\n                domHandlers.mousemove.call(this, event);\n                domHandlers.mousedown.call(this, event);\n                setTouchTimer(this);\n            },\n            touchmove: function (event) {\n                event = normalizeEvent(this.dom, event);\n                processGesture(this, event, 'change');\n                // Mouse move should always be triggered no matter whether\n                // there is gestrue event, because mouse move and pinch may\n                // be used at the same time.\n                domHandlers.mousemove.call(this, event);\n                setTouchTimer(this);\n            },\n            touchend: function (event) {\n                event = normalizeEvent(this.dom, event);\n                processGesture(this, event, 'end');\n                domHandlers.mouseup.call(this, event);\n                // click event should always be triggered no matter whether\n                // there is gestrue event. System click can not be prevented.\n                if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                    domHandlers.click.call(this, event);\n                }\n                setTouchTimer(this);\n            }\n        };\n    // Common handlers\n    zrUtil.each([\n        'click',\n        'mousedown',\n        'mouseup',\n        'mousewheel',\n        'dblclick'\n    ], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n    /**\n     * 为控制类实例初始化dom 事件处理函数\n     *\n     * @inner\n     * @param {module:zrender/Handler} instance 控制类实例\n     */\n    function initDomHandler(instance) {\n        for (var i = 0; i < touchHandlerNames.length; i++) {\n            var name = touchHandlerNames[i];\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        }\n        for (var i = 0; i < mouseHandlerNames.length; i++) {\n            var name = mouseHandlerNames[i];\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        }\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n        this.dom = dom;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n        this._handlers = {};\n        initDomHandler(this);\n        if (useTouchEvent()) {\n            mountHandlers(touchHandlerNames, this);    // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                                                       // addEventListener(root, 'mouseout', this._mouseoutHandler);\n        }\n        // Considering some devices that both enable touch and mouse event (like MS Surface\n        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n        // mouse event can not be handle in those devices.\n        mountHandlers(mouseHandlerNames, this);\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n    return HandlerDomProxy;\n});\ndefine('zrender/Painter', ['require', './config', './core/util', './core/log', './core/BoundingRect', './core/timsort', './Layer', './animation/requestAnimationFrame', './graphic/Image'], function (require) {\n    'use strict';\n    var config = require('./config');\n    var util = require('./core/util');\n    var log = require('./core/log');\n    var BoundingRect = require('./core/BoundingRect');\n    var timsort = require('./core/timsort');\n    var Layer = require('./Layer');\n    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n        if (layer.isBuildin) {\n            return true;\n        }\n        if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n            return false;\n        }\n        return true;\n    }\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) {\n            // Can both be null or undefined\n            return false;\n        }\n        if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n            var path = clipPath.path;\n            clipPath.setTransform(ctx);\n            path.beginPath(ctx);\n            clipPath.buildPath(path, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n        var domRootStyle = domRoot.style;\n        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n        domRootStyle.position = 'relative';\n        domRootStyle.overflow = 'hidden';\n        domRootStyle.width = width + 'px';\n        domRootStyle.height = height + 'px';\n        return domRoot;\n    }\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root 绘图容器\n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === 'CANVAS';\n        opts = opts || {};\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * 绘图容器\n         * @type {HTMLElement}\n         */\n        this.root = root;\n        var rootStyle = root.style;\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n            root.innerHTML = '';\n        }\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n        if (!singleCanvas) {\n            this._width = this._getWidth();\n            this._height = this._getHeight();\n            var domRoot = this._domRoot = createRoot(this._width, this._height);\n            root.appendChild(domRoot);\n        } else {\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n        }\n        this.pathToImage = this._createPathToImage();\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n        this._hoverElements = [];\n    };\n    Painter.prototype = {\n        constructor: Painter,\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        getViewportRoot: function () {\n            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n        },\n        refresh: function (paintAll) {\n            var list = this.storage.getDisplayList(true);\n            var zlevelList = this._zlevelList;\n            this._paintList(list, paintAll);\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.isBuildin && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n            this.refreshHover();\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n            return this;\n        },\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                    style: el.style,\n                    shape: el.shape\n                });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(100000);\n            }\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n        _startProgessive: function () {\n            var self = this;\n            if (!self._furtherProgressive) {\n                return;\n            }\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n            self._progress++;\n            requestAnimationFrame(step);\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n                    self._doPaintList(self.storage.getDisplayList());\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    } else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n        _paintList: function (list, paintAll) {\n            if (paintAll == null) {\n                paintAll = false;\n            }\n            this._updateLayerStatus(list);\n            this._clearProgressive();\n            this.eachBuildinLayer(preProcessLayer);\n            this._doPaintList(list, paintAll);\n            this.eachBuildinLayer(postProcessLayer);\n        },\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n            // var invTransform = [];\n            var scope;\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n                var elFrame = el.__frame;\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n                    // Reset scope\n                    scope = {};\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n                    if (!currentLayer.isBuildin) {\n                        log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n                    }\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n                        if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n                        layerProgress = currentProgressiveLayer.__progress;\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                } else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n                el.__dirty = false;\n            }\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if ((currentLayer.__dirty || forcePaint) && !el.invisible && el.style.opacity !== 0 && !(m && !m[0] && !m[3]) && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n                var clipPaths = el.__clipPaths;\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.isBuildin = true;\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n                this.insertLayer(zlevel, layer);\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n            return layer;\n        },\n        insertLayer: function (zlevel, layer) {\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n            if (prevLayer) {\n                var prevDom = prevLayer.dom;\n                if (prevDom.nextSibling) {\n                    domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n                } else {\n                    domRoot.appendChild(layer.dom);\n                }\n            } else {\n                if (domRoot.firstChild) {\n                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                } else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n            layersMap[zlevel] = layer;\n        },\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n        eachBuildinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (!layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n        getLayers: function () {\n            return this._layers;\n        },\n        _updateLayerStatus: function (list) {\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n            this.eachBuildinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n                    currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                } else {\n                    el.__frame = -1;\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n            // 层中的元素数量有发生变化\n            this.eachBuildinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n        clear: function () {\n            this.eachBuildinLayer(this._clearLayer);\n            return this;\n        },\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                } else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n                var layer = this._layers[zlevel];\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n            width = width || this._getWidth();\n            height = height || this._getHeight();\n            domRoot.style.display = '';\n            // 优化没有实际改变的resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n                for (var id in this._layers) {\n                    this._layers[id].resize(width, height);\n                }\n                this.refresh(true);\n            }\n            this._width = width;\n            this._height = height;\n            return this;\n        },\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n        dispose: function () {\n            this.root.innerHTML = '';\n            this.root = this.storage = this._domRoot = this._layers = null;\n        },\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n            var displayList = this.storage.getDisplayList(true);\n            var scope = {};\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n            return imageLayer.dom;\n        },\n        getWidth: function () {\n            return this._width;\n        },\n        getHeight: function () {\n            return this._height;\n        },\n        _getWidth: function () {\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n            // FIXME Better way to get the width and height when element has not been append to the document\n            return (root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width)) - (parseInt10(stl.paddingLeft) || 0) - (parseInt10(stl.paddingRight) || 0) | 0;\n        },\n        _getHeight: function () {\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n            return (root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height)) - (parseInt10(stl.paddingTop) || 0) - (parseInt10(stl.paddingBottom) || 0) | 0;\n        },\n        _pathToImage: function (id, path, width, height, dpr) {\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n            ctx.clearRect(0, 0, width * dpr, height * dpr);\n            var pathTransform = {\n                    position: path.position,\n                    rotation: path.rotation,\n                    scale: path.scale\n                };\n            path.position = [\n                0,\n                0,\n                0\n            ];\n            path.rotation = 0;\n            path.scale = [\n                1,\n                1\n            ];\n            if (path) {\n                path.brush(ctx);\n            }\n            var ImageShape = require('./graphic/Image');\n            var imgShape = new ImageShape({\n                    id: id,\n                    style: {\n                        x: 0,\n                        y: 0,\n                        image: canvas\n                    }\n                });\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n            return imgShape;\n        },\n        _createPathToImage: function () {\n            var me = this;\n            return function (id, e, width, height) {\n                return me._pathToImage(id, e, width, height, me.dpr);\n            };\n        }\n    };\n    return Painter;\n});\ndefine('zrender/mixin/Draggable', ['require'], function (require) {\n    function Draggable() {\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);    // this._dropTarget = null;\n                                                      // this._draggingTarget = null;\n                                                      // this._x = 0;\n                                                      // this._y = 0;\n    }\n    Draggable.prototype = {\n        constructor: Draggable,\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n            }\n        },\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n                var x = e.offsetX;\n                var y = e.offsetY;\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(draggingTarget, 'drag', e.event);\n                var dropTarget = this.findHover(x, y, draggingTarget);\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n            if (this._dropTarget) {\n                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n            }\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n    };\n    return Draggable;\n});\ndefine('zrender/core/event', ['require', '../mixin/Eventful'], function (require) {\n    'use strict';\n    var Eventful = require('../mixin/Eventful');\n    var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {\n            left: 0,\n            top: 0\n        };\n    }\n    function clientToLocal(el, e, out) {\n        // clientX/clientY is according to view port.\n        var box = getBoundingClientRect(el);\n        out = out || {};\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n        return out;\n    }\n    /**\n     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标\n     */\n    function normalizeEvent(el, e) {\n        e = e || window.event;\n        if (e.zrX != null) {\n            return e;\n        }\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n        if (!isTouch) {\n            clientToLocal(el, e, e);\n            e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        } else {\n            var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e);\n        }\n        return e;\n    }\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        } else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        } else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n    /**\n     * 停止冒泡和阻止默认行为\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event对象\n     */\n    var stop = isDomLevel2 ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        } : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n    return {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n        stop: stop,\n        Dispatcher: Eventful\n    };\n});\ndefine('zrender/animation/requestAnimationFrame', ['require'], function (require) {\n    return typeof window !== 'undefined' && (window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n        setTimeout(func, 16);\n    };\n});\ndefine('zrender/core/GestureMgr', ['require', './event'], function (require) {\n    'use strict';\n    var eventUtil = require('./event');\n    var GestureMgr = function () {\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n    GestureMgr.prototype = {\n        constructor: GestureMgr,\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n            if (!touches) {\n                return;\n            }\n            var trackItem = {\n                    points: [],\n                    touches: [],\n                    target: target,\n                    event: event\n                };\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch);\n                trackItem.points.push([\n                    pos.zrX,\n                    pos.zrY\n                ]);\n                trackItem.touches.push(touch);\n            }\n            this._track.push(trackItem);\n        },\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n    var recognizers = {\n            pinch: function (track, event) {\n                var trackLen = track.length;\n                if (!trackLen) {\n                    return;\n                }\n                var pinchEnd = (track[trackLen - 1] || {}).points;\n                var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n                if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n                    var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                    !isFinite(pinchScale) && (pinchScale = 1);\n                    event.pinchScale = pinchScale;\n                    var pinchCenter = center(pinchEnd);\n                    event.pinchX = pinchCenter[0];\n                    event.pinchY = pinchCenter[1];\n                    return {\n                        type: 'pinch',\n                        target: track[0].target,\n                        event: event\n                    };\n                }\n            }    // Only pinch currently.\n        };\n    return GestureMgr;\n});\ndefine('zrender/Layer', ['require', './core/util', './config', './graphic/Style', './graphic/Pattern'], function (require) {\n    var util = require('./core/util');\n    var config = require('./config');\n    var Style = require('./graphic/Style');\n    var Pattern = require('./graphic/Pattern');\n    function returnFalse() {\n        return false;\n    }\n    /**\n     * 创建dom\n     *\n     * @inner\n     * @param {string} id dom id 待用\n     * @param {string} type dom type，such as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n        var newDomStyle = newDom.style;\n        // 没append呢，请原谅我这样写，清晰~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n        // id不作为索引用，避免可能造成的重名，定义为私有属性\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function (id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }    // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n        var domStyle = dom.style;\n        if (domStyle) {\n            // Not in node\n            dom.onselectstart = returnFalse;\n            // 避免页面选中的尴尬\n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n        }\n        this.domBack = null;\n        this.ctxBack = null;\n        this.painter = painter;\n        this.config = null;\n        // Configs\n        /**\n         * 每次清空画布的颜色\n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * 是否开启动态模糊\n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n    Layer.prototype = {\n        constructor: Layer,\n        elCount: 0,\n        __dirty: true,\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n            this.ctx.dpr = this.dpr;\n        },\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n        resize: function (width, height) {\n            var dpr = this.dpr;\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n            var dpr = this.dpr;\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n            }\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }    // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n    return Layer;\n});\ndefine('echarts/preprocessor/helper/compatStyle', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var POSSIBLE_STYLES = [\n            'areaStyle',\n            'lineStyle',\n            'nodeStyle',\n            'linkStyle',\n            'chordStyle',\n            'label',\n            'labelLine'\n        ];\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (itemStyleOpt) {\n            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n                var normalItemStyleOpt = itemStyleOpt.normal;\n                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].normal) {\n                        opt[styleName].normal = normalItemStyleOpt[styleName];\n                    } else {\n                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                    }\n                    normalItemStyleOpt[styleName] = null;\n                }\n                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].emphasis) {\n                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                    } else {\n                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                    }\n                    emphasisItemStyleOpt[styleName] = null;\n                }\n            });\n        }\n    }\n    return function (seriesOpt) {\n        if (!seriesOpt) {\n            return;\n        }\n        compatItemStyle(seriesOpt);\n        compatItemStyle(seriesOpt.markPoint);\n        compatItemStyle(seriesOpt.markLine);\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n            }\n            // mark point data\n            var markPoint = seriesOpt.markPoint;\n            if (markPoint && markPoint.data) {\n                var mpData = markPoint.data;\n                for (var i = 0; i < mpData.length; i++) {\n                    compatItemStyle(mpData[i]);\n                }\n            }\n            // mark line data\n            var markLine = seriesOpt.markLine;\n            if (markLine && markLine.data) {\n                var mlData = markLine.data;\n                for (var i = 0; i < mlData.length; i++) {\n                    if (zrUtil.isArray(mlData[i])) {\n                        compatItemStyle(mlData[i][0]);\n                        compatItemStyle(mlData[i][1]);\n                    } else {\n                        compatItemStyle(mlData[i]);\n                    }\n                }\n            }\n        }\n    };\n});\ndefine('echarts/component/helper/selectableMixin', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    return {\n        updateSelectedMap: function (targetList) {\n            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n                targetMap[target.name] = target;\n                return targetMap;\n            }, {});\n        },\n        select: function (name) {\n            var targetMap = this._selectTargetMap;\n            var target = targetMap[name];\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                zrUtil.each(targetMap, function (target) {\n                    target.selected = false;\n                });\n            }\n            target && (target.selected = true);\n        },\n        unSelect: function (name) {\n            var target = this._selectTargetMap[name];\n            // var selectedMode = this.get('selectedMode');\n            // selectedMode !== 'single' && target && (target.selected = false);\n            target && (target.selected = false);\n        },\n        toggleSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            if (target != null) {\n                this[target.selected ? 'unSelect' : 'select'](name);\n                return target.selected;\n            }\n        },\n        isSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            return target && target.selected;\n        }\n    };\n});\ndefine('echarts/component/axis/AxisView', ['require', 'zrender/core/util', '../../util/graphic', './AxisBuilder', '../../echarts'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var graphic = require('../../util/graphic');\n    var AxisBuilder = require('./AxisBuilder');\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n    var getInterval = AxisBuilder.getInterval;\n    var axisBuilderAttrs = [\n            'axisLine',\n            'axisLabel',\n            'axisTick',\n            'axisName'\n        ];\n    var selfBuilderAttrs = [\n            'splitArea',\n            'splitLine'\n        ];\n    // function getAlignWithLabel(model, axisModel) {\n    //     var alignWithLabel = model.get('alignWithLabel');\n    //     if (alignWithLabel === 'auto') {\n    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n    //     }\n    //     return alignWithLabel;\n    // }\n    var AxisView = require('../../echarts').extendComponentView({\n            type: 'axis',\n            render: function (axisModel, ecModel) {\n                this.group.removeAll();\n                var oldAxisGroup = this._axisGroup;\n                this._axisGroup = new graphic.Group();\n                this.group.add(this._axisGroup);\n                if (!axisModel.get('show')) {\n                    return;\n                }\n                var gridModel = axisModel.findGridModel();\n                var layout = layoutAxis(gridModel, axisModel);\n                var axisBuilder = new AxisBuilder(axisModel, layout);\n                zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n                this._axisGroup.add(axisBuilder.getGroup());\n                zrUtil.each(selfBuilderAttrs, function (name) {\n                    if (axisModel.get(name + '.show')) {\n                        this['_' + name](axisModel, gridModel, layout.labelInterval);\n                    }\n                }, this);\n                graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n            },\n            _splitLine: function (axisModel, gridModel, labelInterval) {\n                var axis = axisModel.axis;\n                var splitLineModel = axisModel.getModel('splitLine');\n                var lineStyleModel = splitLineModel.getModel('lineStyle');\n                var lineColors = lineStyleModel.get('color');\n                var lineInterval = getInterval(splitLineModel, labelInterval);\n                lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n                var gridRect = gridModel.coordinateSystem.getRect();\n                var isHorizontal = axis.isHorizontal();\n                var lineCount = 0;\n                var ticksCoords = axis.getTicksCoords();\n                var ticks = axis.scale.getTicks();\n                var p1 = [];\n                var p2 = [];\n                // Simple optimization\n                // Batching the lines if color are the same\n                var lineStyle = lineStyleModel.getLineStyle();\n                for (var i = 0; i < ticksCoords.length; i++) {\n                    if (ifIgnoreOnTick(axis, i, lineInterval)) {\n                        continue;\n                    }\n                    var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n                    if (isHorizontal) {\n                        p1[0] = tickCoord;\n                        p1[1] = gridRect.y;\n                        p2[0] = tickCoord;\n                        p2[1] = gridRect.y + gridRect.height;\n                    } else {\n                        p1[0] = gridRect.x;\n                        p1[1] = tickCoord;\n                        p2[0] = gridRect.x + gridRect.width;\n                        p2[1] = tickCoord;\n                    }\n                    var colorIndex = lineCount++ % lineColors.length;\n                    this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                        anid: 'line_' + ticks[i],\n                        shape: {\n                            x1: p1[0],\n                            y1: p1[1],\n                            x2: p2[0],\n                            y2: p2[1]\n                        },\n                        style: zrUtil.defaults({ stroke: lineColors[colorIndex] }, lineStyle),\n                        silent: true\n                    })));\n                }\n            },\n            _splitArea: function (axisModel, gridModel, labelInterval) {\n                var axis = axisModel.axis;\n                var splitAreaModel = axisModel.getModel('splitArea');\n                var areaStyleModel = splitAreaModel.getModel('areaStyle');\n                var areaColors = areaStyleModel.get('color');\n                var gridRect = gridModel.coordinateSystem.getRect();\n                var ticksCoords = axis.getTicksCoords();\n                var ticks = axis.scale.getTicks();\n                var prevX = axis.toGlobalCoord(ticksCoords[0]);\n                var prevY = axis.toGlobalCoord(ticksCoords[0]);\n                var count = 0;\n                var areaInterval = getInterval(splitAreaModel, labelInterval);\n                var areaStyle = areaStyleModel.getAreaStyle();\n                areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n                for (var i = 1; i < ticksCoords.length; i++) {\n                    if (ifIgnoreOnTick(axis, i, areaInterval)) {\n                        continue;\n                    }\n                    var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n                    var x;\n                    var y;\n                    var width;\n                    var height;\n                    if (axis.isHorizontal()) {\n                        x = prevX;\n                        y = gridRect.y;\n                        width = tickCoord - x;\n                        height = gridRect.height;\n                    } else {\n                        x = gridRect.x;\n                        y = prevY;\n                        width = gridRect.width;\n                        height = tickCoord - y;\n                    }\n                    var colorIndex = count++ % areaColors.length;\n                    this._axisGroup.add(new graphic.Rect({\n                        anid: 'area_' + ticks[i],\n                        shape: {\n                            x: x,\n                            y: y,\n                            width: width,\n                            height: height\n                        },\n                        style: zrUtil.defaults({ fill: areaColors[colorIndex] }, areaStyle),\n                        silent: true\n                    }));\n                    prevX = x + width;\n                    prevY = y + height;\n                }\n            }\n        });\n    AxisView.extend({ type: 'xAxis' });\n    AxisView.extend({ type: 'yAxis' });\n    /**\n     * @inner\n     */\n    function layoutAxis(gridModel, axisModel) {\n        var grid = gridModel.coordinateSystem;\n        var axis = axisModel.axis;\n        var layout = {};\n        var rawAxisPosition = axis.position;\n        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n        var axisDim = axis.dim;\n        // [left, right, top, bottom]\n        var rect = grid.getRect();\n        var rectBound = [\n                rect.x,\n                rect.x + rect.width,\n                rect.y,\n                rect.y + rect.height\n            ];\n        var axisOffset = axisModel.get('offset') || 0;\n        var posMap = {\n                x: {\n                    top: rectBound[2] - axisOffset,\n                    bottom: rectBound[3] + axisOffset\n                },\n                y: {\n                    left: rectBound[0] - axisOffset,\n                    right: rectBound[1] + axisOffset\n                }\n            };\n        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n        function getZero(dim, val) {\n            var theAxis = grid.getAxis(dim);\n            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n        }\n        // Axis position\n        layout.position = [\n            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n        ];\n        // Axis rotation\n        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n        // Tick and label direction, x y is axisDim\n        var dirMap = {\n                top: -1,\n                bottom: 1,\n                left: -1,\n                right: 1\n            };\n        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n        if (axis.onZero) {\n            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;\n        }\n        if (axisModel.getModel('axisTick').get('inside')) {\n            layout.tickDirection = -layout.tickDirection;\n        }\n        if (axisModel.getModel('axisLabel').get('inside')) {\n            layout.labelDirection = -layout.labelDirection;\n        }\n        // Special label rotation\n        var labelRotation = axisModel.getModel('axisLabel').get('rotate');\n        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n        // label interval when auto mode.\n        layout.labelInterval = axis.getLabelInterval();\n        // Over splitLine and splitArea\n        layout.z2 = 1;\n        return layout;\n    }\n});\ndefine('echarts/chart/pie/labelLayout', ['require', 'zrender/contain/text'], function (require) {\n    'use strict';\n    var textContain = require('zrender/contain/text');\n    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n        list.sort(function (a, b) {\n            return a.y - b.y;\n        });\n        // 压\n        function shiftDown(start, end, delta, dir) {\n            for (var j = start; j < end; j++) {\n                list[j].y += delta;\n                if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n                    shiftUp(j, delta / 2);\n                    return;\n                }\n            }\n            shiftUp(end - 1, delta / 2);\n        }\n        // 弹\n        function shiftUp(end, delta) {\n            for (var j = end; j >= 0; j--) {\n                list[j].y -= delta;\n                if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n                    break;\n                }\n            }\n        }\n        function changeX(list, isDownList, cx, cy, r, dir) {\n            var lastDeltaX = dir > 0 ? isDownList ? Number.MAX_VALUE : 0 : isDownList ? Number.MAX_VALUE : 0;\n            // 上\n            for (var i = 0, l = list.length; i < l; i++) {\n                // Not change x for center label\n                if (list[i].position === 'center') {\n                    continue;\n                }\n                var deltaY = Math.abs(list[i].y - cy);\n                var length = list[i].len;\n                var length2 = list[i].len2;\n                var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n                if (isDownList && deltaX >= lastDeltaX) {\n                    // 右下，左下\n                    deltaX = lastDeltaX - 10;\n                }\n                if (!isDownList && deltaX <= lastDeltaX) {\n                    // 右上，左上\n                    deltaX = lastDeltaX + 10;\n                }\n                list[i].x = cx + deltaX * dir;\n                lastDeltaX = deltaX;\n            }\n        }\n        var lastY = 0;\n        var delta;\n        var len = list.length;\n        var upList = [];\n        var downList = [];\n        for (var i = 0; i < len; i++) {\n            delta = list[i].y - lastY;\n            if (delta < 0) {\n                shiftDown(i, len, -delta, dir);\n            }\n            lastY = list[i].y + list[i].height;\n        }\n        if (viewHeight - lastY < 0) {\n            shiftUp(len - 1, lastY - viewHeight);\n        }\n        for (var i = 0; i < len; i++) {\n            if (list[i].y >= cy) {\n                downList.push(list[i]);\n            } else {\n                upList.push(list[i]);\n            }\n        }\n        changeX(upList, false, cx, cy, r, dir);\n        changeX(downList, true, cx, cy, r, dir);\n    }\n    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n        var leftList = [];\n        var rightList = [];\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            if (labelLayoutList[i].x < cx) {\n                leftList.push(labelLayoutList[i]);\n            } else {\n                rightList.push(labelLayoutList[i]);\n            }\n        }\n        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            var linePoints = labelLayoutList[i].linePoints;\n            if (linePoints) {\n                var dist = linePoints[1][0] - linePoints[2][0];\n                if (labelLayoutList[i].x < cx) {\n                    linePoints[2][0] = labelLayoutList[i].x + 3;\n                } else {\n                    linePoints[2][0] = labelLayoutList[i].x - 3;\n                }\n                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n                linePoints[1][0] = linePoints[2][0] + dist;\n            }\n        }\n    }\n    return function (seriesModel, r, viewWidth, viewHeight) {\n        var data = seriesModel.getData();\n        var labelLayoutList = [];\n        var cx;\n        var cy;\n        var hasLabelRotate = false;\n        data.each(function (idx) {\n            var layout = data.getItemLayout(idx);\n            var itemModel = data.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            // Use position in normal or emphasis\n            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n            var labelLineModel = itemModel.getModel('labelLine.normal');\n            var labelLineLen = labelLineModel.get('length');\n            var labelLineLen2 = labelLineModel.get('length2');\n            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n            var dx = Math.cos(midAngle);\n            var dy = Math.sin(midAngle);\n            var textX;\n            var textY;\n            var linePoints;\n            var textAlign;\n            cx = layout.cx;\n            cy = layout.cy;\n            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n            if (labelPosition === 'center') {\n                textX = layout.cx;\n                textY = layout.cy;\n                textAlign = 'center';\n            } else {\n                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n                textX = x1 + dx * 3;\n                textY = y1 + dy * 3;\n                if (!isLabelInside) {\n                    // For roseType\n                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n                    var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n                    var y3 = y2;\n                    textX = x3 + (dx < 0 ? -5 : 5);\n                    textY = y3;\n                    linePoints = [\n                        [\n                            x1,\n                            y1\n                        ],\n                        [\n                            x2,\n                            y2\n                        ],\n                        [\n                            x3,\n                            y3\n                        ]\n                    ];\n                }\n                textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n            }\n            var font = labelModel.getModel('textStyle').getFont();\n            var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n            var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n            var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n            hasLabelRotate = !!labelRotate;\n            layout.label = {\n                x: textX,\n                y: textY,\n                position: labelPosition,\n                height: textRect.height,\n                len: labelLineLen,\n                len2: labelLineLen2,\n                linePoints: linePoints,\n                textAlign: textAlign,\n                verticalAlign: 'middle',\n                font: font,\n                rotation: labelRotate\n            };\n            // Not layout the inside label\n            if (!isLabelInside) {\n                labelLayoutList.push(layout.label);\n            }\n        });\n        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n        }\n    };\n});\ndefine('echarts/component/axis/AxisBuilder', ['require', 'zrender/core/util', '../../util/format', '../../util/graphic', '../../model/Model', '../../util/number', 'zrender/core/vector'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n    var Model = require('../../model/Model');\n    var numberUtil = require('../../util/number');\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = require('zrender/core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n    var PI = Math.PI;\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = { componentType: axisModel.mainType };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotation] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     */\n    var AxisBuilder = function (axisModel, opt) {\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n        // Default value\n        zrUtil.defaults(opt, {\n            labelOffset: 0,\n            nameDirection: 1,\n            tickDirection: 1,\n            labelDirection: 1,\n            silent: true\n        });\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n                position: opt.position.slice(),\n                rotation: opt.rotation\n            });\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n        this._dumbGroup = dumbGroup;\n    };\n    AxisBuilder.prototype = {\n        constructor: AxisBuilder,\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n        add: function (name) {\n            builders[name].call(this);\n        },\n        getGroup: function () {\n            return this.group;\n        }\n    };\n    var builders = {\n            axisLine: function () {\n                var opt = this.opt;\n                var axisModel = this.axisModel;\n                if (!axisModel.get('axisLine.show')) {\n                    return;\n                }\n                var extent = this.axisModel.axis.getExtent();\n                var matrix = this._transform;\n                var pt1 = [\n                        extent[0],\n                        0\n                    ];\n                var pt2 = [\n                        extent[1],\n                        0\n                    ];\n                if (matrix) {\n                    v2ApplyTransform(pt1, pt1, matrix);\n                    v2ApplyTransform(pt2, pt2, matrix);\n                }\n                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                    anid: 'line',\n                    shape: {\n                        x1: pt1[0],\n                        y1: pt1[1],\n                        x2: pt2[0],\n                        y2: pt2[1]\n                    },\n                    style: zrUtil.extend({ lineCap: 'round' }, axisModel.getModel('axisLine.lineStyle').getLineStyle()),\n                    strokeContainThreshold: opt.strokeContainThreshold || 5,\n                    silent: true,\n                    z2: 1\n                })));\n            },\n            axisTick: function () {\n                var axisModel = this.axisModel;\n                if (!axisModel.get('axisTick.show')) {\n                    return;\n                }\n                var axis = axisModel.axis;\n                var tickModel = axisModel.getModel('axisTick');\n                var opt = this.opt;\n                var lineStyleModel = tickModel.getModel('lineStyle');\n                var tickLen = tickModel.get('length');\n                var tickInterval = getInterval(tickModel, opt.labelInterval);\n                var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n                var ticks = axis.scale.getTicks();\n                var pt1 = [];\n                var pt2 = [];\n                var matrix = this._transform;\n                for (var i = 0; i < ticksCoords.length; i++) {\n                    // Only ordinal scale support tick interval\n                    if (ifIgnoreOnTick(axis, i, tickInterval)) {\n                        continue;\n                    }\n                    var tickCoord = ticksCoords[i];\n                    pt1[0] = tickCoord;\n                    pt1[1] = 0;\n                    pt2[0] = tickCoord;\n                    pt2[1] = opt.tickDirection * tickLen;\n                    if (matrix) {\n                        v2ApplyTransform(pt1, pt1, matrix);\n                        v2ApplyTransform(pt2, pt2, matrix);\n                    }\n                    // Tick line, Not use group transform to have better line draw\n                    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                        anid: 'tick_' + ticks[i],\n                        shape: {\n                            x1: pt1[0],\n                            y1: pt1[1],\n                            x2: pt2[0],\n                            y2: pt2[1]\n                        },\n                        style: zrUtil.defaults(lineStyleModel.getLineStyle(), { stroke: axisModel.get('axisLine.lineStyle.color') }),\n                        z2: 2,\n                        silent: true\n                    })));\n                }\n            },\n            axisLabel: function () {\n                var opt = this.opt;\n                var axisModel = this.axisModel;\n                var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n                if (!show) {\n                    return;\n                }\n                var axis = axisModel.axis;\n                var labelModel = axisModel.getModel('axisLabel');\n                var textStyleModel = labelModel.getModel('textStyle');\n                var labelMargin = labelModel.get('margin');\n                var ticks = axis.scale.getTicks();\n                var labels = axisModel.getFormattedLabels();\n                // Special label rotate.\n                var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;\n                // To radian.\n                labelRotation = labelRotation * PI / 180;\n                var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);\n                var categoryData = axisModel.get('data');\n                var textEls = [];\n                var silent = isSilent(axisModel);\n                var triggerEvent = axisModel.get('triggerEvent');\n                for (var i = 0; i < ticks.length; i++) {\n                    if (ifIgnoreOnTick(axis, i, opt.labelInterval)) {\n                        continue;\n                    }\n                    var itemTextStyleModel = textStyleModel;\n                    if (categoryData && categoryData[i] && categoryData[i].textStyle) {\n                        itemTextStyleModel = new Model(categoryData[i].textStyle, textStyleModel, axisModel.ecModel);\n                    }\n                    var textColor = itemTextStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n                    var tickCoord = axis.dataToCoord(ticks[i]);\n                    var pos = [\n                            tickCoord,\n                            opt.labelOffset + opt.labelDirection * labelMargin\n                        ];\n                    var labelBeforeFormat = axis.scale.getLabel(ticks[i]);\n                    var textEl = new graphic.Text({\n                            anid: 'label_' + ticks[i],\n                            style: {\n                                text: labels[i],\n                                textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n                                textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,\n                                textFont: itemTextStyleModel.getFont(),\n                                fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor\n                            },\n                            position: pos,\n                            rotation: labelLayout.rotation,\n                            silent: silent,\n                            z2: 10\n                        });\n                    // Pack data for mouse event\n                    if (triggerEvent) {\n                        textEl.eventData = makeAxisEventDataBase(axisModel);\n                        textEl.eventData.targetType = 'axisLabel';\n                        textEl.eventData.value = labelBeforeFormat;\n                    }\n                    // FIXME\n                    this._dumbGroup.add(textEl);\n                    textEl.updateTransform();\n                    textEls.push(textEl);\n                    this.group.add(textEl);\n                    textEl.decomposeTransform();\n                }\n                function isTwoLabelOverlapped(current, next) {\n                    var firstRect = current && current.getBoundingRect().clone();\n                    var nextRect = next && next.getBoundingRect().clone();\n                    if (firstRect && nextRect) {\n                        firstRect.applyTransform(current.getLocalTransform());\n                        nextRect.applyTransform(next.getLocalTransform());\n                        return firstRect.intersect(nextRect);\n                    }\n                }\n                if (axis.type !== 'category') {\n                    // If min or max are user set, we need to check\n                    // If the tick on min(max) are overlap on their neighbour tick\n                    // If they are overlapped, we need to hide the min(max) tick label\n                    if (axisModel.getMin ? axisModel.getMin() : axisModel.get('min')) {\n                        var firstLabel = textEls[0];\n                        var nextLabel = textEls[1];\n                        if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n                            firstLabel.ignore = true;\n                        }\n                    }\n                    if (axisModel.getMax ? axisModel.getMax() : axisModel.get('max')) {\n                        var lastLabel = textEls[textEls.length - 1];\n                        var prevLabel = textEls[textEls.length - 2];\n                        if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n                            lastLabel.ignore = true;\n                        }\n                    }\n                }\n            },\n            axisName: function () {\n                var opt = this.opt;\n                var axisModel = this.axisModel;\n                var name = retrieve(opt.axisName, axisModel.get('name'));\n                if (!name) {\n                    return;\n                }\n                var nameLocation = axisModel.get('nameLocation');\n                var nameDirection = opt.nameDirection;\n                var textStyleModel = axisModel.getModel('nameTextStyle');\n                var gap = axisModel.get('nameGap') || 0;\n                var extent = this.axisModel.axis.getExtent();\n                var gapSignal = extent[0] > extent[1] ? -1 : 1;\n                var pos = [\n                        nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2,\n                        nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n                    ];\n                var labelLayout;\n                var nameRotation = axisModel.get('nameRotate');\n                if (nameRotation != null) {\n                    nameRotation = nameRotation * PI / 180;    // To radian.\n                }\n                var axisNameAvailableWidth;\n                if (nameLocation === 'middle') {\n                    labelLayout = innerTextLayout(opt, nameRotation != null ? nameRotation : opt.rotation, nameDirection);\n                } else {\n                    labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n                    axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                    if (axisNameAvailableWidth != null) {\n                        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n                        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                    }\n                }\n                var textFont = textStyleModel.getFont();\n                var truncateOpt = axisModel.get('nameTruncate', true) || {};\n                var ellipsis = truncateOpt.ellipsis;\n                var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);\n                var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n                        minChar: 2,\n                        placeholder: truncateOpt.placeholder\n                    }) : name;\n                var tooltipOpt = axisModel.get('tooltip', true);\n                var mainType = axisModel.mainType;\n                var formatterParams = {\n                        componentType: mainType,\n                        name: name,\n                        $vars: ['name']\n                    };\n                formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n                var textEl = new graphic.Text({\n                        anid: 'name',\n                        __fullText: name,\n                        __truncatedText: truncatedText,\n                        style: {\n                            text: truncatedText,\n                            textFont: textFont,\n                            fill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n                            textAlign: labelLayout.textAlign,\n                            textVerticalAlign: labelLayout.verticalAlign\n                        },\n                        position: pos,\n                        rotation: labelLayout.rotation,\n                        silent: isSilent(axisModel),\n                        z2: 1,\n                        tooltip: tooltipOpt && tooltipOpt.show ? zrUtil.extend({\n                            content: name,\n                            formatter: function () {\n                                return name;\n                            },\n                            formatterParams: formatterParams\n                        }, tooltipOpt) : null\n                    });\n                if (axisModel.get('triggerEvent')) {\n                    textEl.eventData = makeAxisEventDataBase(axisModel);\n                    textEl.eventData.targetType = 'axisName';\n                    textEl.eventData.name = name;\n                }\n                // FIXME\n                this._dumbGroup.add(textEl);\n                textEl.updateTransform();\n                this.group.add(textEl);\n                textEl.decomposeTransform();\n            }\n        };\n    /**\n     * @inner\n     */\n    function innerTextLayout(opt, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n        if (isRadianAroundZero(rotationDiff)) {\n            // Label is parallel with axis line.\n            verticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        } else if (isRadianAroundZero(rotationDiff - PI)) {\n            // Label is inverse parallel with axis line.\n            verticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        } else {\n            verticalAlign = 'middle';\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            } else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n    /**\n     * @inner\n     */\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            verticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            verticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        } else {\n            verticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            } else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n    /**\n     * @inner\n     */\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent') || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n    }\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n            var rawTick;\n            var scale = axis.scale;\n            return scale.type === 'ordinal' && (typeof interval === 'function' ? (rawTick = scale.getTicks()[i], !interval(rawTick, scale.getLabel(rawTick))) : i % (interval + 1));\n        };\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n            var interval = model.get('interval');\n            if (interval == null || interval == 'auto') {\n                interval = labelInterval;\n            }\n            return interval;\n        };\n    return AxisBuilder;\n});\ndefine('zrender', ['zrender/zrender'], function (zrender) { return zrender;});\ndefine('echarts', ['echarts/echarts'], function (echarts) { return echarts;});\nvar echarts = require('echarts');\n\necharts.graphic = require('echarts/util/graphic');\necharts.number = require('echarts/util/number');\necharts.format = require('echarts/util/format');\n\n\nrequire('echarts/chart/bar');\n\nrequire('echarts/chart/pie');\n\n\nrequire('echarts/component/grid');\n\nrequire('echarts/component/title');\n\n\n\n\nreturn echarts;\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/echarts.js\n ** module id = 50\n ** module chunks = 2\n **/"],"sourceRoot":""}