{"version":3,"sources":["webpack:///build.js","webpack:///./src/main.js","webpack:///./~/.npminstall/css-loader/0.23.1/css-loader/lib/css-base.js","webpack:///./~/.npminstall/vue-style-loader/1.0.0/vue-style-loader/addStyles.js","webpack:///./~/.npminstall/babel-runtime/6.11.6/babel-runtime/core-js/json/stringify.js","webpack:///./src/components/Calendar.vue","webpack:///./src/components/Index.vue","webpack:///./~/.npminstall/vue/1.0.26/vue/dist/vue.common.js","webpack:///./src/router.js","webpack:///./src/vuex/store.js","webpack:///App.vue","webpack:///Calendar.vue","webpack:///Create.vue","webpack:///Data.vue","webpack:///Edit.vue","webpack:///Index.vue","webpack:///Preview.vue","webpack:///./~/.npminstall/core-js/2.4.1/core-js/library/fn/json/stringify.js","webpack:///./~/.npminstall/core-js/2.4.1/core-js/library/modules/_core.js","webpack:///./src/components/Calendar.vue?e3d9","webpack:///./src/components/Create.vue?1690","webpack:///./src/components/Data.vue?64be","webpack:///./src/components/Header.vue?36c0","webpack:///./src/components/Index.vue?28b7","webpack:///./src/components/Preview.vue?3c63","webpack:///./src/App.vue?6302","webpack:///./src/App.vue?7bf5","webpack:///./src/components/Calendar.vue?e1f5","webpack:///./src/components/Create.vue?0487","webpack:///./src/components/Data.vue?0fb9","webpack:///./src/components/Edit.vue?ce79","webpack:///./src/components/Header.vue?b008","webpack:///./src/components/Index.vue?c5f4","webpack:///./src/components/Preview.vue?d2c8","webpack:///./src/App.vue","webpack:///./src/components/Create.vue","webpack:///./src/components/Data.vue","webpack:///./src/components/Edit.vue","webpack:///./src/components/Header.vue","webpack:///./src/components/Preview.vue","webpack:///./~/.npminstall/vue-router/0.7.13/vue-router/dist/vue-router.js","webpack:///./src/components/Calendar.vue?9d17","webpack:///./src/components/Create.vue?ade2","webpack:///./src/components/Data.vue?a463","webpack:///./src/components/Header.vue?83f9","webpack:///./src/components/Index.vue?710a","webpack:///./src/components/Preview.vue?cca8","webpack:///./src/App.vue?f8bb","webpack:///./~/.npminstall/vuex/1.0.0-rc.2/vuex/dist/vuex.js","webpack:///./src/echarts.js"],"names":["webpackJsonp","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_vue","_vue2","_vueRouter","_vueRouter2","_router","use","router","configRouter","list","toString","result","i","this","length","item","push","join","modules","mediaQuery","alreadyImportedModules","id","addStylesToDom","styles","options","domStyle","stylesInDom","refs","j","parts","addStyle","listToStyles","newStyles","css","media","sourceMap","part","insertStyleElement","styleElement","head","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","nextSibling","insertBefore","appendChild","firstChild","Error","removeStyleElement","parentNode","removeChild","idx","indexOf","splice","createStyleElement","document","createElement","type","update","remove","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","bind","applyToTag","newObj","index","styleSheet","cssText","replaceText","cssNode","createTextNode","childNodes","setAttribute","sources","btoa","unescape","encodeURIComponent","JSON","stringify","memoize","fn","memo","apply","arguments","isOldIE","test","window","navigator","userAgent","toLowerCase","getElementsByTagName","newList","mayRemove","textStore","replacement","filter","Boolean","__vue_script__","__vue_template__","template","global","set","key","val","hasOwn","_isVue","_data","ob","__ob__","convert","dep","notify","vms","vm","_proxy","_digest","del","_unproxy","hasOwnProperty","call","isLiteral","exp","literalValueRE","isReserved","str","c","charCodeAt","_toString","value","toNumber","parsed","Number","isNaN","toBoolean","stripQuotes","a","b","slice","camelize","replace","camelizeRE","toUpper","_","toUpperCase","hyphenate","hyphenateRE","classify","classifyRE","ctx","l","toArray","start","ret","Array","extend","to","from","keys","Object","isObject","isPlainObject","OBJECT_STRING","def","enumerable","defineProperty","writable","configurable","_debounce","func","wait","timeout","args","context","timestamp","later","last","Date","now","setTimeout","arr","cancellable","cb","cancelled","cancel","looseEqual","Cache","limit","size","tail","undefined","_keymap","create","pushFilter","lastFilterIndex","trim","tokens","match","filterTokenRE","name","map","processFilterArg","dir","filters","arg","reservedArgRE","dynamic","stripped","parseDirective","s","hit","cache$1","get","inSingle","inDouble","curly","square","paren","prev","expression","put","escapeRegex","regexEscapeRE","compileRegex","open","config","delimiters","close","unsafeOpen","unsafeDelimiters","unsafeClose","tagRE","RegExp","htmlRE","cache","parseText","text","html","first","oneTime","lastIndex","exec","tag","tokensToExp","token","formatToken","single","$eval","inlineFilters","filterRE","appendWithTransition","el","target","applyTransition","beforeWithTransition","before","removeWithTransition","direction","op","transition","__v_trans","hooks","transitionEndEvent","_isCompiled","$parent","action","query","querySelector","inDoc","node","doc","ownerDocument","documentElement","parent","nodeType","contains","getAttr","_attr","getAttribute","removeAttribute","getBindAttr","hasBindAttr","hasAttribute","after","prepend","replaceChild","on","event","useCapture","addEventListener","off","removeEventListener","getClass","classname","className","baseVal","setClass","cls","isIE9","namespaceURI","addClass","classList","add","cur","removeClass","tar","extractContent","asFragment","child","rawContent","isTemplate","isFragment","content","hasChildNodes","trimNode","createDocumentFragment","isTrimmable","lastChild","data","tagName","createAnchor","persist","anchor","debug","createComment","__v_anchor","findRef","hasAttributes","attrs","attributes","refRE","mapNodeRange","end","next","removeNodeRange","frag","onRemoved","removed","done","nodes","getOuterHTML","outerHTML","container","cloneNode","innerHTML","checkComponentAttr","hasAttrs","commonTagRE","reservedTagRE","getIsBinding","resolveAsset","is","mergeData","toVal","fromVal","mergeAssets","parentVal","childVal","res","guardArrayAssets","guardComponents","components","ids","Vue","guardProps","props","isArray","assets","asset","mergeOptions","mergeField","strat","strats","defaultStrat","mixins","mixin","mixinOptions","prototype","warnMissing","camelizedId","charAt","Dep","uid$1","subs","withoutConversion","shouldConvert","Observer","augment","hasProto","protoAugment","copyAugment","arrayMethods","arrayKeys","observeArray","walk","src","__proto__","observe","isExtensible","addVm","defineReactive","property","getOwnPropertyDescriptor","getter","setter","childOb","depend","e","newVal","initMixin","_init","$el","$root","$children","$refs","$els","_watchers","_directives","_uid","uid","_events","_eventsCount","_isFragment","_fragment","_fragmentStart","_fragmentEnd","_isDestroyed","_isReady","_isAttached","_isBeingDestroyed","_vForRemoving","_unlinkFn","_context","_scope","_frag","children","$options","constructor","_updateRef","_callHook","_initState","_initEvents","$mount","getPathCharType","ch","code","formatSubPath","path","trimmed","parse","maybeUnescapeQuote","nextChar","mode","IN_SINGLE_QUOTE","IN_DOUBLE_QUOTE","newChar","actions","APPEND","typeMap","BEFORE_PATH","subPathDepth","PUSH","INC_SUB_PATH_DEPTH","PUSH_SUB_PATH","IN_SUB_PATH","pathStateMachine","ERROR","AFTER_PATH","raw","parsePath","pathCache","getPath","parseExpression","setPath","original","$set","noop","save","isString","saved","newlineRE","rewrite","allowedKeywordsRE","restoreRE","restore","compileGetter","improperKeywordsRE","body","saveRE","wsRE","identRE","makeGetterFn","Function","compileSetter","scope","needSet","expressionCache","isSimplePath","pathTestRE","literalValueRE$1","resetBatcherState","queue","userQueue","has","circular","waiting","flushBatcherQueue","_again","runBatcherQueue","devtools","emit","watcher","run","pushWatcher","q","user","nextTick","Watcher","expOrFn","isFn","uid$2","active","dirty","lazy","deps","newDeps","depIds","_Set","newDepIds","prevError","twoWay","queued","shallow","traverse","seen","seenObjects","clear","isA","isO","depId","isRealTemplate","stringToFragment","templateString","cacheKey","templateCache","tagMatch","tagRE$1","entityMatch","entityRE","commentMatch","commentRE","wrap","efault","depth","prefix","suffix","nodeToFragment","textContent","clonedNode","querySelectorAll","cloned","hasBrokenTemplate","tempClone","hasTextareaCloneBug","parseTemplate","shouldClone","idSelectorCache","getElementById","Fragment","linker","host","parentFrag","childFrags","inserted","unlink","singleBefore","singleRemove","multiBefore","multiRemove","__v_frag","withTransition","method","callHook","attach","shouldCallRemove","self","beforeRemove","detach","destroy","FragmentFactory","cid","cacheId","linkerCache","compile","findPrevFrag","previousSibling","forId","findVmFromFrag","__vue__","range","n","Math","floor","getTrackByKey","trackByKey","getValue","multi","init","selected","_value","indexOf$1","keyFilter","handler","codes","charCode","parseInt","keyCodes","concat","keyCode","stopFilter","stopPropagation","preventFilter","preventDefault","selfFilter","currentTarget","normalize","prop","propCache","camel","upper","testEl","prefixed","prefixes","style","kebab","camelPrefixes","normalize$1","_key","k","split","callActivateHooks","called","total","compileProps","propOptions","attr","names","empty","identRE$1","propBindingModes","ONE_WAY","TWO_WAY","ONE_TIME","optimizedLiteral","parentPath","makePropsLinkFn","_props","inlineProps","propsData","initProp","$get","_bindDir","propDef","processPropValue","rawValue","isSimple","getPropDefaultValue","coerceProp","coerced","assertProp","updateProp","required","valid","expectedTypes","assertedType","assertType","expectedType","validator","coerce","String","pushJob","job","queue$1","flush","f","offsetHeight","Transition","enterClass","leaveClass","pendingCssEvent","pendingCssCb","pendingJsCb","justEntered","entered","left","typeCache","forEach","m","isHidden","rect","getBoundingClientRect","width","height","offsetWidth","getClientRects","partial","nodeLinkFn","_asComponent","compileNode","childLinkFn","terminal","isScript","compileNodeList","dirs","linkAndCapture","makeUnlinkFn","originalDirCount","sort","directiveComparator","_bind","descriptor","priority","DEFAULT_PRIORITY","contextDirs","destroying","teardownDirs","_teardown","compileAndLinkProps","propsLinkFn","propDirs","compileRoot","contextOptions","contextLinkFn","replacerLinkFn","containerAttrs","_containerAttrs","replacerAttrs","_replacerAttrs","compileDirectives","selfDirs","compileTextNode","compileElement","linkFn","checkTerminalDirectives","checkElementDirectives","checkComponent","_skip","removeText","wholeText","processTextToken","makeTextNodeLinkFn","setTokenType","directives","fragClone","nodeList","linkFns","makeChildLinkFn","childrenLinkFn","makeTerminalNodeLinkFn","component","ref","internalDirectives","modifiers","literal","componentLinkFn","skip","previousElementSibling","matched","dirName","rawName","termDef","modifierRE","dirAttrRE","DEFAULT_TERMINAL_PRIORITY","parseModifiers","pushDir","interpTokens","hasOneTimeToken","hasOneTime","interp","dirDef","transitionRE","bindRE","onRE","makeNodeLinkFn","transclude","extractAttrs","_content","transcludeTemplate","replacer","mergeAttrs","specialCharRE","resolveSlots","contents","_slotContents","extractFragment","stateMixin","makeComputedGetter","owner","evaluate","newData","_setData","_initProps","_initMeta","_initMethods","_initData","_initComputed","_propsUnlinkFn","dataFn","oldData","removeVm","computed","userDef","methods","metas","_meta","eventsMixin","registerComponentEvents","eventRE","_fromParent","$on","registerCallbacks","hash","handlers","register","onAttached","callAttach","onDetached","callDetach","events","watch","_initDOMHooks","hook","$emit","noop$1","Directive","_locked","_bound","_listeners","_host","lifecycleMixin","_ref","_compile","_initElement","rootLinker","contentLinkFn","ctor","_linkerCachable","rootUnlinkFn","contentUnlinkFn","_destroy","deferCleanup","_cleanup","destroyReady","pendingRemoval","cleanupIfPossible","$remove","$destroy","teardown","$off","miscMixin","_applyFilters","oldValue","write","offset","read","_resolveComponent","factory","resolved","requested","pendingCallbacks","cbs","reason","dataAPI","clean","asStatement","$arguments","$delete","$watch","deep","sync","immediate","filterRE$1","$interpolate","$log","console","log","domAPI","insert","op1","op2","targetIsDetached","shouldCallHook","append","beforeWithCb","removeWithCb","$nextTick","$appendTo","$prependTo","$before","$after","inDocument","realCb","eventsAPI","modifyListenerCount","count","hookRE","$once","isSource","shouldPropagate","hasParentCbs","some","$broadcast","source","$dispatch","lifecycleAPI","ready","$compile","limitBy","filterBy","search","delimiter","convertArray","$value","$key","orderBy","baseCompare","sortKeyIndex","sortKey","sortKeys","order","comparator","firstArg","installGlobalAPI","createClass","elementDirectives","transitions","partials","util","compiler","parsers","directive","extendOptions","Super","isFirstExtend","_Ctor","Sub","_assetTypes","plugin","installed","unshift","install","definition","inBrowser","__VUE_DEVTOOLS_GLOBAL_HOOK__","UA","isIE","isAndroid","isIos","iosVersionMatch","iosVersion","hasMutationObserverBug","indexedDB","transitionProp","animationProp","animationEndEvent","isWebkitTrans","ontransitionend","onwebkittransitionend","isWebkitAnim","onanimationend","onwebkitanimationend","nextTickHandler","pending","copies","callbacks","timerFunc","MutationObserver","setImmediate","counter","observer","textNode","characterData","Set","p","entry","shift","newer","older","returnEntry","freeze","defineProperties","silent","async","warnExpressionErrors","_delimitersChanged","_propBindingModes","_maxUpdateCount","warn","optionMergeStrategies","instanceData","defaultData","created","attached","detached","beforeCompile","compiled","beforeDestroy","destroyed","activate","addSub","sub","removeSub","addDep","arrayProto","getOwnPropertyNames","items","debounce","IN_PATH","BEFORE_IDENT","IN_IDENT","ws","ident","[","eof",".","0","number","'","\"","]","else","allowedKeywords","improperKeywords","beforeGet","preProcess","postProcess","afterGet","forContext","$forContext","alias","_withLock","$index","tmp","current","text$1","legend","tr","col","td","th","option","optgroup","thead","tbody","colgroup","caption","tfoot","g","defs","symbol","image","circle","ellipse","line","polygon","polyline","t","placeholder","swap","_watcher","ON","MODEL","BIND","TRANSITION","EL","COMPONENT","PARTIAL","IF","FOR","SLOT","uid$3","vFor","params","inMatch","itMatch","iterator","isOption","diff","updateRef","updateModel","primitive","convertedFromObject","fromObject","trackBy","oldFrags","frags","getCachedFrag","reused","fresh","removalIndex","totalRemoved","deleteCachedFrag","w","targetPrev","prevEl","currentPrev","insertionIndex","staggerCb","staggerAnchor","move","parentScope","cacheFrag","model","__v_model","forceUpdate","staggerAmount","getStagger","trans","stagger","_preProcess","_postProcess","unbind","vIf","invalid","nextElementSibling","elseEl","elseFrag","elseFactory","show","toggle","display","text$2","isRange","composing","listener","focused","rawListener","hasjQuery","jQuery","afterBind","radio","checked","select","_this","multiple","initValue","selectedIndex","checkbox","getBooleanValue","_trueValue","_falseValue","checkFilters","hasRead","hasWrite","_unbind","esc","tab","enter","space","delete","up","right","down","on$1","acceptStatement","iframeBind","contentWindow","capture","stop","prevent","reset","importantRE","handleObject","reduce","handleSingle","isImportant","setProperty","xlinkNS","xlinkRE","disallowedInterpAttrRE","attrWithPropsRE","enumeratedAttrRE","modelProps","true-value","false-value","bind$1","attrValue","modelProp","setAttributeNS","cloak","for","if","vClass","cleanup","prevKeys","keepAlive","inlineTemplate","pendingComponentCb","Component","pendingRemovals","pendingRemovalCb","setComponent","invalidatePending","resolveComponent","mountComponent","unbuild","childVM","ComponentName","activateHooks","cached","getCached","newComponent","build","waitingFor","extraOptions","_isRouterView","defer","_inactive","transitionMode","bindingModes","childKey","parentKey","parentWatcher","childWatcher","TYPE_TRANSITION","TYPE_ANIMATION","transDurationProp","animDurationProp","raf","requestAnimationFrame","waitForTransitionStart","p$1","cancelPending","callHookWithCb","enterCancelled","enterNextTick","enterDone","getCssTransitionType","setupCssCb","leave","leaveCancelled","leaveDone","leaveNextTick","hasPending","hidden","inlineStyles","computedStyles","getComputedStyle","transDuration","animDuration","onEnd","transition$1","oldId","class","_setupParams","_checkStatement","_update","oldVal","mappedKey","_setupParamWatcher","unwatch","paramWatchers","_paramUnwatchFns","$event","listeners","unwatchFns","slot","fallback","elseBlock","digitsRE","json","indent","capitalize","uppercase","lowercase","currency","_currency","decimals","parseFloat","isFinite","stringified","abs","toFixed","_int","_float","sign","pluralize","delay","version","/index","/create","/edit/:questId","/preview/:questId","/data/:questId","redirect","*","_App2","_App","updateStorage","state","localStorage","setItem","KEY","_stringify2","questionnaireList","_stringify","_vuex","_vuex2","questionnaire01","title","deadline","questItemList","selections","questionnaire02","questionnaire03","getItem","currentQuestionnaire","mutations","ADD_QUEST","RM_QUEST","UPDATE_QUEST","SET_QUEST","Store","_Header","_Header2","_Index","_Index2","_store","_store2","msg","v-header","Index","store","date","weekList","currentYear","getFullYear","currentMonth","getMonth","yearList","monthList","tableData","currentDateList","oneDayMilliseconds","dateWeek","getDay","firstDate","getTime","incrMonth","decrMonth","handleClick","dataset","_date","showCalendar","_Calendar","_Calendar2","showSelections","showMask","questionnaire","questItem","textarea","addItem","nodeName","handleInput","itemTitle","itemSelections","operation","addTextarea","addSelections","handleCancel","handleItemOperation","moveUp","moveDown","removeQuestItem","reuseQuestItem","newQuestItem","submit","alert","publish","Calendar","date-change","toLocaleDateString","vuex","dispatch","$router","go","_ref2","_echarts","_echarts2","getters","setCurrentQuest","route","questId","echarts","instance","seriesData","random","grid","top","bottom","textAlign","yAxis","xAxis","series","radius","setOption","dispose","_ref3","_ref4","checkedQuest","setQuest","removeQuest","createQuest","handleOperation","handleChecked","createOrRm","core","$JSON","it","__e","Target","matcher","delegate","Matcher","routes","generateMatch","startingPath","nestedCallback","fullPath","addRoute","routeArray","len","substr","eachRoute","baseRoute","callback","binding","addRouteCallback","noWarning","error","tryDecode","uri","asComponent","decodeURIComponent","decodeURI","StaticSegment","string","DynamicSegment","StarSegment","EpsilonSegment","specificity","segments","results","segment","State","charSpec","nextStates","sortSolutions","states","recognizeChar","RecognizeResults","queryParams","findHandler","regex","captures","currentCapture","isDynamic","addSegment","currentState","eachChar","decodeQueryParamPart","warn$1","resolvePath","base","relative","stack","pop","isPromise","then","getRouteConfig","resolveAsyncComponent","resolver","resolve","exports$1","mapParams","genQuery","canReuse","view","canReuseFn","canDeactivate","fromComponent","expectBoolean","canActivate","aborted","deactivate","callHooks","reuse","activateQueue","saveChildView","activateHook","dataHook","waitForData","activated","loading","$loadingRouteData","_routerView","cachedChildView","_keepAliveRouterView","childView","_rendered","_transitionOnLoad","setCurrent","afterData","afterActivate","loadData","postActivate","processData","promises","resolvedVal","all","isPlainOjbect","applyOverride","_Vue$util","root","_parent","$route","_children","_defineMeta","hooksToMergeRE","View","componentDef","viewDef","_isDynamicLiteral","parentView","_rootView","_currentTransition","elementDirective","Link","sameOrigin","link","protocol","location","hostname","port","toggleClasses","onPriority","LINK_UPDATE","activeId","childLinks","existingId","activeIds","updateClasses","onRouteUpdate","onClick","exact","prevActiveClass","activeClass","metaKey","ctrlKey","shiftKey","defaultPrevented","button","pathname","history","rootRE","newPath","stringifyPath","updateActiveMatch","updateHref","activeRE","queryStringRE","isAbsolute","href","formatPath","_linkActiveClass","dest","trailingSlashRE","guardComponent","comp","babelHelpers","classCallCheck","Constructor","TypeError","willAddRoute","addChild","contextEntered","specials","validChars","generate","invalidChars","repeat","isEqual","chars","returned","oCreate","proto","F","RouteRecognizer","rootState","allSegments","isEmpty","as","handlersFor","hasRoute","output","generateQueryString","pairs","pair","arrayPair","parseQueryString","queryString","keyLength","recognize","pathLen","queryStart","isSlashDropped","solutions","hashRE","HTML5History","onChange","baseEl","url","replaceState","pos","x","pageXOffset","y","pageYOffset","pushState","hashMatch","HashHistory","hashbang","formattedPath","isAbsoloute","AbstractHistory","currentPath","RouteTransition","abort","abortingOnLoad","deactivateQueue","reverseDeactivateQueue","reverse","reuseQueue","runQueue","_onTransitionValidated","_view","step","_ref$expectBoolean","_ref$postActivate","nextCalled","onError","err","_suppress","onPromiseError","nextWithBoolean","ok","nextWithData","exposed","internalKeysRE","Route","_recognizer","_notFoundHandler","historyBackends","abstract","html5","Router","_ref$hashbang","_ref$abstract","_ref$history","_ref$saveScrollPosition","saveScrollPosition","_ref$transitionOnLoad","transitionOnLoad","_ref$suppressTransitionError","suppressTransitionError","_ref$root","_ref$linkActiveClass","linkActiveClass","app","_guardRecognizer","_started","_startCb","_currentRoute","_previousTransition","_notFoundRedirect","_beforeEachHooks","_afterEachHooks","_root","_abstract","_hashbang","hasPushState","_history","_historyFallback","History","_match","_saveScrollPosition","_map","rootPath","_notFound","_addRoute","_addRedirect","_addAlias","beforeEach","afterEach","App","_appContainer","Ctor","_appConstructor","_location","assign","generatedPath","currentParams","targetParams","encodeURI","subRoutes","subPath","redirectPath","_addGuard","aliasPath","mappedPath","_handler","_this2","realPath","_checkGuard","_this3","currentRoute","currentTransition","_prevTransition","beforeHooks","startTransition","_postTransition","scrollTo","scrollX","offsetTop","externalVue","locals","mergeObjects","existing","_typeof","getNestedState","nestedKeys","getWatcher","getDep","devtoolPlugin","targetState","subscribe","mutation","override","vuexInit","$store","defineVuexGetter","makeBoundAction","_getterCacheId","_vm","computedGetter","_len","_key2","usesInit","_lifecycleHooks","beforeCreate","merge","_Vue","Symbol","protoProps","staticProps","toConsumableArray","arr2","_ref$state","_ref$mutations","_ref$modules","_ref$plugins","plugins","_ref$strict","strict","_dispatching","_rootMutations","_mutations","_modules","_subscribers","_setupModuleState","_setupModuleMutations","_setupMutationCheck","_len2","payload","isObjectStyleDispatch","h","_this4","updatedModules","updatedMutations","_createModuleMutations","_this5","newNestedKeys","nestedMutations","_len3","_key3","_this6","v","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","require","define","baseId","basePath","namePath","baseLen","nameLen","cutBaseTerms","cutNameTerms","pathLoop","createRequire","localRequire","cacheMods","getModExports","getModsExports","es","mod","mods","min","defined","factoryReturn","zrUtil","registerVisual","curry","registerLayout","registerProcessor","barLayoutGrid","ecModel","eachSeriesByType","seriesModel","getData","setVisual","graphic","layout","extendComponentModel","layoutMode","ignoreSize","defaultOption","zlevel","z","subtext","subtarget","backgroundColor","borderColor","borderWidth","padding","itemGap","textStyle","fontSize","fontWeight","color","subtextStyle","extendComponentView","render","titleModel","api","group","removeAll","textStyleModel","getModel","subtextStyleModel","textBaseline","textEl","Text","textFont","getFont","fill","getTextColor","z2","textRect","getBoundingRect","subText","subTextEl","sublink","groupRect","layoutOption","getBoxLayoutParams","layoutRect","getLayoutRect","getWidth","getHeight","alignStyle","textVerticalAlign","setStyle","margin","getItemStyle","Rect","shape","subPixelOptimizeRect","gridModel","coordinateSystem","getRect","defaults","registerPreprocessor","numberUtil","formatUtil","IntervalScale","intervalScaleProto","mathCeil","ceil","mathFloor","ONE_SECOND","ONE_MINUTE","ONE_HOUR","ONE_DAY","bisect","lo","hi","mid","TimeScale","getLabel","stepLvl","_stepLvl","formatTime","niceExtent","approxTickNum","fixMin","fixMax","extent","_extent","Infinity","d","getDate","niceTicks","interval","_interval","round","span","approxInterval","scaleLevelsLen","scaleLevels","level","yearSpan","yearStep","nice","_niceExtent","parseDate","each","methodName","createRegisterEventWithLowercaseName","eventName","Eventful","MessageCenter","ECharts","dom","theme","opts","prioritySortFunc","prio","themeStorage","_dom","_zr","zrender","renderer","devicePixelRatio","_theme","clone","_chartsViews","_chartsMap","_componentsViews","_componentsMap","_api","ExtensionAPI","_coordSysMgr","CoordinateSystemManager","_messageCenter","resize","_pendingActions","timsort","visualFuncs","dataProcessorFuncs","animation","_onframe","toggleHighlight","_model","eachComponent","mainType","chartView","__viewId","__alive","invokeUpdateMethod","componentModel","__model","updateZ","eachSeries","chart","updateProgressiveAndBlend","updateHoverLayerStatus","prepareView","isComponent","viewList","viewMap","zr","componentType","viewId","classType","ComponentModel","parseClassType","Clazz","ComponentView","main","ChartView","__id","process","stackSeriesData","stackedDataMap","previousStack","stackedOn","doLayout","visual","isLayout","doVisualEncoding","clearColorPalette","doRender","componentView","storage","elCount","isGroup","env","useHoverLayer","ignore","frameDrawNum","needProgressive","progressive","stopAnimation","blendMode","canvasSupported","enableConnect","updateConnectedChartsStatus","charts","status","otherChart","STATUS_KEY","STATUS_PENDING","STATUS_UPDATING","STATUS_UPDATED","eventActionMap","actionType","eventType","connectedGroups","makeActionFromEvent","otherCharts","instances","dispatchAction","GlobalModel","OptionManager","SeriesModel","colorTool","PRIORITY_PROCESSOR_FILTER","PRIORITY_PROCESSOR_STATISTIC","PRIORITY_VISUAL_LAYOUT","PRIORITY_VISUAL_GLOBAL","PRIORITY_VISUAL_CHART","PRIORITY_VISUAL_COMPONENT","PRIORITY_VISUAL_BRUSH","IN_MAIN_PROCESS","HAS_GRADIENT_OR_PATTERN_BG","OPTION_UPDATED","one","echartsProto","updateMethods","prepareAndUpdate","getDom","getZr","notMerge","lazyUpdate","assert","optionManager","optionPreprocessorFuncs","refreshImmediately","_flushPendingActions","setTheme","getOption","getRenderedCanvas","pixelRatio","getDisplayList","painter","getDataURL","excludeComponents","excludesComponentViews","toDataURL","getConnectedDataURL","groupId","mathMin","mathMax","max","MAX_NUMBER","canvasList","dpr","canvas","boundingRect","targetCanvas","createCanvas","img","Image","coordSysMgr","restoreData","isSingleCanvas","configLayer","clearColor","colorArr","colorStops","background","updateView","clearAllVisual","updateVisual","updateLayout","highlight","downplay","optionChanged","resetOption","_loadingFX","showLoading","cfg","hideLoading","loadingEffects","eventObj","actionWrap","actionInfo","updateMethod","payloads","batched","batch","eventObjBatch","isHighlightOrDownplay","batchItem","trigger","pendingActions","MOUSE_EVENT_NAMES","eveName","dataIndex","dataModel","getSeriesByIndex","seriesIndex","getDataParams","dataType","eventData","isDisposed","_disposed","idBase","groupIdBase","DOM_ATTRIBUTE_KEY","dependencies","isDom","clientWidth","clientHeight","connect","disConnect","getInstanceByDom","getInstanceById","registerTheme","preprocessorFunc","processorFunc","registerAction","registerCoordinateSystem","CoordinateSystem","layoutFunc","visualFunc","registerLoading","loadingFx","superClass","extendSeriesModel","extendChartView","setCanvasCreator","creator","List","Model","format","matrix","vector","PRIORITY","PROCESSOR","FILTER","STATISTIC","VISUAL","LAYOUT","GLOBAL","CHART","BRUSH","Scale","scaleProto","mathPow","pow","mathLog","LogScale","getTicks","scale","setExtent","getExtent","unionExtent","quantity","updateDataSelected","hasAnimation","getName","selectedOffset","seriesId","toggleItemSelected","getItemGraphicEl","getItemLayout","isSelected","midAngle","startAngle","endAngle","dx","cos","dy","sin","position","animate","when","PiePiece","onEmphasis","hoverIgnore","onNormal","normalIgnore","Group","sector","Sector","Polyline","updateData","getLabelStyle","labelModel","labelPosition","isLabelInside","getItemVisual","opacity","retrieve","hostModel","getFormattedLabel","piePieceProto","firstCreate","animateTo","r","childAt","itemModel","getItemModel","sectorShape","label","setShape","updateProps","itemStyleModel","visualColor","useStyle","lineJoin","hoverStyle","ifEnableAnimation","_updateLabel","setHoverStyle","labelLine","labelText","labelLayout","points","linePoints","verticalAlign","font","rotation","origin","labelHoverModel","labelLineModel","labelLineHoverModel","stroke","getLineStyle","smooth","inherits","Pie","sectorGroup","_sectorGroup","isFirstRender","onSectorClick","selectedMode","piePiece","eachChild","setItemGraphicEl","newIdx","oldIdx","execute","removeClipPath","setClipPath","_createClipPath","cx","cy","clockwise","clipPath","r0","initProps","PI","modelUtil","completeDimensions","dataSelectableMixin","PieSeries","superApply","legendDataProvider","_dataBeforeProcessed","updateSelectedMap","_defaultLabelLine","mergeOption","newOption","superCall","getInitialData","dimensions","initData","sum","getSum","percent","$vars","defaultEmphasis","labelLineNormalOpt","normal","labelLineEmphasisOpt","emphasis","legendHoverLink","hoverAnimation","center","minAngle","avoidLabelOverlap","rotate","length2","lineStyle","itemStyle","animationEasing","seriesType","actionInfos","subType","isBuildInObject","overwrite","targetProp","sourceProp","mergeAll","targetAndSources","overlay","getContext","_ctx","array","clazz","baseClazz","clazzPrototype","isArrayLike","nativeForEach","nativeMap","nativeReduce","nativeFilter","find","nativeSlice","objToString","isFunction","BUILTIN_OBJECT","values","condition","message","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","paletteScope","eachRawSeriesByType","dataAll","getRawData","idxMap","isSeriesFiltered","rawIdx","getRawIndex","filteredIdx","singleDataColor","setItemVisual","getColorFromPalette","parsePercent","PI2","RADIAN","unitRadian","roseType","getDataExtent","restAngle","valueSumLargerThanMinAngle","currentAngle","angle","setItemLayout","linearMap","legendModels","findComponents","filterSelf","isAxisUsedInTheGrid","axisModel","findGridModel","getLabelUnionRect","axis","labels","getFormattedLabels","labelCount","isLabelIgnored","singleRect","getTextRect","union","Grid","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","updateAxisTransfrom","coordBase","axisExtent","axisExtentSum","toGlobalCoord","dim","coord","toLocalCoord","findAxesModels","axesTypes","axisType","queryComponents","isCartesian2D","axisHelper","Cartesian2D","Axis2D","ifAxisCrossZero","niceScaleExtent","gridProto","_rect","ifAxisCanNotOnZero","otherAxisDim","axes","axesMap","_updateScale","onZero","adjustAxes","axesList","isHorizontal","gridRect","inverse","labelUnionRect","getAxis","axisIndex","axesMapOnDim","getCartesian","xAxisIndex","yAxisIndex","coordList","createAxisCreator","axisPosition","axisPositionUsed","createScaleByModel","isCategory","onBand","axesCount","cartesian","addAxis","coordDimToDataDim","axesModels","xAxisModel","yAxisModel","componentIndex","grids","createListFromArray","coordSys","getMarkerPosition","pt","dataToPoint","getLayout","offsetIndex","getBaseAxis","NaN","brushSelector","barMinHeight","fixLayoutWithLineWidth","lineWidth","signX","signY","coordinateSystemType","_renderOnCartesian","createRect","isUpdate","barBorderWidthQuery","enableAnimation","rectShape","animateProperty","animateTarget","baseAxis","hasValue","newIndex","oldIndex","_updateStyle","setLabel","labelPositionOutside","setText","textPosition","eachItemGraphicEl","getBarItemStyle","hoverLabelModel","rectStyle","getRawValue","getSeriesStackId","getAxisKey","calBarWidthAndOffset","barSeries","columnsMap","bandWidth","getBandWidth","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","stackId","maxWidth","barWidth","barMaxWidth","barGap","barCategoryGap","coordSysName","barGapPercent","autoWidth","column","lastColumn","widthSum","barWidthAndOffset","getSeriesByType","lastStackCoords","columnLayoutInfo","columnOffset","columnWidth","valueAxis","getOtherAxis","valueAxisStart","dataToCoord","getGlobalExtent","coords","dataToPoints","setLayout","lastCoord","hasFillOrStroke","fillOrStroke","liftColor","lift","cacheElementStl","__hoverStlDirty","__hoverStl","normalStyle","__normalStl","doSingleEnterHover","__isHover","__zr","addHover","doSingleLeaveHover","normalStl","removeHover","doEnterHover","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","animatableModel","animationEnabled","getShallow","postfix","duration","animationDelay","pathTool","Path","Circle","Ring","Polygon","Line","BezierCurve","Arc","CompoundPath","LinearGradient","RadialGradient","BoundingRect","extendShape","extendPath","pathData","extendFromString","makePath","createFromString","aspect","resizePath","mergePath","applyTransform","pathRect","calculateTransform","subPixelOptimizeLine","param","subPixelOptimize","x1","x2","y1","y2","originX","originY","originWidth","originHeight","positiveOrNegative","doubledPosition","labelColor","textDistance","textFill","getTransform","ancestor","mat","identity","mul","getLocalTransform","vertex","transform","invert","transformDirection","hBase","vBase","groupTransition","g1","g2","getElMap","elMap","anid","getAnimatableProps","elMap1","oldEl","newProp","boxLayout","orient","maxHeight","currentLineMaxSize","nextX","nextY","nextChild","nextChildRect","moveX","newline","moveY","LOCATION_PARAMS","box","vbox","hbox","getAvailableSize","positionInfo","containerRect","containerWidth","containerHeight","normalizeCssArray","verticalMargin","horizontalMargin","positionGroup","mergeLayoutParam","targetOption","opt","newParams","newValueCount","merged","mergedValueCount","enoughParamNumber","hasProp","copy","hNames","vNames","hResult","vResult","getLayoutParams","copyLayoutParams","_trim","RADIAN_EPSILON","domain","clamp","subDomain","subRange","precision","asc","getPrecision","getPrecisionSafe","dotIndex","getPixelPrecision","dataExtent","pixelExtent","LN10","dataQuantity","sizeQuantity","MAX_SAFE_INTEGER","remRadian","radian","pi2","isRadianAroundZero","nf","exp10","textContain","addCommas","toCamelCase","group1","encodeHTML","TPL_VAR_ALIAS","wrapVar","varName","seriesIdx","formatTpl","tpl","paramsList","seriesLen","s2d","M","getHours","getMinutes","getSeconds","capitalFirst","truncateText","roundingErrorFix","thisExtent","other","getInterval","setInterval","ticks","safeLimit","tick","getTicksLabels","splitNumber","expandSize","detect","ua","os","browser","firefox","ie","edge","touchEventsSupported","pointerEventsSupported","chartInstance","echartsAPIList","mergeTheme","hasClass","initBase","baseOption","OPTION_INNER_KEY","_seriesIndices","globalDefault","getComponentsByTypes","componentsMap","types","makeKeyInfo","mapResult","idMap","existCpt","exist","determineSubType","keyInfo","idNum","newCptOption","existComponent","createSeriesIndices","seriesModels","filterBySubType","cpt","assertSeriesInitialized","parentModel","_optionManager","mountOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","mediaOption","visitComponent","newCptOptionList","normalizeToArray","mappingToExists","dependentModels","resultItem","ComponentModelClass","optionUpdated","extraOpt","newCptTypes","componentOption","topologicalTravel","getAllClassMainTypes","isIdInner","getTheme","getComponent","cpts","isIdArray","isNameArray","getQueryCond","indexAttr","idAttr","nameAttr","doFilter","queryCond","queryResult","getSeriesByName","oneSeries","getSeries","rawSeriesIndex","eachRawSeries","filterSeries","filteredSeries","componentTypes","_timelineOptions","_mediaList","_mediaDefault","_currentMediaIndices","_optionBackup","_newBaseOption","parseRawOption","rawOption","isNew","mediaDefault","timelineOptions","mediaList","timelineOpt","timeline","singleMedia","applyMediaQuery","ecWidth","ecHeight","realMap","aspectratio","applicatable","QUERY_REG","operator","realAttr","compare","real","expect","indicesEquals","indices1","indices2","oldOption","newCptOpt","oldCptOpt","oldOptionBackup","newParsedOption","isRecreate","optionBackup","timelineModel","getCurrentIndex","indices","_coordinateSystems","coordinateSystemCreators","coordinateSystems","coordinateSystemCreator","colorPaletteMixin","visualColorAccessPath","mergeDefaultAndTheme","cloneShallow","getDefaultOption","LABEL_OPTIONS","fillDataTextStyle","newSeriesOption","getLinkedData","setData","coordDim","dataDimToCoordDim","dataDim","formatTooltip","multipleSeries","formatArrayValue","dimInfo","getDimensionInfo","dimType","formattedValue","colorEl","seriesName","getAxisTooltipDataIndex","dataFormatMixin","getDependencies","getClassesByMainType","arrayPush","clazzUtil","componentUtil","$constructor","getUID","inputPositionParams","themeModel","isInit","optList","Class","__defaultOption","enableClassManagement","registerWhenExtend","enableSubTypeDefaulter","enableTopologicalTravel","componentProto","enableClassExtend","Chart","elSetState","childCount","dataIndices","indexOfName","chartProto","delInstance","guid","Handler","Storage","Animation","HandlerProxy","useVML","painterCtors","ZRender","getInstance","registerPainter","rendererType","vml","handerProxy","getViewportRoot","stage","_needsRefresh","_needsRefreshHover","refreshHoverImmediately","oldDelFromMap","delFromMap","oldAddToMap","addToMap","elId","removeSelfFromZr","addSelfToZr","getId","addRoot","delRoot","zLevel","refresh","refreshHover","clearHover","clearAnimation","pathToImage","setCursorStyle","cursorStyle","eventHandler","arrySlice","_$handlers","_h","isSilent","argLen","triggerWithContext","clampCssByte","clampCssAngle","clampCssFloat","parseCssInt","parseCssFloat","cssHueToRgb","m1","m2","lerp","colorStr","kCSSColorTable","ep","fname","alpha","hsla2rgba","iv","hsla","rgba","rgba2hsla","H","S","R","G","B","vMin","vMax","delta","L","deltaR","deltaG","deltaB","toHex","fastMapToColor","normalizedValue","colors","out","leftIndex","rightIndex","leftColor","rightColor","dv","mapToColor","fullOutput","modifyHSL","modifyAlpha","arrColor","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","minRunLength","DEFAULT_MIN_MERGE","makeAscendingRun","runHi","reverseRun","binaryInsertionSort","pivot","gallopLeft","hint","lastOffset","maxOffset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","mergeLow","mergeHigh","cursor1","cursor2","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","tmpStorageLength","DEFAULT_TMP_STORAGE_LENGTH","stackLength","remaining","ts","minRun","force","Gradient","encodeColor","colorAccessPath","compatLayoutProperties","LAYOUT_PROPERTIES","compatStyle","COMPATITABLE_COMPONENTS","COMPATITABLE_SERIES","seriesOpt","clockWise","pointerColor","dataRange","visualMap","componentName","textColor","maskColor","mask","arc","lineCap","labelRect","animateShape","ArrayCtor","Float32Array","out0","out1","out2","out3","out4","out5","translate","rad","aa","ac","atx","ab","ad","aty","st","ct","vx","vy","det","ignoreParent","thisParentModel","setReadOnly","properties","normalizeDimensions","cloneListForMapAndSample","excludeDimensions","allDimensions","transferProperties","_storage","originalStorage","dimStore","UNDEFINED","globalObj","Float64Array","Int32Array","dataCtors","float","int","ordinal","time","DataDiffer","TRANSFERABLE_PROPERTIES","__wrappedMethods","propName","dimensionInfos","dimensionNames","dimensionName","dimensionInfo","stackable","_dimensionInfos","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_rawData","listProto","hasItemOption","getDimension","nameList","dimValueGetter","dimensionInfoMap","idList","nameRepeatCount","DataCtor","dataItem","dimName","dimIndex","getDataItemValue","isDataItemOption","converDataValue","dimStorage","stackedValue","getValues","dimData","dimExtent","rawIndex","indexOfRawIndex","indexOfNearest","maxDistance","nearestIdx","minDist","MAX_VALUE","dist","getRawDataItem","dims","dimSize","newIndices","keep","mapArray","tmpRetValue","retValue","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","originalIndices","frameValues","frameIndices","frameSize","otherList","otherIdList","getVisual","clearItemLayouts","itemVisual","setItemDataAndSeriesIndex","dimensionInfoList","wrapMethod","injectFunction","originalMethod","TRANSFERABLE_METHODS","CHANGABLE_METHODS","v1","v2","scaleAndAdd","sqrt","lenSquare","div","dot","distance","distanceSquare","negate","lengthSquare","distSquare","contain","OrdinalScale","getScaleExtent","originalExtent","getMin","getMax","crossZero","getNeedCrossZero","boundaryGap","minInterval","intervalScale","getCategories","getAxisLabelInterval","tickCoords","isAxisHorizontal","textSpaceTakenRect","autoLabelInterval","accumulatedLabelInterval","tickCoord","intersect","labelFormatter","Cartesian","getAxesByScale","containPoint","point","axisX","axisY","containData","pointToData","coordToData","Axis","axisLabelInterval","coordExtent","getLabelInterval","labelInterval","_labelInterval","containLabel","processArc","fa","fs","rx","ry","psiDeg","cmd","psi","xp","mathCos","mathSin","yp","lambda","mathSqrt","cxp","cyp","theta","vAngle","u","dTheta","vRatio","addData","createPathProxyFromString","cs","cc","prevCmd","cpx","cpy","PathProxy","CMD","ctlPtx","ctlPty","C","Q","A","Z","toStatic","createPathOptions","pathProxy","buildPath","transformPath","rebuildPath","vMag","acos","pathEls","pathList","pathEl","__dirty","pathBundle","appendPath","Displayable","pathContain","Pattern","getCanvasPattern","__dirtyPath","strokeContainThreshold","brush","hasStroke","hasFill","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","setTransform","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDash","lineDashOffset","ctxLineDash","setLineDash","getGlobalScale","setScale","beginPath","setLineDashOffset","restoreTransform","drawRectText","shapeCfg","inBundle","needsUpdateRect","rectWithStroke","_rectWithStroke","lineScale","strokeNoScale","getLineScale","localPos","transformCoordToLocal","containStroke","dirtyPath","__clipTarget","loop","attrKV","extendFrom","defaultShape","thisShape","addColorStop","Element","__storage","childOfName","_doAdd","addBefore","addChildrenToStorage","delChildrenFromStorage","includeChildren","tmpRect","tmpMat","invisible","childRect","lineHeight","measureText","textLines","fillText","strokeText","ZImage","LRU","globalImageCache","_image","cachedImgObj","onload","sWidth","sHeight","sx","sy","drawImage","moveTo","unitX","unitY","lineTo","closePath","roundRectHelper","polyHelper","smoothConstraint","pointAt","someVectorAt","isTangent","cpx2","cpy2","cubicDerivativeAt","cubicAt","cpx1","cpy1","quadraticDerivativeAt","quadraticAt","curveTool","vec2","quadraticSubdivide","cubicSubdivide","quadraticCurveTo","bezierCurveTo","tangentAt","globalCoord","paths","_updatePathDirty","beforeBrush","afterBrush","v2ApplyTransform","mathAbs","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","getTextWidth","textWidthCache","textWidthCacheCounter","TEXT_CACHE_MAX","textLineLen","adjustTextPositionOnRect","textHeight","halfHeight","ellipsis","maxIterations","minChar","cnCharWidth","ascCharWidth","contentWidth","ellipsisWidth","textLine","subLength","estimateLength","nubmerUtil","subOpts","emphasisOpt","normalOpt","subOptName","createDataFormatModel","rawDataIndex","itemOpt","componentSubType","formatter","exists","newCptOptions","cptOption","compressBatches","batchA","batchB","makeMap","sourceBatch","otherMap","otherDataIndices","lenj","mapToArray","isData","mapA","mapB","platform","fontFamily","fontStyle","animationDuration","animationDurationUpdate","animationEasingUpdate","animationThreshold","progressiveThreshold","hoverLayerThreshold","_colorIdx","_colorNameMap","colorIdx","colorNameMap","colorPalette","curve","bbox","min2","max2","hasTypedArray","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","exceedUnit","_needsDash","_dashedLineTo","x3","y3","_dashedBezierTo","_dashedQuadraticTo","anticlockwise","arcTo","x0","y0","lineDashSum","appendSize","appendPathData","_expandData","_prevCmd","dash","dashSum","nDash","bezierLen","tmpLen","xi","yi","fromLine","fromCubic","fromQuadratic","fromArc","ux","uy","scaleX","scaleY","isEllipse","nPoint","mathAtan2","atan2","TYPE_DELIMITER","IS_CONTAINER","RootClass","ExtendedClass","entity","makeContainer","registerClass","componentTypeMain","throwWhenNotFound","o","hasSubTypes","originalExtend","Style","__clipPaths","RectText","draggable","dragging","culling","cursor","rectHover","rectContain","animateStyle","isAroundEqual","EPSILON","swapExtrema","extrema","windingCubic","nRoots","cubicRootAt","roots","y0_","y1_","nExtrema","unit","x_","cubicExtrema","windingQuadratic","quadraticRootAt","quadraticExtremum","y_","windingArc","normalizeRadian","containPath","isStroke","windingLine","cubic","quadratic","_x","excludes","getLineDash","lineType","rank","_canvasPattern","createPattern","getAreaStyle","gTextStyleModel","align","baseline","getBorderLineDash","createLinearGradient","canvasGradient","createRadialGradient","STYLE_COMMON_PROPS","shadowBlur","shadowOffsetX","shadowOffsetY","textStroke","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textTransform","textRotation","blend","prevStyle","firstDraw","styleName","globalAlpha","globalCompositeOperation","otherStyle","newStyle","styleProto","maxValue","lastIndexOf","shadowColor","textShadowColor","Transformable","Animatable","drift","decomposeTransform","beforeUpdate","afterUpdate","updateTransform","hide","animators","addAnimator","removeAnimator","dimAxisMapper","_axes","_dimList","getAxes","scaleType","_dataCoordConvert","input","dimList","idStart","isNotAroundZero","mIdentity","transformableProto","needLocalTransform","parentHasTransform","invTransform","tmpTransform","transformCoordToGlobal","Animator","animatingShape","pathSplitted","animator","during","forwardToLast","easing","_animateToShallow","objShallow","propertyCount","DELIMITER","subTypeDefaulters","registerSubTypeDefaulter","defaulter","dependencyGetter","makeDepndencyGraph","fullNameList","graph","noEntryList","thisItem","createDependencyGraphItem","originalDeps","availableDeps","getAvailableDependencies","entryCount","dependentName","predecessor","thatItem","successor","targetNameList","removeEdge","succComponentType","removeEdgeAndAdd","targetNameSet","currComponentType","currVertex","isInTargetNameSet","fixExtentWithBands","nTick","normalizedExtent","getTicksCoords","alignWithLabel","bands","getBands","getLabelsCoords","debugMode","defaultGetter","defaultSetter","interpolateNumber","p0","p1","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","arraySlice","isArraySame","catmullRomInterpolateArray","p2","p3","t2","t3","catmullRomInterpolate","v0","cloneValue","rgba2String","createTrackClip","oneTrackDone","keyframes","_getter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","lastValue","_target","lastFrame","lastFramePercent","onframe","frame","clip","Clip","life","_loop","_delay","ondestroy","_tracks","_clipCount","_doneList","_onframeList","_clipList","tracks","_doneCallback","doneList","lastClip","clipCount","addClip","oldOnFrame","clipList","removeClip","getClips","getAxisType","axisDim","axisModelCreator","AxisModel","_resetRange","setRange","rangeStart","rangeEnd","extraOption","_life","_initialized","onrestart","easingFuncs","globalTime","_startTime","easingFunc","schedule","fire","restart","_needsRemove","remainder","axisDefault","AXIS_TYPES","axisName","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","linear","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","asin","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","nameLocation","nameRotate","nameTruncate","nameTextStyle","nameGap","triggerEvent","tooltip","axisLine","axisTick","inside","axisLabel","splitLine","splitArea","areaStyle","categoryAxis","timeAxis","logAxis","logBase","firstDataNotNull","ifNeedCompleteOrdinalData","sampleItem","creators","registeredCoordSys","axesInfo","categoryIndex","createNameList","categories","categoryAxesModels","isStackable","getDimTypeByAxis","categoryAxisModel","categoryDim","dataLen","cartesian2d","xAxisType","yAxisType","isXAxisCateogry","isYAxisCategory","polar","polarModel","angleAxisModel","findAxisModel","radiusAxisModel","radiusAxisType","angleAxisType","isAngleAxisCateogry","isRadiusAxisCateogry","geo","isAroundZero","onet","t1","disc","K","discSqrt","Y1","Y2","ONE_THIRD","T","ASqrt","THREE_SQRT","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","d1","d2","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","divider","quadraticProjectPoint","v2Create","extremity","fromPoints","xDim","yDim","tx","ty","vec2Min","vec2Max","defaultKeyGetter","oldArr","newArr","oldKeyGetter","newKeyGetter","_old","_new","_oldKeyGetter","_newKeyGetter","initIndexMap","keyArr","keyGetter","existence","_add","_remove","oldDataIndexMap","newDataIndexMap","oldDataKeyArr","newDataKeyArr","defaultNames","extraPrefix","value0","retrieveValue","guessOrdinal","_l","_a","_b","_s","LinkedList","linkedListProto","Entry","insertEntry","maxSize","_list","_maxSize","LRUProto","leastUsedEntry","smoothSpline","smoothBezier","controlPoints","cp1","cp2","interpolate","isLoop","segs","w2","w3","v2Min","v2Max","v2Scale","v2Distance","v2Add","constraint","prevPoint","nextPoint","cps","d0","cp0","r1","r2","r3","r4","shapeCompareFunc","_elements","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","displayList","_updateAndAddDisplayable","clipPaths","elements","_renderList","displayableSortFunc","makeEventPacket","eveType","cancelBubble","offsetX","zrX","offsetY","zrY","gestureEvent","pinchX","pinchY","pinchScale","wheelDelta","zrDelta","EmptyProxy","isHover","displayable","Draggable","handlerNames","proxy","_hovered","_lastTouchMoment","_lastX","_lastY","mousemove","hovered","findHover","lastHovered","setCursor","dispatchToElement","mouseout","eventArgs","targetEl","eventPacket","eachOtherLayer","layer","exclude","_downel","_upel","Dispatcher","_clips","_running","_time","_pausedTime","_pauseStart","_paused","clips","deferredEvents","deferredClips","_startLoop","pause","resume","eventNameFix","processGesture","gestureMgr","_gestureMgr","gestureInfo","setTouchTimer","_touching","clearTimeout","_touchTimer","useTouchEvent","initDomHandler","makeMouseHandler","touchHandlerNames","_handlers","domHandlers","mouseHandlerNames","HandlerDomProxy","mountHandlers","GestureMgr","eventTool","normalizeEvent","TOUCH_CLICK_DELAY","element","toElement","relatedTarget","touchstart","mousedown","touchmove","touchend","mouseup","click","handlerDomProxyProto","parseInt10","isLayerValid","isBuildin","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","prevClipPaths","doClip","createRoot","domRoot","domRootStyle","overflow","Layer","MAX_PROGRESSIVE_LAYER_NUMBER","Painter","singleCanvas","_singleCanvas","rootStyle","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","initContext","_getWidth","_getHeight","_domRoot","_createPathToImage","_progressiveLayers","_hoverlayer","_hoverElements","paintAll","_paintList","_startProgessive","__hoverMir","elMirror","__from","hoverElements","hoverLayer","getLayer","originalEl","_doPaintEl","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuildinLayer","flushProgressiveLayer","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","prevClipLayer","prevElClipPaths","insertLayer","layersMap","prevLayer","prevDom","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","layerConfig","delLayer","clearLayer","imageLayer","stl","defaultView","paddingLeft","paddingRight","paddingTop","paddingBottom","_pathToImage","clearRect","pathTransform","ImageShape","imgShape","me","_dragStart","_drag","_dragEnd","draggingTarget","_draggingTarget","_y","dropTarget","lastDropTarget","_dropTarget","clientToLocal","clientX","clientY","isTouch","touch","targetTouches","changedTouches","detail","isDomLevel2","attachEvent","detachEvent","returnValue","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","pointPair","eventUtil","_track","_doTrack","_recognize","touches","trackItem","recognizers","pinch","track","pinchEnd","pinchPre","pinchCenter","returnFalse","createDom","newDom","newDomStyle","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","createBackBuffer","clearAll","haveMotionBLur","clearColorGradientOrPattern","__canvasGradient","fillRect","compatItemStyle","itemStyleOpt","POSSIBLE_STYLES","normalItemStyleOpt","emphasisItemStyleOpt","markPoint","markLine","mpData","mlData","targetList","_selectTargetMap","targetMap","unSelect","toggleSelected","layoutAxis","getZero","theAxis","rawAxisPosition","rectBound","axisOffset","posMap","dirMap","labelDirection","tickDirection","nameDirection","labelOffset","labelRotation","AxisBuilder","ifIgnoreOnTick","axisBuilderAttrs","selfBuilderAttrs","AxisView","oldAxisGroup","_axisGroup","axisBuilder","getGroup","_splitLine","splitLineModel","lineStyleModel","lineColors","lineInterval","lineCount","ticksCoords","colorIndex","_splitArea","splitAreaModel","areaStyleModel","areaColors","prevX","prevY","areaInterval","adjustSingleSide","viewWidth","viewHeight","shiftDown","shiftUp","changeX","isDownList","lastDeltaX","deltaY","deltaX","lastY","upList","downList","avoidOverlap","labelLayoutList","leftList","rightList","hasLabelRotate","textX","textY","labelLineLen","labelLineLen2","labelRotate","makeAxisEventDataBase","innerTextLayout","rotationDiff","endTextLayout","textRotate","onLeft","tooltipOpt","dumbGroup","_transform","_dumbGroup","hasBuilder","builders","pt1","pt2","tickModel","tickLen","tickInterval","isTwoLabelOverlapped","firstRect","nextRect","axisLabelShow","labelMargin","categoryData","textEls","itemTextStyleModel","labelBeforeFormat","targetType","firstLabel","nextLabel","lastLabel","prevLabel","gapSignal","nameRotation","axisNameAvailableWidth","truncateOpt","truncatedText","formatterParams","__fullText","__truncatedText","rawTick"],"mappings":"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C,EAAA,GAAAC,IACAtC,EAAAM,EAAA8B,EAAA,GAAAC,EAAA,GAAAC,KACA,OACA,OAAAE,IACAzmC,QACAmmC,YACAC,aACA9xF,SACS0rD,GAUT,QAAA0mC,GAAA1mC,EAAAjE,EAAAziD,EAAA3D,GAEA,GADAqqD,EAAA13C,EAAA03C,GAMA,MAJAA,GAAAilC,EAAAjlC,GACA,MAAAjE,IAAAiE,EAAA,GAAAgkC,EAAAjoC,IACA,MAAAziD,IAAA0mD,EAAA,GAAAmkC,EAAA7qF,IACA,MAAA3D,IAAAqqD,EAAA,GAAAmkC,EAAAxuF,IACAvE,EAAAyzF,EAAA7kC,GAAA,QASA,QAAA2mC,GAAA3mC,EAAA4kC,GAEA,GADA5kC,EAAA13C,EAAA03C,GACAA,GAAA,MAAA4kC,EAEA,MADA5kC,GAAA,GAAAikC,EAAAW,GACAxzF,EAAA4uD,EAAA,QAQA,QAAA5uD,GAAAw1F,EAAAh3F,GACA,GAAA40F,GAAAoC,EAAA,OAAAA,EAAA,OAAAA,EAAA,EAIA,OAHA,SAAAh3F,GAAA,SAAAA,GAAA,SAAAA,IACA40F,GAAA,IAAAoC,EAAA,IAEAh3F,EAAA,IAAA40F,EAAA,IAvtCA,GAAAC,IACAoC,aACA,EACA,EACA,EACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,cACA,IACA,IACA,IACA,GAEAC,MACA,EACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,QACA,IACA,IACA,IACA,GAEAC,OACA,EACA,EACA,EACA,GAEAC,gBACA,IACA,IACA,IACA,GAEAC,MACA,EACA,EACA,IACA,GAEAC,YACA,IACA,GACA,IACA,GAEAC,OACA,IACA,GACA,GACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,WACA,GACA,IACA,IACA,GAEAC,YACA,IACA,IACA,EACA,GAEAC,WACA,IACA,IACA,GACA,GAEAC,OACA,IACA,IACA,GACA,GAEAC,gBACA,IACA,IACA,IACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,SACA,IACA,GACA,GACA,GAEAC,MACA,EACA,IACA,IACA,GAEAC,UACA,EACA,EACA,IACA,GAEAC,UACA,EACA,IACA,IACA,GAEAC,eACA,IACA,IACA,GACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,WACA,EACA,IACA,EACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,aACA,IACA,EACA,IACA,GAEAC,gBACA,GACA,IACA,GACA,GAEAC,YACA,IACA,IACA,EACA,GAEAC,YACA,IACA,GACA,IACA,GAEAC,SACA,IACA,EACA,EACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,cACA,IACA,IACA,IACA,GAEAC,eACA,GACA,GACA,IACA,GAEAC,eACA,GACA,GACA,GACA,GAEAC,eACA,GACA,GACA,GACA,GAEAC,eACA,EACA,IACA,IACA,GAEAC,YACA,IACA,EACA,IACA,GAEAC,UACA,IACA,GACA,IACA,GAEAC,aACA,EACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,YACA,GACA,IACA,IACA,GAEAC,WACA,IACA,GACA,GACA,GAEAC,aACA,IACA,IACA,IACA,GAEAC,aACA,GACA,IACA,GACA,GAEAC,SACA,IACA,EACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,MACA,IACA,IACA,EACA,GAEAC,WACA,IACA,IACA,GACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,OACA,EACA,IACA,EACA,GAEAC,aACA,IACA,IACA,GACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,WACA,IACA,GACA,GACA,GAEAC,QACA,GACA,EACA,IACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,eACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,EACA,GAEAC,cACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,sBACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,aACA,IACA,IACA,IACA,GAEAC,eACA,GACA,IACA,IACA,GAEAC,cACA,IACA,IACA,IACA,GAEAC,gBACA,IACA,IACA,IACA,GAEAC,gBACA,IACA,IACA,IACA,GAEAC,gBACA,IACA,IACA,IACA,GAEAC,aACA,IACA,IACA,IACA,GAEAC,MACA,EACA,IACA,EACA,GAEAC,WACA,GACA,IACA,GACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,SACA,IACA,EACA,IACA,GAEAC,QACA,IACA,EACA,EACA,GAEAC,kBACA,IACA,IACA,IACA,GAEAC,YACA,EACA,EACA,IACA,GAEAC,cACA,IACA,GACA,IACA,GAEAC,cACA,IACA,IACA,IACA,GAEAC,gBACA,GACA,IACA,IACA,GAEAC,iBACA,IACA,IACA,IACA,GAEAC,mBACA,EACA,IACA,IACA,GAEAC,iBACA,GACA,IACA,IACA,GAEAC,iBACA,IACA,GACA,IACA,GAEAC,cACA,GACA,GACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,aACA,IACA,IACA,IACA,GAEAC,MACA,EACA,EACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,OACA,IACA,IACA,EACA,GAEAC,WACA,IACA,IACA,GACA,GAEAC,QACA,IACA,IACA,EACA,GAEAC,WACA,IACA,GACA,EACA,GAEAC,QACA,IACA,IACA,IACA,GAEAC,eACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,eACA,IACA,IACA,IACA,GAEAC,eACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,MACA,IACA,IACA,GACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,QACA,IACA,EACA,IACA,GAEAC,KACA,IACA,EACA,EACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,WACA,GACA,IACA,IACA,GAEAC,aACA,IACA,GACA,GACA,GAEAC,QACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,GACA,GAEAC,UACA,GACA,IACA,GACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,QACA,IACA,GACA,GACA,GAEAC,QACA,IACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,WACA,IACA,GACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,aACA,EACA,IACA,IACA,GAEAC,WACA,GACA,IACA,IACA,GAEAC,KACA,IACA,IACA,IACA,GAEAC,MACA,EACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,QACA,IACA,GACA,GACA,GAEAC,WACA,GACA,IACA,IACA,GAEAC,QACA,IACA,IACA,IACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,QACA,IACA,IACA,EACA,GAEAC,aACA,IACA,IACA,GACA,GAkWA,QACA1nF,QACAwiE,OACAgb,QACAC,iBACAS,aACAE,YACAC,cACAv1F,eAGA2rD,EAAA,qCAIA,QAAAkzC,GAAAp+E,GAEA,IADA,GAAAimD,GAAA,EACAjmD,GAAAq+E,GACAp4B,GAAA,EAAAjmD,EACAA,IAAA,CAEA,OAAAA,GAAAimD,EAEA,QAAAq4B,GAAAjyB,EAAA1a,EAAAC,EAAAq5B,GACA,GAAAsT,GAAA5sC,EAAA,CACA,IAAA4sC,IA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","file":"build.js","sourcesContent":["webpackJsonp([1,0],[\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _vue = __webpack_require__(7);\n\t\n\tvar _vue2 = _interopRequireDefault(_vue);\n\t\n\tvar _vueRouter = __webpack_require__(41);\n\t\n\tvar _vueRouter2 = _interopRequireDefault(_vueRouter);\n\t\n\tvar _router = __webpack_require__(8);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_vue2.default.use(_vueRouter2.default);\n\t\n\tvar router = new _vueRouter2.default();\n\t(0, _router.configRouter)(router);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\n\t\tAuthor Tobias Koppers @sokra\n\t*/\n\tvar stylesInDom = {},\n\t\tmemoize = function(fn) {\n\t\t\tvar memo;\n\t\t\treturn function () {\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\t\treturn memo;\n\t\t\t};\n\t\t},\n\t\tisOldIE = memoize(function() {\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\n\t\t}),\n\t\tgetHeadElement = memoize(function () {\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t\t}),\n\t\tsingletonElement = null,\n\t\tsingletonCounter = 0,\n\t\tstyleElementsInsertedAtTop = [];\n\t\n\tmodule.exports = function(list, options) {\n\t\tif(false) {\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t\t}\n\t\n\t\toptions = options || {};\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t\t// tags it will allow on a page\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\t\n\t\t// By default, add <style> tags to the bottom of <head>.\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\t\n\t\tvar styles = listToStyles(list);\n\t\taddStylesToDom(styles, options);\n\t\n\t\treturn function update(newList) {\n\t\t\tvar mayRemove = [];\n\t\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\t\tvar item = styles[i];\n\t\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\t\tdomStyle.refs--;\n\t\t\t\tmayRemove.push(domStyle);\n\t\t\t}\n\t\t\tif(newList) {\n\t\t\t\tvar newStyles = listToStyles(newList);\n\t\t\t\taddStylesToDom(newStyles, options);\n\t\t\t}\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\t\tvar domStyle = mayRemove[i];\n\t\t\t\tif(domStyle.refs === 0) {\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction addStylesToDom(styles, options) {\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tif(domStyle) {\n\t\t\t\tdomStyle.refs++;\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t\t}\n\t\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar parts = [];\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t\t}\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction listToStyles(list) {\n\t\tvar styles = [];\n\t\tvar newStyles = {};\n\t\tfor(var i = 0; i < list.length; i++) {\n\t\t\tvar item = list[i];\n\t\t\tvar id = item[0];\n\t\t\tvar css = item[1];\n\t\t\tvar media = item[2];\n\t\t\tvar sourceMap = item[3];\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\t\tif(!newStyles[id])\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\t\telse\n\t\t\t\tnewStyles[id].parts.push(part);\n\t\t}\n\t\treturn styles;\n\t}\n\t\n\tfunction insertStyleElement(options, styleElement) {\n\t\tvar head = getHeadElement();\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\t\tif (options.insertAt === \"top\") {\n\t\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t\t} else {\n\t\t\t\thead.appendChild(styleElement);\n\t\t\t}\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t\t} else if (options.insertAt === \"bottom\") {\n\t\t\thead.appendChild(styleElement);\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t\t}\n\t}\n\t\n\tfunction removeStyleElement(styleElement) {\n\t\tstyleElement.parentNode.removeChild(styleElement);\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\t\tif(idx >= 0) {\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t\t}\n\t}\n\t\n\tfunction createStyleElement(options) {\n\t\tvar styleElement = document.createElement(\"style\");\n\t\tstyleElement.type = \"text/css\";\n\t\tinsertStyleElement(options, styleElement);\n\t\treturn styleElement;\n\t}\n\t\n\tfunction addStyle(obj, options) {\n\t\tvar styleElement, update, remove;\n\t\n\t\tif (options.singleton) {\n\t\t\tvar styleIndex = singletonCounter++;\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t\t} else {\n\t\t\tstyleElement = createStyleElement(options);\n\t\t\tupdate = applyToTag.bind(null, styleElement);\n\t\t\tremove = function() {\n\t\t\t\tremoveStyleElement(styleElement);\n\t\t\t};\n\t\t}\n\t\n\t\tupdate(obj);\n\t\n\t\treturn function updateStyle(newObj) {\n\t\t\tif(newObj) {\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\t\treturn;\n\t\t\t\tupdate(obj = newObj);\n\t\t\t} else {\n\t\t\t\tremove();\n\t\t\t}\n\t\t};\n\t}\n\t\n\tvar replaceText = (function () {\n\t\tvar textStore = [];\n\t\n\t\treturn function (index, replacement) {\n\t\t\ttextStore[index] = replacement;\n\t\t\treturn textStore.filter(Boolean).join('\\n');\n\t\t};\n\t})();\n\t\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\t\tvar css = remove ? \"\" : obj.css;\n\t\n\t\tif (styleElement.styleSheet) {\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t\t} else {\n\t\t\tvar cssNode = document.createTextNode(css);\n\t\t\tvar childNodes = styleElement.childNodes;\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\t\tif (childNodes.length) {\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t\t} else {\n\t\t\t\tstyleElement.appendChild(cssNode);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction applyToTag(styleElement, obj) {\n\t\tvar css = obj.css;\n\t\tvar media = obj.media;\n\t\tvar sourceMap = obj.sourceMap;\n\t\n\t\tif (media) {\n\t\t\tstyleElement.setAttribute(\"media\", media);\n\t\t}\n\t\n\t\tif (sourceMap) {\n\t\t\t// https://developer.chrome.com/devtools/docs/javascript-debugging\n\t\t\t// this makes source maps inside style tags work properly in Chrome\n\t\t\tcss += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */';\n\t\t\t// http://stackoverflow.com/a/26603875\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t\t}\n\t\n\t\tif (styleElement.styleSheet) {\n\t\t\tstyleElement.styleSheet.cssText = css;\n\t\t} else {\n\t\t\twhile(styleElement.firstChild) {\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t\t}\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\n\t\t}\n\t}\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(18), __esModule: true };\n\n/***/ },\n/* 4 */,\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\t__webpack_require__(42)\n\t__vue_script__ = __webpack_require__(11)\n\t__vue_template__ = __webpack_require__(28)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tif (__vue_template__) {\n\t(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n\t}\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\t__webpack_require__(46)\n\t__vue_script__ = __webpack_require__(16)\n\t__vue_template__ = __webpack_require__(33)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tif (__vue_template__) {\n\t(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n\t}\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*!\n\t * Vue.js v1.0.26\n\t * (c) 2016 Evan You\n\t * Released under the MIT License.\n\t */\n\t'use strict';\n\t\n\tfunction set(obj, key, val) {\n\t  if (hasOwn(obj, key)) {\n\t    obj[key] = val;\n\t    return;\n\t  }\n\t  if (obj._isVue) {\n\t    set(obj._data, key, val);\n\t    return;\n\t  }\n\t  var ob = obj.__ob__;\n\t  if (!ob) {\n\t    obj[key] = val;\n\t    return;\n\t  }\n\t  ob.convert(key, val);\n\t  ob.dep.notify();\n\t  if (ob.vms) {\n\t    var i = ob.vms.length;\n\t    while (i--) {\n\t      var vm = ob.vms[i];\n\t      vm._proxy(key);\n\t      vm._digest();\n\t    }\n\t  }\n\t  return val;\n\t}\n\t\n\t/**\n\t * Delete a property and trigger change if necessary.\n\t *\n\t * @param {Object} obj\n\t * @param {String} key\n\t */\n\t\n\tfunction del(obj, key) {\n\t  if (!hasOwn(obj, key)) {\n\t    return;\n\t  }\n\t  delete obj[key];\n\t  var ob = obj.__ob__;\n\t  if (!ob) {\n\t    if (obj._isVue) {\n\t      delete obj._data[key];\n\t      obj._digest();\n\t    }\n\t    return;\n\t  }\n\t  ob.dep.notify();\n\t  if (ob.vms) {\n\t    var i = ob.vms.length;\n\t    while (i--) {\n\t      var vm = ob.vms[i];\n\t      vm._unproxy(key);\n\t      vm._digest();\n\t    }\n\t  }\n\t}\n\t\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t/**\n\t * Check whether the object has the property.\n\t *\n\t * @param {Object} obj\n\t * @param {String} key\n\t * @return {Boolean}\n\t */\n\t\n\tfunction hasOwn(obj, key) {\n\t  return hasOwnProperty.call(obj, key);\n\t}\n\t\n\t/**\n\t * Check if an expression is a literal value.\n\t *\n\t * @param {String} exp\n\t * @return {Boolean}\n\t */\n\t\n\tvar literalValueRE = /^\\s?(true|false|-?[\\d\\.]+|'[^']*'|\"[^\"]*\")\\s?$/;\n\t\n\tfunction isLiteral(exp) {\n\t  return literalValueRE.test(exp);\n\t}\n\t\n\t/**\n\t * Check if a string starts with $ or _\n\t *\n\t * @param {String} str\n\t * @return {Boolean}\n\t */\n\t\n\tfunction isReserved(str) {\n\t  var c = (str + '').charCodeAt(0);\n\t  return c === 0x24 || c === 0x5F;\n\t}\n\t\n\t/**\n\t * Guard text output, make sure undefined outputs\n\t * empty string\n\t *\n\t * @param {*} value\n\t * @return {String}\n\t */\n\t\n\tfunction _toString(value) {\n\t  return value == null ? '' : value.toString();\n\t}\n\t\n\t/**\n\t * Check and convert possible numeric strings to numbers\n\t * before setting back to data\n\t *\n\t * @param {*} value\n\t * @return {*|Number}\n\t */\n\t\n\tfunction toNumber(value) {\n\t  if (typeof value !== 'string') {\n\t    return value;\n\t  } else {\n\t    var parsed = Number(value);\n\t    return isNaN(parsed) ? value : parsed;\n\t  }\n\t}\n\t\n\t/**\n\t * Convert string boolean literals into real booleans.\n\t *\n\t * @param {*} value\n\t * @return {*|Boolean}\n\t */\n\t\n\tfunction toBoolean(value) {\n\t  return value === 'true' ? true : value === 'false' ? false : value;\n\t}\n\t\n\t/**\n\t * Strip quotes from a string\n\t *\n\t * @param {String} str\n\t * @return {String | false}\n\t */\n\t\n\tfunction stripQuotes(str) {\n\t  var a = str.charCodeAt(0);\n\t  var b = str.charCodeAt(str.length - 1);\n\t  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;\n\t}\n\t\n\t/**\n\t * Camelize a hyphen-delmited string.\n\t *\n\t * @param {String} str\n\t * @return {String}\n\t */\n\t\n\tvar camelizeRE = /-(\\w)/g;\n\t\n\tfunction camelize(str) {\n\t  return str.replace(camelizeRE, toUpper);\n\t}\n\t\n\tfunction toUpper(_, c) {\n\t  return c ? c.toUpperCase() : '';\n\t}\n\t\n\t/**\n\t * Hyphenate a camelCase string.\n\t *\n\t * @param {String} str\n\t * @return {String}\n\t */\n\t\n\tvar hyphenateRE = /([a-z\\d])([A-Z])/g;\n\t\n\tfunction hyphenate(str) {\n\t  return str.replace(hyphenateRE, '$1-$2').toLowerCase();\n\t}\n\t\n\t/**\n\t * Converts hyphen/underscore/slash delimitered names into\n\t * camelized classNames.\n\t *\n\t * e.g. my-component => MyComponent\n\t *      some_else    => SomeElse\n\t *      some/comp    => SomeComp\n\t *\n\t * @param {String} str\n\t * @return {String}\n\t */\n\t\n\tvar classifyRE = /(?:^|[-_\\/])(\\w)/g;\n\t\n\tfunction classify(str) {\n\t  return str.replace(classifyRE, toUpper);\n\t}\n\t\n\t/**\n\t * Simple bind, faster than native\n\t *\n\t * @param {Function} fn\n\t * @param {Object} ctx\n\t * @return {Function}\n\t */\n\t\n\tfunction bind(fn, ctx) {\n\t  return function (a) {\n\t    var l = arguments.length;\n\t    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n\t  };\n\t}\n\t\n\t/**\n\t * Convert an Array-like object to a real Array.\n\t *\n\t * @param {Array-like} list\n\t * @param {Number} [start] - start index\n\t * @return {Array}\n\t */\n\t\n\tfunction toArray(list, start) {\n\t  start = start || 0;\n\t  var i = list.length - start;\n\t  var ret = new Array(i);\n\t  while (i--) {\n\t    ret[i] = list[i + start];\n\t  }\n\t  return ret;\n\t}\n\t\n\t/**\n\t * Mix properties into target object.\n\t *\n\t * @param {Object} to\n\t * @param {Object} from\n\t */\n\t\n\tfunction extend(to, from) {\n\t  var keys = Object.keys(from);\n\t  var i = keys.length;\n\t  while (i--) {\n\t    to[keys[i]] = from[keys[i]];\n\t  }\n\t  return to;\n\t}\n\t\n\t/**\n\t * Quick object check - this is primarily used to tell\n\t * Objects from primitive values when we know the value\n\t * is a JSON-compliant type.\n\t *\n\t * @param {*} obj\n\t * @return {Boolean}\n\t */\n\t\n\tfunction isObject(obj) {\n\t  return obj !== null && typeof obj === 'object';\n\t}\n\t\n\t/**\n\t * Strict object type check. Only returns true\n\t * for plain JavaScript objects.\n\t *\n\t * @param {*} obj\n\t * @return {Boolean}\n\t */\n\t\n\tvar toString = Object.prototype.toString;\n\tvar OBJECT_STRING = '[object Object]';\n\t\n\tfunction isPlainObject(obj) {\n\t  return toString.call(obj) === OBJECT_STRING;\n\t}\n\t\n\t/**\n\t * Array type check.\n\t *\n\t * @param {*} obj\n\t * @return {Boolean}\n\t */\n\t\n\tvar isArray = Array.isArray;\n\t\n\t/**\n\t * Define a property.\n\t *\n\t * @param {Object} obj\n\t * @param {String} key\n\t * @param {*} val\n\t * @param {Boolean} [enumerable]\n\t */\n\t\n\tfunction def(obj, key, val, enumerable) {\n\t  Object.defineProperty(obj, key, {\n\t    value: val,\n\t    enumerable: !!enumerable,\n\t    writable: true,\n\t    configurable: true\n\t  });\n\t}\n\t\n\t/**\n\t * Debounce a function so it only gets called after the\n\t * input stops arriving after the given wait period.\n\t *\n\t * @param {Function} func\n\t * @param {Number} wait\n\t * @return {Function} - the debounced function\n\t */\n\t\n\tfunction _debounce(func, wait) {\n\t  var timeout, args, context, timestamp, result;\n\t  var later = function later() {\n\t    var last = Date.now() - timestamp;\n\t    if (last < wait && last >= 0) {\n\t      timeout = setTimeout(later, wait - last);\n\t    } else {\n\t      timeout = null;\n\t      result = func.apply(context, args);\n\t      if (!timeout) context = args = null;\n\t    }\n\t  };\n\t  return function () {\n\t    context = this;\n\t    args = arguments;\n\t    timestamp = Date.now();\n\t    if (!timeout) {\n\t      timeout = setTimeout(later, wait);\n\t    }\n\t    return result;\n\t  };\n\t}\n\t\n\t/**\n\t * Manual indexOf because it's slightly faster than\n\t * native.\n\t *\n\t * @param {Array} arr\n\t * @param {*} obj\n\t */\n\t\n\tfunction indexOf(arr, obj) {\n\t  var i = arr.length;\n\t  while (i--) {\n\t    if (arr[i] === obj) return i;\n\t  }\n\t  return -1;\n\t}\n\t\n\t/**\n\t * Make a cancellable version of an async callback.\n\t *\n\t * @param {Function} fn\n\t * @return {Function}\n\t */\n\t\n\tfunction cancellable(fn) {\n\t  var cb = function cb() {\n\t    if (!cb.cancelled) {\n\t      return fn.apply(this, arguments);\n\t    }\n\t  };\n\t  cb.cancel = function () {\n\t    cb.cancelled = true;\n\t  };\n\t  return cb;\n\t}\n\t\n\t/**\n\t * Check if two values are loosely equal - that is,\n\t * if they are plain objects, do they have the same shape?\n\t *\n\t * @param {*} a\n\t * @param {*} b\n\t * @return {Boolean}\n\t */\n\t\n\tfunction looseEqual(a, b) {\n\t  /* eslint-disable eqeqeq */\n\t  return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);\n\t  /* eslint-enable eqeqeq */\n\t}\n\t\n\tvar hasProto = ('__proto__' in {});\n\t\n\t// Browser environment sniffing\n\tvar inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';\n\t\n\t// detect devtools\n\tvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\t\n\t// UA sniffing for working around browser-specific quirks\n\tvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\n\tvar isIE = UA && UA.indexOf('trident') > 0;\n\tvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n\tvar isAndroid = UA && UA.indexOf('android') > 0;\n\tvar isIos = UA && /(iphone|ipad|ipod|ios)/i.test(UA);\n\tvar iosVersionMatch = isIos && UA.match(/os ([\\d_]+)/);\n\tvar iosVersion = iosVersionMatch && iosVersionMatch[1].split('_');\n\t\n\t// detecting iOS UIWebView by indexedDB\n\tvar hasMutationObserverBug = iosVersion && Number(iosVersion[0]) >= 9 && Number(iosVersion[1]) >= 3 && !window.indexedDB;\n\t\n\tvar transitionProp = undefined;\n\tvar transitionEndEvent = undefined;\n\tvar animationProp = undefined;\n\tvar animationEndEvent = undefined;\n\t\n\t// Transition property/event sniffing\n\tif (inBrowser && !isIE9) {\n\t  var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;\n\t  var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;\n\t  transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';\n\t  transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';\n\t  animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';\n\t  animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';\n\t}\n\t\n\t/**\n\t * Defer a task to execute it asynchronously. Ideally this\n\t * should be executed as a microtask, so we leverage\n\t * MutationObserver if it's available, and fallback to\n\t * setTimeout(0).\n\t *\n\t * @param {Function} cb\n\t * @param {Object} ctx\n\t */\n\t\n\tvar nextTick = (function () {\n\t  var callbacks = [];\n\t  var pending = false;\n\t  var timerFunc;\n\t  function nextTickHandler() {\n\t    pending = false;\n\t    var copies = callbacks.slice(0);\n\t    callbacks = [];\n\t    for (var i = 0; i < copies.length; i++) {\n\t      copies[i]();\n\t    }\n\t  }\n\t\n\t  /* istanbul ignore if */\n\t  if (typeof MutationObserver !== 'undefined' && !hasMutationObserverBug) {\n\t    var counter = 1;\n\t    var observer = new MutationObserver(nextTickHandler);\n\t    var textNode = document.createTextNode(counter);\n\t    observer.observe(textNode, {\n\t      characterData: true\n\t    });\n\t    timerFunc = function () {\n\t      counter = (counter + 1) % 2;\n\t      textNode.data = counter;\n\t    };\n\t  } else {\n\t    // webpack attempts to inject a shim for setImmediate\n\t    // if it is used as a global, so we have to work around that to\n\t    // avoid bundling unnecessary code.\n\t    var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};\n\t    timerFunc = context.setImmediate || setTimeout;\n\t  }\n\t  return function (cb, ctx) {\n\t    var func = ctx ? function () {\n\t      cb.call(ctx);\n\t    } : cb;\n\t    callbacks.push(func);\n\t    if (pending) return;\n\t    pending = true;\n\t    timerFunc(nextTickHandler, 0);\n\t  };\n\t})();\n\t\n\tvar _Set = undefined;\n\t/* istanbul ignore if */\n\tif (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {\n\t  // use native Set when available.\n\t  _Set = Set;\n\t} else {\n\t  // a non-standard Set polyfill that only works with primitive keys.\n\t  _Set = function () {\n\t    this.set = Object.create(null);\n\t  };\n\t  _Set.prototype.has = function (key) {\n\t    return this.set[key] !== undefined;\n\t  };\n\t  _Set.prototype.add = function (key) {\n\t    this.set[key] = 1;\n\t  };\n\t  _Set.prototype.clear = function () {\n\t    this.set = Object.create(null);\n\t  };\n\t}\n\t\n\tfunction Cache(limit) {\n\t  this.size = 0;\n\t  this.limit = limit;\n\t  this.head = this.tail = undefined;\n\t  this._keymap = Object.create(null);\n\t}\n\t\n\tvar p = Cache.prototype;\n\t\n\t/**\n\t * Put <value> into the cache associated with <key>.\n\t * Returns the entry which was removed to make room for\n\t * the new entry. Otherwise undefined is returned.\n\t * (i.e. if there was enough room already).\n\t *\n\t * @param {String} key\n\t * @param {*} value\n\t * @return {Entry|undefined}\n\t */\n\t\n\tp.put = function (key, value) {\n\t  var removed;\n\t\n\t  var entry = this.get(key, true);\n\t  if (!entry) {\n\t    if (this.size === this.limit) {\n\t      removed = this.shift();\n\t    }\n\t    entry = {\n\t      key: key\n\t    };\n\t    this._keymap[key] = entry;\n\t    if (this.tail) {\n\t      this.tail.newer = entry;\n\t      entry.older = this.tail;\n\t    } else {\n\t      this.head = entry;\n\t    }\n\t    this.tail = entry;\n\t    this.size++;\n\t  }\n\t  entry.value = value;\n\t\n\t  return removed;\n\t};\n\t\n\t/**\n\t * Purge the least recently used (oldest) entry from the\n\t * cache. Returns the removed entry or undefined if the\n\t * cache was empty.\n\t */\n\t\n\tp.shift = function () {\n\t  var entry = this.head;\n\t  if (entry) {\n\t    this.head = this.head.newer;\n\t    this.head.older = undefined;\n\t    entry.newer = entry.older = undefined;\n\t    this._keymap[entry.key] = undefined;\n\t    this.size--;\n\t  }\n\t  return entry;\n\t};\n\t\n\t/**\n\t * Get and register recent use of <key>. Returns the value\n\t * associated with <key> or undefined if not in cache.\n\t *\n\t * @param {String} key\n\t * @param {Boolean} returnEntry\n\t * @return {Entry|*}\n\t */\n\t\n\tp.get = function (key, returnEntry) {\n\t  var entry = this._keymap[key];\n\t  if (entry === undefined) return;\n\t  if (entry === this.tail) {\n\t    return returnEntry ? entry : entry.value;\n\t  }\n\t  // HEAD--------------TAIL\n\t  //   <.older   .newer>\n\t  //  <--- add direction --\n\t  //   A  B  C  <D>  E\n\t  if (entry.newer) {\n\t    if (entry === this.head) {\n\t      this.head = entry.newer;\n\t    }\n\t    entry.newer.older = entry.older; // C <-- E.\n\t  }\n\t  if (entry.older) {\n\t    entry.older.newer = entry.newer; // C. --> E\n\t  }\n\t  entry.newer = undefined; // D --x\n\t  entry.older = this.tail; // D. --> E\n\t  if (this.tail) {\n\t    this.tail.newer = entry; // E. <-- D\n\t  }\n\t  this.tail = entry;\n\t  return returnEntry ? entry : entry.value;\n\t};\n\t\n\tvar cache$1 = new Cache(1000);\n\tvar filterTokenRE = /[^\\s'\"]+|'[^']*'|\"[^\"]*\"/g;\n\tvar reservedArgRE = /^in$|^-?\\d+/;\n\t\n\t/**\n\t * Parser state\n\t */\n\t\n\tvar str;\n\tvar dir;\n\tvar c;\n\tvar prev;\n\tvar i;\n\tvar l;\n\tvar lastFilterIndex;\n\tvar inSingle;\n\tvar inDouble;\n\tvar curly;\n\tvar square;\n\tvar paren;\n\t/**\n\t * Push a filter to the current directive object\n\t */\n\t\n\tfunction pushFilter() {\n\t  var exp = str.slice(lastFilterIndex, i).trim();\n\t  var filter;\n\t  if (exp) {\n\t    filter = {};\n\t    var tokens = exp.match(filterTokenRE);\n\t    filter.name = tokens[0];\n\t    if (tokens.length > 1) {\n\t      filter.args = tokens.slice(1).map(processFilterArg);\n\t    }\n\t  }\n\t  if (filter) {\n\t    (dir.filters = dir.filters || []).push(filter);\n\t  }\n\t  lastFilterIndex = i + 1;\n\t}\n\t\n\t/**\n\t * Check if an argument is dynamic and strip quotes.\n\t *\n\t * @param {String} arg\n\t * @return {Object}\n\t */\n\t\n\tfunction processFilterArg(arg) {\n\t  if (reservedArgRE.test(arg)) {\n\t    return {\n\t      value: toNumber(arg),\n\t      dynamic: false\n\t    };\n\t  } else {\n\t    var stripped = stripQuotes(arg);\n\t    var dynamic = stripped === arg;\n\t    return {\n\t      value: dynamic ? arg : stripped,\n\t      dynamic: dynamic\n\t    };\n\t  }\n\t}\n\t\n\t/**\n\t * Parse a directive value and extract the expression\n\t * and its filters into a descriptor.\n\t *\n\t * Example:\n\t *\n\t * \"a + 1 | uppercase\" will yield:\n\t * {\n\t *   expression: 'a + 1',\n\t *   filters: [\n\t *     { name: 'uppercase', args: null }\n\t *   ]\n\t * }\n\t *\n\t * @param {String} s\n\t * @return {Object}\n\t */\n\t\n\tfunction parseDirective(s) {\n\t  var hit = cache$1.get(s);\n\t  if (hit) {\n\t    return hit;\n\t  }\n\t\n\t  // reset parser state\n\t  str = s;\n\t  inSingle = inDouble = false;\n\t  curly = square = paren = 0;\n\t  lastFilterIndex = 0;\n\t  dir = {};\n\t\n\t  for (i = 0, l = str.length; i < l; i++) {\n\t    prev = c;\n\t    c = str.charCodeAt(i);\n\t    if (inSingle) {\n\t      // check single quote\n\t      if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;\n\t    } else if (inDouble) {\n\t      // check double quote\n\t      if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;\n\t    } else if (c === 0x7C && // pipe\n\t    str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {\n\t      if (dir.expression == null) {\n\t        // first filter, end of expression\n\t        lastFilterIndex = i + 1;\n\t        dir.expression = str.slice(0, i).trim();\n\t      } else {\n\t        // already has filter\n\t        pushFilter();\n\t      }\n\t    } else {\n\t      switch (c) {\n\t        case 0x22:\n\t          inDouble = true;break; // \"\n\t        case 0x27:\n\t          inSingle = true;break; // '\n\t        case 0x28:\n\t          paren++;break; // (\n\t        case 0x29:\n\t          paren--;break; // )\n\t        case 0x5B:\n\t          square++;break; // [\n\t        case 0x5D:\n\t          square--;break; // ]\n\t        case 0x7B:\n\t          curly++;break; // {\n\t        case 0x7D:\n\t          curly--;break; // }\n\t      }\n\t    }\n\t  }\n\t\n\t  if (dir.expression == null) {\n\t    dir.expression = str.slice(0, i).trim();\n\t  } else if (lastFilterIndex !== 0) {\n\t    pushFilter();\n\t  }\n\t\n\t  cache$1.put(s, dir);\n\t  return dir;\n\t}\n\t\n\tvar directive = Object.freeze({\n\t  parseDirective: parseDirective\n\t});\n\t\n\tvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\tvar cache = undefined;\n\tvar tagRE = undefined;\n\tvar htmlRE = undefined;\n\t/**\n\t * Escape a string so it can be used in a RegExp\n\t * constructor.\n\t *\n\t * @param {String} str\n\t */\n\t\n\tfunction escapeRegex(str) {\n\t  return str.replace(regexEscapeRE, '\\\\$&');\n\t}\n\t\n\tfunction compileRegex() {\n\t  var open = escapeRegex(config.delimiters[0]);\n\t  var close = escapeRegex(config.delimiters[1]);\n\t  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);\n\t  var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);\n\t  tagRE = new RegExp(unsafeOpen + '((?:.|\\\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\\\n)+?)' + close, 'g');\n\t  htmlRE = new RegExp('^' + unsafeOpen + '((?:.|\\\\n)+?)' + unsafeClose + '$');\n\t  // reset cache\n\t  cache = new Cache(1000);\n\t}\n\t\n\t/**\n\t * Parse a template text string into an array of tokens.\n\t *\n\t * @param {String} text\n\t * @return {Array<Object> | null}\n\t *               - {String} type\n\t *               - {String} value\n\t *               - {Boolean} [html]\n\t *               - {Boolean} [oneTime]\n\t */\n\t\n\tfunction parseText(text) {\n\t  if (!cache) {\n\t    compileRegex();\n\t  }\n\t  var hit = cache.get(text);\n\t  if (hit) {\n\t    return hit;\n\t  }\n\t  if (!tagRE.test(text)) {\n\t    return null;\n\t  }\n\t  var tokens = [];\n\t  var lastIndex = tagRE.lastIndex = 0;\n\t  var match, index, html, value, first, oneTime;\n\t  /* eslint-disable no-cond-assign */\n\t  while (match = tagRE.exec(text)) {\n\t    /* eslint-enable no-cond-assign */\n\t    index = match.index;\n\t    // push text token\n\t    if (index > lastIndex) {\n\t      tokens.push({\n\t        value: text.slice(lastIndex, index)\n\t      });\n\t    }\n\t    // tag token\n\t    html = htmlRE.test(match[0]);\n\t    value = html ? match[1] : match[2];\n\t    first = value.charCodeAt(0);\n\t    oneTime = first === 42; // *\n\t    value = oneTime ? value.slice(1) : value;\n\t    tokens.push({\n\t      tag: true,\n\t      value: value.trim(),\n\t      html: html,\n\t      oneTime: oneTime\n\t    });\n\t    lastIndex = index + match[0].length;\n\t  }\n\t  if (lastIndex < text.length) {\n\t    tokens.push({\n\t      value: text.slice(lastIndex)\n\t    });\n\t  }\n\t  cache.put(text, tokens);\n\t  return tokens;\n\t}\n\t\n\t/**\n\t * Format a list of tokens into an expression.\n\t * e.g. tokens parsed from 'a {{b}} c' can be serialized\n\t * into one single expression as '\"a \" + b + \" c\"'.\n\t *\n\t * @param {Array} tokens\n\t * @param {Vue} [vm]\n\t * @return {String}\n\t */\n\t\n\tfunction tokensToExp(tokens, vm) {\n\t  if (tokens.length > 1) {\n\t    return tokens.map(function (token) {\n\t      return formatToken(token, vm);\n\t    }).join('+');\n\t  } else {\n\t    return formatToken(tokens[0], vm, true);\n\t  }\n\t}\n\t\n\t/**\n\t * Format a single token.\n\t *\n\t * @param {Object} token\n\t * @param {Vue} [vm]\n\t * @param {Boolean} [single]\n\t * @return {String}\n\t */\n\t\n\tfunction formatToken(token, vm, single) {\n\t  return token.tag ? token.oneTime && vm ? '\"' + vm.$eval(token.value) + '\"' : inlineFilters(token.value, single) : '\"' + token.value + '\"';\n\t}\n\t\n\t/**\n\t * For an attribute with multiple interpolation tags,\n\t * e.g. attr=\"some-{{thing | filter}}\", in order to combine\n\t * the whole thing into a single watchable expression, we\n\t * have to inline those filters. This function does exactly\n\t * that. This is a bit hacky but it avoids heavy changes\n\t * to directive parser and watcher mechanism.\n\t *\n\t * @param {String} exp\n\t * @param {Boolean} single\n\t * @return {String}\n\t */\n\t\n\tvar filterRE = /[^|]\\|[^|]/;\n\tfunction inlineFilters(exp, single) {\n\t  if (!filterRE.test(exp)) {\n\t    return single ? exp : '(' + exp + ')';\n\t  } else {\n\t    var dir = parseDirective(exp);\n\t    if (!dir.filters) {\n\t      return '(' + exp + ')';\n\t    } else {\n\t      return 'this._applyFilters(' + dir.expression + // value\n\t      ',null,' + // oldValue (null for read)\n\t      JSON.stringify(dir.filters) + // filter descriptors\n\t      ',false)'; // write?\n\t    }\n\t  }\n\t}\n\t\n\tvar text = Object.freeze({\n\t  compileRegex: compileRegex,\n\t  parseText: parseText,\n\t  tokensToExp: tokensToExp\n\t});\n\t\n\tvar delimiters = ['{{', '}}'];\n\tvar unsafeDelimiters = ['{{{', '}}}'];\n\t\n\tvar config = Object.defineProperties({\n\t\n\t  /**\n\t   * Whether to print debug messages.\n\t   * Also enables stack trace for warnings.\n\t   *\n\t   * @type {Boolean}\n\t   */\n\t\n\t  debug: false,\n\t\n\t  /**\n\t   * Whether to suppress warnings.\n\t   *\n\t   * @type {Boolean}\n\t   */\n\t\n\t  silent: false,\n\t\n\t  /**\n\t   * Whether to use async rendering.\n\t   */\n\t\n\t  async: true,\n\t\n\t  /**\n\t   * Whether to warn against errors caught when evaluating\n\t   * expressions.\n\t   */\n\t\n\t  warnExpressionErrors: true,\n\t\n\t  /**\n\t   * Whether to allow devtools inspection.\n\t   * Disabled by default in production builds.\n\t   */\n\t\n\t  devtools: (\"production\") !== 'production',\n\t\n\t  /**\n\t   * Internal flag to indicate the delimiters have been\n\t   * changed.\n\t   *\n\t   * @type {Boolean}\n\t   */\n\t\n\t  _delimitersChanged: true,\n\t\n\t  /**\n\t   * List of asset types that a component can own.\n\t   *\n\t   * @type {Array}\n\t   */\n\t\n\t  _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],\n\t\n\t  /**\n\t   * prop binding modes\n\t   */\n\t\n\t  _propBindingModes: {\n\t    ONE_WAY: 0,\n\t    TWO_WAY: 1,\n\t    ONE_TIME: 2\n\t  },\n\t\n\t  /**\n\t   * Max circular updates allowed in a batcher flush cycle.\n\t   */\n\t\n\t  _maxUpdateCount: 100\n\t\n\t}, {\n\t  delimiters: { /**\n\t                 * Interpolation delimiters. Changing these would trigger\n\t                 * the text parser to re-compile the regular expressions.\n\t                 *\n\t                 * @type {Array<String>}\n\t                 */\n\t\n\t    get: function get() {\n\t      return delimiters;\n\t    },\n\t    set: function set(val) {\n\t      delimiters = val;\n\t      compileRegex();\n\t    },\n\t    configurable: true,\n\t    enumerable: true\n\t  },\n\t  unsafeDelimiters: {\n\t    get: function get() {\n\t      return unsafeDelimiters;\n\t    },\n\t    set: function set(val) {\n\t      unsafeDelimiters = val;\n\t      compileRegex();\n\t    },\n\t    configurable: true,\n\t    enumerable: true\n\t  }\n\t});\n\t\n\tvar warn = undefined;\n\tvar formatComponentName = undefined;\n\t\n\tif (false) {\n\t  (function () {\n\t    var hasConsole = typeof console !== 'undefined';\n\t\n\t    warn = function (msg, vm) {\n\t      if (hasConsole && !config.silent) {\n\t        console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));\n\t      }\n\t    };\n\t\n\t    formatComponentName = function (vm) {\n\t      var name = vm._isVue ? vm.$options.name : vm.name;\n\t      return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';\n\t    };\n\t  })();\n\t}\n\t\n\t/**\n\t * Append with transition.\n\t *\n\t * @param {Element} el\n\t * @param {Element} target\n\t * @param {Vue} vm\n\t * @param {Function} [cb]\n\t */\n\t\n\tfunction appendWithTransition(el, target, vm, cb) {\n\t  applyTransition(el, 1, function () {\n\t    target.appendChild(el);\n\t  }, vm, cb);\n\t}\n\t\n\t/**\n\t * InsertBefore with transition.\n\t *\n\t * @param {Element} el\n\t * @param {Element} target\n\t * @param {Vue} vm\n\t * @param {Function} [cb]\n\t */\n\t\n\tfunction beforeWithTransition(el, target, vm, cb) {\n\t  applyTransition(el, 1, function () {\n\t    before(el, target);\n\t  }, vm, cb);\n\t}\n\t\n\t/**\n\t * Remove with transition.\n\t *\n\t * @param {Element} el\n\t * @param {Vue} vm\n\t * @param {Function} [cb]\n\t */\n\t\n\tfunction removeWithTransition(el, vm, cb) {\n\t  applyTransition(el, -1, function () {\n\t    remove(el);\n\t  }, vm, cb);\n\t}\n\t\n\t/**\n\t * Apply transitions with an operation callback.\n\t *\n\t * @param {Element} el\n\t * @param {Number} direction\n\t *                  1: enter\n\t *                 -1: leave\n\t * @param {Function} op - the actual DOM operation\n\t * @param {Vue} vm\n\t * @param {Function} [cb]\n\t */\n\t\n\tfunction applyTransition(el, direction, op, vm, cb) {\n\t  var transition = el.__v_trans;\n\t  if (!transition ||\n\t  // skip if there are no js hooks and CSS transition is\n\t  // not supported\n\t  !transition.hooks && !transitionEndEvent ||\n\t  // skip transitions for initial compile\n\t  !vm._isCompiled ||\n\t  // if the vm is being manipulated by a parent directive\n\t  // during the parent's compilation phase, skip the\n\t  // animation.\n\t  vm.$parent && !vm.$parent._isCompiled) {\n\t    op();\n\t    if (cb) cb();\n\t    return;\n\t  }\n\t  var action = direction > 0 ? 'enter' : 'leave';\n\t  transition[action](op, cb);\n\t}\n\t\n\tvar transition = Object.freeze({\n\t  appendWithTransition: appendWithTransition,\n\t  beforeWithTransition: beforeWithTransition,\n\t  removeWithTransition: removeWithTransition,\n\t  applyTransition: applyTransition\n\t});\n\t\n\t/**\n\t * Query an element selector if it's not an element already.\n\t *\n\t * @param {String|Element} el\n\t * @return {Element}\n\t */\n\t\n\tfunction query(el) {\n\t  if (typeof el === 'string') {\n\t    var selector = el;\n\t    el = document.querySelector(el);\n\t    if (!el) {\n\t      (\"production\") !== 'production' && warn('Cannot find element: ' + selector);\n\t    }\n\t  }\n\t  return el;\n\t}\n\t\n\t/**\n\t * Check if a node is in the document.\n\t * Note: document.documentElement.contains should work here\n\t * but always returns false for comment nodes in phantomjs,\n\t * making unit tests difficult. This is fixed by doing the\n\t * contains() check on the node's parentNode instead of\n\t * the node itself.\n\t *\n\t * @param {Node} node\n\t * @return {Boolean}\n\t */\n\t\n\tfunction inDoc(node) {\n\t  if (!node) return false;\n\t  var doc = node.ownerDocument.documentElement;\n\t  var parent = node.parentNode;\n\t  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));\n\t}\n\t\n\t/**\n\t * Get and remove an attribute from a node.\n\t *\n\t * @param {Node} node\n\t * @param {String} _attr\n\t */\n\t\n\tfunction getAttr(node, _attr) {\n\t  var val = node.getAttribute(_attr);\n\t  if (val !== null) {\n\t    node.removeAttribute(_attr);\n\t  }\n\t  return val;\n\t}\n\t\n\t/**\n\t * Get an attribute with colon or v-bind: prefix.\n\t *\n\t * @param {Node} node\n\t * @param {String} name\n\t * @return {String|null}\n\t */\n\t\n\tfunction getBindAttr(node, name) {\n\t  var val = getAttr(node, ':' + name);\n\t  if (val === null) {\n\t    val = getAttr(node, 'v-bind:' + name);\n\t  }\n\t  return val;\n\t}\n\t\n\t/**\n\t * Check the presence of a bind attribute.\n\t *\n\t * @param {Node} node\n\t * @param {String} name\n\t * @return {Boolean}\n\t */\n\t\n\tfunction hasBindAttr(node, name) {\n\t  return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);\n\t}\n\t\n\t/**\n\t * Insert el before target\n\t *\n\t * @param {Element} el\n\t * @param {Element} target\n\t */\n\t\n\tfunction before(el, target) {\n\t  target.parentNode.insertBefore(el, target);\n\t}\n\t\n\t/**\n\t * Insert el after target\n\t *\n\t * @param {Element} el\n\t * @param {Element} target\n\t */\n\t\n\tfunction after(el, target) {\n\t  if (target.nextSibling) {\n\t    before(el, target.nextSibling);\n\t  } else {\n\t    target.parentNode.appendChild(el);\n\t  }\n\t}\n\t\n\t/**\n\t * Remove el from DOM\n\t *\n\t * @param {Element} el\n\t */\n\t\n\tfunction remove(el) {\n\t  el.parentNode.removeChild(el);\n\t}\n\t\n\t/**\n\t * Prepend el to target\n\t *\n\t * @param {Element} el\n\t * @param {Element} target\n\t */\n\t\n\tfunction prepend(el, target) {\n\t  if (target.firstChild) {\n\t    before(el, target.firstChild);\n\t  } else {\n\t    target.appendChild(el);\n\t  }\n\t}\n\t\n\t/**\n\t * Replace target with el\n\t *\n\t * @param {Element} target\n\t * @param {Element} el\n\t */\n\t\n\tfunction replace(target, el) {\n\t  var parent = target.parentNode;\n\t  if (parent) {\n\t    parent.replaceChild(el, target);\n\t  }\n\t}\n\t\n\t/**\n\t * Add event listener shorthand.\n\t *\n\t * @param {Element} el\n\t * @param {String} event\n\t * @param {Function} cb\n\t * @param {Boolean} [useCapture]\n\t */\n\t\n\tfunction on(el, event, cb, useCapture) {\n\t  el.addEventListener(event, cb, useCapture);\n\t}\n\t\n\t/**\n\t * Remove event listener shorthand.\n\t *\n\t * @param {Element} el\n\t * @param {String} event\n\t * @param {Function} cb\n\t */\n\t\n\tfunction off(el, event, cb) {\n\t  el.removeEventListener(event, cb);\n\t}\n\t\n\t/**\n\t * For IE9 compat: when both class and :class are present\n\t * getAttribute('class') returns wrong value...\n\t *\n\t * @param {Element} el\n\t * @return {String}\n\t */\n\t\n\tfunction getClass(el) {\n\t  var classname = el.className;\n\t  if (typeof classname === 'object') {\n\t    classname = classname.baseVal || '';\n\t  }\n\t  return classname;\n\t}\n\t\n\t/**\n\t * In IE9, setAttribute('class') will result in empty class\n\t * if the element also has the :class attribute; However in\n\t * PhantomJS, setting `className` does not work on SVG elements...\n\t * So we have to do a conditional check here.\n\t *\n\t * @param {Element} el\n\t * @param {String} cls\n\t */\n\t\n\tfunction setClass(el, cls) {\n\t  /* istanbul ignore if */\n\t  if (isIE9 && !/svg$/.test(el.namespaceURI)) {\n\t    el.className = cls;\n\t  } else {\n\t    el.setAttribute('class', cls);\n\t  }\n\t}\n\t\n\t/**\n\t * Add class with compatibility for IE & SVG\n\t *\n\t * @param {Element} el\n\t * @param {String} cls\n\t */\n\t\n\tfunction addClass(el, cls) {\n\t  if (el.classList) {\n\t    el.classList.add(cls);\n\t  } else {\n\t    var cur = ' ' + getClass(el) + ' ';\n\t    if (cur.indexOf(' ' + cls + ' ') < 0) {\n\t      setClass(el, (cur + cls).trim());\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Remove class with compatibility for IE & SVG\n\t *\n\t * @param {Element} el\n\t * @param {String} cls\n\t */\n\t\n\tfunction removeClass(el, cls) {\n\t  if (el.classList) {\n\t    el.classList.remove(cls);\n\t  } else {\n\t    var cur = ' ' + getClass(el) + ' ';\n\t    var tar = ' ' + cls + ' ';\n\t    while (cur.indexOf(tar) >= 0) {\n\t      cur = cur.replace(tar, ' ');\n\t    }\n\t    setClass(el, cur.trim());\n\t  }\n\t  if (!el.className) {\n\t    el.removeAttribute('class');\n\t  }\n\t}\n\t\n\t/**\n\t * Extract raw content inside an element into a temporary\n\t * container div\n\t *\n\t * @param {Element} el\n\t * @param {Boolean} asFragment\n\t * @return {Element|DocumentFragment}\n\t */\n\t\n\tfunction extractContent(el, asFragment) {\n\t  var child;\n\t  var rawContent;\n\t  /* istanbul ignore if */\n\t  if (isTemplate(el) && isFragment(el.content)) {\n\t    el = el.content;\n\t  }\n\t  if (el.hasChildNodes()) {\n\t    trimNode(el);\n\t    rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');\n\t    /* eslint-disable no-cond-assign */\n\t    while (child = el.firstChild) {\n\t      /* eslint-enable no-cond-assign */\n\t      rawContent.appendChild(child);\n\t    }\n\t  }\n\t  return rawContent;\n\t}\n\t\n\t/**\n\t * Trim possible empty head/tail text and comment\n\t * nodes inside a parent.\n\t *\n\t * @param {Node} node\n\t */\n\t\n\tfunction trimNode(node) {\n\t  var child;\n\t  /* eslint-disable no-sequences */\n\t  while ((child = node.firstChild, isTrimmable(child))) {\n\t    node.removeChild(child);\n\t  }\n\t  while ((child = node.lastChild, isTrimmable(child))) {\n\t    node.removeChild(child);\n\t  }\n\t  /* eslint-enable no-sequences */\n\t}\n\t\n\tfunction isTrimmable(node) {\n\t  return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);\n\t}\n\t\n\t/**\n\t * Check if an element is a template tag.\n\t * Note if the template appears inside an SVG its tagName\n\t * will be in lowercase.\n\t *\n\t * @param {Element} el\n\t */\n\t\n\tfunction isTemplate(el) {\n\t  return el.tagName && el.tagName.toLowerCase() === 'template';\n\t}\n\t\n\t/**\n\t * Create an \"anchor\" for performing dom insertion/removals.\n\t * This is used in a number of scenarios:\n\t * - fragment instance\n\t * - v-html\n\t * - v-if\n\t * - v-for\n\t * - component\n\t *\n\t * @param {String} content\n\t * @param {Boolean} persist - IE trashes empty textNodes on\n\t *                            cloneNode(true), so in certain\n\t *                            cases the anchor needs to be\n\t *                            non-empty to be persisted in\n\t *                            templates.\n\t * @return {Comment|Text}\n\t */\n\t\n\tfunction createAnchor(content, persist) {\n\t  var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');\n\t  anchor.__v_anchor = true;\n\t  return anchor;\n\t}\n\t\n\t/**\n\t * Find a component ref attribute that starts with $.\n\t *\n\t * @param {Element} node\n\t * @return {String|undefined}\n\t */\n\t\n\tvar refRE = /^v-ref:/;\n\t\n\tfunction findRef(node) {\n\t  if (node.hasAttributes()) {\n\t    var attrs = node.attributes;\n\t    for (var i = 0, l = attrs.length; i < l; i++) {\n\t      var name = attrs[i].name;\n\t      if (refRE.test(name)) {\n\t        return camelize(name.replace(refRE, ''));\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Map a function to a range of nodes .\n\t *\n\t * @param {Node} node\n\t * @param {Node} end\n\t * @param {Function} op\n\t */\n\t\n\tfunction mapNodeRange(node, end, op) {\n\t  var next;\n\t  while (node !== end) {\n\t    next = node.nextSibling;\n\t    op(node);\n\t    node = next;\n\t  }\n\t  op(end);\n\t}\n\t\n\t/**\n\t * Remove a range of nodes with transition, store\n\t * the nodes in a fragment with correct ordering,\n\t * and call callback when done.\n\t *\n\t * @param {Node} start\n\t * @param {Node} end\n\t * @param {Vue} vm\n\t * @param {DocumentFragment} frag\n\t * @param {Function} cb\n\t */\n\t\n\tfunction removeNodeRange(start, end, vm, frag, cb) {\n\t  var done = false;\n\t  var removed = 0;\n\t  var nodes = [];\n\t  mapNodeRange(start, end, function (node) {\n\t    if (node === end) done = true;\n\t    nodes.push(node);\n\t    removeWithTransition(node, vm, onRemoved);\n\t  });\n\t  function onRemoved() {\n\t    removed++;\n\t    if (done && removed >= nodes.length) {\n\t      for (var i = 0; i < nodes.length; i++) {\n\t        frag.appendChild(nodes[i]);\n\t      }\n\t      cb && cb();\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Check if a node is a DocumentFragment.\n\t *\n\t * @param {Node} node\n\t * @return {Boolean}\n\t */\n\t\n\tfunction isFragment(node) {\n\t  return node && node.nodeType === 11;\n\t}\n\t\n\t/**\n\t * Get outerHTML of elements, taking care\n\t * of SVG elements in IE as well.\n\t *\n\t * @param {Element} el\n\t * @return {String}\n\t */\n\t\n\tfunction getOuterHTML(el) {\n\t  if (el.outerHTML) {\n\t    return el.outerHTML;\n\t  } else {\n\t    var container = document.createElement('div');\n\t    container.appendChild(el.cloneNode(true));\n\t    return container.innerHTML;\n\t  }\n\t}\n\t\n\tvar commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;\n\tvar reservedTagRE = /^(slot|partial|component)$/i;\n\t\n\tvar isUnknownElement = undefined;\n\tif (false) {\n\t  isUnknownElement = function (el, tag) {\n\t    if (tag.indexOf('-') > -1) {\n\t      // http://stackoverflow.com/a/28210364/1070244\n\t      return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n\t    } else {\n\t      return (/HTMLUnknownElement/.test(el.toString()) &&\n\t        // Chrome returns unknown for several HTML5 elements.\n\t        // https://code.google.com/p/chromium/issues/detail?id=540526\n\t        // Firefox returns unknown for some \"Interactive elements.\"\n\t        !/^(data|time|rtc|rb|details|dialog|summary)$/.test(tag)\n\t      );\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Check if an element is a component, if yes return its\n\t * component id.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @return {Object|undefined}\n\t */\n\t\n\tfunction checkComponentAttr(el, options) {\n\t  var tag = el.tagName.toLowerCase();\n\t  var hasAttrs = el.hasAttributes();\n\t  if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {\n\t    if (resolveAsset(options, 'components', tag)) {\n\t      return { id: tag };\n\t    } else {\n\t      var is = hasAttrs && getIsBinding(el, options);\n\t      if (is) {\n\t        return is;\n\t      } else if (false) {\n\t        var expectedTag = options._componentNameMap && options._componentNameMap[tag];\n\t        if (expectedTag) {\n\t          warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');\n\t        } else if (isUnknownElement(el, tag)) {\n\t          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.');\n\t        }\n\t      }\n\t    }\n\t  } else if (hasAttrs) {\n\t    return getIsBinding(el, options);\n\t  }\n\t}\n\t\n\t/**\n\t * Get \"is\" binding from an element.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @return {Object|undefined}\n\t */\n\t\n\tfunction getIsBinding(el, options) {\n\t  // dynamic syntax\n\t  var exp = el.getAttribute('is');\n\t  if (exp != null) {\n\t    if (resolveAsset(options, 'components', exp)) {\n\t      el.removeAttribute('is');\n\t      return { id: exp };\n\t    }\n\t  } else {\n\t    exp = getBindAttr(el, 'is');\n\t    if (exp != null) {\n\t      return { id: exp, dynamic: true };\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Option overwriting strategies are functions that handle\n\t * how to merge a parent option value and a child option\n\t * value into the final value.\n\t *\n\t * All strategy functions follow the same signature:\n\t *\n\t * @param {*} parentVal\n\t * @param {*} childVal\n\t * @param {Vue} [vm]\n\t */\n\t\n\tvar strats = config.optionMergeStrategies = Object.create(null);\n\t\n\t/**\n\t * Helper that recursively merges two data objects together.\n\t */\n\t\n\tfunction mergeData(to, from) {\n\t  var key, toVal, fromVal;\n\t  for (key in from) {\n\t    toVal = to[key];\n\t    fromVal = from[key];\n\t    if (!hasOwn(to, key)) {\n\t      set(to, key, fromVal);\n\t    } else if (isObject(toVal) && isObject(fromVal)) {\n\t      mergeData(toVal, fromVal);\n\t    }\n\t  }\n\t  return to;\n\t}\n\t\n\t/**\n\t * Data\n\t */\n\t\n\tstrats.data = function (parentVal, childVal, vm) {\n\t  if (!vm) {\n\t    // in a Vue.extend merge, both should be functions\n\t    if (!childVal) {\n\t      return parentVal;\n\t    }\n\t    if (typeof childVal !== 'function') {\n\t      (\"production\") !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n\t      return parentVal;\n\t    }\n\t    if (!parentVal) {\n\t      return childVal;\n\t    }\n\t    // when parentVal & childVal are both present,\n\t    // we need to return a function that returns the\n\t    // merged result of both functions... no need to\n\t    // check if parentVal is a function here because\n\t    // it has to be a function to pass previous merges.\n\t    return function mergedDataFn() {\n\t      return mergeData(childVal.call(this), parentVal.call(this));\n\t    };\n\t  } else if (parentVal || childVal) {\n\t    return function mergedInstanceDataFn() {\n\t      // instance merge\n\t      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\n\t      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\n\t      if (instanceData) {\n\t        return mergeData(instanceData, defaultData);\n\t      } else {\n\t        return defaultData;\n\t      }\n\t    };\n\t  }\n\t};\n\t\n\t/**\n\t * El\n\t */\n\t\n\tstrats.el = function (parentVal, childVal, vm) {\n\t  if (!vm && childVal && typeof childVal !== 'function') {\n\t    (\"production\") !== 'production' && warn('The \"el\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n\t    return;\n\t  }\n\t  var ret = childVal || parentVal;\n\t  // invoke the element factory if this is instance merge\n\t  return vm && typeof ret === 'function' ? ret.call(vm) : ret;\n\t};\n\t\n\t/**\n\t * Hooks and param attributes are merged as arrays.\n\t */\n\t\n\tstrats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {\n\t  return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;\n\t};\n\t\n\t/**\n\t * Assets\n\t *\n\t * When a vm is present (instance creation), we need to do\n\t * a three-way merge between constructor options, instance\n\t * options and parent options.\n\t */\n\t\n\tfunction mergeAssets(parentVal, childVal) {\n\t  var res = Object.create(parentVal || null);\n\t  return childVal ? extend(res, guardArrayAssets(childVal)) : res;\n\t}\n\t\n\tconfig._assetTypes.forEach(function (type) {\n\t  strats[type + 's'] = mergeAssets;\n\t});\n\t\n\t/**\n\t * Events & Watchers.\n\t *\n\t * Events & watchers hashes should not overwrite one\n\t * another, so we merge them as arrays.\n\t */\n\t\n\tstrats.watch = strats.events = function (parentVal, childVal) {\n\t  if (!childVal) return parentVal;\n\t  if (!parentVal) return childVal;\n\t  var ret = {};\n\t  extend(ret, parentVal);\n\t  for (var key in childVal) {\n\t    var parent = ret[key];\n\t    var child = childVal[key];\n\t    if (parent && !isArray(parent)) {\n\t      parent = [parent];\n\t    }\n\t    ret[key] = parent ? parent.concat(child) : [child];\n\t  }\n\t  return ret;\n\t};\n\t\n\t/**\n\t * Other object hashes.\n\t */\n\t\n\tstrats.props = strats.methods = strats.computed = function (parentVal, childVal) {\n\t  if (!childVal) return parentVal;\n\t  if (!parentVal) return childVal;\n\t  var ret = Object.create(null);\n\t  extend(ret, parentVal);\n\t  extend(ret, childVal);\n\t  return ret;\n\t};\n\t\n\t/**\n\t * Default strategy.\n\t */\n\t\n\tvar defaultStrat = function defaultStrat(parentVal, childVal) {\n\t  return childVal === undefined ? parentVal : childVal;\n\t};\n\t\n\t/**\n\t * Make sure component options get converted to actual\n\t * constructors.\n\t *\n\t * @param {Object} options\n\t */\n\t\n\tfunction guardComponents(options) {\n\t  if (options.components) {\n\t    var components = options.components = guardArrayAssets(options.components);\n\t    var ids = Object.keys(components);\n\t    var def;\n\t    if (false) {\n\t      var map = options._componentNameMap = {};\n\t    }\n\t    for (var i = 0, l = ids.length; i < l; i++) {\n\t      var key = ids[i];\n\t      if (commonTagRE.test(key) || reservedTagRE.test(key)) {\n\t        (\"production\") !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\n\t        continue;\n\t      }\n\t      // record a all lowercase <-> kebab-case mapping for\n\t      // possible custom element case error warning\n\t      if (false) {\n\t        map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);\n\t      }\n\t      def = components[key];\n\t      if (isPlainObject(def)) {\n\t        components[key] = Vue.extend(def);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Ensure all props option syntax are normalized into the\n\t * Object-based format.\n\t *\n\t * @param {Object} options\n\t */\n\t\n\tfunction guardProps(options) {\n\t  var props = options.props;\n\t  var i, val;\n\t  if (isArray(props)) {\n\t    options.props = {};\n\t    i = props.length;\n\t    while (i--) {\n\t      val = props[i];\n\t      if (typeof val === 'string') {\n\t        options.props[val] = null;\n\t      } else if (val.name) {\n\t        options.props[val.name] = val;\n\t      }\n\t    }\n\t  } else if (isPlainObject(props)) {\n\t    var keys = Object.keys(props);\n\t    i = keys.length;\n\t    while (i--) {\n\t      val = props[keys[i]];\n\t      if (typeof val === 'function') {\n\t        props[keys[i]] = { type: val };\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Guard an Array-format assets option and converted it\n\t * into the key-value Object format.\n\t *\n\t * @param {Object|Array} assets\n\t * @return {Object}\n\t */\n\t\n\tfunction guardArrayAssets(assets) {\n\t  if (isArray(assets)) {\n\t    var res = {};\n\t    var i = assets.length;\n\t    var asset;\n\t    while (i--) {\n\t      asset = assets[i];\n\t      var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;\n\t      if (!id) {\n\t        (\"production\") !== 'production' && warn('Array-syntax assets must provide a \"name\" or \"id\" field.');\n\t      } else {\n\t        res[id] = asset;\n\t      }\n\t    }\n\t    return res;\n\t  }\n\t  return assets;\n\t}\n\t\n\t/**\n\t * Merge two option objects into a new one.\n\t * Core utility used in both instantiation and inheritance.\n\t *\n\t * @param {Object} parent\n\t * @param {Object} child\n\t * @param {Vue} [vm] - if vm is present, indicates this is\n\t *                     an instantiation merge.\n\t */\n\t\n\tfunction mergeOptions(parent, child, vm) {\n\t  guardComponents(child);\n\t  guardProps(child);\n\t  if (false) {\n\t    if (child.propsData && !vm) {\n\t      warn('propsData can only be used as an instantiation option.');\n\t    }\n\t  }\n\t  var options = {};\n\t  var key;\n\t  if (child['extends']) {\n\t    parent = typeof child['extends'] === 'function' ? mergeOptions(parent, child['extends'].options, vm) : mergeOptions(parent, child['extends'], vm);\n\t  }\n\t  if (child.mixins) {\n\t    for (var i = 0, l = child.mixins.length; i < l; i++) {\n\t      var mixin = child.mixins[i];\n\t      var mixinOptions = mixin.prototype instanceof Vue ? mixin.options : mixin;\n\t      parent = mergeOptions(parent, mixinOptions, vm);\n\t    }\n\t  }\n\t  for (key in parent) {\n\t    mergeField(key);\n\t  }\n\t  for (key in child) {\n\t    if (!hasOwn(parent, key)) {\n\t      mergeField(key);\n\t    }\n\t  }\n\t  function mergeField(key) {\n\t    var strat = strats[key] || defaultStrat;\n\t    options[key] = strat(parent[key], child[key], vm, key);\n\t  }\n\t  return options;\n\t}\n\t\n\t/**\n\t * Resolve an asset.\n\t * This function is used because child instances need access\n\t * to assets defined in its ancestor chain.\n\t *\n\t * @param {Object} options\n\t * @param {String} type\n\t * @param {String} id\n\t * @param {Boolean} warnMissing\n\t * @return {Object|Function}\n\t */\n\t\n\tfunction resolveAsset(options, type, id, warnMissing) {\n\t  /* istanbul ignore if */\n\t  if (typeof id !== 'string') {\n\t    return;\n\t  }\n\t  var assets = options[type];\n\t  var camelizedId;\n\t  var res = assets[id] ||\n\t  // camelCase ID\n\t  assets[camelizedId = camelize(id)] ||\n\t  // Pascal Case ID\n\t  assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];\n\t  if (false) {\n\t    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n\t  }\n\t  return res;\n\t}\n\t\n\tvar uid$1 = 0;\n\t\n\t/**\n\t * A dep is an observable that can have multiple\n\t * directives subscribing to it.\n\t *\n\t * @constructor\n\t */\n\tfunction Dep() {\n\t  this.id = uid$1++;\n\t  this.subs = [];\n\t}\n\t\n\t// the current target watcher being evaluated.\n\t// this is globally unique because there could be only one\n\t// watcher being evaluated at any time.\n\tDep.target = null;\n\t\n\t/**\n\t * Add a directive subscriber.\n\t *\n\t * @param {Directive} sub\n\t */\n\t\n\tDep.prototype.addSub = function (sub) {\n\t  this.subs.push(sub);\n\t};\n\t\n\t/**\n\t * Remove a directive subscriber.\n\t *\n\t * @param {Directive} sub\n\t */\n\t\n\tDep.prototype.removeSub = function (sub) {\n\t  this.subs.$remove(sub);\n\t};\n\t\n\t/**\n\t * Add self as a dependency to the target watcher.\n\t */\n\t\n\tDep.prototype.depend = function () {\n\t  Dep.target.addDep(this);\n\t};\n\t\n\t/**\n\t * Notify all subscribers of a new value.\n\t */\n\t\n\tDep.prototype.notify = function () {\n\t  // stablize the subscriber list first\n\t  var subs = toArray(this.subs);\n\t  for (var i = 0, l = subs.length; i < l; i++) {\n\t    subs[i].update();\n\t  }\n\t};\n\t\n\tvar arrayProto = Array.prototype;\n\tvar arrayMethods = Object.create(arrayProto)\n\t\n\t/**\n\t * Intercept mutating methods and emit events\n\t */\n\t\n\t;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n\t  // cache original method\n\t  var original = arrayProto[method];\n\t  def(arrayMethods, method, function mutator() {\n\t    // avoid leaking arguments:\n\t    // http://jsperf.com/closure-with-arguments\n\t    var i = arguments.length;\n\t    var args = new Array(i);\n\t    while (i--) {\n\t      args[i] = arguments[i];\n\t    }\n\t    var result = original.apply(this, args);\n\t    var ob = this.__ob__;\n\t    var inserted;\n\t    switch (method) {\n\t      case 'push':\n\t        inserted = args;\n\t        break;\n\t      case 'unshift':\n\t        inserted = args;\n\t        break;\n\t      case 'splice':\n\t        inserted = args.slice(2);\n\t        break;\n\t    }\n\t    if (inserted) ob.observeArray(inserted);\n\t    // notify change\n\t    ob.dep.notify();\n\t    return result;\n\t  });\n\t});\n\t\n\t/**\n\t * Swap the element at the given index with a new value\n\t * and emits corresponding event.\n\t *\n\t * @param {Number} index\n\t * @param {*} val\n\t * @return {*} - replaced element\n\t */\n\t\n\tdef(arrayProto, '$set', function $set(index, val) {\n\t  if (index >= this.length) {\n\t    this.length = Number(index) + 1;\n\t  }\n\t  return this.splice(index, 1, val)[0];\n\t});\n\t\n\t/**\n\t * Convenience method to remove the element at given index or target element reference.\n\t *\n\t * @param {*} item\n\t */\n\t\n\tdef(arrayProto, '$remove', function $remove(item) {\n\t  /* istanbul ignore if */\n\t  if (!this.length) return;\n\t  var index = indexOf(this, item);\n\t  if (index > -1) {\n\t    return this.splice(index, 1);\n\t  }\n\t});\n\t\n\tvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\t\n\t/**\n\t * By default, when a reactive property is set, the new value is\n\t * also converted to become reactive. However in certain cases, e.g.\n\t * v-for scope alias and props, we don't want to force conversion\n\t * because the value may be a nested value under a frozen data structure.\n\t *\n\t * So whenever we want to set a reactive property without forcing\n\t * conversion on the new value, we wrap that call inside this function.\n\t */\n\t\n\tvar shouldConvert = true;\n\t\n\tfunction withoutConversion(fn) {\n\t  shouldConvert = false;\n\t  fn();\n\t  shouldConvert = true;\n\t}\n\t\n\t/**\n\t * Observer class that are attached to each observed\n\t * object. Once attached, the observer converts target\n\t * object's property keys into getter/setters that\n\t * collect dependencies and dispatches updates.\n\t *\n\t * @param {Array|Object} value\n\t * @constructor\n\t */\n\t\n\tfunction Observer(value) {\n\t  this.value = value;\n\t  this.dep = new Dep();\n\t  def(value, '__ob__', this);\n\t  if (isArray(value)) {\n\t    var augment = hasProto ? protoAugment : copyAugment;\n\t    augment(value, arrayMethods, arrayKeys);\n\t    this.observeArray(value);\n\t  } else {\n\t    this.walk(value);\n\t  }\n\t}\n\t\n\t// Instance methods\n\t\n\t/**\n\t * Walk through each property and convert them into\n\t * getter/setters. This method should only be called when\n\t * value type is Object.\n\t *\n\t * @param {Object} obj\n\t */\n\t\n\tObserver.prototype.walk = function (obj) {\n\t  var keys = Object.keys(obj);\n\t  for (var i = 0, l = keys.length; i < l; i++) {\n\t    this.convert(keys[i], obj[keys[i]]);\n\t  }\n\t};\n\t\n\t/**\n\t * Observe a list of Array items.\n\t *\n\t * @param {Array} items\n\t */\n\t\n\tObserver.prototype.observeArray = function (items) {\n\t  for (var i = 0, l = items.length; i < l; i++) {\n\t    observe(items[i]);\n\t  }\n\t};\n\t\n\t/**\n\t * Convert a property into getter/setter so we can emit\n\t * the events when the property is accessed/changed.\n\t *\n\t * @param {String} key\n\t * @param {*} val\n\t */\n\t\n\tObserver.prototype.convert = function (key, val) {\n\t  defineReactive(this.value, key, val);\n\t};\n\t\n\t/**\n\t * Add an owner vm, so that when $set/$delete mutations\n\t * happen we can notify owner vms to proxy the keys and\n\t * digest the watchers. This is only called when the object\n\t * is observed as an instance's root $data.\n\t *\n\t * @param {Vue} vm\n\t */\n\t\n\tObserver.prototype.addVm = function (vm) {\n\t  (this.vms || (this.vms = [])).push(vm);\n\t};\n\t\n\t/**\n\t * Remove an owner vm. This is called when the object is\n\t * swapped out as an instance's $data object.\n\t *\n\t * @param {Vue} vm\n\t */\n\t\n\tObserver.prototype.removeVm = function (vm) {\n\t  this.vms.$remove(vm);\n\t};\n\t\n\t// helpers\n\t\n\t/**\n\t * Augment an target Object or Array by intercepting\n\t * the prototype chain using __proto__\n\t *\n\t * @param {Object|Array} target\n\t * @param {Object} src\n\t */\n\t\n\tfunction protoAugment(target, src) {\n\t  /* eslint-disable no-proto */\n\t  target.__proto__ = src;\n\t  /* eslint-enable no-proto */\n\t}\n\t\n\t/**\n\t * Augment an target Object or Array by defining\n\t * hidden properties.\n\t *\n\t * @param {Object|Array} target\n\t * @param {Object} proto\n\t */\n\t\n\tfunction copyAugment(target, src, keys) {\n\t  for (var i = 0, l = keys.length; i < l; i++) {\n\t    var key = keys[i];\n\t    def(target, key, src[key]);\n\t  }\n\t}\n\t\n\t/**\n\t * Attempt to create an observer instance for a value,\n\t * returns the new observer if successfully observed,\n\t * or the existing observer if the value already has one.\n\t *\n\t * @param {*} value\n\t * @param {Vue} [vm]\n\t * @return {Observer|undefined}\n\t * @static\n\t */\n\t\n\tfunction observe(value, vm) {\n\t  if (!value || typeof value !== 'object') {\n\t    return;\n\t  }\n\t  var ob;\n\t  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n\t    ob = value.__ob__;\n\t  } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n\t    ob = new Observer(value);\n\t  }\n\t  if (ob && vm) {\n\t    ob.addVm(vm);\n\t  }\n\t  return ob;\n\t}\n\t\n\t/**\n\t * Define a reactive property on an Object.\n\t *\n\t * @param {Object} obj\n\t * @param {String} key\n\t * @param {*} val\n\t */\n\t\n\tfunction defineReactive(obj, key, val) {\n\t  var dep = new Dep();\n\t\n\t  var property = Object.getOwnPropertyDescriptor(obj, key);\n\t  if (property && property.configurable === false) {\n\t    return;\n\t  }\n\t\n\t  // cater for pre-defined getter/setters\n\t  var getter = property && property.get;\n\t  var setter = property && property.set;\n\t\n\t  var childOb = observe(val);\n\t  Object.defineProperty(obj, key, {\n\t    enumerable: true,\n\t    configurable: true,\n\t    get: function reactiveGetter() {\n\t      var value = getter ? getter.call(obj) : val;\n\t      if (Dep.target) {\n\t        dep.depend();\n\t        if (childOb) {\n\t          childOb.dep.depend();\n\t        }\n\t        if (isArray(value)) {\n\t          for (var e, i = 0, l = value.length; i < l; i++) {\n\t            e = value[i];\n\t            e && e.__ob__ && e.__ob__.dep.depend();\n\t          }\n\t        }\n\t      }\n\t      return value;\n\t    },\n\t    set: function reactiveSetter(newVal) {\n\t      var value = getter ? getter.call(obj) : val;\n\t      if (newVal === value) {\n\t        return;\n\t      }\n\t      if (setter) {\n\t        setter.call(obj, newVal);\n\t      } else {\n\t        val = newVal;\n\t      }\n\t      childOb = observe(newVal);\n\t      dep.notify();\n\t    }\n\t  });\n\t}\n\t\n\t\n\t\n\tvar util = Object.freeze({\n\t\tdefineReactive: defineReactive,\n\t\tset: set,\n\t\tdel: del,\n\t\thasOwn: hasOwn,\n\t\tisLiteral: isLiteral,\n\t\tisReserved: isReserved,\n\t\t_toString: _toString,\n\t\ttoNumber: toNumber,\n\t\ttoBoolean: toBoolean,\n\t\tstripQuotes: stripQuotes,\n\t\tcamelize: camelize,\n\t\thyphenate: hyphenate,\n\t\tclassify: classify,\n\t\tbind: bind,\n\t\ttoArray: toArray,\n\t\textend: extend,\n\t\tisObject: isObject,\n\t\tisPlainObject: isPlainObject,\n\t\tdef: def,\n\t\tdebounce: _debounce,\n\t\tindexOf: indexOf,\n\t\tcancellable: cancellable,\n\t\tlooseEqual: looseEqual,\n\t\tisArray: isArray,\n\t\thasProto: hasProto,\n\t\tinBrowser: inBrowser,\n\t\tdevtools: devtools,\n\t\tisIE: isIE,\n\t\tisIE9: isIE9,\n\t\tisAndroid: isAndroid,\n\t\tisIos: isIos,\n\t\tiosVersionMatch: iosVersionMatch,\n\t\tiosVersion: iosVersion,\n\t\thasMutationObserverBug: hasMutationObserverBug,\n\t\tget transitionProp () { return transitionProp; },\n\t\tget transitionEndEvent () { return transitionEndEvent; },\n\t\tget animationProp () { return animationProp; },\n\t\tget animationEndEvent () { return animationEndEvent; },\n\t\tnextTick: nextTick,\n\t\tget _Set () { return _Set; },\n\t\tquery: query,\n\t\tinDoc: inDoc,\n\t\tgetAttr: getAttr,\n\t\tgetBindAttr: getBindAttr,\n\t\thasBindAttr: hasBindAttr,\n\t\tbefore: before,\n\t\tafter: after,\n\t\tremove: remove,\n\t\tprepend: prepend,\n\t\treplace: replace,\n\t\ton: on,\n\t\toff: off,\n\t\tsetClass: setClass,\n\t\taddClass: addClass,\n\t\tremoveClass: removeClass,\n\t\textractContent: extractContent,\n\t\ttrimNode: trimNode,\n\t\tisTemplate: isTemplate,\n\t\tcreateAnchor: createAnchor,\n\t\tfindRef: findRef,\n\t\tmapNodeRange: mapNodeRange,\n\t\tremoveNodeRange: removeNodeRange,\n\t\tisFragment: isFragment,\n\t\tgetOuterHTML: getOuterHTML,\n\t\tmergeOptions: mergeOptions,\n\t\tresolveAsset: resolveAsset,\n\t\tcheckComponentAttr: checkComponentAttr,\n\t\tcommonTagRE: commonTagRE,\n\t\treservedTagRE: reservedTagRE,\n\t\tget warn () { return warn; }\n\t});\n\t\n\tvar uid = 0;\n\t\n\tfunction initMixin (Vue) {\n\t  /**\n\t   * The main init sequence. This is called for every\n\t   * instance, including ones that are created from extended\n\t   * constructors.\n\t   *\n\t   * @param {Object} options - this options object should be\n\t   *                           the result of merging class\n\t   *                           options and the options passed\n\t   *                           in to the constructor.\n\t   */\n\t\n\t  Vue.prototype._init = function (options) {\n\t    options = options || {};\n\t\n\t    this.$el = null;\n\t    this.$parent = options.parent;\n\t    this.$root = this.$parent ? this.$parent.$root : this;\n\t    this.$children = [];\n\t    this.$refs = {}; // child vm references\n\t    this.$els = {}; // element references\n\t    this._watchers = []; // all watchers as an array\n\t    this._directives = []; // all directives\n\t\n\t    // a uid\n\t    this._uid = uid++;\n\t\n\t    // a flag to avoid this being observed\n\t    this._isVue = true;\n\t\n\t    // events bookkeeping\n\t    this._events = {}; // registered callbacks\n\t    this._eventsCount = {}; // for $broadcast optimization\n\t\n\t    // fragment instance properties\n\t    this._isFragment = false;\n\t    this._fragment = // @type {DocumentFragment}\n\t    this._fragmentStart = // @type {Text|Comment}\n\t    this._fragmentEnd = null; // @type {Text|Comment}\n\t\n\t    // lifecycle state\n\t    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;\n\t    this._unlinkFn = null;\n\t\n\t    // context:\n\t    // if this is a transcluded component, context\n\t    // will be the common parent vm of this instance\n\t    // and its host.\n\t    this._context = options._context || this.$parent;\n\t\n\t    // scope:\n\t    // if this is inside an inline v-for, the scope\n\t    // will be the intermediate scope created for this\n\t    // repeat fragment. this is used for linking props\n\t    // and container directives.\n\t    this._scope = options._scope;\n\t\n\t    // fragment:\n\t    // if this instance is compiled inside a Fragment, it\n\t    // needs to reigster itself as a child of that fragment\n\t    // for attach/detach to work properly.\n\t    this._frag = options._frag;\n\t    if (this._frag) {\n\t      this._frag.children.push(this);\n\t    }\n\t\n\t    // push self into parent / transclusion host\n\t    if (this.$parent) {\n\t      this.$parent.$children.push(this);\n\t    }\n\t\n\t    // merge options.\n\t    options = this.$options = mergeOptions(this.constructor.options, options, this);\n\t\n\t    // set ref\n\t    this._updateRef();\n\t\n\t    // initialize data as empty object.\n\t    // it will be filled up in _initData().\n\t    this._data = {};\n\t\n\t    // call init hook\n\t    this._callHook('init');\n\t\n\t    // initialize data observation and scope inheritance.\n\t    this._initState();\n\t\n\t    // setup event system and option events.\n\t    this._initEvents();\n\t\n\t    // call created hook\n\t    this._callHook('created');\n\t\n\t    // if `el` option is passed, start compilation.\n\t    if (options.el) {\n\t      this.$mount(options.el);\n\t    }\n\t  };\n\t}\n\t\n\tvar pathCache = new Cache(1000);\n\t\n\t// actions\n\tvar APPEND = 0;\n\tvar PUSH = 1;\n\tvar INC_SUB_PATH_DEPTH = 2;\n\tvar PUSH_SUB_PATH = 3;\n\t\n\t// states\n\tvar BEFORE_PATH = 0;\n\tvar IN_PATH = 1;\n\tvar BEFORE_IDENT = 2;\n\tvar IN_IDENT = 3;\n\tvar IN_SUB_PATH = 4;\n\tvar IN_SINGLE_QUOTE = 5;\n\tvar IN_DOUBLE_QUOTE = 6;\n\tvar AFTER_PATH = 7;\n\tvar ERROR = 8;\n\t\n\tvar pathStateMachine = [];\n\t\n\tpathStateMachine[BEFORE_PATH] = {\n\t  'ws': [BEFORE_PATH],\n\t  'ident': [IN_IDENT, APPEND],\n\t  '[': [IN_SUB_PATH],\n\t  'eof': [AFTER_PATH]\n\t};\n\t\n\tpathStateMachine[IN_PATH] = {\n\t  'ws': [IN_PATH],\n\t  '.': [BEFORE_IDENT],\n\t  '[': [IN_SUB_PATH],\n\t  'eof': [AFTER_PATH]\n\t};\n\t\n\tpathStateMachine[BEFORE_IDENT] = {\n\t  'ws': [BEFORE_IDENT],\n\t  'ident': [IN_IDENT, APPEND]\n\t};\n\t\n\tpathStateMachine[IN_IDENT] = {\n\t  'ident': [IN_IDENT, APPEND],\n\t  '0': [IN_IDENT, APPEND],\n\t  'number': [IN_IDENT, APPEND],\n\t  'ws': [IN_PATH, PUSH],\n\t  '.': [BEFORE_IDENT, PUSH],\n\t  '[': [IN_SUB_PATH, PUSH],\n\t  'eof': [AFTER_PATH, PUSH]\n\t};\n\t\n\tpathStateMachine[IN_SUB_PATH] = {\n\t  \"'\": [IN_SINGLE_QUOTE, APPEND],\n\t  '\"': [IN_DOUBLE_QUOTE, APPEND],\n\t  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],\n\t  ']': [IN_PATH, PUSH_SUB_PATH],\n\t  'eof': ERROR,\n\t  'else': [IN_SUB_PATH, APPEND]\n\t};\n\t\n\tpathStateMachine[IN_SINGLE_QUOTE] = {\n\t  \"'\": [IN_SUB_PATH, APPEND],\n\t  'eof': ERROR,\n\t  'else': [IN_SINGLE_QUOTE, APPEND]\n\t};\n\t\n\tpathStateMachine[IN_DOUBLE_QUOTE] = {\n\t  '\"': [IN_SUB_PATH, APPEND],\n\t  'eof': ERROR,\n\t  'else': [IN_DOUBLE_QUOTE, APPEND]\n\t};\n\t\n\t/**\n\t * Determine the type of a character in a keypath.\n\t *\n\t * @param {Char} ch\n\t * @return {String} type\n\t */\n\t\n\tfunction getPathCharType(ch) {\n\t  if (ch === undefined) {\n\t    return 'eof';\n\t  }\n\t\n\t  var code = ch.charCodeAt(0);\n\t\n\t  switch (code) {\n\t    case 0x5B: // [\n\t    case 0x5D: // ]\n\t    case 0x2E: // .\n\t    case 0x22: // \"\n\t    case 0x27: // '\n\t    case 0x30:\n\t      // 0\n\t      return ch;\n\t\n\t    case 0x5F: // _\n\t    case 0x24:\n\t      // $\n\t      return 'ident';\n\t\n\t    case 0x20: // Space\n\t    case 0x09: // Tab\n\t    case 0x0A: // Newline\n\t    case 0x0D: // Return\n\t    case 0xA0: // No-break space\n\t    case 0xFEFF: // Byte Order Mark\n\t    case 0x2028: // Line Separator\n\t    case 0x2029:\n\t      // Paragraph Separator\n\t      return 'ws';\n\t  }\n\t\n\t  // a-z, A-Z\n\t  if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {\n\t    return 'ident';\n\t  }\n\t\n\t  // 1-9\n\t  if (code >= 0x31 && code <= 0x39) {\n\t    return 'number';\n\t  }\n\t\n\t  return 'else';\n\t}\n\t\n\t/**\n\t * Format a subPath, return its plain form if it is\n\t * a literal string or number. Otherwise prepend the\n\t * dynamic indicator (*).\n\t *\n\t * @param {String} path\n\t * @return {String}\n\t */\n\t\n\tfunction formatSubPath(path) {\n\t  var trimmed = path.trim();\n\t  // invalid leading 0\n\t  if (path.charAt(0) === '0' && isNaN(path)) {\n\t    return false;\n\t  }\n\t  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;\n\t}\n\t\n\t/**\n\t * Parse a string path into an array of segments\n\t *\n\t * @param {String} path\n\t * @return {Array|undefined}\n\t */\n\t\n\tfunction parse(path) {\n\t  var keys = [];\n\t  var index = -1;\n\t  var mode = BEFORE_PATH;\n\t  var subPathDepth = 0;\n\t  var c, newChar, key, type, transition, action, typeMap;\n\t\n\t  var actions = [];\n\t\n\t  actions[PUSH] = function () {\n\t    if (key !== undefined) {\n\t      keys.push(key);\n\t      key = undefined;\n\t    }\n\t  };\n\t\n\t  actions[APPEND] = function () {\n\t    if (key === undefined) {\n\t      key = newChar;\n\t    } else {\n\t      key += newChar;\n\t    }\n\t  };\n\t\n\t  actions[INC_SUB_PATH_DEPTH] = function () {\n\t    actions[APPEND]();\n\t    subPathDepth++;\n\t  };\n\t\n\t  actions[PUSH_SUB_PATH] = function () {\n\t    if (subPathDepth > 0) {\n\t      subPathDepth--;\n\t      mode = IN_SUB_PATH;\n\t      actions[APPEND]();\n\t    } else {\n\t      subPathDepth = 0;\n\t      key = formatSubPath(key);\n\t      if (key === false) {\n\t        return false;\n\t      } else {\n\t        actions[PUSH]();\n\t      }\n\t    }\n\t  };\n\t\n\t  function maybeUnescapeQuote() {\n\t    var nextChar = path[index + 1];\n\t    if (mode === IN_SINGLE_QUOTE && nextChar === \"'\" || mode === IN_DOUBLE_QUOTE && nextChar === '\"') {\n\t      index++;\n\t      newChar = '\\\\' + nextChar;\n\t      actions[APPEND]();\n\t      return true;\n\t    }\n\t  }\n\t\n\t  while (mode != null) {\n\t    index++;\n\t    c = path[index];\n\t\n\t    if (c === '\\\\' && maybeUnescapeQuote()) {\n\t      continue;\n\t    }\n\t\n\t    type = getPathCharType(c);\n\t    typeMap = pathStateMachine[mode];\n\t    transition = typeMap[type] || typeMap['else'] || ERROR;\n\t\n\t    if (transition === ERROR) {\n\t      return; // parse error\n\t    }\n\t\n\t    mode = transition[0];\n\t    action = actions[transition[1]];\n\t    if (action) {\n\t      newChar = transition[2];\n\t      newChar = newChar === undefined ? c : newChar;\n\t      if (action() === false) {\n\t        return;\n\t      }\n\t    }\n\t\n\t    if (mode === AFTER_PATH) {\n\t      keys.raw = path;\n\t      return keys;\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * External parse that check for a cache hit first\n\t *\n\t * @param {String} path\n\t * @return {Array|undefined}\n\t */\n\t\n\tfunction parsePath(path) {\n\t  var hit = pathCache.get(path);\n\t  if (!hit) {\n\t    hit = parse(path);\n\t    if (hit) {\n\t      pathCache.put(path, hit);\n\t    }\n\t  }\n\t  return hit;\n\t}\n\t\n\t/**\n\t * Get from an object from a path string\n\t *\n\t * @param {Object} obj\n\t * @param {String} path\n\t */\n\t\n\tfunction getPath(obj, path) {\n\t  return parseExpression(path).get(obj);\n\t}\n\t\n\t/**\n\t * Warn against setting non-existent root path on a vm.\n\t */\n\t\n\tvar warnNonExistent;\n\tif (false) {\n\t  warnNonExistent = function (path, vm) {\n\t    warn('You are setting a non-existent path \"' + path.raw + '\" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the \"data\" option for more reliable reactivity ' + 'and better performance.', vm);\n\t  };\n\t}\n\t\n\t/**\n\t * Set on an object from a path\n\t *\n\t * @param {Object} obj\n\t * @param {String | Array} path\n\t * @param {*} val\n\t */\n\t\n\tfunction setPath(obj, path, val) {\n\t  var original = obj;\n\t  if (typeof path === 'string') {\n\t    path = parse(path);\n\t  }\n\t  if (!path || !isObject(obj)) {\n\t    return false;\n\t  }\n\t  var last, key;\n\t  for (var i = 0, l = path.length; i < l; i++) {\n\t    last = obj;\n\t    key = path[i];\n\t    if (key.charAt(0) === '*') {\n\t      key = parseExpression(key.slice(1)).get.call(original, original);\n\t    }\n\t    if (i < l - 1) {\n\t      obj = obj[key];\n\t      if (!isObject(obj)) {\n\t        obj = {};\n\t        if (false) {\n\t          warnNonExistent(path, last);\n\t        }\n\t        set(last, key, obj);\n\t      }\n\t    } else {\n\t      if (isArray(obj)) {\n\t        obj.$set(key, val);\n\t      } else if (key in obj) {\n\t        obj[key] = val;\n\t      } else {\n\t        if (false) {\n\t          warnNonExistent(path, obj);\n\t        }\n\t        set(obj, key, val);\n\t      }\n\t    }\n\t  }\n\t  return true;\n\t}\n\t\n\tvar path = Object.freeze({\n\t  parsePath: parsePath,\n\t  getPath: getPath,\n\t  setPath: setPath\n\t});\n\t\n\tvar expressionCache = new Cache(1000);\n\t\n\tvar allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';\n\tvar allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\t\n\t// keywords that don't make sense inside expressions\n\tvar improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';\n\tvar improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\t\n\tvar wsRE = /\\s/g;\n\tvar newlineRE = /\\n/g;\n\tvar saveRE = /[\\{,]\\s*[\\w\\$_]+\\s*:|('(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`)|new |typeof |void /g;\n\tvar restoreRE = /\"(\\d+)\"/g;\n\tvar pathTestRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*$/;\n\tvar identRE = /[^\\w$\\.](?:[A-Za-z_$][\\w$]*)/g;\n\tvar literalValueRE$1 = /^(?:true|false|null|undefined|Infinity|NaN)$/;\n\t\n\tfunction noop() {}\n\t\n\t/**\n\t * Save / Rewrite / Restore\n\t *\n\t * When rewriting paths found in an expression, it is\n\t * possible for the same letter sequences to be found in\n\t * strings and Object literal property keys. Therefore we\n\t * remove and store these parts in a temporary array, and\n\t * restore them after the path rewrite.\n\t */\n\t\n\tvar saved = [];\n\t\n\t/**\n\t * Save replacer\n\t *\n\t * The save regex can match two possible cases:\n\t * 1. An opening object literal\n\t * 2. A string\n\t * If matched as a plain string, we need to escape its\n\t * newlines, since the string needs to be preserved when\n\t * generating the function body.\n\t *\n\t * @param {String} str\n\t * @param {String} isString - str if matched as a string\n\t * @return {String} - placeholder with index\n\t */\n\t\n\tfunction save(str, isString) {\n\t  var i = saved.length;\n\t  saved[i] = isString ? str.replace(newlineRE, '\\\\n') : str;\n\t  return '\"' + i + '\"';\n\t}\n\t\n\t/**\n\t * Path rewrite replacer\n\t *\n\t * @param {String} raw\n\t * @return {String}\n\t */\n\t\n\tfunction rewrite(raw) {\n\t  var c = raw.charAt(0);\n\t  var path = raw.slice(1);\n\t  if (allowedKeywordsRE.test(path)) {\n\t    return raw;\n\t  } else {\n\t    path = path.indexOf('\"') > -1 ? path.replace(restoreRE, restore) : path;\n\t    return c + 'scope.' + path;\n\t  }\n\t}\n\t\n\t/**\n\t * Restore replacer\n\t *\n\t * @param {String} str\n\t * @param {String} i - matched save index\n\t * @return {String}\n\t */\n\t\n\tfunction restore(str, i) {\n\t  return saved[i];\n\t}\n\t\n\t/**\n\t * Rewrite an expression, prefixing all path accessors with\n\t * `scope.` and generate getter/setter functions.\n\t *\n\t * @param {String} exp\n\t * @return {Function}\n\t */\n\t\n\tfunction compileGetter(exp) {\n\t  if (improperKeywordsRE.test(exp)) {\n\t    (\"production\") !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);\n\t  }\n\t  // reset state\n\t  saved.length = 0;\n\t  // save strings and object literal keys\n\t  var body = exp.replace(saveRE, save).replace(wsRE, '');\n\t  // rewrite all paths\n\t  // pad 1 space here because the regex matches 1 extra char\n\t  body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);\n\t  return makeGetterFn(body);\n\t}\n\t\n\t/**\n\t * Build a getter function. Requires eval.\n\t *\n\t * We isolate the try/catch so it doesn't affect the\n\t * optimization of the parse function when it is not called.\n\t *\n\t * @param {String} body\n\t * @return {Function|undefined}\n\t */\n\t\n\tfunction makeGetterFn(body) {\n\t  try {\n\t    /* eslint-disable no-new-func */\n\t    return new Function('scope', 'return ' + body + ';');\n\t    /* eslint-enable no-new-func */\n\t  } catch (e) {\n\t    if (false) {\n\t      /* istanbul ignore if */\n\t      if (e.toString().match(/unsafe-eval|CSP/)) {\n\t        warn('It seems you are using the default build of Vue.js in an environment ' + 'with Content Security Policy that prohibits unsafe-eval. ' + 'Use the CSP-compliant build instead: ' + 'http://vuejs.org/guide/installation.html#CSP-compliant-build');\n\t      } else {\n\t        warn('Invalid expression. ' + 'Generated function body: ' + body);\n\t      }\n\t    }\n\t    return noop;\n\t  }\n\t}\n\t\n\t/**\n\t * Compile a setter function for the expression.\n\t *\n\t * @param {String} exp\n\t * @return {Function|undefined}\n\t */\n\t\n\tfunction compileSetter(exp) {\n\t  var path = parsePath(exp);\n\t  if (path) {\n\t    return function (scope, val) {\n\t      setPath(scope, path, val);\n\t    };\n\t  } else {\n\t    (\"production\") !== 'production' && warn('Invalid setter expression: ' + exp);\n\t  }\n\t}\n\t\n\t/**\n\t * Parse an expression into re-written getter/setters.\n\t *\n\t * @param {String} exp\n\t * @param {Boolean} needSet\n\t * @return {Function}\n\t */\n\t\n\tfunction parseExpression(exp, needSet) {\n\t  exp = exp.trim();\n\t  // try cache\n\t  var hit = expressionCache.get(exp);\n\t  if (hit) {\n\t    if (needSet && !hit.set) {\n\t      hit.set = compileSetter(hit.exp);\n\t    }\n\t    return hit;\n\t  }\n\t  var res = { exp: exp };\n\t  res.get = isSimplePath(exp) && exp.indexOf('[') < 0\n\t  // optimized super simple getter\n\t  ? makeGetterFn('scope.' + exp)\n\t  // dynamic getter\n\t  : compileGetter(exp);\n\t  if (needSet) {\n\t    res.set = compileSetter(exp);\n\t  }\n\t  expressionCache.put(exp, res);\n\t  return res;\n\t}\n\t\n\t/**\n\t * Check if an expression is a simple path.\n\t *\n\t * @param {String} exp\n\t * @return {Boolean}\n\t */\n\t\n\tfunction isSimplePath(exp) {\n\t  return pathTestRE.test(exp) &&\n\t  // don't treat literal values as paths\n\t  !literalValueRE$1.test(exp) &&\n\t  // Math constants e.g. Math.PI, Math.E etc.\n\t  exp.slice(0, 5) !== 'Math.';\n\t}\n\t\n\tvar expression = Object.freeze({\n\t  parseExpression: parseExpression,\n\t  isSimplePath: isSimplePath\n\t});\n\t\n\t// we have two separate queues: one for directive updates\n\t// and one for user watcher registered via $watch().\n\t// we want to guarantee directive updates to be called\n\t// before user watchers so that when user watchers are\n\t// triggered, the DOM would have already been in updated\n\t// state.\n\t\n\tvar queue = [];\n\tvar userQueue = [];\n\tvar has = {};\n\tvar circular = {};\n\tvar waiting = false;\n\t\n\t/**\n\t * Reset the batcher's state.\n\t */\n\t\n\tfunction resetBatcherState() {\n\t  queue.length = 0;\n\t  userQueue.length = 0;\n\t  has = {};\n\t  circular = {};\n\t  waiting = false;\n\t}\n\t\n\t/**\n\t * Flush both queues and run the watchers.\n\t */\n\t\n\tfunction flushBatcherQueue() {\n\t  var _again = true;\n\t\n\t  _function: while (_again) {\n\t    _again = false;\n\t\n\t    runBatcherQueue(queue);\n\t    runBatcherQueue(userQueue);\n\t    // user watchers triggered more watchers,\n\t    // keep flushing until it depletes\n\t    if (queue.length) {\n\t      _again = true;\n\t      continue _function;\n\t    }\n\t    // dev tool hook\n\t    /* istanbul ignore if */\n\t    if (devtools && config.devtools) {\n\t      devtools.emit('flush');\n\t    }\n\t    resetBatcherState();\n\t  }\n\t}\n\t\n\t/**\n\t * Run the watchers in a single queue.\n\t *\n\t * @param {Array} queue\n\t */\n\t\n\tfunction runBatcherQueue(queue) {\n\t  // do not cache length because more watchers might be pushed\n\t  // as we run existing watchers\n\t  for (var i = 0; i < queue.length; i++) {\n\t    var watcher = queue[i];\n\t    var id = watcher.id;\n\t    has[id] = null;\n\t    watcher.run();\n\t    // in dev build, check and stop circular updates.\n\t    if (false) {\n\t      circular[id] = (circular[id] || 0) + 1;\n\t      if (circular[id] > config._maxUpdateCount) {\n\t        warn('You may have an infinite update loop for watcher ' + 'with expression \"' + watcher.expression + '\"', watcher.vm);\n\t        break;\n\t      }\n\t    }\n\t  }\n\t  queue.length = 0;\n\t}\n\t\n\t/**\n\t * Push a watcher into the watcher queue.\n\t * Jobs with duplicate IDs will be skipped unless it's\n\t * pushed when the queue is being flushed.\n\t *\n\t * @param {Watcher} watcher\n\t *   properties:\n\t *   - {Number} id\n\t *   - {Function} run\n\t */\n\t\n\tfunction pushWatcher(watcher) {\n\t  var id = watcher.id;\n\t  if (has[id] == null) {\n\t    // push watcher into appropriate queue\n\t    var q = watcher.user ? userQueue : queue;\n\t    has[id] = q.length;\n\t    q.push(watcher);\n\t    // queue the flush\n\t    if (!waiting) {\n\t      waiting = true;\n\t      nextTick(flushBatcherQueue);\n\t    }\n\t  }\n\t}\n\t\n\tvar uid$2 = 0;\n\t\n\t/**\n\t * A watcher parses an expression, collects dependencies,\n\t * and fires callback when the expression value changes.\n\t * This is used for both the $watch() api and directives.\n\t *\n\t * @param {Vue} vm\n\t * @param {String|Function} expOrFn\n\t * @param {Function} cb\n\t * @param {Object} options\n\t *                 - {Array} filters\n\t *                 - {Boolean} twoWay\n\t *                 - {Boolean} deep\n\t *                 - {Boolean} user\n\t *                 - {Boolean} sync\n\t *                 - {Boolean} lazy\n\t *                 - {Function} [preProcess]\n\t *                 - {Function} [postProcess]\n\t * @constructor\n\t */\n\tfunction Watcher(vm, expOrFn, cb, options) {\n\t  // mix in options\n\t  if (options) {\n\t    extend(this, options);\n\t  }\n\t  var isFn = typeof expOrFn === 'function';\n\t  this.vm = vm;\n\t  vm._watchers.push(this);\n\t  this.expression = expOrFn;\n\t  this.cb = cb;\n\t  this.id = ++uid$2; // uid for batching\n\t  this.active = true;\n\t  this.dirty = this.lazy; // for lazy watchers\n\t  this.deps = [];\n\t  this.newDeps = [];\n\t  this.depIds = new _Set();\n\t  this.newDepIds = new _Set();\n\t  this.prevError = null; // for async error stacks\n\t  // parse expression for getter/setter\n\t  if (isFn) {\n\t    this.getter = expOrFn;\n\t    this.setter = undefined;\n\t  } else {\n\t    var res = parseExpression(expOrFn, this.twoWay);\n\t    this.getter = res.get;\n\t    this.setter = res.set;\n\t  }\n\t  this.value = this.lazy ? undefined : this.get();\n\t  // state for avoiding false triggers for deep and Array\n\t  // watchers during vm._digest()\n\t  this.queued = this.shallow = false;\n\t}\n\t\n\t/**\n\t * Evaluate the getter, and re-collect dependencies.\n\t */\n\t\n\tWatcher.prototype.get = function () {\n\t  this.beforeGet();\n\t  var scope = this.scope || this.vm;\n\t  var value;\n\t  try {\n\t    value = this.getter.call(scope, scope);\n\t  } catch (e) {\n\t    if (false) {\n\t      warn('Error when evaluating expression ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\n\t    }\n\t  }\n\t  // \"touch\" every property so they are all tracked as\n\t  // dependencies for deep watching\n\t  if (this.deep) {\n\t    traverse(value);\n\t  }\n\t  if (this.preProcess) {\n\t    value = this.preProcess(value);\n\t  }\n\t  if (this.filters) {\n\t    value = scope._applyFilters(value, null, this.filters, false);\n\t  }\n\t  if (this.postProcess) {\n\t    value = this.postProcess(value);\n\t  }\n\t  this.afterGet();\n\t  return value;\n\t};\n\t\n\t/**\n\t * Set the corresponding value with the setter.\n\t *\n\t * @param {*} value\n\t */\n\t\n\tWatcher.prototype.set = function (value) {\n\t  var scope = this.scope || this.vm;\n\t  if (this.filters) {\n\t    value = scope._applyFilters(value, this.value, this.filters, true);\n\t  }\n\t  try {\n\t    this.setter.call(scope, scope, value);\n\t  } catch (e) {\n\t    if (false) {\n\t      warn('Error when evaluating setter ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\n\t    }\n\t  }\n\t  // two-way sync for v-for alias\n\t  var forContext = scope.$forContext;\n\t  if (forContext && forContext.alias === this.expression) {\n\t    if (forContext.filters) {\n\t      (\"production\") !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);\n\t      return;\n\t    }\n\t    forContext._withLock(function () {\n\t      if (scope.$key) {\n\t        // original is an object\n\t        forContext.rawValue[scope.$key] = value;\n\t      } else {\n\t        forContext.rawValue.$set(scope.$index, value);\n\t      }\n\t    });\n\t  }\n\t};\n\t\n\t/**\n\t * Prepare for dependency collection.\n\t */\n\t\n\tWatcher.prototype.beforeGet = function () {\n\t  Dep.target = this;\n\t};\n\t\n\t/**\n\t * Add a dependency to this directive.\n\t *\n\t * @param {Dep} dep\n\t */\n\t\n\tWatcher.prototype.addDep = function (dep) {\n\t  var id = dep.id;\n\t  if (!this.newDepIds.has(id)) {\n\t    this.newDepIds.add(id);\n\t    this.newDeps.push(dep);\n\t    if (!this.depIds.has(id)) {\n\t      dep.addSub(this);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Clean up for dependency collection.\n\t */\n\t\n\tWatcher.prototype.afterGet = function () {\n\t  Dep.target = null;\n\t  var i = this.deps.length;\n\t  while (i--) {\n\t    var dep = this.deps[i];\n\t    if (!this.newDepIds.has(dep.id)) {\n\t      dep.removeSub(this);\n\t    }\n\t  }\n\t  var tmp = this.depIds;\n\t  this.depIds = this.newDepIds;\n\t  this.newDepIds = tmp;\n\t  this.newDepIds.clear();\n\t  tmp = this.deps;\n\t  this.deps = this.newDeps;\n\t  this.newDeps = tmp;\n\t  this.newDeps.length = 0;\n\t};\n\t\n\t/**\n\t * Subscriber interface.\n\t * Will be called when a dependency changes.\n\t *\n\t * @param {Boolean} shallow\n\t */\n\t\n\tWatcher.prototype.update = function (shallow) {\n\t  if (this.lazy) {\n\t    this.dirty = true;\n\t  } else if (this.sync || !config.async) {\n\t    this.run();\n\t  } else {\n\t    // if queued, only overwrite shallow with non-shallow,\n\t    // but not the other way around.\n\t    this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;\n\t    this.queued = true;\n\t    // record before-push error stack in debug mode\n\t    /* istanbul ignore if */\n\t    if (false) {\n\t      this.prevError = new Error('[vue] async stack trace');\n\t    }\n\t    pushWatcher(this);\n\t  }\n\t};\n\t\n\t/**\n\t * Batcher job interface.\n\t * Will be called by the batcher.\n\t */\n\t\n\tWatcher.prototype.run = function () {\n\t  if (this.active) {\n\t    var value = this.get();\n\t    if (value !== this.value ||\n\t    // Deep watchers and watchers on Object/Arrays should fire even\n\t    // when the value is the same, because the value may\n\t    // have mutated; but only do so if this is a\n\t    // non-shallow update (caused by a vm digest).\n\t    (isObject(value) || this.deep) && !this.shallow) {\n\t      // set new value\n\t      var oldValue = this.value;\n\t      this.value = value;\n\t      // in debug + async mode, when a watcher callbacks\n\t      // throws, we also throw the saved before-push error\n\t      // so the full cross-tick stack trace is available.\n\t      var prevError = this.prevError;\n\t      /* istanbul ignore if */\n\t      if (false) {\n\t        this.prevError = null;\n\t        try {\n\t          this.cb.call(this.vm, value, oldValue);\n\t        } catch (e) {\n\t          nextTick(function () {\n\t            throw prevError;\n\t          }, 0);\n\t          throw e;\n\t        }\n\t      } else {\n\t        this.cb.call(this.vm, value, oldValue);\n\t      }\n\t    }\n\t    this.queued = this.shallow = false;\n\t  }\n\t};\n\t\n\t/**\n\t * Evaluate the value of the watcher.\n\t * This only gets called for lazy watchers.\n\t */\n\t\n\tWatcher.prototype.evaluate = function () {\n\t  // avoid overwriting another watcher that is being\n\t  // collected.\n\t  var current = Dep.target;\n\t  this.value = this.get();\n\t  this.dirty = false;\n\t  Dep.target = current;\n\t};\n\t\n\t/**\n\t * Depend on all deps collected by this watcher.\n\t */\n\t\n\tWatcher.prototype.depend = function () {\n\t  var i = this.deps.length;\n\t  while (i--) {\n\t    this.deps[i].depend();\n\t  }\n\t};\n\t\n\t/**\n\t * Remove self from all dependencies' subcriber list.\n\t */\n\t\n\tWatcher.prototype.teardown = function () {\n\t  if (this.active) {\n\t    // remove self from vm's watcher list\n\t    // this is a somewhat expensive operation so we skip it\n\t    // if the vm is being destroyed or is performing a v-for\n\t    // re-render (the watcher list is then filtered by v-for).\n\t    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {\n\t      this.vm._watchers.$remove(this);\n\t    }\n\t    var i = this.deps.length;\n\t    while (i--) {\n\t      this.deps[i].removeSub(this);\n\t    }\n\t    this.active = false;\n\t    this.vm = this.cb = this.value = null;\n\t  }\n\t};\n\t\n\t/**\n\t * Recrusively traverse an object to evoke all converted\n\t * getters, so that every nested property inside the object\n\t * is collected as a \"deep\" dependency.\n\t *\n\t * @param {*} val\n\t */\n\t\n\tvar seenObjects = new _Set();\n\tfunction traverse(val, seen) {\n\t  var i = undefined,\n\t      keys = undefined;\n\t  if (!seen) {\n\t    seen = seenObjects;\n\t    seen.clear();\n\t  }\n\t  var isA = isArray(val);\n\t  var isO = isObject(val);\n\t  if ((isA || isO) && Object.isExtensible(val)) {\n\t    if (val.__ob__) {\n\t      var depId = val.__ob__.dep.id;\n\t      if (seen.has(depId)) {\n\t        return;\n\t      } else {\n\t        seen.add(depId);\n\t      }\n\t    }\n\t    if (isA) {\n\t      i = val.length;\n\t      while (i--) traverse(val[i], seen);\n\t    } else if (isO) {\n\t      keys = Object.keys(val);\n\t      i = keys.length;\n\t      while (i--) traverse(val[keys[i]], seen);\n\t    }\n\t  }\n\t}\n\t\n\tvar text$1 = {\n\t\n\t  bind: function bind() {\n\t    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';\n\t  },\n\t\n\t  update: function update(value) {\n\t    this.el[this.attr] = _toString(value);\n\t  }\n\t};\n\t\n\tvar templateCache = new Cache(1000);\n\tvar idSelectorCache = new Cache(1000);\n\t\n\tvar map = {\n\t  efault: [0, '', ''],\n\t  legend: [1, '<fieldset>', '</fieldset>'],\n\t  tr: [2, '<table><tbody>', '</tbody></table>'],\n\t  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']\n\t};\n\t\n\tmap.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\n\t\n\tmap.option = map.optgroup = [1, '<select multiple=\"multiple\">', '</select>'];\n\t\n\tmap.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];\n\t\n\tmap.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns=\"http://www.w3.org/2000/svg\" ' + 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' + 'xmlns:ev=\"http://www.w3.org/2001/xml-events\"' + 'version=\"1.1\">', '</svg>'];\n\t\n\t/**\n\t * Check if a node is a supported template node with a\n\t * DocumentFragment content.\n\t *\n\t * @param {Node} node\n\t * @return {Boolean}\n\t */\n\t\n\tfunction isRealTemplate(node) {\n\t  return isTemplate(node) && isFragment(node.content);\n\t}\n\t\n\tvar tagRE$1 = /<([\\w:-]+)/;\n\tvar entityRE = /&#?\\w+?;/;\n\tvar commentRE = /<!--/;\n\t\n\t/**\n\t * Convert a string template to a DocumentFragment.\n\t * Determines correct wrapping by tag types. Wrapping\n\t * strategy found in jQuery & component/domify.\n\t *\n\t * @param {String} templateString\n\t * @param {Boolean} raw\n\t * @return {DocumentFragment}\n\t */\n\t\n\tfunction stringToFragment(templateString, raw) {\n\t  // try a cache hit first\n\t  var cacheKey = raw ? templateString : templateString.trim();\n\t  var hit = templateCache.get(cacheKey);\n\t  if (hit) {\n\t    return hit;\n\t  }\n\t\n\t  var frag = document.createDocumentFragment();\n\t  var tagMatch = templateString.match(tagRE$1);\n\t  var entityMatch = entityRE.test(templateString);\n\t  var commentMatch = commentRE.test(templateString);\n\t\n\t  if (!tagMatch && !entityMatch && !commentMatch) {\n\t    // text only, return a single text node.\n\t    frag.appendChild(document.createTextNode(templateString));\n\t  } else {\n\t    var tag = tagMatch && tagMatch[1];\n\t    var wrap = map[tag] || map.efault;\n\t    var depth = wrap[0];\n\t    var prefix = wrap[1];\n\t    var suffix = wrap[2];\n\t    var node = document.createElement('div');\n\t\n\t    node.innerHTML = prefix + templateString + suffix;\n\t    while (depth--) {\n\t      node = node.lastChild;\n\t    }\n\t\n\t    var child;\n\t    /* eslint-disable no-cond-assign */\n\t    while (child = node.firstChild) {\n\t      /* eslint-enable no-cond-assign */\n\t      frag.appendChild(child);\n\t    }\n\t  }\n\t  if (!raw) {\n\t    trimNode(frag);\n\t  }\n\t  templateCache.put(cacheKey, frag);\n\t  return frag;\n\t}\n\t\n\t/**\n\t * Convert a template node to a DocumentFragment.\n\t *\n\t * @param {Node} node\n\t * @return {DocumentFragment}\n\t */\n\t\n\tfunction nodeToFragment(node) {\n\t  // if its a template tag and the browser supports it,\n\t  // its content is already a document fragment. However, iOS Safari has\n\t  // bug when using directly cloned template content with touch\n\t  // events and can cause crashes when the nodes are removed from DOM, so we\n\t  // have to treat template elements as string templates. (#2805)\n\t  /* istanbul ignore if */\n\t  if (isRealTemplate(node)) {\n\t    return stringToFragment(node.innerHTML);\n\t  }\n\t  // script template\n\t  if (node.tagName === 'SCRIPT') {\n\t    return stringToFragment(node.textContent);\n\t  }\n\t  // normal node, clone it to avoid mutating the original\n\t  var clonedNode = cloneNode(node);\n\t  var frag = document.createDocumentFragment();\n\t  var child;\n\t  /* eslint-disable no-cond-assign */\n\t  while (child = clonedNode.firstChild) {\n\t    /* eslint-enable no-cond-assign */\n\t    frag.appendChild(child);\n\t  }\n\t  trimNode(frag);\n\t  return frag;\n\t}\n\t\n\t// Test for the presence of the Safari template cloning bug\n\t// https://bugs.webkit.org/showug.cgi?id=137755\n\tvar hasBrokenTemplate = (function () {\n\t  /* istanbul ignore else */\n\t  if (inBrowser) {\n\t    var a = document.createElement('div');\n\t    a.innerHTML = '<template>1</template>';\n\t    return !a.cloneNode(true).firstChild.innerHTML;\n\t  } else {\n\t    return false;\n\t  }\n\t})();\n\t\n\t// Test for IE10/11 textarea placeholder clone bug\n\tvar hasTextareaCloneBug = (function () {\n\t  /* istanbul ignore else */\n\t  if (inBrowser) {\n\t    var t = document.createElement('textarea');\n\t    t.placeholder = 't';\n\t    return t.cloneNode(true).value === 't';\n\t  } else {\n\t    return false;\n\t  }\n\t})();\n\t\n\t/**\n\t * 1. Deal with Safari cloning nested <template> bug by\n\t *    manually cloning all template instances.\n\t * 2. Deal with IE10/11 textarea placeholder bug by setting\n\t *    the correct value after cloning.\n\t *\n\t * @param {Element|DocumentFragment} node\n\t * @return {Element|DocumentFragment}\n\t */\n\t\n\tfunction cloneNode(node) {\n\t  /* istanbul ignore if */\n\t  if (!node.querySelectorAll) {\n\t    return node.cloneNode();\n\t  }\n\t  var res = node.cloneNode(true);\n\t  var i, original, cloned;\n\t  /* istanbul ignore if */\n\t  if (hasBrokenTemplate) {\n\t    var tempClone = res;\n\t    if (isRealTemplate(node)) {\n\t      node = node.content;\n\t      tempClone = res.content;\n\t    }\n\t    original = node.querySelectorAll('template');\n\t    if (original.length) {\n\t      cloned = tempClone.querySelectorAll('template');\n\t      i = cloned.length;\n\t      while (i--) {\n\t        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);\n\t      }\n\t    }\n\t  }\n\t  /* istanbul ignore if */\n\t  if (hasTextareaCloneBug) {\n\t    if (node.tagName === 'TEXTAREA') {\n\t      res.value = node.value;\n\t    } else {\n\t      original = node.querySelectorAll('textarea');\n\t      if (original.length) {\n\t        cloned = res.querySelectorAll('textarea');\n\t        i = cloned.length;\n\t        while (i--) {\n\t          cloned[i].value = original[i].value;\n\t        }\n\t      }\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\t/**\n\t * Process the template option and normalizes it into a\n\t * a DocumentFragment that can be used as a partial or a\n\t * instance template.\n\t *\n\t * @param {*} template\n\t *        Possible values include:\n\t *        - DocumentFragment object\n\t *        - Node object of type Template\n\t *        - id selector: '#some-template-id'\n\t *        - template string: '<div><span>{{msg}}</span></div>'\n\t * @param {Boolean} shouldClone\n\t * @param {Boolean} raw\n\t *        inline HTML interpolation. Do not check for id\n\t *        selector and keep whitespace in the string.\n\t * @return {DocumentFragment|undefined}\n\t */\n\t\n\tfunction parseTemplate(template, shouldClone, raw) {\n\t  var node, frag;\n\t\n\t  // if the template is already a document fragment,\n\t  // do nothing\n\t  if (isFragment(template)) {\n\t    trimNode(template);\n\t    return shouldClone ? cloneNode(template) : template;\n\t  }\n\t\n\t  if (typeof template === 'string') {\n\t    // id selector\n\t    if (!raw && template.charAt(0) === '#') {\n\t      // id selector can be cached too\n\t      frag = idSelectorCache.get(template);\n\t      if (!frag) {\n\t        node = document.getElementById(template.slice(1));\n\t        if (node) {\n\t          frag = nodeToFragment(node);\n\t          // save selector to cache\n\t          idSelectorCache.put(template, frag);\n\t        }\n\t      }\n\t    } else {\n\t      // normal string template\n\t      frag = stringToFragment(template, raw);\n\t    }\n\t  } else if (template.nodeType) {\n\t    // a direct node\n\t    frag = nodeToFragment(template);\n\t  }\n\t\n\t  return frag && shouldClone ? cloneNode(frag) : frag;\n\t}\n\t\n\tvar template = Object.freeze({\n\t  cloneNode: cloneNode,\n\t  parseTemplate: parseTemplate\n\t});\n\t\n\tvar html = {\n\t\n\t  bind: function bind() {\n\t    // a comment node means this is a binding for\n\t    // {{{ inline unescaped html }}}\n\t    if (this.el.nodeType === 8) {\n\t      // hold nodes\n\t      this.nodes = [];\n\t      // replace the placeholder with proper anchor\n\t      this.anchor = createAnchor('v-html');\n\t      replace(this.el, this.anchor);\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    value = _toString(value);\n\t    if (this.nodes) {\n\t      this.swap(value);\n\t    } else {\n\t      this.el.innerHTML = value;\n\t    }\n\t  },\n\t\n\t  swap: function swap(value) {\n\t    // remove old nodes\n\t    var i = this.nodes.length;\n\t    while (i--) {\n\t      remove(this.nodes[i]);\n\t    }\n\t    // convert new value to a fragment\n\t    // do not attempt to retrieve from id selector\n\t    var frag = parseTemplate(value, true, true);\n\t    // save a reference to these nodes so we can remove later\n\t    this.nodes = toArray(frag.childNodes);\n\t    before(frag, this.anchor);\n\t  }\n\t};\n\t\n\t/**\n\t * Abstraction for a partially-compiled fragment.\n\t * Can optionally compile content with a child scope.\n\t *\n\t * @param {Function} linker\n\t * @param {Vue} vm\n\t * @param {DocumentFragment} frag\n\t * @param {Vue} [host]\n\t * @param {Object} [scope]\n\t * @param {Fragment} [parentFrag]\n\t */\n\tfunction Fragment(linker, vm, frag, host, scope, parentFrag) {\n\t  this.children = [];\n\t  this.childFrags = [];\n\t  this.vm = vm;\n\t  this.scope = scope;\n\t  this.inserted = false;\n\t  this.parentFrag = parentFrag;\n\t  if (parentFrag) {\n\t    parentFrag.childFrags.push(this);\n\t  }\n\t  this.unlink = linker(vm, frag, host, scope, this);\n\t  var single = this.single = frag.childNodes.length === 1 &&\n\t  // do not go single mode if the only node is an anchor\n\t  !frag.childNodes[0].__v_anchor;\n\t  if (single) {\n\t    this.node = frag.childNodes[0];\n\t    this.before = singleBefore;\n\t    this.remove = singleRemove;\n\t  } else {\n\t    this.node = createAnchor('fragment-start');\n\t    this.end = createAnchor('fragment-end');\n\t    this.frag = frag;\n\t    prepend(this.node, frag);\n\t    frag.appendChild(this.end);\n\t    this.before = multiBefore;\n\t    this.remove = multiRemove;\n\t  }\n\t  this.node.__v_frag = this;\n\t}\n\t\n\t/**\n\t * Call attach/detach for all components contained within\n\t * this fragment. Also do so recursively for all child\n\t * fragments.\n\t *\n\t * @param {Function} hook\n\t */\n\t\n\tFragment.prototype.callHook = function (hook) {\n\t  var i, l;\n\t  for (i = 0, l = this.childFrags.length; i < l; i++) {\n\t    this.childFrags[i].callHook(hook);\n\t  }\n\t  for (i = 0, l = this.children.length; i < l; i++) {\n\t    hook(this.children[i]);\n\t  }\n\t};\n\t\n\t/**\n\t * Insert fragment before target, single node version\n\t *\n\t * @param {Node} target\n\t * @param {Boolean} withTransition\n\t */\n\t\n\tfunction singleBefore(target, withTransition) {\n\t  this.inserted = true;\n\t  var method = withTransition !== false ? beforeWithTransition : before;\n\t  method(this.node, target, this.vm);\n\t  if (inDoc(this.node)) {\n\t    this.callHook(attach);\n\t  }\n\t}\n\t\n\t/**\n\t * Remove fragment, single node version\n\t */\n\t\n\tfunction singleRemove() {\n\t  this.inserted = false;\n\t  var shouldCallRemove = inDoc(this.node);\n\t  var self = this;\n\t  this.beforeRemove();\n\t  removeWithTransition(this.node, this.vm, function () {\n\t    if (shouldCallRemove) {\n\t      self.callHook(detach);\n\t    }\n\t    self.destroy();\n\t  });\n\t}\n\t\n\t/**\n\t * Insert fragment before target, multi-nodes version\n\t *\n\t * @param {Node} target\n\t * @param {Boolean} withTransition\n\t */\n\t\n\tfunction multiBefore(target, withTransition) {\n\t  this.inserted = true;\n\t  var vm = this.vm;\n\t  var method = withTransition !== false ? beforeWithTransition : before;\n\t  mapNodeRange(this.node, this.end, function (node) {\n\t    method(node, target, vm);\n\t  });\n\t  if (inDoc(this.node)) {\n\t    this.callHook(attach);\n\t  }\n\t}\n\t\n\t/**\n\t * Remove fragment, multi-nodes version\n\t */\n\t\n\tfunction multiRemove() {\n\t  this.inserted = false;\n\t  var self = this;\n\t  var shouldCallRemove = inDoc(this.node);\n\t  this.beforeRemove();\n\t  removeNodeRange(this.node, this.end, this.vm, this.frag, function () {\n\t    if (shouldCallRemove) {\n\t      self.callHook(detach);\n\t    }\n\t    self.destroy();\n\t  });\n\t}\n\t\n\t/**\n\t * Prepare the fragment for removal.\n\t */\n\t\n\tFragment.prototype.beforeRemove = function () {\n\t  var i, l;\n\t  for (i = 0, l = this.childFrags.length; i < l; i++) {\n\t    // call the same method recursively on child\n\t    // fragments, depth-first\n\t    this.childFrags[i].beforeRemove(false);\n\t  }\n\t  for (i = 0, l = this.children.length; i < l; i++) {\n\t    // Call destroy for all contained instances,\n\t    // with remove:false and defer:true.\n\t    // Defer is necessary because we need to\n\t    // keep the children to call detach hooks\n\t    // on them.\n\t    this.children[i].$destroy(false, true);\n\t  }\n\t  var dirs = this.unlink.dirs;\n\t  for (i = 0, l = dirs.length; i < l; i++) {\n\t    // disable the watchers on all the directives\n\t    // so that the rendered content stays the same\n\t    // during removal.\n\t    dirs[i]._watcher && dirs[i]._watcher.teardown();\n\t  }\n\t};\n\t\n\t/**\n\t * Destroy the fragment.\n\t */\n\t\n\tFragment.prototype.destroy = function () {\n\t  if (this.parentFrag) {\n\t    this.parentFrag.childFrags.$remove(this);\n\t  }\n\t  this.node.__v_frag = null;\n\t  this.unlink();\n\t};\n\t\n\t/**\n\t * Call attach hook for a Vue instance.\n\t *\n\t * @param {Vue} child\n\t */\n\t\n\tfunction attach(child) {\n\t  if (!child._isAttached && inDoc(child.$el)) {\n\t    child._callHook('attached');\n\t  }\n\t}\n\t\n\t/**\n\t * Call detach hook for a Vue instance.\n\t *\n\t * @param {Vue} child\n\t */\n\t\n\tfunction detach(child) {\n\t  if (child._isAttached && !inDoc(child.$el)) {\n\t    child._callHook('detached');\n\t  }\n\t}\n\t\n\tvar linkerCache = new Cache(5000);\n\t\n\t/**\n\t * A factory that can be used to create instances of a\n\t * fragment. Caches the compiled linker if possible.\n\t *\n\t * @param {Vue} vm\n\t * @param {Element|String} el\n\t */\n\tfunction FragmentFactory(vm, el) {\n\t  this.vm = vm;\n\t  var template;\n\t  var isString = typeof el === 'string';\n\t  if (isString || isTemplate(el) && !el.hasAttribute('v-if')) {\n\t    template = parseTemplate(el, true);\n\t  } else {\n\t    template = document.createDocumentFragment();\n\t    template.appendChild(el);\n\t  }\n\t  this.template = template;\n\t  // linker can be cached, but only for components\n\t  var linker;\n\t  var cid = vm.constructor.cid;\n\t  if (cid > 0) {\n\t    var cacheId = cid + (isString ? el : getOuterHTML(el));\n\t    linker = linkerCache.get(cacheId);\n\t    if (!linker) {\n\t      linker = compile(template, vm.$options, true);\n\t      linkerCache.put(cacheId, linker);\n\t    }\n\t  } else {\n\t    linker = compile(template, vm.$options, true);\n\t  }\n\t  this.linker = linker;\n\t}\n\t\n\t/**\n\t * Create a fragment instance with given host and scope.\n\t *\n\t * @param {Vue} host\n\t * @param {Object} scope\n\t * @param {Fragment} parentFrag\n\t */\n\t\n\tFragmentFactory.prototype.create = function (host, scope, parentFrag) {\n\t  var frag = cloneNode(this.template);\n\t  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);\n\t};\n\t\n\tvar ON = 700;\n\tvar MODEL = 800;\n\tvar BIND = 850;\n\tvar TRANSITION = 1100;\n\tvar EL = 1500;\n\tvar COMPONENT = 1500;\n\tvar PARTIAL = 1750;\n\tvar IF = 2100;\n\tvar FOR = 2200;\n\tvar SLOT = 2300;\n\t\n\tvar uid$3 = 0;\n\t\n\tvar vFor = {\n\t\n\t  priority: FOR,\n\t  terminal: true,\n\t\n\t  params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],\n\t\n\t  bind: function bind() {\n\t    // support \"item in/of items\" syntax\n\t    var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);\n\t    if (inMatch) {\n\t      var itMatch = inMatch[1].match(/\\((.*),(.*)\\)/);\n\t      if (itMatch) {\n\t        this.iterator = itMatch[1].trim();\n\t        this.alias = itMatch[2].trim();\n\t      } else {\n\t        this.alias = inMatch[1].trim();\n\t      }\n\t      this.expression = inMatch[2];\n\t    }\n\t\n\t    if (!this.alias) {\n\t      (\"production\") !== 'production' && warn('Invalid v-for expression \"' + this.descriptor.raw + '\": ' + 'alias is required.', this.vm);\n\t      return;\n\t    }\n\t\n\t    // uid as a cache identifier\n\t    this.id = '__v-for__' + ++uid$3;\n\t\n\t    // check if this is an option list,\n\t    // so that we know if we need to update the <select>'s\n\t    // v-model when the option list has changed.\n\t    // because v-model has a lower priority than v-for,\n\t    // the v-model is not bound here yet, so we have to\n\t    // retrive it in the actual updateModel() function.\n\t    var tag = this.el.tagName;\n\t    this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';\n\t\n\t    // setup anchor nodes\n\t    this.start = createAnchor('v-for-start');\n\t    this.end = createAnchor('v-for-end');\n\t    replace(this.el, this.end);\n\t    before(this.start, this.end);\n\t\n\t    // cache\n\t    this.cache = Object.create(null);\n\t\n\t    // fragment factory\n\t    this.factory = new FragmentFactory(this.vm, this.el);\n\t  },\n\t\n\t  update: function update(data) {\n\t    this.diff(data);\n\t    this.updateRef();\n\t    this.updateModel();\n\t  },\n\t\n\t  /**\n\t   * Diff, based on new data and old data, determine the\n\t   * minimum amount of DOM manipulations needed to make the\n\t   * DOM reflect the new data Array.\n\t   *\n\t   * The algorithm diffs the new data Array by storing a\n\t   * hidden reference to an owner vm instance on previously\n\t   * seen data. This allows us to achieve O(n) which is\n\t   * better than a levenshtein distance based algorithm,\n\t   * which is O(m * n).\n\t   *\n\t   * @param {Array} data\n\t   */\n\t\n\t  diff: function diff(data) {\n\t    // check if the Array was converted from an Object\n\t    var item = data[0];\n\t    var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');\n\t\n\t    var trackByKey = this.params.trackBy;\n\t    var oldFrags = this.frags;\n\t    var frags = this.frags = new Array(data.length);\n\t    var alias = this.alias;\n\t    var iterator = this.iterator;\n\t    var start = this.start;\n\t    var end = this.end;\n\t    var inDocument = inDoc(start);\n\t    var init = !oldFrags;\n\t    var i, l, frag, key, value, primitive;\n\t\n\t    // First pass, go through the new Array and fill up\n\t    // the new frags array. If a piece of data has a cached\n\t    // instance for it, we reuse it. Otherwise build a new\n\t    // instance.\n\t    for (i = 0, l = data.length; i < l; i++) {\n\t      item = data[i];\n\t      key = convertedFromObject ? item.$key : null;\n\t      value = convertedFromObject ? item.$value : item;\n\t      primitive = !isObject(value);\n\t      frag = !init && this.getCachedFrag(value, i, key);\n\t      if (frag) {\n\t        // reusable fragment\n\t        frag.reused = true;\n\t        // update $index\n\t        frag.scope.$index = i;\n\t        // update $key\n\t        if (key) {\n\t          frag.scope.$key = key;\n\t        }\n\t        // update iterator\n\t        if (iterator) {\n\t          frag.scope[iterator] = key !== null ? key : i;\n\t        }\n\t        // update data for track-by, object repeat &\n\t        // primitive values.\n\t        if (trackByKey || convertedFromObject || primitive) {\n\t          withoutConversion(function () {\n\t            frag.scope[alias] = value;\n\t          });\n\t        }\n\t      } else {\n\t        // new isntance\n\t        frag = this.create(value, alias, i, key);\n\t        frag.fresh = !init;\n\t      }\n\t      frags[i] = frag;\n\t      if (init) {\n\t        frag.before(end);\n\t      }\n\t    }\n\t\n\t    // we're done for the initial render.\n\t    if (init) {\n\t      return;\n\t    }\n\t\n\t    // Second pass, go through the old fragments and\n\t    // destroy those who are not reused (and remove them\n\t    // from cache)\n\t    var removalIndex = 0;\n\t    var totalRemoved = oldFrags.length - frags.length;\n\t    // when removing a large number of fragments, watcher removal\n\t    // turns out to be a perf bottleneck, so we batch the watcher\n\t    // removals into a single filter call!\n\t    this.vm._vForRemoving = true;\n\t    for (i = 0, l = oldFrags.length; i < l; i++) {\n\t      frag = oldFrags[i];\n\t      if (!frag.reused) {\n\t        this.deleteCachedFrag(frag);\n\t        this.remove(frag, removalIndex++, totalRemoved, inDocument);\n\t      }\n\t    }\n\t    this.vm._vForRemoving = false;\n\t    if (removalIndex) {\n\t      this.vm._watchers = this.vm._watchers.filter(function (w) {\n\t        return w.active;\n\t      });\n\t    }\n\t\n\t    // Final pass, move/insert new fragments into the\n\t    // right place.\n\t    var targetPrev, prevEl, currentPrev;\n\t    var insertionIndex = 0;\n\t    for (i = 0, l = frags.length; i < l; i++) {\n\t      frag = frags[i];\n\t      // this is the frag that we should be after\n\t      targetPrev = frags[i - 1];\n\t      prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;\n\t      if (frag.reused && !frag.staggerCb) {\n\t        currentPrev = findPrevFrag(frag, start, this.id);\n\t        if (currentPrev !== targetPrev && (!currentPrev ||\n\t        // optimization for moving a single item.\n\t        // thanks to suggestions by @livoras in #1807\n\t        findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {\n\t          this.move(frag, prevEl);\n\t        }\n\t      } else {\n\t        // new instance, or still in stagger.\n\t        // insert with updated stagger index.\n\t        this.insert(frag, insertionIndex++, prevEl, inDocument);\n\t      }\n\t      frag.reused = frag.fresh = false;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Create a new fragment instance.\n\t   *\n\t   * @param {*} value\n\t   * @param {String} alias\n\t   * @param {Number} index\n\t   * @param {String} [key]\n\t   * @return {Fragment}\n\t   */\n\t\n\t  create: function create(value, alias, index, key) {\n\t    var host = this._host;\n\t    // create iteration scope\n\t    var parentScope = this._scope || this.vm;\n\t    var scope = Object.create(parentScope);\n\t    // ref holder for the scope\n\t    scope.$refs = Object.create(parentScope.$refs);\n\t    scope.$els = Object.create(parentScope.$els);\n\t    // make sure point $parent to parent scope\n\t    scope.$parent = parentScope;\n\t    // for two-way binding on alias\n\t    scope.$forContext = this;\n\t    // define scope properties\n\t    // important: define the scope alias without forced conversion\n\t    // so that frozen data structures remain non-reactive.\n\t    withoutConversion(function () {\n\t      defineReactive(scope, alias, value);\n\t    });\n\t    defineReactive(scope, '$index', index);\n\t    if (key) {\n\t      defineReactive(scope, '$key', key);\n\t    } else if (scope.$key) {\n\t      // avoid accidental fallback\n\t      def(scope, '$key', null);\n\t    }\n\t    if (this.iterator) {\n\t      defineReactive(scope, this.iterator, key !== null ? key : index);\n\t    }\n\t    var frag = this.factory.create(host, scope, this._frag);\n\t    frag.forId = this.id;\n\t    this.cacheFrag(value, frag, index, key);\n\t    return frag;\n\t  },\n\t\n\t  /**\n\t   * Update the v-ref on owner vm.\n\t   */\n\t\n\t  updateRef: function updateRef() {\n\t    var ref = this.descriptor.ref;\n\t    if (!ref) return;\n\t    var hash = (this._scope || this.vm).$refs;\n\t    var refs;\n\t    if (!this.fromObject) {\n\t      refs = this.frags.map(findVmFromFrag);\n\t    } else {\n\t      refs = {};\n\t      this.frags.forEach(function (frag) {\n\t        refs[frag.scope.$key] = findVmFromFrag(frag);\n\t      });\n\t    }\n\t    hash[ref] = refs;\n\t  },\n\t\n\t  /**\n\t   * For option lists, update the containing v-model on\n\t   * parent <select>.\n\t   */\n\t\n\t  updateModel: function updateModel() {\n\t    if (this.isOption) {\n\t      var parent = this.start.parentNode;\n\t      var model = parent && parent.__v_model;\n\t      if (model) {\n\t        model.forceUpdate();\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Insert a fragment. Handles staggering.\n\t   *\n\t   * @param {Fragment} frag\n\t   * @param {Number} index\n\t   * @param {Node} prevEl\n\t   * @param {Boolean} inDocument\n\t   */\n\t\n\t  insert: function insert(frag, index, prevEl, inDocument) {\n\t    if (frag.staggerCb) {\n\t      frag.staggerCb.cancel();\n\t      frag.staggerCb = null;\n\t    }\n\t    var staggerAmount = this.getStagger(frag, index, null, 'enter');\n\t    if (inDocument && staggerAmount) {\n\t      // create an anchor and insert it synchronously,\n\t      // so that we can resolve the correct order without\n\t      // worrying about some elements not inserted yet\n\t      var anchor = frag.staggerAnchor;\n\t      if (!anchor) {\n\t        anchor = frag.staggerAnchor = createAnchor('stagger-anchor');\n\t        anchor.__v_frag = frag;\n\t      }\n\t      after(anchor, prevEl);\n\t      var op = frag.staggerCb = cancellable(function () {\n\t        frag.staggerCb = null;\n\t        frag.before(anchor);\n\t        remove(anchor);\n\t      });\n\t      setTimeout(op, staggerAmount);\n\t    } else {\n\t      var target = prevEl.nextSibling;\n\t      /* istanbul ignore if */\n\t      if (!target) {\n\t        // reset end anchor position in case the position was messed up\n\t        // by an external drag-n-drop library.\n\t        after(this.end, prevEl);\n\t        target = this.end;\n\t      }\n\t      frag.before(target);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Remove a fragment. Handles staggering.\n\t   *\n\t   * @param {Fragment} frag\n\t   * @param {Number} index\n\t   * @param {Number} total\n\t   * @param {Boolean} inDocument\n\t   */\n\t\n\t  remove: function remove(frag, index, total, inDocument) {\n\t    if (frag.staggerCb) {\n\t      frag.staggerCb.cancel();\n\t      frag.staggerCb = null;\n\t      // it's not possible for the same frag to be removed\n\t      // twice, so if we have a pending stagger callback,\n\t      // it means this frag is queued for enter but removed\n\t      // before its transition started. Since it is already\n\t      // destroyed, we can just leave it in detached state.\n\t      return;\n\t    }\n\t    var staggerAmount = this.getStagger(frag, index, total, 'leave');\n\t    if (inDocument && staggerAmount) {\n\t      var op = frag.staggerCb = cancellable(function () {\n\t        frag.staggerCb = null;\n\t        frag.remove();\n\t      });\n\t      setTimeout(op, staggerAmount);\n\t    } else {\n\t      frag.remove();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Move a fragment to a new position.\n\t   * Force no transition.\n\t   *\n\t   * @param {Fragment} frag\n\t   * @param {Node} prevEl\n\t   */\n\t\n\t  move: function move(frag, prevEl) {\n\t    // fix a common issue with Sortable:\n\t    // if prevEl doesn't have nextSibling, this means it's\n\t    // been dragged after the end anchor. Just re-position\n\t    // the end anchor to the end of the container.\n\t    /* istanbul ignore if */\n\t    if (!prevEl.nextSibling) {\n\t      this.end.parentNode.appendChild(this.end);\n\t    }\n\t    frag.before(prevEl.nextSibling, false);\n\t  },\n\t\n\t  /**\n\t   * Cache a fragment using track-by or the object key.\n\t   *\n\t   * @param {*} value\n\t   * @param {Fragment} frag\n\t   * @param {Number} index\n\t   * @param {String} [key]\n\t   */\n\t\n\t  cacheFrag: function cacheFrag(value, frag, index, key) {\n\t    var trackByKey = this.params.trackBy;\n\t    var cache = this.cache;\n\t    var primitive = !isObject(value);\n\t    var id;\n\t    if (key || trackByKey || primitive) {\n\t      id = getTrackByKey(index, key, value, trackByKey);\n\t      if (!cache[id]) {\n\t        cache[id] = frag;\n\t      } else if (trackByKey !== '$index') {\n\t        (\"production\") !== 'production' && this.warnDuplicate(value);\n\t      }\n\t    } else {\n\t      id = this.id;\n\t      if (hasOwn(value, id)) {\n\t        if (value[id] === null) {\n\t          value[id] = frag;\n\t        } else {\n\t          (\"production\") !== 'production' && this.warnDuplicate(value);\n\t        }\n\t      } else if (Object.isExtensible(value)) {\n\t        def(value, id, frag);\n\t      } else if (false) {\n\t        warn('Frozen v-for objects cannot be automatically tracked, make sure to ' + 'provide a track-by key.');\n\t      }\n\t    }\n\t    frag.raw = value;\n\t  },\n\t\n\t  /**\n\t   * Get a cached fragment from the value/index/key\n\t   *\n\t   * @param {*} value\n\t   * @param {Number} index\n\t   * @param {String} key\n\t   * @return {Fragment}\n\t   */\n\t\n\t  getCachedFrag: function getCachedFrag(value, index, key) {\n\t    var trackByKey = this.params.trackBy;\n\t    var primitive = !isObject(value);\n\t    var frag;\n\t    if (key || trackByKey || primitive) {\n\t      var id = getTrackByKey(index, key, value, trackByKey);\n\t      frag = this.cache[id];\n\t    } else {\n\t      frag = value[this.id];\n\t    }\n\t    if (frag && (frag.reused || frag.fresh)) {\n\t      (\"production\") !== 'production' && this.warnDuplicate(value);\n\t    }\n\t    return frag;\n\t  },\n\t\n\t  /**\n\t   * Delete a fragment from cache.\n\t   *\n\t   * @param {Fragment} frag\n\t   */\n\t\n\t  deleteCachedFrag: function deleteCachedFrag(frag) {\n\t    var value = frag.raw;\n\t    var trackByKey = this.params.trackBy;\n\t    var scope = frag.scope;\n\t    var index = scope.$index;\n\t    // fix #948: avoid accidentally fall through to\n\t    // a parent repeater which happens to have $key.\n\t    var key = hasOwn(scope, '$key') && scope.$key;\n\t    var primitive = !isObject(value);\n\t    if (trackByKey || key || primitive) {\n\t      var id = getTrackByKey(index, key, value, trackByKey);\n\t      this.cache[id] = null;\n\t    } else {\n\t      value[this.id] = null;\n\t      frag.raw = null;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Get the stagger amount for an insertion/removal.\n\t   *\n\t   * @param {Fragment} frag\n\t   * @param {Number} index\n\t   * @param {Number} total\n\t   * @param {String} type\n\t   */\n\t\n\t  getStagger: function getStagger(frag, index, total, type) {\n\t    type = type + 'Stagger';\n\t    var trans = frag.node.__v_trans;\n\t    var hooks = trans && trans.hooks;\n\t    var hook = hooks && (hooks[type] || hooks.stagger);\n\t    return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);\n\t  },\n\t\n\t  /**\n\t   * Pre-process the value before piping it through the\n\t   * filters. This is passed to and called by the watcher.\n\t   */\n\t\n\t  _preProcess: function _preProcess(value) {\n\t    // regardless of type, store the un-filtered raw value.\n\t    this.rawValue = value;\n\t    return value;\n\t  },\n\t\n\t  /**\n\t   * Post-process the value after it has been piped through\n\t   * the filters. This is passed to and called by the watcher.\n\t   *\n\t   * It is necessary for this to be called during the\n\t   * watcher's dependency collection phase because we want\n\t   * the v-for to update when the source Object is mutated.\n\t   */\n\t\n\t  _postProcess: function _postProcess(value) {\n\t    if (isArray(value)) {\n\t      return value;\n\t    } else if (isPlainObject(value)) {\n\t      // convert plain object to array.\n\t      var keys = Object.keys(value);\n\t      var i = keys.length;\n\t      var res = new Array(i);\n\t      var key;\n\t      while (i--) {\n\t        key = keys[i];\n\t        res[i] = {\n\t          $key: key,\n\t          $value: value[key]\n\t        };\n\t      }\n\t      return res;\n\t    } else {\n\t      if (typeof value === 'number' && !isNaN(value)) {\n\t        value = range(value);\n\t      }\n\t      return value || [];\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    if (this.descriptor.ref) {\n\t      (this._scope || this.vm).$refs[this.descriptor.ref] = null;\n\t    }\n\t    if (this.frags) {\n\t      var i = this.frags.length;\n\t      var frag;\n\t      while (i--) {\n\t        frag = this.frags[i];\n\t        this.deleteCachedFrag(frag);\n\t        frag.destroy();\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Helper to find the previous element that is a fragment\n\t * anchor. This is necessary because a destroyed frag's\n\t * element could still be lingering in the DOM before its\n\t * leaving transition finishes, but its inserted flag\n\t * should have been set to false so we can skip them.\n\t *\n\t * If this is a block repeat, we want to make sure we only\n\t * return frag that is bound to this v-for. (see #929)\n\t *\n\t * @param {Fragment} frag\n\t * @param {Comment|Text} anchor\n\t * @param {String} id\n\t * @return {Fragment}\n\t */\n\t\n\tfunction findPrevFrag(frag, anchor, id) {\n\t  var el = frag.node.previousSibling;\n\t  /* istanbul ignore if */\n\t  if (!el) return;\n\t  frag = el.__v_frag;\n\t  while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {\n\t    el = el.previousSibling;\n\t    /* istanbul ignore if */\n\t    if (!el) return;\n\t    frag = el.__v_frag;\n\t  }\n\t  return frag;\n\t}\n\t\n\t/**\n\t * Find a vm from a fragment.\n\t *\n\t * @param {Fragment} frag\n\t * @return {Vue|undefined}\n\t */\n\t\n\tfunction findVmFromFrag(frag) {\n\t  var node = frag.node;\n\t  // handle multi-node frag\n\t  if (frag.end) {\n\t    while (!node.__vue__ && node !== frag.end && node.nextSibling) {\n\t      node = node.nextSibling;\n\t    }\n\t  }\n\t  return node.__vue__;\n\t}\n\t\n\t/**\n\t * Create a range array from given number.\n\t *\n\t * @param {Number} n\n\t * @return {Array}\n\t */\n\t\n\tfunction range(n) {\n\t  var i = -1;\n\t  var ret = new Array(Math.floor(n));\n\t  while (++i < n) {\n\t    ret[i] = i;\n\t  }\n\t  return ret;\n\t}\n\t\n\t/**\n\t * Get the track by key for an item.\n\t *\n\t * @param {Number} index\n\t * @param {String} key\n\t * @param {*} value\n\t * @param {String} [trackByKey]\n\t */\n\t\n\tfunction getTrackByKey(index, key, value, trackByKey) {\n\t  return trackByKey ? trackByKey === '$index' ? index : trackByKey.charAt(0).match(/\\w/) ? getPath(value, trackByKey) : value[trackByKey] : key || value;\n\t}\n\t\n\tif (false) {\n\t  vFor.warnDuplicate = function (value) {\n\t    warn('Duplicate value found in v-for=\"' + this.descriptor.raw + '\": ' + JSON.stringify(value) + '. Use track-by=\"$index\" if ' + 'you are expecting duplicate values.', this.vm);\n\t  };\n\t}\n\t\n\tvar vIf = {\n\t\n\t  priority: IF,\n\t  terminal: true,\n\t\n\t  bind: function bind() {\n\t    var el = this.el;\n\t    if (!el.__vue__) {\n\t      // check else block\n\t      var next = el.nextElementSibling;\n\t      if (next && getAttr(next, 'v-else') !== null) {\n\t        remove(next);\n\t        this.elseEl = next;\n\t      }\n\t      // check main block\n\t      this.anchor = createAnchor('v-if');\n\t      replace(el, this.anchor);\n\t    } else {\n\t      (\"production\") !== 'production' && warn('v-if=\"' + this.expression + '\" cannot be ' + 'used on an instance root element.', this.vm);\n\t      this.invalid = true;\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    if (this.invalid) return;\n\t    if (value) {\n\t      if (!this.frag) {\n\t        this.insert();\n\t      }\n\t    } else {\n\t      this.remove();\n\t    }\n\t  },\n\t\n\t  insert: function insert() {\n\t    if (this.elseFrag) {\n\t      this.elseFrag.remove();\n\t      this.elseFrag = null;\n\t    }\n\t    // lazy init factory\n\t    if (!this.factory) {\n\t      this.factory = new FragmentFactory(this.vm, this.el);\n\t    }\n\t    this.frag = this.factory.create(this._host, this._scope, this._frag);\n\t    this.frag.before(this.anchor);\n\t  },\n\t\n\t  remove: function remove() {\n\t    if (this.frag) {\n\t      this.frag.remove();\n\t      this.frag = null;\n\t    }\n\t    if (this.elseEl && !this.elseFrag) {\n\t      if (!this.elseFactory) {\n\t        this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);\n\t      }\n\t      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);\n\t      this.elseFrag.before(this.anchor);\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    if (this.frag) {\n\t      this.frag.destroy();\n\t    }\n\t    if (this.elseFrag) {\n\t      this.elseFrag.destroy();\n\t    }\n\t  }\n\t};\n\t\n\tvar show = {\n\t\n\t  bind: function bind() {\n\t    // check else block\n\t    var next = this.el.nextElementSibling;\n\t    if (next && getAttr(next, 'v-else') !== null) {\n\t      this.elseEl = next;\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    this.apply(this.el, value);\n\t    if (this.elseEl) {\n\t      this.apply(this.elseEl, !value);\n\t    }\n\t  },\n\t\n\t  apply: function apply(el, value) {\n\t    if (inDoc(el)) {\n\t      applyTransition(el, value ? 1 : -1, toggle, this.vm);\n\t    } else {\n\t      toggle();\n\t    }\n\t    function toggle() {\n\t      el.style.display = value ? '' : 'none';\n\t    }\n\t  }\n\t};\n\t\n\tvar text$2 = {\n\t\n\t  bind: function bind() {\n\t    var self = this;\n\t    var el = this.el;\n\t    var isRange = el.type === 'range';\n\t    var lazy = this.params.lazy;\n\t    var number = this.params.number;\n\t    var debounce = this.params.debounce;\n\t\n\t    // handle composition events.\n\t    //   http://blog.evanyou.me/2014/01/03/composition-event/\n\t    // skip this for Android because it handles composition\n\t    // events quite differently. Android doesn't trigger\n\t    // composition events for language input methods e.g.\n\t    // Chinese, but instead triggers them for spelling\n\t    // suggestions... (see Discussion/#162)\n\t    var composing = false;\n\t    if (!isAndroid && !isRange) {\n\t      this.on('compositionstart', function () {\n\t        composing = true;\n\t      });\n\t      this.on('compositionend', function () {\n\t        composing = false;\n\t        // in IE11 the \"compositionend\" event fires AFTER\n\t        // the \"input\" event, so the input handler is blocked\n\t        // at the end... have to call it here.\n\t        //\n\t        // #1327: in lazy mode this is unecessary.\n\t        if (!lazy) {\n\t          self.listener();\n\t        }\n\t      });\n\t    }\n\t\n\t    // prevent messing with the input when user is typing,\n\t    // and force update on blur.\n\t    this.focused = false;\n\t    if (!isRange && !lazy) {\n\t      this.on('focus', function () {\n\t        self.focused = true;\n\t      });\n\t      this.on('blur', function () {\n\t        self.focused = false;\n\t        // do not sync value after fragment removal (#2017)\n\t        if (!self._frag || self._frag.inserted) {\n\t          self.rawListener();\n\t        }\n\t      });\n\t    }\n\t\n\t    // Now attach the main listener\n\t    this.listener = this.rawListener = function () {\n\t      if (composing || !self._bound) {\n\t        return;\n\t      }\n\t      var val = number || isRange ? toNumber(el.value) : el.value;\n\t      self.set(val);\n\t      // force update on next tick to avoid lock & same value\n\t      // also only update when user is not typing\n\t      nextTick(function () {\n\t        if (self._bound && !self.focused) {\n\t          self.update(self._watcher.value);\n\t        }\n\t      });\n\t    };\n\t\n\t    // apply debounce\n\t    if (debounce) {\n\t      this.listener = _debounce(this.listener, debounce);\n\t    }\n\t\n\t    // Support jQuery events, since jQuery.trigger() doesn't\n\t    // trigger native events in some cases and some plugins\n\t    // rely on $.trigger()\n\t    //\n\t    // We want to make sure if a listener is attached using\n\t    // jQuery, it is also removed with jQuery, that's why\n\t    // we do the check for each directive instance and\n\t    // store that check result on itself. This also allows\n\t    // easier test coverage control by unsetting the global\n\t    // jQuery variable in tests.\n\t    this.hasjQuery = typeof jQuery === 'function';\n\t    if (this.hasjQuery) {\n\t      var method = jQuery.fn.on ? 'on' : 'bind';\n\t      jQuery(el)[method]('change', this.rawListener);\n\t      if (!lazy) {\n\t        jQuery(el)[method]('input', this.listener);\n\t      }\n\t    } else {\n\t      this.on('change', this.rawListener);\n\t      if (!lazy) {\n\t        this.on('input', this.listener);\n\t      }\n\t    }\n\t\n\t    // IE9 doesn't fire input event on backspace/del/cut\n\t    if (!lazy && isIE9) {\n\t      this.on('cut', function () {\n\t        nextTick(self.listener);\n\t      });\n\t      this.on('keyup', function (e) {\n\t        if (e.keyCode === 46 || e.keyCode === 8) {\n\t          self.listener();\n\t        }\n\t      });\n\t    }\n\t\n\t    // set initial value if present\n\t    if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {\n\t      this.afterBind = this.listener;\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    // #3029 only update when the value changes. This prevent\n\t    // browsers from overwriting values like selectionStart\n\t    value = _toString(value);\n\t    if (value !== this.el.value) this.el.value = value;\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    var el = this.el;\n\t    if (this.hasjQuery) {\n\t      var method = jQuery.fn.off ? 'off' : 'unbind';\n\t      jQuery(el)[method]('change', this.listener);\n\t      jQuery(el)[method]('input', this.listener);\n\t    }\n\t  }\n\t};\n\t\n\tvar radio = {\n\t\n\t  bind: function bind() {\n\t    var self = this;\n\t    var el = this.el;\n\t\n\t    this.getValue = function () {\n\t      // value overwrite via v-bind:value\n\t      if (el.hasOwnProperty('_value')) {\n\t        return el._value;\n\t      }\n\t      var val = el.value;\n\t      if (self.params.number) {\n\t        val = toNumber(val);\n\t      }\n\t      return val;\n\t    };\n\t\n\t    this.listener = function () {\n\t      self.set(self.getValue());\n\t    };\n\t    this.on('change', this.listener);\n\t\n\t    if (el.hasAttribute('checked')) {\n\t      this.afterBind = this.listener;\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    this.el.checked = looseEqual(value, this.getValue());\n\t  }\n\t};\n\t\n\tvar select = {\n\t\n\t  bind: function bind() {\n\t    var _this = this;\n\t\n\t    var self = this;\n\t    var el = this.el;\n\t\n\t    // method to force update DOM using latest value.\n\t    this.forceUpdate = function () {\n\t      if (self._watcher) {\n\t        self.update(self._watcher.get());\n\t      }\n\t    };\n\t\n\t    // check if this is a multiple select\n\t    var multiple = this.multiple = el.hasAttribute('multiple');\n\t\n\t    // attach listener\n\t    this.listener = function () {\n\t      var value = getValue(el, multiple);\n\t      value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;\n\t      self.set(value);\n\t    };\n\t    this.on('change', this.listener);\n\t\n\t    // if has initial value, set afterBind\n\t    var initValue = getValue(el, multiple, true);\n\t    if (multiple && initValue.length || !multiple && initValue !== null) {\n\t      this.afterBind = this.listener;\n\t    }\n\t\n\t    // All major browsers except Firefox resets\n\t    // selectedIndex with value -1 to 0 when the element\n\t    // is appended to a new parent, therefore we have to\n\t    // force a DOM update whenever that happens...\n\t    this.vm.$on('hook:attached', function () {\n\t      nextTick(_this.forceUpdate);\n\t    });\n\t    if (!inDoc(el)) {\n\t      nextTick(this.forceUpdate);\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    var el = this.el;\n\t    el.selectedIndex = -1;\n\t    var multi = this.multiple && isArray(value);\n\t    var options = el.options;\n\t    var i = options.length;\n\t    var op, val;\n\t    while (i--) {\n\t      op = options[i];\n\t      val = op.hasOwnProperty('_value') ? op._value : op.value;\n\t      /* eslint-disable eqeqeq */\n\t      op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);\n\t      /* eslint-enable eqeqeq */\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    /* istanbul ignore next */\n\t    this.vm.$off('hook:attached', this.forceUpdate);\n\t  }\n\t};\n\t\n\t/**\n\t * Get select value\n\t *\n\t * @param {SelectElement} el\n\t * @param {Boolean} multi\n\t * @param {Boolean} init\n\t * @return {Array|*}\n\t */\n\t\n\tfunction getValue(el, multi, init) {\n\t  var res = multi ? [] : null;\n\t  var op, val, selected;\n\t  for (var i = 0, l = el.options.length; i < l; i++) {\n\t    op = el.options[i];\n\t    selected = init ? op.hasAttribute('selected') : op.selected;\n\t    if (selected) {\n\t      val = op.hasOwnProperty('_value') ? op._value : op.value;\n\t      if (multi) {\n\t        res.push(val);\n\t      } else {\n\t        return val;\n\t      }\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\t/**\n\t * Native Array.indexOf uses strict equal, but in this\n\t * case we need to match string/numbers with custom equal.\n\t *\n\t * @param {Array} arr\n\t * @param {*} val\n\t */\n\t\n\tfunction indexOf$1(arr, val) {\n\t  var i = arr.length;\n\t  while (i--) {\n\t    if (looseEqual(arr[i], val)) {\n\t      return i;\n\t    }\n\t  }\n\t  return -1;\n\t}\n\t\n\tvar checkbox = {\n\t\n\t  bind: function bind() {\n\t    var self = this;\n\t    var el = this.el;\n\t\n\t    this.getValue = function () {\n\t      return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;\n\t    };\n\t\n\t    function getBooleanValue() {\n\t      var val = el.checked;\n\t      if (val && el.hasOwnProperty('_trueValue')) {\n\t        return el._trueValue;\n\t      }\n\t      if (!val && el.hasOwnProperty('_falseValue')) {\n\t        return el._falseValue;\n\t      }\n\t      return val;\n\t    }\n\t\n\t    this.listener = function () {\n\t      var model = self._watcher.value;\n\t      if (isArray(model)) {\n\t        var val = self.getValue();\n\t        if (el.checked) {\n\t          if (indexOf(model, val) < 0) {\n\t            model.push(val);\n\t          }\n\t        } else {\n\t          model.$remove(val);\n\t        }\n\t      } else {\n\t        self.set(getBooleanValue());\n\t      }\n\t    };\n\t\n\t    this.on('change', this.listener);\n\t    if (el.hasAttribute('checked')) {\n\t      this.afterBind = this.listener;\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    var el = this.el;\n\t    if (isArray(value)) {\n\t      el.checked = indexOf(value, this.getValue()) > -1;\n\t    } else {\n\t      if (el.hasOwnProperty('_trueValue')) {\n\t        el.checked = looseEqual(value, el._trueValue);\n\t      } else {\n\t        el.checked = !!value;\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tvar handlers = {\n\t  text: text$2,\n\t  radio: radio,\n\t  select: select,\n\t  checkbox: checkbox\n\t};\n\t\n\tvar model = {\n\t\n\t  priority: MODEL,\n\t  twoWay: true,\n\t  handlers: handlers,\n\t  params: ['lazy', 'number', 'debounce'],\n\t\n\t  /**\n\t   * Possible elements:\n\t   *   <select>\n\t   *   <textarea>\n\t   *   <input type=\"*\">\n\t   *     - text\n\t   *     - checkbox\n\t   *     - radio\n\t   *     - number\n\t   */\n\t\n\t  bind: function bind() {\n\t    // friendly warning...\n\t    this.checkFilters();\n\t    if (this.hasRead && !this.hasWrite) {\n\t      (\"production\") !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model=\"' + this.descriptor.raw + '\". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);\n\t    }\n\t    var el = this.el;\n\t    var tag = el.tagName;\n\t    var handler;\n\t    if (tag === 'INPUT') {\n\t      handler = handlers[el.type] || handlers.text;\n\t    } else if (tag === 'SELECT') {\n\t      handler = handlers.select;\n\t    } else if (tag === 'TEXTAREA') {\n\t      handler = handlers.text;\n\t    } else {\n\t      (\"production\") !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);\n\t      return;\n\t    }\n\t    el.__v_model = this;\n\t    handler.bind.call(this);\n\t    this.update = handler.update;\n\t    this._unbind = handler.unbind;\n\t  },\n\t\n\t  /**\n\t   * Check read/write filter stats.\n\t   */\n\t\n\t  checkFilters: function checkFilters() {\n\t    var filters = this.filters;\n\t    if (!filters) return;\n\t    var i = filters.length;\n\t    while (i--) {\n\t      var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);\n\t      if (typeof filter === 'function' || filter.read) {\n\t        this.hasRead = true;\n\t      }\n\t      if (filter.write) {\n\t        this.hasWrite = true;\n\t      }\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    this.el.__v_model = null;\n\t    this._unbind && this._unbind();\n\t  }\n\t};\n\t\n\t// keyCode aliases\n\tvar keyCodes = {\n\t  esc: 27,\n\t  tab: 9,\n\t  enter: 13,\n\t  space: 32,\n\t  'delete': [8, 46],\n\t  up: 38,\n\t  left: 37,\n\t  right: 39,\n\t  down: 40\n\t};\n\t\n\tfunction keyFilter(handler, keys) {\n\t  var codes = keys.map(function (key) {\n\t    var charCode = key.charCodeAt(0);\n\t    if (charCode > 47 && charCode < 58) {\n\t      return parseInt(key, 10);\n\t    }\n\t    if (key.length === 1) {\n\t      charCode = key.toUpperCase().charCodeAt(0);\n\t      if (charCode > 64 && charCode < 91) {\n\t        return charCode;\n\t      }\n\t    }\n\t    return keyCodes[key];\n\t  });\n\t  codes = [].concat.apply([], codes);\n\t  return function keyHandler(e) {\n\t    if (codes.indexOf(e.keyCode) > -1) {\n\t      return handler.call(this, e);\n\t    }\n\t  };\n\t}\n\t\n\tfunction stopFilter(handler) {\n\t  return function stopHandler(e) {\n\t    e.stopPropagation();\n\t    return handler.call(this, e);\n\t  };\n\t}\n\t\n\tfunction preventFilter(handler) {\n\t  return function preventHandler(e) {\n\t    e.preventDefault();\n\t    return handler.call(this, e);\n\t  };\n\t}\n\t\n\tfunction selfFilter(handler) {\n\t  return function selfHandler(e) {\n\t    if (e.target === e.currentTarget) {\n\t      return handler.call(this, e);\n\t    }\n\t  };\n\t}\n\t\n\tvar on$1 = {\n\t\n\t  priority: ON,\n\t  acceptStatement: true,\n\t  keyCodes: keyCodes,\n\t\n\t  bind: function bind() {\n\t    // deal with iframes\n\t    if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {\n\t      var self = this;\n\t      this.iframeBind = function () {\n\t        on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);\n\t      };\n\t      this.on('load', this.iframeBind);\n\t    }\n\t  },\n\t\n\t  update: function update(handler) {\n\t    // stub a noop for v-on with no value,\n\t    // e.g. @mousedown.prevent\n\t    if (!this.descriptor.raw) {\n\t      handler = function () {};\n\t    }\n\t\n\t    if (typeof handler !== 'function') {\n\t      (\"production\") !== 'production' && warn('v-on:' + this.arg + '=\"' + this.expression + '\" expects a function value, ' + 'got ' + handler, this.vm);\n\t      return;\n\t    }\n\t\n\t    // apply modifiers\n\t    if (this.modifiers.stop) {\n\t      handler = stopFilter(handler);\n\t    }\n\t    if (this.modifiers.prevent) {\n\t      handler = preventFilter(handler);\n\t    }\n\t    if (this.modifiers.self) {\n\t      handler = selfFilter(handler);\n\t    }\n\t    // key filter\n\t    var keys = Object.keys(this.modifiers).filter(function (key) {\n\t      return key !== 'stop' && key !== 'prevent' && key !== 'self' && key !== 'capture';\n\t    });\n\t    if (keys.length) {\n\t      handler = keyFilter(handler, keys);\n\t    }\n\t\n\t    this.reset();\n\t    this.handler = handler;\n\t\n\t    if (this.iframeBind) {\n\t      this.iframeBind();\n\t    } else {\n\t      on(this.el, this.arg, this.handler, this.modifiers.capture);\n\t    }\n\t  },\n\t\n\t  reset: function reset() {\n\t    var el = this.iframeBind ? this.el.contentWindow : this.el;\n\t    if (this.handler) {\n\t      off(el, this.arg, this.handler);\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    this.reset();\n\t  }\n\t};\n\t\n\tvar prefixes = ['-webkit-', '-moz-', '-ms-'];\n\tvar camelPrefixes = ['Webkit', 'Moz', 'ms'];\n\tvar importantRE = /!important;?$/;\n\tvar propCache = Object.create(null);\n\t\n\tvar testEl = null;\n\t\n\tvar style = {\n\t\n\t  deep: true,\n\t\n\t  update: function update(value) {\n\t    if (typeof value === 'string') {\n\t      this.el.style.cssText = value;\n\t    } else if (isArray(value)) {\n\t      this.handleObject(value.reduce(extend, {}));\n\t    } else {\n\t      this.handleObject(value || {});\n\t    }\n\t  },\n\t\n\t  handleObject: function handleObject(value) {\n\t    // cache object styles so that only changed props\n\t    // are actually updated.\n\t    var cache = this.cache || (this.cache = {});\n\t    var name, val;\n\t    for (name in cache) {\n\t      if (!(name in value)) {\n\t        this.handleSingle(name, null);\n\t        delete cache[name];\n\t      }\n\t    }\n\t    for (name in value) {\n\t      val = value[name];\n\t      if (val !== cache[name]) {\n\t        cache[name] = val;\n\t        this.handleSingle(name, val);\n\t      }\n\t    }\n\t  },\n\t\n\t  handleSingle: function handleSingle(prop, value) {\n\t    prop = normalize(prop);\n\t    if (!prop) return; // unsupported prop\n\t    // cast possible numbers/booleans into strings\n\t    if (value != null) value += '';\n\t    if (value) {\n\t      var isImportant = importantRE.test(value) ? 'important' : '';\n\t      if (isImportant) {\n\t        /* istanbul ignore if */\n\t        if (false) {\n\t          warn('It\\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');\n\t        }\n\t        value = value.replace(importantRE, '').trim();\n\t        this.el.style.setProperty(prop.kebab, value, isImportant);\n\t      } else {\n\t        this.el.style[prop.camel] = value;\n\t      }\n\t    } else {\n\t      this.el.style[prop.camel] = '';\n\t    }\n\t  }\n\t\n\t};\n\t\n\t/**\n\t * Normalize a CSS property name.\n\t * - cache result\n\t * - auto prefix\n\t * - camelCase -> dash-case\n\t *\n\t * @param {String} prop\n\t * @return {String}\n\t */\n\t\n\tfunction normalize(prop) {\n\t  if (propCache[prop]) {\n\t    return propCache[prop];\n\t  }\n\t  var res = prefix(prop);\n\t  propCache[prop] = propCache[res] = res;\n\t  return res;\n\t}\n\t\n\t/**\n\t * Auto detect the appropriate prefix for a CSS property.\n\t * https://gist.github.com/paulirish/523692\n\t *\n\t * @param {String} prop\n\t * @return {String}\n\t */\n\t\n\tfunction prefix(prop) {\n\t  prop = hyphenate(prop);\n\t  var camel = camelize(prop);\n\t  var upper = camel.charAt(0).toUpperCase() + camel.slice(1);\n\t  if (!testEl) {\n\t    testEl = document.createElement('div');\n\t  }\n\t  var i = prefixes.length;\n\t  var prefixed;\n\t  if (camel !== 'filter' && camel in testEl.style) {\n\t    return {\n\t      kebab: prop,\n\t      camel: camel\n\t    };\n\t  }\n\t  while (i--) {\n\t    prefixed = camelPrefixes[i] + upper;\n\t    if (prefixed in testEl.style) {\n\t      return {\n\t        kebab: prefixes[i] + prop,\n\t        camel: prefixed\n\t      };\n\t    }\n\t  }\n\t}\n\t\n\t// xlink\n\tvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\tvar xlinkRE = /^xlink:/;\n\t\n\t// check for attributes that prohibit interpolations\n\tvar disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;\n\t// these attributes should also set their corresponding properties\n\t// because they only affect the initial state of the element\n\tvar attrWithPropsRE = /^(?:value|checked|selected|muted)$/;\n\t// these attributes expect enumrated values of \"true\" or \"false\"\n\t// but are not boolean attributes\n\tvar enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;\n\t\n\t// these attributes should set a hidden property for\n\t// binding v-model to object values\n\tvar modelProps = {\n\t  value: '_value',\n\t  'true-value': '_trueValue',\n\t  'false-value': '_falseValue'\n\t};\n\t\n\tvar bind$1 = {\n\t\n\t  priority: BIND,\n\t\n\t  bind: function bind() {\n\t    var attr = this.arg;\n\t    var tag = this.el.tagName;\n\t    // should be deep watch on object mode\n\t    if (!attr) {\n\t      this.deep = true;\n\t    }\n\t    // handle interpolation bindings\n\t    var descriptor = this.descriptor;\n\t    var tokens = descriptor.interp;\n\t    if (tokens) {\n\t      // handle interpolations with one-time tokens\n\t      if (descriptor.hasOneTime) {\n\t        this.expression = tokensToExp(tokens, this._scope || this.vm);\n\t      }\n\t\n\t      // only allow binding on native attributes\n\t      if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {\n\t        (\"production\") !== 'production' && warn(attr + '=\"' + descriptor.raw + '\": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);\n\t        this.el.removeAttribute(attr);\n\t        this.invalid = true;\n\t      }\n\t\n\t      /* istanbul ignore if */\n\t      if (false) {\n\t        var raw = attr + '=\"' + descriptor.raw + '\": ';\n\t        // warn src\n\t        if (attr === 'src') {\n\t          warn(raw + 'interpolation in \"src\" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);\n\t        }\n\t\n\t        // warn style\n\t        if (attr === 'style') {\n\t          warn(raw + 'interpolation in \"style\" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);\n\t        }\n\t      }\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    if (this.invalid) {\n\t      return;\n\t    }\n\t    var attr = this.arg;\n\t    if (this.arg) {\n\t      this.handleSingle(attr, value);\n\t    } else {\n\t      this.handleObject(value || {});\n\t    }\n\t  },\n\t\n\t  // share object handler with v-bind:class\n\t  handleObject: style.handleObject,\n\t\n\t  handleSingle: function handleSingle(attr, value) {\n\t    var el = this.el;\n\t    var interp = this.descriptor.interp;\n\t    if (this.modifiers.camel) {\n\t      attr = camelize(attr);\n\t    }\n\t    if (!interp && attrWithPropsRE.test(attr) && attr in el) {\n\t      var attrValue = attr === 'value' ? value == null // IE9 will set input.value to \"null\" for null...\n\t      ? '' : value : value;\n\t\n\t      if (el[attr] !== attrValue) {\n\t        el[attr] = attrValue;\n\t      }\n\t    }\n\t    // set model props\n\t    var modelProp = modelProps[attr];\n\t    if (!interp && modelProp) {\n\t      el[modelProp] = value;\n\t      // update v-model if present\n\t      var model = el.__v_model;\n\t      if (model) {\n\t        model.listener();\n\t      }\n\t    }\n\t    // do not set value attribute for textarea\n\t    if (attr === 'value' && el.tagName === 'TEXTAREA') {\n\t      el.removeAttribute(attr);\n\t      return;\n\t    }\n\t    // update attribute\n\t    if (enumeratedAttrRE.test(attr)) {\n\t      el.setAttribute(attr, value ? 'true' : 'false');\n\t    } else if (value != null && value !== false) {\n\t      if (attr === 'class') {\n\t        // handle edge case #1960:\n\t        // class interpolation should not overwrite Vue transition class\n\t        if (el.__v_trans) {\n\t          value += ' ' + el.__v_trans.id + '-transition';\n\t        }\n\t        setClass(el, value);\n\t      } else if (xlinkRE.test(attr)) {\n\t        el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);\n\t      } else {\n\t        el.setAttribute(attr, value === true ? '' : value);\n\t      }\n\t    } else {\n\t      el.removeAttribute(attr);\n\t    }\n\t  }\n\t};\n\t\n\tvar el = {\n\t\n\t  priority: EL,\n\t\n\t  bind: function bind() {\n\t    /* istanbul ignore if */\n\t    if (!this.arg) {\n\t      return;\n\t    }\n\t    var id = this.id = camelize(this.arg);\n\t    var refs = (this._scope || this.vm).$els;\n\t    if (hasOwn(refs, id)) {\n\t      refs[id] = this.el;\n\t    } else {\n\t      defineReactive(refs, id, this.el);\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    var refs = (this._scope || this.vm).$els;\n\t    if (refs[this.id] === this.el) {\n\t      refs[this.id] = null;\n\t    }\n\t  }\n\t};\n\t\n\tvar ref = {\n\t  bind: function bind() {\n\t    (\"production\") !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);\n\t  }\n\t};\n\t\n\tvar cloak = {\n\t  bind: function bind() {\n\t    var el = this.el;\n\t    this.vm.$once('pre-hook:compiled', function () {\n\t      el.removeAttribute('v-cloak');\n\t    });\n\t  }\n\t};\n\t\n\t// must export plain object\n\tvar directives = {\n\t  text: text$1,\n\t  html: html,\n\t  'for': vFor,\n\t  'if': vIf,\n\t  show: show,\n\t  model: model,\n\t  on: on$1,\n\t  bind: bind$1,\n\t  el: el,\n\t  ref: ref,\n\t  cloak: cloak\n\t};\n\t\n\tvar vClass = {\n\t\n\t  deep: true,\n\t\n\t  update: function update(value) {\n\t    if (!value) {\n\t      this.cleanup();\n\t    } else if (typeof value === 'string') {\n\t      this.setClass(value.trim().split(/\\s+/));\n\t    } else {\n\t      this.setClass(normalize$1(value));\n\t    }\n\t  },\n\t\n\t  setClass: function setClass(value) {\n\t    this.cleanup(value);\n\t    for (var i = 0, l = value.length; i < l; i++) {\n\t      var val = value[i];\n\t      if (val) {\n\t        apply(this.el, val, addClass);\n\t      }\n\t    }\n\t    this.prevKeys = value;\n\t  },\n\t\n\t  cleanup: function cleanup(value) {\n\t    var prevKeys = this.prevKeys;\n\t    if (!prevKeys) return;\n\t    var i = prevKeys.length;\n\t    while (i--) {\n\t      var key = prevKeys[i];\n\t      if (!value || value.indexOf(key) < 0) {\n\t        apply(this.el, key, removeClass);\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Normalize objects and arrays (potentially containing objects)\n\t * into array of strings.\n\t *\n\t * @param {Object|Array<String|Object>} value\n\t * @return {Array<String>}\n\t */\n\t\n\tfunction normalize$1(value) {\n\t  var res = [];\n\t  if (isArray(value)) {\n\t    for (var i = 0, l = value.length; i < l; i++) {\n\t      var _key = value[i];\n\t      if (_key) {\n\t        if (typeof _key === 'string') {\n\t          res.push(_key);\n\t        } else {\n\t          for (var k in _key) {\n\t            if (_key[k]) res.push(k);\n\t          }\n\t        }\n\t      }\n\t    }\n\t  } else if (isObject(value)) {\n\t    for (var key in value) {\n\t      if (value[key]) res.push(key);\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\t/**\n\t * Add or remove a class/classes on an element\n\t *\n\t * @param {Element} el\n\t * @param {String} key The class name. This may or may not\n\t *                     contain a space character, in such a\n\t *                     case we'll deal with multiple class\n\t *                     names at once.\n\t * @param {Function} fn\n\t */\n\t\n\tfunction apply(el, key, fn) {\n\t  key = key.trim();\n\t  if (key.indexOf(' ') === -1) {\n\t    fn(el, key);\n\t    return;\n\t  }\n\t  // The key contains one or more space characters.\n\t  // Since a class name doesn't accept such characters, we\n\t  // treat it as multiple classes.\n\t  var keys = key.split(/\\s+/);\n\t  for (var i = 0, l = keys.length; i < l; i++) {\n\t    fn(el, keys[i]);\n\t  }\n\t}\n\t\n\tvar component = {\n\t\n\t  priority: COMPONENT,\n\t\n\t  params: ['keep-alive', 'transition-mode', 'inline-template'],\n\t\n\t  /**\n\t   * Setup. Two possible usages:\n\t   *\n\t   * - static:\n\t   *   <comp> or <div v-component=\"comp\">\n\t   *\n\t   * - dynamic:\n\t   *   <component :is=\"view\">\n\t   */\n\t\n\t  bind: function bind() {\n\t    if (!this.el.__vue__) {\n\t      // keep-alive cache\n\t      this.keepAlive = this.params.keepAlive;\n\t      if (this.keepAlive) {\n\t        this.cache = {};\n\t      }\n\t      // check inline-template\n\t      if (this.params.inlineTemplate) {\n\t        // extract inline template as a DocumentFragment\n\t        this.inlineTemplate = extractContent(this.el, true);\n\t      }\n\t      // component resolution related state\n\t      this.pendingComponentCb = this.Component = null;\n\t      // transition related state\n\t      this.pendingRemovals = 0;\n\t      this.pendingRemovalCb = null;\n\t      // create a ref anchor\n\t      this.anchor = createAnchor('v-component');\n\t      replace(this.el, this.anchor);\n\t      // remove is attribute.\n\t      // this is removed during compilation, but because compilation is\n\t      // cached, when the component is used elsewhere this attribute\n\t      // will remain at link time.\n\t      this.el.removeAttribute('is');\n\t      this.el.removeAttribute(':is');\n\t      // remove ref, same as above\n\t      if (this.descriptor.ref) {\n\t        this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));\n\t      }\n\t      // if static, build right now.\n\t      if (this.literal) {\n\t        this.setComponent(this.expression);\n\t      }\n\t    } else {\n\t      (\"production\") !== 'production' && warn('cannot mount component \"' + this.expression + '\" ' + 'on already mounted element: ' + this.el);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Public update, called by the watcher in the dynamic\n\t   * literal scenario, e.g. <component :is=\"view\">\n\t   */\n\t\n\t  update: function update(value) {\n\t    if (!this.literal) {\n\t      this.setComponent(value);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Switch dynamic components. May resolve the component\n\t   * asynchronously, and perform transition based on\n\t   * specified transition mode. Accepts a few additional\n\t   * arguments specifically for vue-router.\n\t   *\n\t   * The callback is called when the full transition is\n\t   * finished.\n\t   *\n\t   * @param {String} value\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  setComponent: function setComponent(value, cb) {\n\t    this.invalidatePending();\n\t    if (!value) {\n\t      // just remove current\n\t      this.unbuild(true);\n\t      this.remove(this.childVM, cb);\n\t      this.childVM = null;\n\t    } else {\n\t      var self = this;\n\t      this.resolveComponent(value, function () {\n\t        self.mountComponent(cb);\n\t      });\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Resolve the component constructor to use when creating\n\t   * the child vm.\n\t   *\n\t   * @param {String|Function} value\n\t   * @param {Function} cb\n\t   */\n\t\n\t  resolveComponent: function resolveComponent(value, cb) {\n\t    var self = this;\n\t    this.pendingComponentCb = cancellable(function (Component) {\n\t      self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);\n\t      self.Component = Component;\n\t      cb();\n\t    });\n\t    this.vm._resolveComponent(value, this.pendingComponentCb);\n\t  },\n\t\n\t  /**\n\t   * Create a new instance using the current constructor and\n\t   * replace the existing instance. This method doesn't care\n\t   * whether the new component and the old one are actually\n\t   * the same.\n\t   *\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  mountComponent: function mountComponent(cb) {\n\t    // actual mount\n\t    this.unbuild(true);\n\t    var self = this;\n\t    var activateHooks = this.Component.options.activate;\n\t    var cached = this.getCached();\n\t    var newComponent = this.build();\n\t    if (activateHooks && !cached) {\n\t      this.waitingFor = newComponent;\n\t      callActivateHooks(activateHooks, newComponent, function () {\n\t        if (self.waitingFor !== newComponent) {\n\t          return;\n\t        }\n\t        self.waitingFor = null;\n\t        self.transition(newComponent, cb);\n\t      });\n\t    } else {\n\t      // update ref for kept-alive component\n\t      if (cached) {\n\t        newComponent._updateRef();\n\t      }\n\t      this.transition(newComponent, cb);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * When the component changes or unbinds before an async\n\t   * constructor is resolved, we need to invalidate its\n\t   * pending callback.\n\t   */\n\t\n\t  invalidatePending: function invalidatePending() {\n\t    if (this.pendingComponentCb) {\n\t      this.pendingComponentCb.cancel();\n\t      this.pendingComponentCb = null;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Instantiate/insert a new child vm.\n\t   * If keep alive and has cached instance, insert that\n\t   * instance; otherwise build a new one and cache it.\n\t   *\n\t   * @param {Object} [extraOptions]\n\t   * @return {Vue} - the created instance\n\t   */\n\t\n\t  build: function build(extraOptions) {\n\t    var cached = this.getCached();\n\t    if (cached) {\n\t      return cached;\n\t    }\n\t    if (this.Component) {\n\t      // default options\n\t      var options = {\n\t        name: this.ComponentName,\n\t        el: cloneNode(this.el),\n\t        template: this.inlineTemplate,\n\t        // make sure to add the child with correct parent\n\t        // if this is a transcluded component, its parent\n\t        // should be the transclusion host.\n\t        parent: this._host || this.vm,\n\t        // if no inline-template, then the compiled\n\t        // linker can be cached for better performance.\n\t        _linkerCachable: !this.inlineTemplate,\n\t        _ref: this.descriptor.ref,\n\t        _asComponent: true,\n\t        _isRouterView: this._isRouterView,\n\t        // if this is a transcluded component, context\n\t        // will be the common parent vm of this instance\n\t        // and its host.\n\t        _context: this.vm,\n\t        // if this is inside an inline v-for, the scope\n\t        // will be the intermediate scope created for this\n\t        // repeat fragment. this is used for linking props\n\t        // and container directives.\n\t        _scope: this._scope,\n\t        // pass in the owner fragment of this component.\n\t        // this is necessary so that the fragment can keep\n\t        // track of its contained components in order to\n\t        // call attach/detach hooks for them.\n\t        _frag: this._frag\n\t      };\n\t      // extra options\n\t      // in 1.0.0 this is used by vue-router only\n\t      /* istanbul ignore if */\n\t      if (extraOptions) {\n\t        extend(options, extraOptions);\n\t      }\n\t      var child = new this.Component(options);\n\t      if (this.keepAlive) {\n\t        this.cache[this.Component.cid] = child;\n\t      }\n\t      /* istanbul ignore if */\n\t      if (false) {\n\t        warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);\n\t      }\n\t      return child;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Try to get a cached instance of the current component.\n\t   *\n\t   * @return {Vue|undefined}\n\t   */\n\t\n\t  getCached: function getCached() {\n\t    return this.keepAlive && this.cache[this.Component.cid];\n\t  },\n\t\n\t  /**\n\t   * Teardown the current child, but defers cleanup so\n\t   * that we can separate the destroy and removal steps.\n\t   *\n\t   * @param {Boolean} defer\n\t   */\n\t\n\t  unbuild: function unbuild(defer) {\n\t    if (this.waitingFor) {\n\t      if (!this.keepAlive) {\n\t        this.waitingFor.$destroy();\n\t      }\n\t      this.waitingFor = null;\n\t    }\n\t    var child = this.childVM;\n\t    if (!child || this.keepAlive) {\n\t      if (child) {\n\t        // remove ref\n\t        child._inactive = true;\n\t        child._updateRef(true);\n\t      }\n\t      return;\n\t    }\n\t    // the sole purpose of `deferCleanup` is so that we can\n\t    // \"deactivate\" the vm right now and perform DOM removal\n\t    // later.\n\t    child.$destroy(false, defer);\n\t  },\n\t\n\t  /**\n\t   * Remove current destroyed child and manually do\n\t   * the cleanup after removal.\n\t   *\n\t   * @param {Function} cb\n\t   */\n\t\n\t  remove: function remove(child, cb) {\n\t    var keepAlive = this.keepAlive;\n\t    if (child) {\n\t      // we may have a component switch when a previous\n\t      // component is still being transitioned out.\n\t      // we want to trigger only one lastest insertion cb\n\t      // when the existing transition finishes. (#1119)\n\t      this.pendingRemovals++;\n\t      this.pendingRemovalCb = cb;\n\t      var self = this;\n\t      child.$remove(function () {\n\t        self.pendingRemovals--;\n\t        if (!keepAlive) child._cleanup();\n\t        if (!self.pendingRemovals && self.pendingRemovalCb) {\n\t          self.pendingRemovalCb();\n\t          self.pendingRemovalCb = null;\n\t        }\n\t      });\n\t    } else if (cb) {\n\t      cb();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Actually swap the components, depending on the\n\t   * transition mode. Defaults to simultaneous.\n\t   *\n\t   * @param {Vue} target\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  transition: function transition(target, cb) {\n\t    var self = this;\n\t    var current = this.childVM;\n\t    // for devtool inspection\n\t    if (current) current._inactive = true;\n\t    target._inactive = false;\n\t    this.childVM = target;\n\t    switch (self.params.transitionMode) {\n\t      case 'in-out':\n\t        target.$before(self.anchor, function () {\n\t          self.remove(current, cb);\n\t        });\n\t        break;\n\t      case 'out-in':\n\t        self.remove(current, function () {\n\t          target.$before(self.anchor, cb);\n\t        });\n\t        break;\n\t      default:\n\t        self.remove(current);\n\t        target.$before(self.anchor, cb);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Unbind.\n\t   */\n\t\n\t  unbind: function unbind() {\n\t    this.invalidatePending();\n\t    // Do not defer cleanup when unbinding\n\t    this.unbuild();\n\t    // destroy all keep-alive cached instances\n\t    if (this.cache) {\n\t      for (var key in this.cache) {\n\t        this.cache[key].$destroy();\n\t      }\n\t      this.cache = null;\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Call activate hooks in order (asynchronous)\n\t *\n\t * @param {Array} hooks\n\t * @param {Vue} vm\n\t * @param {Function} cb\n\t */\n\t\n\tfunction callActivateHooks(hooks, vm, cb) {\n\t  var total = hooks.length;\n\t  var called = 0;\n\t  hooks[0].call(vm, next);\n\t  function next() {\n\t    if (++called >= total) {\n\t      cb();\n\t    } else {\n\t      hooks[called].call(vm, next);\n\t    }\n\t  }\n\t}\n\t\n\tvar propBindingModes = config._propBindingModes;\n\tvar empty = {};\n\t\n\t// regexes\n\tvar identRE$1 = /^[$_a-zA-Z]+[\\w$]*$/;\n\tvar settablePathRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\[[^\\[\\]]+\\])*$/;\n\t\n\t/**\n\t * Compile props on a root element and return\n\t * a props link function.\n\t *\n\t * @param {Element|DocumentFragment} el\n\t * @param {Array} propOptions\n\t * @param {Vue} vm\n\t * @return {Function} propsLinkFn\n\t */\n\t\n\tfunction compileProps(el, propOptions, vm) {\n\t  var props = [];\n\t  var names = Object.keys(propOptions);\n\t  var i = names.length;\n\t  var options, name, attr, value, path, parsed, prop;\n\t  while (i--) {\n\t    name = names[i];\n\t    options = propOptions[name] || empty;\n\t\n\t    if (false) {\n\t      warn('Do not use $data as prop.', vm);\n\t      continue;\n\t    }\n\t\n\t    // props could contain dashes, which will be\n\t    // interpreted as minus calculations by the parser\n\t    // so we need to camelize the path here\n\t    path = camelize(name);\n\t    if (!identRE$1.test(path)) {\n\t      (\"production\") !== 'production' && warn('Invalid prop key: \"' + name + '\". Prop keys ' + 'must be valid identifiers.', vm);\n\t      continue;\n\t    }\n\t\n\t    prop = {\n\t      name: name,\n\t      path: path,\n\t      options: options,\n\t      mode: propBindingModes.ONE_WAY,\n\t      raw: null\n\t    };\n\t\n\t    attr = hyphenate(name);\n\t    // first check dynamic version\n\t    if ((value = getBindAttr(el, attr)) === null) {\n\t      if ((value = getBindAttr(el, attr + '.sync')) !== null) {\n\t        prop.mode = propBindingModes.TWO_WAY;\n\t      } else if ((value = getBindAttr(el, attr + '.once')) !== null) {\n\t        prop.mode = propBindingModes.ONE_TIME;\n\t      }\n\t    }\n\t    if (value !== null) {\n\t      // has dynamic binding!\n\t      prop.raw = value;\n\t      parsed = parseDirective(value);\n\t      value = parsed.expression;\n\t      prop.filters = parsed.filters;\n\t      // check binding type\n\t      if (isLiteral(value) && !parsed.filters) {\n\t        // for expressions containing literal numbers and\n\t        // booleans, there's no need to setup a prop binding,\n\t        // so we can optimize them as a one-time set.\n\t        prop.optimizedLiteral = true;\n\t      } else {\n\t        prop.dynamic = true;\n\t        // check non-settable path for two-way bindings\n\t        if (false) {\n\t          prop.mode = propBindingModes.ONE_WAY;\n\t          warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);\n\t        }\n\t      }\n\t      prop.parentPath = value;\n\t\n\t      // warn required two-way\n\t      if (false) {\n\t        warn('Prop \"' + name + '\" expects a two-way binding type.', vm);\n\t      }\n\t    } else if ((value = getAttr(el, attr)) !== null) {\n\t      // has literal binding!\n\t      prop.raw = value;\n\t    } else if (false) {\n\t      // check possible camelCase prop usage\n\t      var lowerCaseName = path.toLowerCase();\n\t      value = /[A-Z\\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));\n\t      if (value) {\n\t        warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);\n\t      } else if (options.required) {\n\t        // warn missing required\n\t        warn('Missing required prop: ' + name, vm);\n\t      }\n\t    }\n\t    // push prop\n\t    props.push(prop);\n\t  }\n\t  return makePropsLinkFn(props);\n\t}\n\t\n\t/**\n\t * Build a function that applies props to a vm.\n\t *\n\t * @param {Array} props\n\t * @return {Function} propsLinkFn\n\t */\n\t\n\tfunction makePropsLinkFn(props) {\n\t  return function propsLinkFn(vm, scope) {\n\t    // store resolved props info\n\t    vm._props = {};\n\t    var inlineProps = vm.$options.propsData;\n\t    var i = props.length;\n\t    var prop, path, options, value, raw;\n\t    while (i--) {\n\t      prop = props[i];\n\t      raw = prop.raw;\n\t      path = prop.path;\n\t      options = prop.options;\n\t      vm._props[path] = prop;\n\t      if (inlineProps && hasOwn(inlineProps, path)) {\n\t        initProp(vm, prop, inlineProps[path]);\n\t      }if (raw === null) {\n\t        // initialize absent prop\n\t        initProp(vm, prop, undefined);\n\t      } else if (prop.dynamic) {\n\t        // dynamic prop\n\t        if (prop.mode === propBindingModes.ONE_TIME) {\n\t          // one time binding\n\t          value = (scope || vm._context || vm).$get(prop.parentPath);\n\t          initProp(vm, prop, value);\n\t        } else {\n\t          if (vm._context) {\n\t            // dynamic binding\n\t            vm._bindDir({\n\t              name: 'prop',\n\t              def: propDef,\n\t              prop: prop\n\t            }, null, null, scope); // el, host, scope\n\t          } else {\n\t              // root instance\n\t              initProp(vm, prop, vm.$get(prop.parentPath));\n\t            }\n\t        }\n\t      } else if (prop.optimizedLiteral) {\n\t        // optimized literal, cast it and just set once\n\t        var stripped = stripQuotes(raw);\n\t        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;\n\t        initProp(vm, prop, value);\n\t      } else {\n\t        // string literal, but we need to cater for\n\t        // Boolean props with no value, or with same\n\t        // literal value (e.g. disabled=\"disabled\")\n\t        // see https://github.com/vuejs/vue-loader/issues/182\n\t        value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;\n\t        initProp(vm, prop, value);\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Process a prop with a rawValue, applying necessary coersions,\n\t * default values & assertions and call the given callback with\n\t * processed value.\n\t *\n\t * @param {Vue} vm\n\t * @param {Object} prop\n\t * @param {*} rawValue\n\t * @param {Function} fn\n\t */\n\t\n\tfunction processPropValue(vm, prop, rawValue, fn) {\n\t  var isSimple = prop.dynamic && isSimplePath(prop.parentPath);\n\t  var value = rawValue;\n\t  if (value === undefined) {\n\t    value = getPropDefaultValue(vm, prop);\n\t  }\n\t  value = coerceProp(prop, value, vm);\n\t  var coerced = value !== rawValue;\n\t  if (!assertProp(prop, value, vm)) {\n\t    value = undefined;\n\t  }\n\t  if (isSimple && !coerced) {\n\t    withoutConversion(function () {\n\t      fn(value);\n\t    });\n\t  } else {\n\t    fn(value);\n\t  }\n\t}\n\t\n\t/**\n\t * Set a prop's initial value on a vm and its data object.\n\t *\n\t * @param {Vue} vm\n\t * @param {Object} prop\n\t * @param {*} value\n\t */\n\t\n\tfunction initProp(vm, prop, value) {\n\t  processPropValue(vm, prop, value, function (value) {\n\t    defineReactive(vm, prop.path, value);\n\t  });\n\t}\n\t\n\t/**\n\t * Update a prop's value on a vm.\n\t *\n\t * @param {Vue} vm\n\t * @param {Object} prop\n\t * @param {*} value\n\t */\n\t\n\tfunction updateProp(vm, prop, value) {\n\t  processPropValue(vm, prop, value, function (value) {\n\t    vm[prop.path] = value;\n\t  });\n\t}\n\t\n\t/**\n\t * Get the default value of a prop.\n\t *\n\t * @param {Vue} vm\n\t * @param {Object} prop\n\t * @return {*}\n\t */\n\t\n\tfunction getPropDefaultValue(vm, prop) {\n\t  // no default, return undefined\n\t  var options = prop.options;\n\t  if (!hasOwn(options, 'default')) {\n\t    // absent boolean value defaults to false\n\t    return options.type === Boolean ? false : undefined;\n\t  }\n\t  var def = options['default'];\n\t  // warn against non-factory defaults for Object & Array\n\t  if (isObject(def)) {\n\t    (\"production\") !== 'production' && warn('Invalid default value for prop \"' + prop.name + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n\t  }\n\t  // call factory function for non-Function types\n\t  return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;\n\t}\n\t\n\t/**\n\t * Assert whether a prop is valid.\n\t *\n\t * @param {Object} prop\n\t * @param {*} value\n\t * @param {Vue} vm\n\t */\n\t\n\tfunction assertProp(prop, value, vm) {\n\t  if (!prop.options.required && ( // non-required\n\t  prop.raw === null || // abscent\n\t  value == null) // null or undefined\n\t  ) {\n\t      return true;\n\t    }\n\t  var options = prop.options;\n\t  var type = options.type;\n\t  var valid = !type;\n\t  var expectedTypes = [];\n\t  if (type) {\n\t    if (!isArray(type)) {\n\t      type = [type];\n\t    }\n\t    for (var i = 0; i < type.length && !valid; i++) {\n\t      var assertedType = assertType(value, type[i]);\n\t      expectedTypes.push(assertedType.expectedType);\n\t      valid = assertedType.valid;\n\t    }\n\t  }\n\t  if (!valid) {\n\t    if (false) {\n\t      warn('Invalid prop: type check failed for prop \"' + prop.name + '\".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);\n\t    }\n\t    return false;\n\t  }\n\t  var validator = options.validator;\n\t  if (validator) {\n\t    if (!validator(value)) {\n\t      (\"production\") !== 'production' && warn('Invalid prop: custom validator check failed for prop \"' + prop.name + '\".', vm);\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t}\n\t\n\t/**\n\t * Force parsing value with coerce option.\n\t *\n\t * @param {*} value\n\t * @param {Object} options\n\t * @return {*}\n\t */\n\t\n\tfunction coerceProp(prop, value, vm) {\n\t  var coerce = prop.options.coerce;\n\t  if (!coerce) {\n\t    return value;\n\t  }\n\t  if (typeof coerce === 'function') {\n\t    return coerce(value);\n\t  } else {\n\t    (\"production\") !== 'production' && warn('Invalid coerce for prop \"' + prop.name + '\": expected function, got ' + typeof coerce + '.', vm);\n\t    return value;\n\t  }\n\t}\n\t\n\t/**\n\t * Assert the type of a value\n\t *\n\t * @param {*} value\n\t * @param {Function} type\n\t * @return {Object}\n\t */\n\t\n\tfunction assertType(value, type) {\n\t  var valid;\n\t  var expectedType;\n\t  if (type === String) {\n\t    expectedType = 'string';\n\t    valid = typeof value === expectedType;\n\t  } else if (type === Number) {\n\t    expectedType = 'number';\n\t    valid = typeof value === expectedType;\n\t  } else if (type === Boolean) {\n\t    expectedType = 'boolean';\n\t    valid = typeof value === expectedType;\n\t  } else if (type === Function) {\n\t    expectedType = 'function';\n\t    valid = typeof value === expectedType;\n\t  } else if (type === Object) {\n\t    expectedType = 'object';\n\t    valid = isPlainObject(value);\n\t  } else if (type === Array) {\n\t    expectedType = 'array';\n\t    valid = isArray(value);\n\t  } else {\n\t    valid = value instanceof type;\n\t  }\n\t  return {\n\t    valid: valid,\n\t    expectedType: expectedType\n\t  };\n\t}\n\t\n\t/**\n\t * Format type for output\n\t *\n\t * @param {String} type\n\t * @return {String}\n\t */\n\t\n\tfunction formatType(type) {\n\t  return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';\n\t}\n\t\n\t/**\n\t * Format value\n\t *\n\t * @param {*} value\n\t * @return {String}\n\t */\n\t\n\tfunction formatValue(val) {\n\t  return Object.prototype.toString.call(val).slice(8, -1);\n\t}\n\t\n\tvar bindingModes = config._propBindingModes;\n\t\n\tvar propDef = {\n\t\n\t  bind: function bind() {\n\t    var child = this.vm;\n\t    var parent = child._context;\n\t    // passed in from compiler directly\n\t    var prop = this.descriptor.prop;\n\t    var childKey = prop.path;\n\t    var parentKey = prop.parentPath;\n\t    var twoWay = prop.mode === bindingModes.TWO_WAY;\n\t\n\t    var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {\n\t      updateProp(child, prop, val);\n\t    }, {\n\t      twoWay: twoWay,\n\t      filters: prop.filters,\n\t      // important: props need to be observed on the\n\t      // v-for scope if present\n\t      scope: this._scope\n\t    });\n\t\n\t    // set the child initial value.\n\t    initProp(child, prop, parentWatcher.value);\n\t\n\t    // setup two-way binding\n\t    if (twoWay) {\n\t      // important: defer the child watcher creation until\n\t      // the created hook (after data observation)\n\t      var self = this;\n\t      child.$once('pre-hook:created', function () {\n\t        self.childWatcher = new Watcher(child, childKey, function (val) {\n\t          parentWatcher.set(val);\n\t        }, {\n\t          // ensure sync upward before parent sync down.\n\t          // this is necessary in cases e.g. the child\n\t          // mutates a prop array, then replaces it. (#1683)\n\t          sync: true\n\t        });\n\t      });\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    this.parentWatcher.teardown();\n\t    if (this.childWatcher) {\n\t      this.childWatcher.teardown();\n\t    }\n\t  }\n\t};\n\t\n\tvar queue$1 = [];\n\tvar queued = false;\n\t\n\t/**\n\t * Push a job into the queue.\n\t *\n\t * @param {Function} job\n\t */\n\t\n\tfunction pushJob(job) {\n\t  queue$1.push(job);\n\t  if (!queued) {\n\t    queued = true;\n\t    nextTick(flush);\n\t  }\n\t}\n\t\n\t/**\n\t * Flush the queue, and do one forced reflow before\n\t * triggering transitions.\n\t */\n\t\n\tfunction flush() {\n\t  // Force layout\n\t  var f = document.documentElement.offsetHeight;\n\t  for (var i = 0; i < queue$1.length; i++) {\n\t    queue$1[i]();\n\t  }\n\t  queue$1 = [];\n\t  queued = false;\n\t  // dummy return, so js linters don't complain about\n\t  // unused variable f\n\t  return f;\n\t}\n\t\n\tvar TYPE_TRANSITION = 'transition';\n\tvar TYPE_ANIMATION = 'animation';\n\tvar transDurationProp = transitionProp + 'Duration';\n\tvar animDurationProp = animationProp + 'Duration';\n\t\n\t/**\n\t * If a just-entered element is applied the\n\t * leave class while its enter transition hasn't started yet,\n\t * and the transitioned property has the same value for both\n\t * enter/leave, then the leave transition will be skipped and\n\t * the transitionend event never fires. This function ensures\n\t * its callback to be called after a transition has started\n\t * by waiting for double raf.\n\t *\n\t * It falls back to setTimeout on devices that support CSS\n\t * transitions but not raf (e.g. Android 4.2 browser) - since\n\t * these environments are usually slow, we are giving it a\n\t * relatively large timeout.\n\t */\n\t\n\tvar raf = inBrowser && window.requestAnimationFrame;\n\tvar waitForTransitionStart = raf\n\t/* istanbul ignore next */\n\t? function (fn) {\n\t  raf(function () {\n\t    raf(fn);\n\t  });\n\t} : function (fn) {\n\t  setTimeout(fn, 50);\n\t};\n\t\n\t/**\n\t * A Transition object that encapsulates the state and logic\n\t * of the transition.\n\t *\n\t * @param {Element} el\n\t * @param {String} id\n\t * @param {Object} hooks\n\t * @param {Vue} vm\n\t */\n\tfunction Transition(el, id, hooks, vm) {\n\t  this.id = id;\n\t  this.el = el;\n\t  this.enterClass = hooks && hooks.enterClass || id + '-enter';\n\t  this.leaveClass = hooks && hooks.leaveClass || id + '-leave';\n\t  this.hooks = hooks;\n\t  this.vm = vm;\n\t  // async state\n\t  this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;\n\t  this.justEntered = false;\n\t  this.entered = this.left = false;\n\t  this.typeCache = {};\n\t  // check css transition type\n\t  this.type = hooks && hooks.type;\n\t  /* istanbul ignore if */\n\t  if (false) {\n\t    if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {\n\t      warn('invalid CSS transition type for transition=\"' + this.id + '\": ' + this.type, vm);\n\t    }\n\t  }\n\t  // bind\n\t  var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {\n\t    self[m] = bind(self[m], self);\n\t  });\n\t}\n\t\n\tvar p$1 = Transition.prototype;\n\t\n\t/**\n\t * Start an entering transition.\n\t *\n\t * 1. enter transition triggered\n\t * 2. call beforeEnter hook\n\t * 3. add enter class\n\t * 4. insert/show element\n\t * 5. call enter hook (with possible explicit js callback)\n\t * 6. reflow\n\t * 7. based on transition type:\n\t *    - transition:\n\t *        remove class now, wait for transitionend,\n\t *        then done if there's no explicit js callback.\n\t *    - animation:\n\t *        wait for animationend, remove class,\n\t *        then done if there's no explicit js callback.\n\t *    - no css transition:\n\t *        done now if there's no explicit js callback.\n\t * 8. wait for either done or js callback, then call\n\t *    afterEnter hook.\n\t *\n\t * @param {Function} op - insert/show the element\n\t * @param {Function} [cb]\n\t */\n\t\n\tp$1.enter = function (op, cb) {\n\t  this.cancelPending();\n\t  this.callHook('beforeEnter');\n\t  this.cb = cb;\n\t  addClass(this.el, this.enterClass);\n\t  op();\n\t  this.entered = false;\n\t  this.callHookWithCb('enter');\n\t  if (this.entered) {\n\t    return; // user called done synchronously.\n\t  }\n\t  this.cancel = this.hooks && this.hooks.enterCancelled;\n\t  pushJob(this.enterNextTick);\n\t};\n\t\n\t/**\n\t * The \"nextTick\" phase of an entering transition, which is\n\t * to be pushed into a queue and executed after a reflow so\n\t * that removing the class can trigger a CSS transition.\n\t */\n\t\n\tp$1.enterNextTick = function () {\n\t  var _this = this;\n\t\n\t  // prevent transition skipping\n\t  this.justEntered = true;\n\t  waitForTransitionStart(function () {\n\t    _this.justEntered = false;\n\t  });\n\t  var enterDone = this.enterDone;\n\t  var type = this.getCssTransitionType(this.enterClass);\n\t  if (!this.pendingJsCb) {\n\t    if (type === TYPE_TRANSITION) {\n\t      // trigger transition by removing enter class now\n\t      removeClass(this.el, this.enterClass);\n\t      this.setupCssCb(transitionEndEvent, enterDone);\n\t    } else if (type === TYPE_ANIMATION) {\n\t      this.setupCssCb(animationEndEvent, enterDone);\n\t    } else {\n\t      enterDone();\n\t    }\n\t  } else if (type === TYPE_TRANSITION) {\n\t    removeClass(this.el, this.enterClass);\n\t  }\n\t};\n\t\n\t/**\n\t * The \"cleanup\" phase of an entering transition.\n\t */\n\t\n\tp$1.enterDone = function () {\n\t  this.entered = true;\n\t  this.cancel = this.pendingJsCb = null;\n\t  removeClass(this.el, this.enterClass);\n\t  this.callHook('afterEnter');\n\t  if (this.cb) this.cb();\n\t};\n\t\n\t/**\n\t * Start a leaving transition.\n\t *\n\t * 1. leave transition triggered.\n\t * 2. call beforeLeave hook\n\t * 3. add leave class (trigger css transition)\n\t * 4. call leave hook (with possible explicit js callback)\n\t * 5. reflow if no explicit js callback is provided\n\t * 6. based on transition type:\n\t *    - transition or animation:\n\t *        wait for end event, remove class, then done if\n\t *        there's no explicit js callback.\n\t *    - no css transition:\n\t *        done if there's no explicit js callback.\n\t * 7. wait for either done or js callback, then call\n\t *    afterLeave hook.\n\t *\n\t * @param {Function} op - remove/hide the element\n\t * @param {Function} [cb]\n\t */\n\t\n\tp$1.leave = function (op, cb) {\n\t  this.cancelPending();\n\t  this.callHook('beforeLeave');\n\t  this.op = op;\n\t  this.cb = cb;\n\t  addClass(this.el, this.leaveClass);\n\t  this.left = false;\n\t  this.callHookWithCb('leave');\n\t  if (this.left) {\n\t    return; // user called done synchronously.\n\t  }\n\t  this.cancel = this.hooks && this.hooks.leaveCancelled;\n\t  // only need to handle leaveDone if\n\t  // 1. the transition is already done (synchronously called\n\t  //    by the user, which causes this.op set to null)\n\t  // 2. there's no explicit js callback\n\t  if (this.op && !this.pendingJsCb) {\n\t    // if a CSS transition leaves immediately after enter,\n\t    // the transitionend event never fires. therefore we\n\t    // detect such cases and end the leave immediately.\n\t    if (this.justEntered) {\n\t      this.leaveDone();\n\t    } else {\n\t      pushJob(this.leaveNextTick);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * The \"nextTick\" phase of a leaving transition.\n\t */\n\t\n\tp$1.leaveNextTick = function () {\n\t  var type = this.getCssTransitionType(this.leaveClass);\n\t  if (type) {\n\t    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;\n\t    this.setupCssCb(event, this.leaveDone);\n\t  } else {\n\t    this.leaveDone();\n\t  }\n\t};\n\t\n\t/**\n\t * The \"cleanup\" phase of a leaving transition.\n\t */\n\t\n\tp$1.leaveDone = function () {\n\t  this.left = true;\n\t  this.cancel = this.pendingJsCb = null;\n\t  this.op();\n\t  removeClass(this.el, this.leaveClass);\n\t  this.callHook('afterLeave');\n\t  if (this.cb) this.cb();\n\t  this.op = null;\n\t};\n\t\n\t/**\n\t * Cancel any pending callbacks from a previously running\n\t * but not finished transition.\n\t */\n\t\n\tp$1.cancelPending = function () {\n\t  this.op = this.cb = null;\n\t  var hasPending = false;\n\t  if (this.pendingCssCb) {\n\t    hasPending = true;\n\t    off(this.el, this.pendingCssEvent, this.pendingCssCb);\n\t    this.pendingCssEvent = this.pendingCssCb = null;\n\t  }\n\t  if (this.pendingJsCb) {\n\t    hasPending = true;\n\t    this.pendingJsCb.cancel();\n\t    this.pendingJsCb = null;\n\t  }\n\t  if (hasPending) {\n\t    removeClass(this.el, this.enterClass);\n\t    removeClass(this.el, this.leaveClass);\n\t  }\n\t  if (this.cancel) {\n\t    this.cancel.call(this.vm, this.el);\n\t    this.cancel = null;\n\t  }\n\t};\n\t\n\t/**\n\t * Call a user-provided synchronous hook function.\n\t *\n\t * @param {String} type\n\t */\n\t\n\tp$1.callHook = function (type) {\n\t  if (this.hooks && this.hooks[type]) {\n\t    this.hooks[type].call(this.vm, this.el);\n\t  }\n\t};\n\t\n\t/**\n\t * Call a user-provided, potentially-async hook function.\n\t * We check for the length of arguments to see if the hook\n\t * expects a `done` callback. If true, the transition's end\n\t * will be determined by when the user calls that callback;\n\t * otherwise, the end is determined by the CSS transition or\n\t * animation.\n\t *\n\t * @param {String} type\n\t */\n\t\n\tp$1.callHookWithCb = function (type) {\n\t  var hook = this.hooks && this.hooks[type];\n\t  if (hook) {\n\t    if (hook.length > 1) {\n\t      this.pendingJsCb = cancellable(this[type + 'Done']);\n\t    }\n\t    hook.call(this.vm, this.el, this.pendingJsCb);\n\t  }\n\t};\n\t\n\t/**\n\t * Get an element's transition type based on the\n\t * calculated styles.\n\t *\n\t * @param {String} className\n\t * @return {Number}\n\t */\n\t\n\tp$1.getCssTransitionType = function (className) {\n\t  /* istanbul ignore if */\n\t  if (!transitionEndEvent ||\n\t  // skip CSS transitions if page is not visible -\n\t  // this solves the issue of transitionend events not\n\t  // firing until the page is visible again.\n\t  // pageVisibility API is supported in IE10+, same as\n\t  // CSS transitions.\n\t  document.hidden ||\n\t  // explicit js-only transition\n\t  this.hooks && this.hooks.css === false ||\n\t  // element is hidden\n\t  isHidden(this.el)) {\n\t    return;\n\t  }\n\t  var type = this.type || this.typeCache[className];\n\t  if (type) return type;\n\t  var inlineStyles = this.el.style;\n\t  var computedStyles = window.getComputedStyle(this.el);\n\t  var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];\n\t  if (transDuration && transDuration !== '0s') {\n\t    type = TYPE_TRANSITION;\n\t  } else {\n\t    var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];\n\t    if (animDuration && animDuration !== '0s') {\n\t      type = TYPE_ANIMATION;\n\t    }\n\t  }\n\t  if (type) {\n\t    this.typeCache[className] = type;\n\t  }\n\t  return type;\n\t};\n\t\n\t/**\n\t * Setup a CSS transitionend/animationend callback.\n\t *\n\t * @param {String} event\n\t * @param {Function} cb\n\t */\n\t\n\tp$1.setupCssCb = function (event, cb) {\n\t  this.pendingCssEvent = event;\n\t  var self = this;\n\t  var el = this.el;\n\t  var onEnd = this.pendingCssCb = function (e) {\n\t    if (e.target === el) {\n\t      off(el, event, onEnd);\n\t      self.pendingCssEvent = self.pendingCssCb = null;\n\t      if (!self.pendingJsCb && cb) {\n\t        cb();\n\t      }\n\t    }\n\t  };\n\t  on(el, event, onEnd);\n\t};\n\t\n\t/**\n\t * Check if an element is hidden - in that case we can just\n\t * skip the transition alltogether.\n\t *\n\t * @param {Element} el\n\t * @return {Boolean}\n\t */\n\t\n\tfunction isHidden(el) {\n\t  if (/svg$/.test(el.namespaceURI)) {\n\t    // SVG elements do not have offset(Width|Height)\n\t    // so we need to check the client rect\n\t    var rect = el.getBoundingClientRect();\n\t    return !(rect.width || rect.height);\n\t  } else {\n\t    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\n\t  }\n\t}\n\t\n\tvar transition$1 = {\n\t\n\t  priority: TRANSITION,\n\t\n\t  update: function update(id, oldId) {\n\t    var el = this.el;\n\t    // resolve on owner vm\n\t    var hooks = resolveAsset(this.vm.$options, 'transitions', id);\n\t    id = id || 'v';\n\t    oldId = oldId || 'v';\n\t    el.__v_trans = new Transition(el, id, hooks, this.vm);\n\t    removeClass(el, oldId + '-transition');\n\t    addClass(el, id + '-transition');\n\t  }\n\t};\n\t\n\tvar internalDirectives = {\n\t  style: style,\n\t  'class': vClass,\n\t  component: component,\n\t  prop: propDef,\n\t  transition: transition$1\n\t};\n\t\n\t// special binding prefixes\n\tvar bindRE = /^v-bind:|^:/;\n\tvar onRE = /^v-on:|^@/;\n\tvar dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;\n\tvar modifierRE = /\\.[^\\.]+/g;\n\tvar transitionRE = /^(v-bind:|:)?transition$/;\n\t\n\t// default directive priority\n\tvar DEFAULT_PRIORITY = 1000;\n\tvar DEFAULT_TERMINAL_PRIORITY = 2000;\n\t\n\t/**\n\t * Compile a template and return a reusable composite link\n\t * function, which recursively contains more link functions\n\t * inside. This top level compile function would normally\n\t * be called on instance root nodes, but can also be used\n\t * for partial compilation if the partial argument is true.\n\t *\n\t * The returned composite link function, when called, will\n\t * return an unlink function that tearsdown all directives\n\t * created during the linking phase.\n\t *\n\t * @param {Element|DocumentFragment} el\n\t * @param {Object} options\n\t * @param {Boolean} partial\n\t * @return {Function}\n\t */\n\t\n\tfunction compile(el, options, partial) {\n\t  // link function for the node itself.\n\t  var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;\n\t  // link function for the childNodes\n\t  var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && !isScript(el) && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;\n\t\n\t  /**\n\t   * A composite linker function to be called on a already\n\t   * compiled piece of DOM, which instantiates all directive\n\t   * instances.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {Element|DocumentFragment} el\n\t   * @param {Vue} [host] - host vm of transcluded content\n\t   * @param {Object} [scope] - v-for scope\n\t   * @param {Fragment} [frag] - link context fragment\n\t   * @return {Function|undefined}\n\t   */\n\t\n\t  return function compositeLinkFn(vm, el, host, scope, frag) {\n\t    // cache childNodes before linking parent, fix #657\n\t    var childNodes = toArray(el.childNodes);\n\t    // link\n\t    var dirs = linkAndCapture(function compositeLinkCapturer() {\n\t      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);\n\t      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);\n\t    }, vm);\n\t    return makeUnlinkFn(vm, dirs);\n\t  };\n\t}\n\t\n\t/**\n\t * Apply a linker to a vm/element pair and capture the\n\t * directives created during the process.\n\t *\n\t * @param {Function} linker\n\t * @param {Vue} vm\n\t */\n\t\n\tfunction linkAndCapture(linker, vm) {\n\t  /* istanbul ignore if */\n\t  if (true) {\n\t    // reset directives before every capture in production\n\t    // mode, so that when unlinking we don't need to splice\n\t    // them out (which turns out to be a perf hit).\n\t    // they are kept in development mode because they are\n\t    // useful for Vue's own tests.\n\t    vm._directives = [];\n\t  }\n\t  var originalDirCount = vm._directives.length;\n\t  linker();\n\t  var dirs = vm._directives.slice(originalDirCount);\n\t  dirs.sort(directiveComparator);\n\t  for (var i = 0, l = dirs.length; i < l; i++) {\n\t    dirs[i]._bind();\n\t  }\n\t  return dirs;\n\t}\n\t\n\t/**\n\t * Directive priority sort comparator\n\t *\n\t * @param {Object} a\n\t * @param {Object} b\n\t */\n\t\n\tfunction directiveComparator(a, b) {\n\t  a = a.descriptor.def.priority || DEFAULT_PRIORITY;\n\t  b = b.descriptor.def.priority || DEFAULT_PRIORITY;\n\t  return a > b ? -1 : a === b ? 0 : 1;\n\t}\n\t\n\t/**\n\t * Linker functions return an unlink function that\n\t * tearsdown all directives instances generated during\n\t * the process.\n\t *\n\t * We create unlink functions with only the necessary\n\t * information to avoid retaining additional closures.\n\t *\n\t * @param {Vue} vm\n\t * @param {Array} dirs\n\t * @param {Vue} [context]\n\t * @param {Array} [contextDirs]\n\t * @return {Function}\n\t */\n\t\n\tfunction makeUnlinkFn(vm, dirs, context, contextDirs) {\n\t  function unlink(destroying) {\n\t    teardownDirs(vm, dirs, destroying);\n\t    if (context && contextDirs) {\n\t      teardownDirs(context, contextDirs);\n\t    }\n\t  }\n\t  // expose linked directives\n\t  unlink.dirs = dirs;\n\t  return unlink;\n\t}\n\t\n\t/**\n\t * Teardown partial linked directives.\n\t *\n\t * @param {Vue} vm\n\t * @param {Array} dirs\n\t * @param {Boolean} destroying\n\t */\n\t\n\tfunction teardownDirs(vm, dirs, destroying) {\n\t  var i = dirs.length;\n\t  while (i--) {\n\t    dirs[i]._teardown();\n\t    if (false) {\n\t      vm._directives.$remove(dirs[i]);\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Compile link props on an instance.\n\t *\n\t * @param {Vue} vm\n\t * @param {Element} el\n\t * @param {Object} props\n\t * @param {Object} [scope]\n\t * @return {Function}\n\t */\n\t\n\tfunction compileAndLinkProps(vm, el, props, scope) {\n\t  var propsLinkFn = compileProps(el, props, vm);\n\t  var propDirs = linkAndCapture(function () {\n\t    propsLinkFn(vm, scope);\n\t  }, vm);\n\t  return makeUnlinkFn(vm, propDirs);\n\t}\n\t\n\t/**\n\t * Compile the root element of an instance.\n\t *\n\t * 1. attrs on context container (context scope)\n\t * 2. attrs on the component template root node, if\n\t *    replace:true (child scope)\n\t *\n\t * If this is a fragment instance, we only need to compile 1.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @param {Object} contextOptions\n\t * @return {Function}\n\t */\n\t\n\tfunction compileRoot(el, options, contextOptions) {\n\t  var containerAttrs = options._containerAttrs;\n\t  var replacerAttrs = options._replacerAttrs;\n\t  var contextLinkFn, replacerLinkFn;\n\t\n\t  // only need to compile other attributes for\n\t  // non-fragment instances\n\t  if (el.nodeType !== 11) {\n\t    // for components, container and replacer need to be\n\t    // compiled separately and linked in different scopes.\n\t    if (options._asComponent) {\n\t      // 2. container attributes\n\t      if (containerAttrs && contextOptions) {\n\t        contextLinkFn = compileDirectives(containerAttrs, contextOptions);\n\t      }\n\t      if (replacerAttrs) {\n\t        // 3. replacer attributes\n\t        replacerLinkFn = compileDirectives(replacerAttrs, options);\n\t      }\n\t    } else {\n\t      // non-component, just compile as a normal element.\n\t      replacerLinkFn = compileDirectives(el.attributes, options);\n\t    }\n\t  } else if (false) {\n\t    // warn container directives for fragment instances\n\t    var names = containerAttrs.filter(function (attr) {\n\t      // allow vue-loader/vueify scoped css attributes\n\t      return attr.name.indexOf('_v-') < 0 &&\n\t      // allow event listeners\n\t      !onRE.test(attr.name) &&\n\t      // allow slots\n\t      attr.name !== 'slot';\n\t    }).map(function (attr) {\n\t      return '\"' + attr.name + '\"';\n\t    });\n\t    if (names.length) {\n\t      var plural = names.length > 1;\n\t      warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment-Instance');\n\t    }\n\t  }\n\t\n\t  options._containerAttrs = options._replacerAttrs = null;\n\t  return function rootLinkFn(vm, el, scope) {\n\t    // link context scope dirs\n\t    var context = vm._context;\n\t    var contextDirs;\n\t    if (context && contextLinkFn) {\n\t      contextDirs = linkAndCapture(function () {\n\t        contextLinkFn(context, el, null, scope);\n\t      }, context);\n\t    }\n\t\n\t    // link self\n\t    var selfDirs = linkAndCapture(function () {\n\t      if (replacerLinkFn) replacerLinkFn(vm, el);\n\t    }, vm);\n\t\n\t    // return the unlink function that tearsdown context\n\t    // container directives.\n\t    return makeUnlinkFn(vm, selfDirs, context, contextDirs);\n\t  };\n\t}\n\t\n\t/**\n\t * Compile a node and return a nodeLinkFn based on the\n\t * node type.\n\t *\n\t * @param {Node} node\n\t * @param {Object} options\n\t * @return {Function|null}\n\t */\n\t\n\tfunction compileNode(node, options) {\n\t  var type = node.nodeType;\n\t  if (type === 1 && !isScript(node)) {\n\t    return compileElement(node, options);\n\t  } else if (type === 3 && node.data.trim()) {\n\t    return compileTextNode(node, options);\n\t  } else {\n\t    return null;\n\t  }\n\t}\n\t\n\t/**\n\t * Compile an element and return a nodeLinkFn.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @return {Function|null}\n\t */\n\t\n\tfunction compileElement(el, options) {\n\t  // preprocess textareas.\n\t  // textarea treats its text content as the initial value.\n\t  // just bind it as an attr directive for value.\n\t  if (el.tagName === 'TEXTAREA') {\n\t    var tokens = parseText(el.value);\n\t    if (tokens) {\n\t      el.setAttribute(':value', tokensToExp(tokens));\n\t      el.value = '';\n\t    }\n\t  }\n\t  var linkFn;\n\t  var hasAttrs = el.hasAttributes();\n\t  var attrs = hasAttrs && toArray(el.attributes);\n\t  // check terminal directives (for & if)\n\t  if (hasAttrs) {\n\t    linkFn = checkTerminalDirectives(el, attrs, options);\n\t  }\n\t  // check element directives\n\t  if (!linkFn) {\n\t    linkFn = checkElementDirectives(el, options);\n\t  }\n\t  // check component\n\t  if (!linkFn) {\n\t    linkFn = checkComponent(el, options);\n\t  }\n\t  // normal directives\n\t  if (!linkFn && hasAttrs) {\n\t    linkFn = compileDirectives(attrs, options);\n\t  }\n\t  return linkFn;\n\t}\n\t\n\t/**\n\t * Compile a textNode and return a nodeLinkFn.\n\t *\n\t * @param {TextNode} node\n\t * @param {Object} options\n\t * @return {Function|null} textNodeLinkFn\n\t */\n\t\n\tfunction compileTextNode(node, options) {\n\t  // skip marked text nodes\n\t  if (node._skip) {\n\t    return removeText;\n\t  }\n\t\n\t  var tokens = parseText(node.wholeText);\n\t  if (!tokens) {\n\t    return null;\n\t  }\n\t\n\t  // mark adjacent text nodes as skipped,\n\t  // because we are using node.wholeText to compile\n\t  // all adjacent text nodes together. This fixes\n\t  // issues in IE where sometimes it splits up a single\n\t  // text node into multiple ones.\n\t  var next = node.nextSibling;\n\t  while (next && next.nodeType === 3) {\n\t    next._skip = true;\n\t    next = next.nextSibling;\n\t  }\n\t\n\t  var frag = document.createDocumentFragment();\n\t  var el, token;\n\t  for (var i = 0, l = tokens.length; i < l; i++) {\n\t    token = tokens[i];\n\t    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);\n\t    frag.appendChild(el);\n\t  }\n\t  return makeTextNodeLinkFn(tokens, frag, options);\n\t}\n\t\n\t/**\n\t * Linker for an skipped text node.\n\t *\n\t * @param {Vue} vm\n\t * @param {Text} node\n\t */\n\t\n\tfunction removeText(vm, node) {\n\t  remove(node);\n\t}\n\t\n\t/**\n\t * Process a single text token.\n\t *\n\t * @param {Object} token\n\t * @param {Object} options\n\t * @return {Node}\n\t */\n\t\n\tfunction processTextToken(token, options) {\n\t  var el;\n\t  if (token.oneTime) {\n\t    el = document.createTextNode(token.value);\n\t  } else {\n\t    if (token.html) {\n\t      el = document.createComment('v-html');\n\t      setTokenType('html');\n\t    } else {\n\t      // IE will clean up empty textNodes during\n\t      // frag.cloneNode(true), so we have to give it\n\t      // something here...\n\t      el = document.createTextNode(' ');\n\t      setTokenType('text');\n\t    }\n\t  }\n\t  function setTokenType(type) {\n\t    if (token.descriptor) return;\n\t    var parsed = parseDirective(token.value);\n\t    token.descriptor = {\n\t      name: type,\n\t      def: directives[type],\n\t      expression: parsed.expression,\n\t      filters: parsed.filters\n\t    };\n\t  }\n\t  return el;\n\t}\n\t\n\t/**\n\t * Build a function that processes a textNode.\n\t *\n\t * @param {Array<Object>} tokens\n\t * @param {DocumentFragment} frag\n\t */\n\t\n\tfunction makeTextNodeLinkFn(tokens, frag) {\n\t  return function textNodeLinkFn(vm, el, host, scope) {\n\t    var fragClone = frag.cloneNode(true);\n\t    var childNodes = toArray(fragClone.childNodes);\n\t    var token, value, node;\n\t    for (var i = 0, l = tokens.length; i < l; i++) {\n\t      token = tokens[i];\n\t      value = token.value;\n\t      if (token.tag) {\n\t        node = childNodes[i];\n\t        if (token.oneTime) {\n\t          value = (scope || vm).$eval(value);\n\t          if (token.html) {\n\t            replace(node, parseTemplate(value, true));\n\t          } else {\n\t            node.data = _toString(value);\n\t          }\n\t        } else {\n\t          vm._bindDir(token.descriptor, node, host, scope);\n\t        }\n\t      }\n\t    }\n\t    replace(el, fragClone);\n\t  };\n\t}\n\t\n\t/**\n\t * Compile a node list and return a childLinkFn.\n\t *\n\t * @param {NodeList} nodeList\n\t * @param {Object} options\n\t * @return {Function|undefined}\n\t */\n\t\n\tfunction compileNodeList(nodeList, options) {\n\t  var linkFns = [];\n\t  var nodeLinkFn, childLinkFn, node;\n\t  for (var i = 0, l = nodeList.length; i < l; i++) {\n\t    node = nodeList[i];\n\t    nodeLinkFn = compileNode(node, options);\n\t    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;\n\t    linkFns.push(nodeLinkFn, childLinkFn);\n\t  }\n\t  return linkFns.length ? makeChildLinkFn(linkFns) : null;\n\t}\n\t\n\t/**\n\t * Make a child link function for a node's childNodes.\n\t *\n\t * @param {Array<Function>} linkFns\n\t * @return {Function} childLinkFn\n\t */\n\t\n\tfunction makeChildLinkFn(linkFns) {\n\t  return function childLinkFn(vm, nodes, host, scope, frag) {\n\t    var node, nodeLinkFn, childrenLinkFn;\n\t    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {\n\t      node = nodes[n];\n\t      nodeLinkFn = linkFns[i++];\n\t      childrenLinkFn = linkFns[i++];\n\t      // cache childNodes before linking parent, fix #657\n\t      var childNodes = toArray(node.childNodes);\n\t      if (nodeLinkFn) {\n\t        nodeLinkFn(vm, node, host, scope, frag);\n\t      }\n\t      if (childrenLinkFn) {\n\t        childrenLinkFn(vm, childNodes, host, scope, frag);\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Check for element directives (custom elements that should\n\t * be resovled as terminal directives).\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t */\n\t\n\tfunction checkElementDirectives(el, options) {\n\t  var tag = el.tagName.toLowerCase();\n\t  if (commonTagRE.test(tag)) {\n\t    return;\n\t  }\n\t  var def = resolveAsset(options, 'elementDirectives', tag);\n\t  if (def) {\n\t    return makeTerminalNodeLinkFn(el, tag, '', options, def);\n\t  }\n\t}\n\t\n\t/**\n\t * Check if an element is a component. If yes, return\n\t * a component link function.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @return {Function|undefined}\n\t */\n\t\n\tfunction checkComponent(el, options) {\n\t  var component = checkComponentAttr(el, options);\n\t  if (component) {\n\t    var ref = findRef(el);\n\t    var descriptor = {\n\t      name: 'component',\n\t      ref: ref,\n\t      expression: component.id,\n\t      def: internalDirectives.component,\n\t      modifiers: {\n\t        literal: !component.dynamic\n\t      }\n\t    };\n\t    var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {\n\t      if (ref) {\n\t        defineReactive((scope || vm).$refs, ref, null);\n\t      }\n\t      vm._bindDir(descriptor, el, host, scope, frag);\n\t    };\n\t    componentLinkFn.terminal = true;\n\t    return componentLinkFn;\n\t  }\n\t}\n\t\n\t/**\n\t * Check an element for terminal directives in fixed order.\n\t * If it finds one, return a terminal link function.\n\t *\n\t * @param {Element} el\n\t * @param {Array} attrs\n\t * @param {Object} options\n\t * @return {Function} terminalLinkFn\n\t */\n\t\n\tfunction checkTerminalDirectives(el, attrs, options) {\n\t  // skip v-pre\n\t  if (getAttr(el, 'v-pre') !== null) {\n\t    return skip;\n\t  }\n\t  // skip v-else block, but only if following v-if\n\t  if (el.hasAttribute('v-else')) {\n\t    var prev = el.previousElementSibling;\n\t    if (prev && prev.hasAttribute('v-if')) {\n\t      return skip;\n\t    }\n\t  }\n\t\n\t  var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;\n\t  for (var i = 0, j = attrs.length; i < j; i++) {\n\t    attr = attrs[i];\n\t    name = attr.name.replace(modifierRE, '');\n\t    if (matched = name.match(dirAttrRE)) {\n\t      def = resolveAsset(options, 'directives', matched[1]);\n\t      if (def && def.terminal) {\n\t        if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {\n\t          termDef = def;\n\t          rawName = attr.name;\n\t          modifiers = parseModifiers(attr.name);\n\t          value = attr.value;\n\t          dirName = matched[1];\n\t          arg = matched[2];\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  if (termDef) {\n\t    return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);\n\t  }\n\t}\n\t\n\tfunction skip() {}\n\tskip.terminal = true;\n\t\n\t/**\n\t * Build a node link function for a terminal directive.\n\t * A terminal link function terminates the current\n\t * compilation recursion and handles compilation of the\n\t * subtree in the directive.\n\t *\n\t * @param {Element} el\n\t * @param {String} dirName\n\t * @param {String} value\n\t * @param {Object} options\n\t * @param {Object} def\n\t * @param {String} [rawName]\n\t * @param {String} [arg]\n\t * @param {Object} [modifiers]\n\t * @return {Function} terminalLinkFn\n\t */\n\t\n\tfunction makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {\n\t  var parsed = parseDirective(value);\n\t  var descriptor = {\n\t    name: dirName,\n\t    arg: arg,\n\t    expression: parsed.expression,\n\t    filters: parsed.filters,\n\t    raw: value,\n\t    attr: rawName,\n\t    modifiers: modifiers,\n\t    def: def\n\t  };\n\t  // check ref for v-for and router-view\n\t  if (dirName === 'for' || dirName === 'router-view') {\n\t    descriptor.ref = findRef(el);\n\t  }\n\t  var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {\n\t    if (descriptor.ref) {\n\t      defineReactive((scope || vm).$refs, descriptor.ref, null);\n\t    }\n\t    vm._bindDir(descriptor, el, host, scope, frag);\n\t  };\n\t  fn.terminal = true;\n\t  return fn;\n\t}\n\t\n\t/**\n\t * Compile the directives on an element and return a linker.\n\t *\n\t * @param {Array|NamedNodeMap} attrs\n\t * @param {Object} options\n\t * @return {Function}\n\t */\n\t\n\tfunction compileDirectives(attrs, options) {\n\t  var i = attrs.length;\n\t  var dirs = [];\n\t  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;\n\t  while (i--) {\n\t    attr = attrs[i];\n\t    name = rawName = attr.name;\n\t    value = rawValue = attr.value;\n\t    tokens = parseText(value);\n\t    // reset arg\n\t    arg = null;\n\t    // check modifiers\n\t    modifiers = parseModifiers(name);\n\t    name = name.replace(modifierRE, '');\n\t\n\t    // attribute interpolations\n\t    if (tokens) {\n\t      value = tokensToExp(tokens);\n\t      arg = name;\n\t      pushDir('bind', directives.bind, tokens);\n\t      // warn against mixing mustaches with v-bind\n\t      if (false) {\n\t        if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {\n\t          return attr.name === ':class' || attr.name === 'v-bind:class';\n\t        })) {\n\t          warn('class=\"' + rawValue + '\": Do not mix mustache interpolation ' + 'and v-bind for \"class\" on the same element. Use one or the other.', options);\n\t        }\n\t      }\n\t    } else\n\t\n\t      // special attribute: transition\n\t      if (transitionRE.test(name)) {\n\t        modifiers.literal = !bindRE.test(name);\n\t        pushDir('transition', internalDirectives.transition);\n\t      } else\n\t\n\t        // event handlers\n\t        if (onRE.test(name)) {\n\t          arg = name.replace(onRE, '');\n\t          pushDir('on', directives.on);\n\t        } else\n\t\n\t          // attribute bindings\n\t          if (bindRE.test(name)) {\n\t            dirName = name.replace(bindRE, '');\n\t            if (dirName === 'style' || dirName === 'class') {\n\t              pushDir(dirName, internalDirectives[dirName]);\n\t            } else {\n\t              arg = dirName;\n\t              pushDir('bind', directives.bind);\n\t            }\n\t          } else\n\t\n\t            // normal directives\n\t            if (matched = name.match(dirAttrRE)) {\n\t              dirName = matched[1];\n\t              arg = matched[2];\n\t\n\t              // skip v-else (when used with v-show)\n\t              if (dirName === 'else') {\n\t                continue;\n\t              }\n\t\n\t              dirDef = resolveAsset(options, 'directives', dirName, true);\n\t              if (dirDef) {\n\t                pushDir(dirName, dirDef);\n\t              }\n\t            }\n\t  }\n\t\n\t  /**\n\t   * Push a directive.\n\t   *\n\t   * @param {String} dirName\n\t   * @param {Object|Function} def\n\t   * @param {Array} [interpTokens]\n\t   */\n\t\n\t  function pushDir(dirName, def, interpTokens) {\n\t    var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);\n\t    var parsed = !hasOneTimeToken && parseDirective(value);\n\t    dirs.push({\n\t      name: dirName,\n\t      attr: rawName,\n\t      raw: rawValue,\n\t      def: def,\n\t      arg: arg,\n\t      modifiers: modifiers,\n\t      // conversion from interpolation strings with one-time token\n\t      // to expression is differed until directive bind time so that we\n\t      // have access to the actual vm context for one-time bindings.\n\t      expression: parsed && parsed.expression,\n\t      filters: parsed && parsed.filters,\n\t      interp: interpTokens,\n\t      hasOneTime: hasOneTimeToken\n\t    });\n\t  }\n\t\n\t  if (dirs.length) {\n\t    return makeNodeLinkFn(dirs);\n\t  }\n\t}\n\t\n\t/**\n\t * Parse modifiers from directive attribute name.\n\t *\n\t * @param {String} name\n\t * @return {Object}\n\t */\n\t\n\tfunction parseModifiers(name) {\n\t  var res = Object.create(null);\n\t  var match = name.match(modifierRE);\n\t  if (match) {\n\t    var i = match.length;\n\t    while (i--) {\n\t      res[match[i].slice(1)] = true;\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\t/**\n\t * Build a link function for all directives on a single node.\n\t *\n\t * @param {Array} directives\n\t * @return {Function} directivesLinkFn\n\t */\n\t\n\tfunction makeNodeLinkFn(directives) {\n\t  return function nodeLinkFn(vm, el, host, scope, frag) {\n\t    // reverse apply because it's sorted low to high\n\t    var i = directives.length;\n\t    while (i--) {\n\t      vm._bindDir(directives[i], el, host, scope, frag);\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Check if an interpolation string contains one-time tokens.\n\t *\n\t * @param {Array} tokens\n\t * @return {Boolean}\n\t */\n\t\n\tfunction hasOneTime(tokens) {\n\t  var i = tokens.length;\n\t  while (i--) {\n\t    if (tokens[i].oneTime) return true;\n\t  }\n\t}\n\t\n\tfunction isScript(el) {\n\t  return el.tagName === 'SCRIPT' && (!el.hasAttribute('type') || el.getAttribute('type') === 'text/javascript');\n\t}\n\t\n\tvar specialCharRE = /[^\\w\\-:\\.]/;\n\t\n\t/**\n\t * Process an element or a DocumentFragment based on a\n\t * instance option object. This allows us to transclude\n\t * a template node/fragment before the instance is created,\n\t * so the processed fragment can then be cloned and reused\n\t * in v-for.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @return {Element|DocumentFragment}\n\t */\n\t\n\tfunction transclude(el, options) {\n\t  // extract container attributes to pass them down\n\t  // to compiler, because they need to be compiled in\n\t  // parent scope. we are mutating the options object here\n\t  // assuming the same object will be used for compile\n\t  // right after this.\n\t  if (options) {\n\t    options._containerAttrs = extractAttrs(el);\n\t  }\n\t  // for template tags, what we want is its content as\n\t  // a documentFragment (for fragment instances)\n\t  if (isTemplate(el)) {\n\t    el = parseTemplate(el);\n\t  }\n\t  if (options) {\n\t    if (options._asComponent && !options.template) {\n\t      options.template = '<slot></slot>';\n\t    }\n\t    if (options.template) {\n\t      options._content = extractContent(el);\n\t      el = transcludeTemplate(el, options);\n\t    }\n\t  }\n\t  if (isFragment(el)) {\n\t    // anchors for fragment instance\n\t    // passing in `persist: true` to avoid them being\n\t    // discarded by IE during template cloning\n\t    prepend(createAnchor('v-start', true), el);\n\t    el.appendChild(createAnchor('v-end', true));\n\t  }\n\t  return el;\n\t}\n\t\n\t/**\n\t * Process the template option.\n\t * If the replace option is true this will swap the $el.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @return {Element|DocumentFragment}\n\t */\n\t\n\tfunction transcludeTemplate(el, options) {\n\t  var template = options.template;\n\t  var frag = parseTemplate(template, true);\n\t  if (frag) {\n\t    var replacer = frag.firstChild;\n\t    var tag = replacer.tagName && replacer.tagName.toLowerCase();\n\t    if (options.replace) {\n\t      /* istanbul ignore if */\n\t      if (el === document.body) {\n\t        (\"production\") !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');\n\t      }\n\t      // there are many cases where the instance must\n\t      // become a fragment instance: basically anything that\n\t      // can create more than 1 root nodes.\n\t      if (\n\t      // multi-children template\n\t      frag.childNodes.length > 1 ||\n\t      // non-element template\n\t      replacer.nodeType !== 1 ||\n\t      // single nested component\n\t      tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||\n\t      // element directive\n\t      resolveAsset(options, 'elementDirectives', tag) ||\n\t      // for block\n\t      replacer.hasAttribute('v-for') ||\n\t      // if block\n\t      replacer.hasAttribute('v-if')) {\n\t        return frag;\n\t      } else {\n\t        options._replacerAttrs = extractAttrs(replacer);\n\t        mergeAttrs(el, replacer);\n\t        return replacer;\n\t      }\n\t    } else {\n\t      el.appendChild(frag);\n\t      return el;\n\t    }\n\t  } else {\n\t    (\"production\") !== 'production' && warn('Invalid template option: ' + template);\n\t  }\n\t}\n\t\n\t/**\n\t * Helper to extract a component container's attributes\n\t * into a plain object array.\n\t *\n\t * @param {Element} el\n\t * @return {Array}\n\t */\n\t\n\tfunction extractAttrs(el) {\n\t  if (el.nodeType === 1 && el.hasAttributes()) {\n\t    return toArray(el.attributes);\n\t  }\n\t}\n\t\n\t/**\n\t * Merge the attributes of two elements, and make sure\n\t * the class names are merged properly.\n\t *\n\t * @param {Element} from\n\t * @param {Element} to\n\t */\n\t\n\tfunction mergeAttrs(from, to) {\n\t  var attrs = from.attributes;\n\t  var i = attrs.length;\n\t  var name, value;\n\t  while (i--) {\n\t    name = attrs[i].name;\n\t    value = attrs[i].value;\n\t    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {\n\t      to.setAttribute(name, value);\n\t    } else if (name === 'class' && !parseText(value) && (value = value.trim())) {\n\t      value.split(/\\s+/).forEach(function (cls) {\n\t        addClass(to, cls);\n\t      });\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Scan and determine slot content distribution.\n\t * We do this during transclusion instead at compile time so that\n\t * the distribution is decoupled from the compilation order of\n\t * the slots.\n\t *\n\t * @param {Element|DocumentFragment} template\n\t * @param {Element} content\n\t * @param {Vue} vm\n\t */\n\t\n\tfunction resolveSlots(vm, content) {\n\t  if (!content) {\n\t    return;\n\t  }\n\t  var contents = vm._slotContents = Object.create(null);\n\t  var el, name;\n\t  for (var i = 0, l = content.children.length; i < l; i++) {\n\t    el = content.children[i];\n\t    /* eslint-disable no-cond-assign */\n\t    if (name = el.getAttribute('slot')) {\n\t      (contents[name] || (contents[name] = [])).push(el);\n\t    }\n\t    /* eslint-enable no-cond-assign */\n\t    if (false) {\n\t      warn('The \"slot\" attribute must be static.', vm.$parent);\n\t    }\n\t  }\n\t  for (name in contents) {\n\t    contents[name] = extractFragment(contents[name], content);\n\t  }\n\t  if (content.hasChildNodes()) {\n\t    var nodes = content.childNodes;\n\t    if (nodes.length === 1 && nodes[0].nodeType === 3 && !nodes[0].data.trim()) {\n\t      return;\n\t    }\n\t    contents['default'] = extractFragment(content.childNodes, content);\n\t  }\n\t}\n\t\n\t/**\n\t * Extract qualified content nodes from a node list.\n\t *\n\t * @param {NodeList} nodes\n\t * @return {DocumentFragment}\n\t */\n\t\n\tfunction extractFragment(nodes, parent) {\n\t  var frag = document.createDocumentFragment();\n\t  nodes = toArray(nodes);\n\t  for (var i = 0, l = nodes.length; i < l; i++) {\n\t    var node = nodes[i];\n\t    if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {\n\t      parent.removeChild(node);\n\t      node = parseTemplate(node, true);\n\t    }\n\t    frag.appendChild(node);\n\t  }\n\t  return frag;\n\t}\n\t\n\t\n\t\n\tvar compiler = Object.freeze({\n\t\tcompile: compile,\n\t\tcompileAndLinkProps: compileAndLinkProps,\n\t\tcompileRoot: compileRoot,\n\t\ttransclude: transclude,\n\t\tresolveSlots: resolveSlots\n\t});\n\t\n\tfunction stateMixin (Vue) {\n\t  /**\n\t   * Accessor for `$data` property, since setting $data\n\t   * requires observing the new object and updating\n\t   * proxied properties.\n\t   */\n\t\n\t  Object.defineProperty(Vue.prototype, '$data', {\n\t    get: function get() {\n\t      return this._data;\n\t    },\n\t    set: function set(newData) {\n\t      if (newData !== this._data) {\n\t        this._setData(newData);\n\t      }\n\t    }\n\t  });\n\t\n\t  /**\n\t   * Setup the scope of an instance, which contains:\n\t   * - observed data\n\t   * - computed properties\n\t   * - user methods\n\t   * - meta properties\n\t   */\n\t\n\t  Vue.prototype._initState = function () {\n\t    this._initProps();\n\t    this._initMeta();\n\t    this._initMethods();\n\t    this._initData();\n\t    this._initComputed();\n\t  };\n\t\n\t  /**\n\t   * Initialize props.\n\t   */\n\t\n\t  Vue.prototype._initProps = function () {\n\t    var options = this.$options;\n\t    var el = options.el;\n\t    var props = options.props;\n\t    if (props && !el) {\n\t      (\"production\") !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);\n\t    }\n\t    // make sure to convert string selectors into element now\n\t    el = options.el = query(el);\n\t    this._propsUnlinkFn = el && el.nodeType === 1 && props\n\t    // props must be linked in proper scope if inside v-for\n\t    ? compileAndLinkProps(this, el, props, this._scope) : null;\n\t  };\n\t\n\t  /**\n\t   * Initialize the data.\n\t   */\n\t\n\t  Vue.prototype._initData = function () {\n\t    var dataFn = this.$options.data;\n\t    var data = this._data = dataFn ? dataFn() : {};\n\t    if (!isPlainObject(data)) {\n\t      data = {};\n\t      (\"production\") !== 'production' && warn('data functions should return an object.', this);\n\t    }\n\t    var props = this._props;\n\t    // proxy data on instance\n\t    var keys = Object.keys(data);\n\t    var i, key;\n\t    i = keys.length;\n\t    while (i--) {\n\t      key = keys[i];\n\t      // there are two scenarios where we can proxy a data key:\n\t      // 1. it's not already defined as a prop\n\t      // 2. it's provided via a instantiation option AND there are no\n\t      //    template prop present\n\t      if (!props || !hasOwn(props, key)) {\n\t        this._proxy(key);\n\t      } else if (false) {\n\t        warn('Data field \"' + key + '\" is already defined ' + 'as a prop. To provide default value for a prop, use the \"default\" ' + 'prop option; if you want to pass prop values to an instantiation ' + 'call, use the \"propsData\" option.', this);\n\t      }\n\t    }\n\t    // observe data\n\t    observe(data, this);\n\t  };\n\t\n\t  /**\n\t   * Swap the instance's $data. Called in $data's setter.\n\t   *\n\t   * @param {Object} newData\n\t   */\n\t\n\t  Vue.prototype._setData = function (newData) {\n\t    newData = newData || {};\n\t    var oldData = this._data;\n\t    this._data = newData;\n\t    var keys, key, i;\n\t    // unproxy keys not present in new data\n\t    keys = Object.keys(oldData);\n\t    i = keys.length;\n\t    while (i--) {\n\t      key = keys[i];\n\t      if (!(key in newData)) {\n\t        this._unproxy(key);\n\t      }\n\t    }\n\t    // proxy keys not already proxied,\n\t    // and trigger change for changed values\n\t    keys = Object.keys(newData);\n\t    i = keys.length;\n\t    while (i--) {\n\t      key = keys[i];\n\t      if (!hasOwn(this, key)) {\n\t        // new property\n\t        this._proxy(key);\n\t      }\n\t    }\n\t    oldData.__ob__.removeVm(this);\n\t    observe(newData, this);\n\t    this._digest();\n\t  };\n\t\n\t  /**\n\t   * Proxy a property, so that\n\t   * vm.prop === vm._data.prop\n\t   *\n\t   * @param {String} key\n\t   */\n\t\n\t  Vue.prototype._proxy = function (key) {\n\t    if (!isReserved(key)) {\n\t      // need to store ref to self here\n\t      // because these getter/setters might\n\t      // be called by child scopes via\n\t      // prototype inheritance.\n\t      var self = this;\n\t      Object.defineProperty(self, key, {\n\t        configurable: true,\n\t        enumerable: true,\n\t        get: function proxyGetter() {\n\t          return self._data[key];\n\t        },\n\t        set: function proxySetter(val) {\n\t          self._data[key] = val;\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Unproxy a property.\n\t   *\n\t   * @param {String} key\n\t   */\n\t\n\t  Vue.prototype._unproxy = function (key) {\n\t    if (!isReserved(key)) {\n\t      delete this[key];\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Force update on every watcher in scope.\n\t   */\n\t\n\t  Vue.prototype._digest = function () {\n\t    for (var i = 0, l = this._watchers.length; i < l; i++) {\n\t      this._watchers[i].update(true); // shallow updates\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Setup computed properties. They are essentially\n\t   * special getter/setters\n\t   */\n\t\n\t  function noop() {}\n\t  Vue.prototype._initComputed = function () {\n\t    var computed = this.$options.computed;\n\t    if (computed) {\n\t      for (var key in computed) {\n\t        var userDef = computed[key];\n\t        var def = {\n\t          enumerable: true,\n\t          configurable: true\n\t        };\n\t        if (typeof userDef === 'function') {\n\t          def.get = makeComputedGetter(userDef, this);\n\t          def.set = noop;\n\t        } else {\n\t          def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;\n\t          def.set = userDef.set ? bind(userDef.set, this) : noop;\n\t        }\n\t        Object.defineProperty(this, key, def);\n\t      }\n\t    }\n\t  };\n\t\n\t  function makeComputedGetter(getter, owner) {\n\t    var watcher = new Watcher(owner, getter, null, {\n\t      lazy: true\n\t    });\n\t    return function computedGetter() {\n\t      if (watcher.dirty) {\n\t        watcher.evaluate();\n\t      }\n\t      if (Dep.target) {\n\t        watcher.depend();\n\t      }\n\t      return watcher.value;\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Setup instance methods. Methods must be bound to the\n\t   * instance since they might be passed down as a prop to\n\t   * child components.\n\t   */\n\t\n\t  Vue.prototype._initMethods = function () {\n\t    var methods = this.$options.methods;\n\t    if (methods) {\n\t      for (var key in methods) {\n\t        this[key] = bind(methods[key], this);\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Initialize meta information like $index, $key & $value.\n\t   */\n\t\n\t  Vue.prototype._initMeta = function () {\n\t    var metas = this.$options._meta;\n\t    if (metas) {\n\t      for (var key in metas) {\n\t        defineReactive(this, key, metas[key]);\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\tvar eventRE = /^v-on:|^@/;\n\t\n\tfunction eventsMixin (Vue) {\n\t  /**\n\t   * Setup the instance's option events & watchers.\n\t   * If the value is a string, we pull it from the\n\t   * instance's methods by name.\n\t   */\n\t\n\t  Vue.prototype._initEvents = function () {\n\t    var options = this.$options;\n\t    if (options._asComponent) {\n\t      registerComponentEvents(this, options.el);\n\t    }\n\t    registerCallbacks(this, '$on', options.events);\n\t    registerCallbacks(this, '$watch', options.watch);\n\t  };\n\t\n\t  /**\n\t   * Register v-on events on a child component\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {Element} el\n\t   */\n\t\n\t  function registerComponentEvents(vm, el) {\n\t    var attrs = el.attributes;\n\t    var name, value, handler;\n\t    for (var i = 0, l = attrs.length; i < l; i++) {\n\t      name = attrs[i].name;\n\t      if (eventRE.test(name)) {\n\t        name = name.replace(eventRE, '');\n\t        // force the expression into a statement so that\n\t        // it always dynamically resolves the method to call (#2670)\n\t        // kinda ugly hack, but does the job.\n\t        value = attrs[i].value;\n\t        if (isSimplePath(value)) {\n\t          value += '.apply(this, $arguments)';\n\t        }\n\t        handler = (vm._scope || vm._context).$eval(value, true);\n\t        handler._fromParent = true;\n\t        vm.$on(name.replace(eventRE), handler);\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Register callbacks for option events and watchers.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {String} action\n\t   * @param {Object} hash\n\t   */\n\t\n\t  function registerCallbacks(vm, action, hash) {\n\t    if (!hash) return;\n\t    var handlers, key, i, j;\n\t    for (key in hash) {\n\t      handlers = hash[key];\n\t      if (isArray(handlers)) {\n\t        for (i = 0, j = handlers.length; i < j; i++) {\n\t          register(vm, action, key, handlers[i]);\n\t        }\n\t      } else {\n\t        register(vm, action, key, handlers);\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Helper to register an event/watch callback.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {String} action\n\t   * @param {String} key\n\t   * @param {Function|String|Object} handler\n\t   * @param {Object} [options]\n\t   */\n\t\n\t  function register(vm, action, key, handler, options) {\n\t    var type = typeof handler;\n\t    if (type === 'function') {\n\t      vm[action](key, handler, options);\n\t    } else if (type === 'string') {\n\t      var methods = vm.$options.methods;\n\t      var method = methods && methods[handler];\n\t      if (method) {\n\t        vm[action](key, method, options);\n\t      } else {\n\t        (\"production\") !== 'production' && warn('Unknown method: \"' + handler + '\" when ' + 'registering callback for ' + action + ': \"' + key + '\".', vm);\n\t      }\n\t    } else if (handler && type === 'object') {\n\t      register(vm, action, key, handler.handler, handler);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Setup recursive attached/detached calls\n\t   */\n\t\n\t  Vue.prototype._initDOMHooks = function () {\n\t    this.$on('hook:attached', onAttached);\n\t    this.$on('hook:detached', onDetached);\n\t  };\n\t\n\t  /**\n\t   * Callback to recursively call attached hook on children\n\t   */\n\t\n\t  function onAttached() {\n\t    if (!this._isAttached) {\n\t      this._isAttached = true;\n\t      this.$children.forEach(callAttach);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Iterator to call attached hook\n\t   *\n\t   * @param {Vue} child\n\t   */\n\t\n\t  function callAttach(child) {\n\t    if (!child._isAttached && inDoc(child.$el)) {\n\t      child._callHook('attached');\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Callback to recursively call detached hook on children\n\t   */\n\t\n\t  function onDetached() {\n\t    if (this._isAttached) {\n\t      this._isAttached = false;\n\t      this.$children.forEach(callDetach);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Iterator to call detached hook\n\t   *\n\t   * @param {Vue} child\n\t   */\n\t\n\t  function callDetach(child) {\n\t    if (child._isAttached && !inDoc(child.$el)) {\n\t      child._callHook('detached');\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Trigger all handlers for a hook\n\t   *\n\t   * @param {String} hook\n\t   */\n\t\n\t  Vue.prototype._callHook = function (hook) {\n\t    this.$emit('pre-hook:' + hook);\n\t    var handlers = this.$options[hook];\n\t    if (handlers) {\n\t      for (var i = 0, j = handlers.length; i < j; i++) {\n\t        handlers[i].call(this);\n\t      }\n\t    }\n\t    this.$emit('hook:' + hook);\n\t  };\n\t}\n\t\n\tfunction noop$1() {}\n\t\n\t/**\n\t * A directive links a DOM element with a piece of data,\n\t * which is the result of evaluating an expression.\n\t * It registers a watcher with the expression and calls\n\t * the DOM update function when a change is triggered.\n\t *\n\t * @param {Object} descriptor\n\t *                 - {String} name\n\t *                 - {Object} def\n\t *                 - {String} expression\n\t *                 - {Array<Object>} [filters]\n\t *                 - {Object} [modifiers]\n\t *                 - {Boolean} literal\n\t *                 - {String} attr\n\t *                 - {String} arg\n\t *                 - {String} raw\n\t *                 - {String} [ref]\n\t *                 - {Array<Object>} [interp]\n\t *                 - {Boolean} [hasOneTime]\n\t * @param {Vue} vm\n\t * @param {Node} el\n\t * @param {Vue} [host] - transclusion host component\n\t * @param {Object} [scope] - v-for scope\n\t * @param {Fragment} [frag] - owner fragment\n\t * @constructor\n\t */\n\tfunction Directive(descriptor, vm, el, host, scope, frag) {\n\t  this.vm = vm;\n\t  this.el = el;\n\t  // copy descriptor properties\n\t  this.descriptor = descriptor;\n\t  this.name = descriptor.name;\n\t  this.expression = descriptor.expression;\n\t  this.arg = descriptor.arg;\n\t  this.modifiers = descriptor.modifiers;\n\t  this.filters = descriptor.filters;\n\t  this.literal = this.modifiers && this.modifiers.literal;\n\t  // private\n\t  this._locked = false;\n\t  this._bound = false;\n\t  this._listeners = null;\n\t  // link context\n\t  this._host = host;\n\t  this._scope = scope;\n\t  this._frag = frag;\n\t  // store directives on node in dev mode\n\t  if (false) {\n\t    this.el._vue_directives = this.el._vue_directives || [];\n\t    this.el._vue_directives.push(this);\n\t  }\n\t}\n\t\n\t/**\n\t * Initialize the directive, mixin definition properties,\n\t * setup the watcher, call definition bind() and update()\n\t * if present.\n\t */\n\t\n\tDirective.prototype._bind = function () {\n\t  var name = this.name;\n\t  var descriptor = this.descriptor;\n\t\n\t  // remove attribute\n\t  if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {\n\t    var attr = descriptor.attr || 'v-' + name;\n\t    this.el.removeAttribute(attr);\n\t  }\n\t\n\t  // copy def properties\n\t  var def = descriptor.def;\n\t  if (typeof def === 'function') {\n\t    this.update = def;\n\t  } else {\n\t    extend(this, def);\n\t  }\n\t\n\t  // setup directive params\n\t  this._setupParams();\n\t\n\t  // initial bind\n\t  if (this.bind) {\n\t    this.bind();\n\t  }\n\t  this._bound = true;\n\t\n\t  if (this.literal) {\n\t    this.update && this.update(descriptor.raw);\n\t  } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {\n\t    // wrapped updater for context\n\t    var dir = this;\n\t    if (this.update) {\n\t      this._update = function (val, oldVal) {\n\t        if (!dir._locked) {\n\t          dir.update(val, oldVal);\n\t        }\n\t      };\n\t    } else {\n\t      this._update = noop$1;\n\t    }\n\t    var preProcess = this._preProcess ? bind(this._preProcess, this) : null;\n\t    var postProcess = this._postProcess ? bind(this._postProcess, this) : null;\n\t    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback\n\t    {\n\t      filters: this.filters,\n\t      twoWay: this.twoWay,\n\t      deep: this.deep,\n\t      preProcess: preProcess,\n\t      postProcess: postProcess,\n\t      scope: this._scope\n\t    });\n\t    // v-model with inital inline value need to sync back to\n\t    // model instead of update to DOM on init. They would\n\t    // set the afterBind hook to indicate that.\n\t    if (this.afterBind) {\n\t      this.afterBind();\n\t    } else if (this.update) {\n\t      this.update(watcher.value);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Setup all param attributes, e.g. track-by,\n\t * transition-mode, etc...\n\t */\n\t\n\tDirective.prototype._setupParams = function () {\n\t  if (!this.params) {\n\t    return;\n\t  }\n\t  var params = this.params;\n\t  // swap the params array with a fresh object.\n\t  this.params = Object.create(null);\n\t  var i = params.length;\n\t  var key, val, mappedKey;\n\t  while (i--) {\n\t    key = hyphenate(params[i]);\n\t    mappedKey = camelize(key);\n\t    val = getBindAttr(this.el, key);\n\t    if (val != null) {\n\t      // dynamic\n\t      this._setupParamWatcher(mappedKey, val);\n\t    } else {\n\t      // static\n\t      val = getAttr(this.el, key);\n\t      if (val != null) {\n\t        this.params[mappedKey] = val === '' ? true : val;\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Setup a watcher for a dynamic param.\n\t *\n\t * @param {String} key\n\t * @param {String} expression\n\t */\n\t\n\tDirective.prototype._setupParamWatcher = function (key, expression) {\n\t  var self = this;\n\t  var called = false;\n\t  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {\n\t    self.params[key] = val;\n\t    // since we are in immediate mode,\n\t    // only call the param change callbacks if this is not the first update.\n\t    if (called) {\n\t      var cb = self.paramWatchers && self.paramWatchers[key];\n\t      if (cb) {\n\t        cb.call(self, val, oldVal);\n\t      }\n\t    } else {\n\t      called = true;\n\t    }\n\t  }, {\n\t    immediate: true,\n\t    user: false\n\t  });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);\n\t};\n\t\n\t/**\n\t * Check if the directive is a function caller\n\t * and if the expression is a callable one. If both true,\n\t * we wrap up the expression and use it as the event\n\t * handler.\n\t *\n\t * e.g. on-click=\"a++\"\n\t *\n\t * @return {Boolean}\n\t */\n\t\n\tDirective.prototype._checkStatement = function () {\n\t  var expression = this.expression;\n\t  if (expression && this.acceptStatement && !isSimplePath(expression)) {\n\t    var fn = parseExpression(expression).get;\n\t    var scope = this._scope || this.vm;\n\t    var handler = function handler(e) {\n\t      scope.$event = e;\n\t      fn.call(scope, scope);\n\t      scope.$event = null;\n\t    };\n\t    if (this.filters) {\n\t      handler = scope._applyFilters(handler, null, this.filters);\n\t    }\n\t    this.update(handler);\n\t    return true;\n\t  }\n\t};\n\t\n\t/**\n\t * Set the corresponding value with the setter.\n\t * This should only be used in two-way directives\n\t * e.g. v-model.\n\t *\n\t * @param {*} value\n\t * @public\n\t */\n\t\n\tDirective.prototype.set = function (value) {\n\t  /* istanbul ignore else */\n\t  if (this.twoWay) {\n\t    this._withLock(function () {\n\t      this._watcher.set(value);\n\t    });\n\t  } else if (false) {\n\t    warn('Directive.set() can only be used inside twoWay' + 'directives.');\n\t  }\n\t};\n\t\n\t/**\n\t * Execute a function while preventing that function from\n\t * triggering updates on this directive instance.\n\t *\n\t * @param {Function} fn\n\t */\n\t\n\tDirective.prototype._withLock = function (fn) {\n\t  var self = this;\n\t  self._locked = true;\n\t  fn.call(self);\n\t  nextTick(function () {\n\t    self._locked = false;\n\t  });\n\t};\n\t\n\t/**\n\t * Convenience method that attaches a DOM event listener\n\t * to the directive element and autometically tears it down\n\t * during unbind.\n\t *\n\t * @param {String} event\n\t * @param {Function} handler\n\t * @param {Boolean} [useCapture]\n\t */\n\t\n\tDirective.prototype.on = function (event, handler, useCapture) {\n\t  on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);\n\t};\n\t\n\t/**\n\t * Teardown the watcher and call unbind.\n\t */\n\t\n\tDirective.prototype._teardown = function () {\n\t  if (this._bound) {\n\t    this._bound = false;\n\t    if (this.unbind) {\n\t      this.unbind();\n\t    }\n\t    if (this._watcher) {\n\t      this._watcher.teardown();\n\t    }\n\t    var listeners = this._listeners;\n\t    var i;\n\t    if (listeners) {\n\t      i = listeners.length;\n\t      while (i--) {\n\t        off(this.el, listeners[i][0], listeners[i][1]);\n\t      }\n\t    }\n\t    var unwatchFns = this._paramUnwatchFns;\n\t    if (unwatchFns) {\n\t      i = unwatchFns.length;\n\t      while (i--) {\n\t        unwatchFns[i]();\n\t      }\n\t    }\n\t    if (false) {\n\t      this.el._vue_directives.$remove(this);\n\t    }\n\t    this.vm = this.el = this._watcher = this._listeners = null;\n\t  }\n\t};\n\t\n\tfunction lifecycleMixin (Vue) {\n\t  /**\n\t   * Update v-ref for component.\n\t   *\n\t   * @param {Boolean} remove\n\t   */\n\t\n\t  Vue.prototype._updateRef = function (remove) {\n\t    var ref = this.$options._ref;\n\t    if (ref) {\n\t      var refs = (this._scope || this._context).$refs;\n\t      if (remove) {\n\t        if (refs[ref] === this) {\n\t          refs[ref] = null;\n\t        }\n\t      } else {\n\t        refs[ref] = this;\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Transclude, compile and link element.\n\t   *\n\t   * If a pre-compiled linker is available, that means the\n\t   * passed in element will be pre-transcluded and compiled\n\t   * as well - all we need to do is to call the linker.\n\t   *\n\t   * Otherwise we need to call transclude/compile/link here.\n\t   *\n\t   * @param {Element} el\n\t   */\n\t\n\t  Vue.prototype._compile = function (el) {\n\t    var options = this.$options;\n\t\n\t    // transclude and init element\n\t    // transclude can potentially replace original\n\t    // so we need to keep reference; this step also injects\n\t    // the template and caches the original attributes\n\t    // on the container node and replacer node.\n\t    var original = el;\n\t    el = transclude(el, options);\n\t    this._initElement(el);\n\t\n\t    // handle v-pre on root node (#2026)\n\t    if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {\n\t      return;\n\t    }\n\t\n\t    // root is always compiled per-instance, because\n\t    // container attrs and props can be different every time.\n\t    var contextOptions = this._context && this._context.$options;\n\t    var rootLinker = compileRoot(el, options, contextOptions);\n\t\n\t    // resolve slot distribution\n\t    resolveSlots(this, options._content);\n\t\n\t    // compile and link the rest\n\t    var contentLinkFn;\n\t    var ctor = this.constructor;\n\t    // component compilation can be cached\n\t    // as long as it's not using inline-template\n\t    if (options._linkerCachable) {\n\t      contentLinkFn = ctor.linker;\n\t      if (!contentLinkFn) {\n\t        contentLinkFn = ctor.linker = compile(el, options);\n\t      }\n\t    }\n\t\n\t    // link phase\n\t    // make sure to link root with prop scope!\n\t    var rootUnlinkFn = rootLinker(this, el, this._scope);\n\t    var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);\n\t\n\t    // register composite unlink function\n\t    // to be called during instance destruction\n\t    this._unlinkFn = function () {\n\t      rootUnlinkFn();\n\t      // passing destroying: true to avoid searching and\n\t      // splicing the directives\n\t      contentUnlinkFn(true);\n\t    };\n\t\n\t    // finally replace original\n\t    if (options.replace) {\n\t      replace(original, el);\n\t    }\n\t\n\t    this._isCompiled = true;\n\t    this._callHook('compiled');\n\t  };\n\t\n\t  /**\n\t   * Initialize instance element. Called in the public\n\t   * $mount() method.\n\t   *\n\t   * @param {Element} el\n\t   */\n\t\n\t  Vue.prototype._initElement = function (el) {\n\t    if (isFragment(el)) {\n\t      this._isFragment = true;\n\t      this.$el = this._fragmentStart = el.firstChild;\n\t      this._fragmentEnd = el.lastChild;\n\t      // set persisted text anchors to empty\n\t      if (this._fragmentStart.nodeType === 3) {\n\t        this._fragmentStart.data = this._fragmentEnd.data = '';\n\t      }\n\t      this._fragment = el;\n\t    } else {\n\t      this.$el = el;\n\t    }\n\t    this.$el.__vue__ = this;\n\t    this._callHook('beforeCompile');\n\t  };\n\t\n\t  /**\n\t   * Create and bind a directive to an element.\n\t   *\n\t   * @param {Object} descriptor - parsed directive descriptor\n\t   * @param {Node} node   - target node\n\t   * @param {Vue} [host] - transclusion host component\n\t   * @param {Object} [scope] - v-for scope\n\t   * @param {Fragment} [frag] - owner fragment\n\t   */\n\t\n\t  Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {\n\t    this._directives.push(new Directive(descriptor, this, node, host, scope, frag));\n\t  };\n\t\n\t  /**\n\t   * Teardown an instance, unobserves the data, unbind all the\n\t   * directives, turn off all the event listeners, etc.\n\t   *\n\t   * @param {Boolean} remove - whether to remove the DOM node.\n\t   * @param {Boolean} deferCleanup - if true, defer cleanup to\n\t   *                                 be called later\n\t   */\n\t\n\t  Vue.prototype._destroy = function (remove, deferCleanup) {\n\t    if (this._isBeingDestroyed) {\n\t      if (!deferCleanup) {\n\t        this._cleanup();\n\t      }\n\t      return;\n\t    }\n\t\n\t    var destroyReady;\n\t    var pendingRemoval;\n\t\n\t    var self = this;\n\t    // Cleanup should be called either synchronously or asynchronoysly as\n\t    // callback of this.$remove(), or if remove and deferCleanup are false.\n\t    // In any case it should be called after all other removing, unbinding and\n\t    // turning of is done\n\t    var cleanupIfPossible = function cleanupIfPossible() {\n\t      if (destroyReady && !pendingRemoval && !deferCleanup) {\n\t        self._cleanup();\n\t      }\n\t    };\n\t\n\t    // remove DOM element\n\t    if (remove && this.$el) {\n\t      pendingRemoval = true;\n\t      this.$remove(function () {\n\t        pendingRemoval = false;\n\t        cleanupIfPossible();\n\t      });\n\t    }\n\t\n\t    this._callHook('beforeDestroy');\n\t    this._isBeingDestroyed = true;\n\t    var i;\n\t    // remove self from parent. only necessary\n\t    // if parent is not being destroyed as well.\n\t    var parent = this.$parent;\n\t    if (parent && !parent._isBeingDestroyed) {\n\t      parent.$children.$remove(this);\n\t      // unregister ref (remove: true)\n\t      this._updateRef(true);\n\t    }\n\t    // destroy all children.\n\t    i = this.$children.length;\n\t    while (i--) {\n\t      this.$children[i].$destroy();\n\t    }\n\t    // teardown props\n\t    if (this._propsUnlinkFn) {\n\t      this._propsUnlinkFn();\n\t    }\n\t    // teardown all directives. this also tearsdown all\n\t    // directive-owned watchers.\n\t    if (this._unlinkFn) {\n\t      this._unlinkFn();\n\t    }\n\t    i = this._watchers.length;\n\t    while (i--) {\n\t      this._watchers[i].teardown();\n\t    }\n\t    // remove reference to self on $el\n\t    if (this.$el) {\n\t      this.$el.__vue__ = null;\n\t    }\n\t\n\t    destroyReady = true;\n\t    cleanupIfPossible();\n\t  };\n\t\n\t  /**\n\t   * Clean up to ensure garbage collection.\n\t   * This is called after the leave transition if there\n\t   * is any.\n\t   */\n\t\n\t  Vue.prototype._cleanup = function () {\n\t    if (this._isDestroyed) {\n\t      return;\n\t    }\n\t    // remove self from owner fragment\n\t    // do it in cleanup so that we can call $destroy with\n\t    // defer right when a fragment is about to be removed.\n\t    if (this._frag) {\n\t      this._frag.children.$remove(this);\n\t    }\n\t    // remove reference from data ob\n\t    // frozen object may not have observer.\n\t    if (this._data && this._data.__ob__) {\n\t      this._data.__ob__.removeVm(this);\n\t    }\n\t    // Clean up references to private properties and other\n\t    // instances. preserve reference to _data so that proxy\n\t    // accessors still work. The only potential side effect\n\t    // here is that mutating the instance after it's destroyed\n\t    // may affect the state of other components that are still\n\t    // observing the same object, but that seems to be a\n\t    // reasonable responsibility for the user rather than\n\t    // always throwing an error on them.\n\t    this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;\n\t    // call the last hook...\n\t    this._isDestroyed = true;\n\t    this._callHook('destroyed');\n\t    // turn off all instance listeners.\n\t    this.$off();\n\t  };\n\t}\n\t\n\tfunction miscMixin (Vue) {\n\t  /**\n\t   * Apply a list of filter (descriptors) to a value.\n\t   * Using plain for loops here because this will be called in\n\t   * the getter of any watcher with filters so it is very\n\t   * performance sensitive.\n\t   *\n\t   * @param {*} value\n\t   * @param {*} [oldValue]\n\t   * @param {Array} filters\n\t   * @param {Boolean} write\n\t   * @return {*}\n\t   */\n\t\n\t  Vue.prototype._applyFilters = function (value, oldValue, filters, write) {\n\t    var filter, fn, args, arg, offset, i, l, j, k;\n\t    for (i = 0, l = filters.length; i < l; i++) {\n\t      filter = filters[write ? l - i - 1 : i];\n\t      fn = resolveAsset(this.$options, 'filters', filter.name, true);\n\t      if (!fn) continue;\n\t      fn = write ? fn.write : fn.read || fn;\n\t      if (typeof fn !== 'function') continue;\n\t      args = write ? [value, oldValue] : [value];\n\t      offset = write ? 2 : 1;\n\t      if (filter.args) {\n\t        for (j = 0, k = filter.args.length; j < k; j++) {\n\t          arg = filter.args[j];\n\t          args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;\n\t        }\n\t      }\n\t      value = fn.apply(this, args);\n\t    }\n\t    return value;\n\t  };\n\t\n\t  /**\n\t   * Resolve a component, depending on whether the component\n\t   * is defined normally or using an async factory function.\n\t   * Resolves synchronously if already resolved, otherwise\n\t   * resolves asynchronously and caches the resolved\n\t   * constructor on the factory.\n\t   *\n\t   * @param {String|Function} value\n\t   * @param {Function} cb\n\t   */\n\t\n\t  Vue.prototype._resolveComponent = function (value, cb) {\n\t    var factory;\n\t    if (typeof value === 'function') {\n\t      factory = value;\n\t    } else {\n\t      factory = resolveAsset(this.$options, 'components', value, true);\n\t    }\n\t    /* istanbul ignore if */\n\t    if (!factory) {\n\t      return;\n\t    }\n\t    // async component factory\n\t    if (!factory.options) {\n\t      if (factory.resolved) {\n\t        // cached\n\t        cb(factory.resolved);\n\t      } else if (factory.requested) {\n\t        // pool callbacks\n\t        factory.pendingCallbacks.push(cb);\n\t      } else {\n\t        factory.requested = true;\n\t        var cbs = factory.pendingCallbacks = [cb];\n\t        factory.call(this, function resolve(res) {\n\t          if (isPlainObject(res)) {\n\t            res = Vue.extend(res);\n\t          }\n\t          // cache resolved\n\t          factory.resolved = res;\n\t          // invoke callbacks\n\t          for (var i = 0, l = cbs.length; i < l; i++) {\n\t            cbs[i](res);\n\t          }\n\t        }, function reject(reason) {\n\t          (\"production\") !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\\nReason: ' + reason : ''));\n\t        });\n\t      }\n\t    } else {\n\t      // normal component\n\t      cb(factory);\n\t    }\n\t  };\n\t}\n\t\n\tvar filterRE$1 = /[^|]\\|[^|]/;\n\t\n\tfunction dataAPI (Vue) {\n\t  /**\n\t   * Get the value from an expression on this vm.\n\t   *\n\t   * @param {String} exp\n\t   * @param {Boolean} [asStatement]\n\t   * @return {*}\n\t   */\n\t\n\t  Vue.prototype.$get = function (exp, asStatement) {\n\t    var res = parseExpression(exp);\n\t    if (res) {\n\t      if (asStatement) {\n\t        var self = this;\n\t        return function statementHandler() {\n\t          self.$arguments = toArray(arguments);\n\t          var result = res.get.call(self, self);\n\t          self.$arguments = null;\n\t          return result;\n\t        };\n\t      } else {\n\t        try {\n\t          return res.get.call(this, this);\n\t        } catch (e) {}\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Set the value from an expression on this vm.\n\t   * The expression must be a valid left-hand\n\t   * expression in an assignment.\n\t   *\n\t   * @param {String} exp\n\t   * @param {*} val\n\t   */\n\t\n\t  Vue.prototype.$set = function (exp, val) {\n\t    var res = parseExpression(exp, true);\n\t    if (res && res.set) {\n\t      res.set.call(this, this, val);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Delete a property on the VM\n\t   *\n\t   * @param {String} key\n\t   */\n\t\n\t  Vue.prototype.$delete = function (key) {\n\t    del(this._data, key);\n\t  };\n\t\n\t  /**\n\t   * Watch an expression, trigger callback when its\n\t   * value changes.\n\t   *\n\t   * @param {String|Function} expOrFn\n\t   * @param {Function} cb\n\t   * @param {Object} [options]\n\t   *                 - {Boolean} deep\n\t   *                 - {Boolean} immediate\n\t   * @return {Function} - unwatchFn\n\t   */\n\t\n\t  Vue.prototype.$watch = function (expOrFn, cb, options) {\n\t    var vm = this;\n\t    var parsed;\n\t    if (typeof expOrFn === 'string') {\n\t      parsed = parseDirective(expOrFn);\n\t      expOrFn = parsed.expression;\n\t    }\n\t    var watcher = new Watcher(vm, expOrFn, cb, {\n\t      deep: options && options.deep,\n\t      sync: options && options.sync,\n\t      filters: parsed && parsed.filters,\n\t      user: !options || options.user !== false\n\t    });\n\t    if (options && options.immediate) {\n\t      cb.call(vm, watcher.value);\n\t    }\n\t    return function unwatchFn() {\n\t      watcher.teardown();\n\t    };\n\t  };\n\t\n\t  /**\n\t   * Evaluate a text directive, including filters.\n\t   *\n\t   * @param {String} text\n\t   * @param {Boolean} [asStatement]\n\t   * @return {String}\n\t   */\n\t\n\t  Vue.prototype.$eval = function (text, asStatement) {\n\t    // check for filters.\n\t    if (filterRE$1.test(text)) {\n\t      var dir = parseDirective(text);\n\t      // the filter regex check might give false positive\n\t      // for pipes inside strings, so it's possible that\n\t      // we don't get any filters here\n\t      var val = this.$get(dir.expression, asStatement);\n\t      return dir.filters ? this._applyFilters(val, null, dir.filters) : val;\n\t    } else {\n\t      // no filter\n\t      return this.$get(text, asStatement);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Interpolate a piece of template text.\n\t   *\n\t   * @param {String} text\n\t   * @return {String}\n\t   */\n\t\n\t  Vue.prototype.$interpolate = function (text) {\n\t    var tokens = parseText(text);\n\t    var vm = this;\n\t    if (tokens) {\n\t      if (tokens.length === 1) {\n\t        return vm.$eval(tokens[0].value) + '';\n\t      } else {\n\t        return tokens.map(function (token) {\n\t          return token.tag ? vm.$eval(token.value) : token.value;\n\t        }).join('');\n\t      }\n\t    } else {\n\t      return text;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Log instance data as a plain JS object\n\t   * so that it is easier to inspect in console.\n\t   * This method assumes console is available.\n\t   *\n\t   * @param {String} [path]\n\t   */\n\t\n\t  Vue.prototype.$log = function (path) {\n\t    var data = path ? getPath(this._data, path) : this._data;\n\t    if (data) {\n\t      data = clean(data);\n\t    }\n\t    // include computed fields\n\t    if (!path) {\n\t      var key;\n\t      for (key in this.$options.computed) {\n\t        data[key] = clean(this[key]);\n\t      }\n\t      if (this._props) {\n\t        for (key in this._props) {\n\t          data[key] = clean(this[key]);\n\t        }\n\t      }\n\t    }\n\t    console.log(data);\n\t  };\n\t\n\t  /**\n\t   * \"clean\" a getter/setter converted object into a plain\n\t   * object copy.\n\t   *\n\t   * @param {Object} - obj\n\t   * @return {Object}\n\t   */\n\t\n\t  function clean(obj) {\n\t    return JSON.parse(JSON.stringify(obj));\n\t  }\n\t}\n\t\n\tfunction domAPI (Vue) {\n\t  /**\n\t   * Convenience on-instance nextTick. The callback is\n\t   * auto-bound to the instance, and this avoids component\n\t   * modules having to rely on the global Vue.\n\t   *\n\t   * @param {Function} fn\n\t   */\n\t\n\t  Vue.prototype.$nextTick = function (fn) {\n\t    nextTick(fn, this);\n\t  };\n\t\n\t  /**\n\t   * Append instance to target\n\t   *\n\t   * @param {Node} target\n\t   * @param {Function} [cb]\n\t   * @param {Boolean} [withTransition] - defaults to true\n\t   */\n\t\n\t  Vue.prototype.$appendTo = function (target, cb, withTransition) {\n\t    return insert(this, target, cb, withTransition, append, appendWithTransition);\n\t  };\n\t\n\t  /**\n\t   * Prepend instance to target\n\t   *\n\t   * @param {Node} target\n\t   * @param {Function} [cb]\n\t   * @param {Boolean} [withTransition] - defaults to true\n\t   */\n\t\n\t  Vue.prototype.$prependTo = function (target, cb, withTransition) {\n\t    target = query(target);\n\t    if (target.hasChildNodes()) {\n\t      this.$before(target.firstChild, cb, withTransition);\n\t    } else {\n\t      this.$appendTo(target, cb, withTransition);\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Insert instance before target\n\t   *\n\t   * @param {Node} target\n\t   * @param {Function} [cb]\n\t   * @param {Boolean} [withTransition] - defaults to true\n\t   */\n\t\n\t  Vue.prototype.$before = function (target, cb, withTransition) {\n\t    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);\n\t  };\n\t\n\t  /**\n\t   * Insert instance after target\n\t   *\n\t   * @param {Node} target\n\t   * @param {Function} [cb]\n\t   * @param {Boolean} [withTransition] - defaults to true\n\t   */\n\t\n\t  Vue.prototype.$after = function (target, cb, withTransition) {\n\t    target = query(target);\n\t    if (target.nextSibling) {\n\t      this.$before(target.nextSibling, cb, withTransition);\n\t    } else {\n\t      this.$appendTo(target.parentNode, cb, withTransition);\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Remove instance from DOM\n\t   *\n\t   * @param {Function} [cb]\n\t   * @param {Boolean} [withTransition] - defaults to true\n\t   */\n\t\n\t  Vue.prototype.$remove = function (cb, withTransition) {\n\t    if (!this.$el.parentNode) {\n\t      return cb && cb();\n\t    }\n\t    var inDocument = this._isAttached && inDoc(this.$el);\n\t    // if we are not in document, no need to check\n\t    // for transitions\n\t    if (!inDocument) withTransition = false;\n\t    var self = this;\n\t    var realCb = function realCb() {\n\t      if (inDocument) self._callHook('detached');\n\t      if (cb) cb();\n\t    };\n\t    if (this._isFragment) {\n\t      removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);\n\t    } else {\n\t      var op = withTransition === false ? removeWithCb : removeWithTransition;\n\t      op(this.$el, this, realCb);\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Shared DOM insertion function.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {Element} target\n\t   * @param {Function} [cb]\n\t   * @param {Boolean} [withTransition]\n\t   * @param {Function} op1 - op for non-transition insert\n\t   * @param {Function} op2 - op for transition insert\n\t   * @return vm\n\t   */\n\t\n\t  function insert(vm, target, cb, withTransition, op1, op2) {\n\t    target = query(target);\n\t    var targetIsDetached = !inDoc(target);\n\t    var op = withTransition === false || targetIsDetached ? op1 : op2;\n\t    var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);\n\t    if (vm._isFragment) {\n\t      mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {\n\t        op(node, target, vm);\n\t      });\n\t      cb && cb();\n\t    } else {\n\t      op(vm.$el, target, vm, cb);\n\t    }\n\t    if (shouldCallHook) {\n\t      vm._callHook('attached');\n\t    }\n\t    return vm;\n\t  }\n\t\n\t  /**\n\t   * Check for selectors\n\t   *\n\t   * @param {String|Element} el\n\t   */\n\t\n\t  function query(el) {\n\t    return typeof el === 'string' ? document.querySelector(el) : el;\n\t  }\n\t\n\t  /**\n\t   * Append operation that takes a callback.\n\t   *\n\t   * @param {Node} el\n\t   * @param {Node} target\n\t   * @param {Vue} vm - unused\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  function append(el, target, vm, cb) {\n\t    target.appendChild(el);\n\t    if (cb) cb();\n\t  }\n\t\n\t  /**\n\t   * InsertBefore operation that takes a callback.\n\t   *\n\t   * @param {Node} el\n\t   * @param {Node} target\n\t   * @param {Vue} vm - unused\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  function beforeWithCb(el, target, vm, cb) {\n\t    before(el, target);\n\t    if (cb) cb();\n\t  }\n\t\n\t  /**\n\t   * Remove operation that takes a callback.\n\t   *\n\t   * @param {Node} el\n\t   * @param {Vue} vm - unused\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  function removeWithCb(el, vm, cb) {\n\t    remove(el);\n\t    if (cb) cb();\n\t  }\n\t}\n\t\n\tfunction eventsAPI (Vue) {\n\t  /**\n\t   * Listen on the given `event` with `fn`.\n\t   *\n\t   * @param {String} event\n\t   * @param {Function} fn\n\t   */\n\t\n\t  Vue.prototype.$on = function (event, fn) {\n\t    (this._events[event] || (this._events[event] = [])).push(fn);\n\t    modifyListenerCount(this, event, 1);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Adds an `event` listener that will be invoked a single\n\t   * time then automatically removed.\n\t   *\n\t   * @param {String} event\n\t   * @param {Function} fn\n\t   */\n\t\n\t  Vue.prototype.$once = function (event, fn) {\n\t    var self = this;\n\t    function on() {\n\t      self.$off(event, on);\n\t      fn.apply(this, arguments);\n\t    }\n\t    on.fn = fn;\n\t    this.$on(event, on);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Remove the given callback for `event` or all\n\t   * registered callbacks.\n\t   *\n\t   * @param {String} event\n\t   * @param {Function} fn\n\t   */\n\t\n\t  Vue.prototype.$off = function (event, fn) {\n\t    var cbs;\n\t    // all\n\t    if (!arguments.length) {\n\t      if (this.$parent) {\n\t        for (event in this._events) {\n\t          cbs = this._events[event];\n\t          if (cbs) {\n\t            modifyListenerCount(this, event, -cbs.length);\n\t          }\n\t        }\n\t      }\n\t      this._events = {};\n\t      return this;\n\t    }\n\t    // specific event\n\t    cbs = this._events[event];\n\t    if (!cbs) {\n\t      return this;\n\t    }\n\t    if (arguments.length === 1) {\n\t      modifyListenerCount(this, event, -cbs.length);\n\t      this._events[event] = null;\n\t      return this;\n\t    }\n\t    // specific handler\n\t    var cb;\n\t    var i = cbs.length;\n\t    while (i--) {\n\t      cb = cbs[i];\n\t      if (cb === fn || cb.fn === fn) {\n\t        modifyListenerCount(this, event, -1);\n\t        cbs.splice(i, 1);\n\t        break;\n\t      }\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Trigger an event on self.\n\t   *\n\t   * @param {String|Object} event\n\t   * @return {Boolean} shouldPropagate\n\t   */\n\t\n\t  Vue.prototype.$emit = function (event) {\n\t    var isSource = typeof event === 'string';\n\t    event = isSource ? event : event.name;\n\t    var cbs = this._events[event];\n\t    var shouldPropagate = isSource || !cbs;\n\t    if (cbs) {\n\t      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n\t      // this is a somewhat hacky solution to the question raised\n\t      // in #2102: for an inline component listener like <comp @test=\"doThis\">,\n\t      // the propagation handling is somewhat broken. Therefore we\n\t      // need to treat these inline callbacks differently.\n\t      var hasParentCbs = isSource && cbs.some(function (cb) {\n\t        return cb._fromParent;\n\t      });\n\t      if (hasParentCbs) {\n\t        shouldPropagate = false;\n\t      }\n\t      var args = toArray(arguments, 1);\n\t      for (var i = 0, l = cbs.length; i < l; i++) {\n\t        var cb = cbs[i];\n\t        var res = cb.apply(this, args);\n\t        if (res === true && (!hasParentCbs || cb._fromParent)) {\n\t          shouldPropagate = true;\n\t        }\n\t      }\n\t    }\n\t    return shouldPropagate;\n\t  };\n\t\n\t  /**\n\t   * Recursively broadcast an event to all children instances.\n\t   *\n\t   * @param {String|Object} event\n\t   * @param {...*} additional arguments\n\t   */\n\t\n\t  Vue.prototype.$broadcast = function (event) {\n\t    var isSource = typeof event === 'string';\n\t    event = isSource ? event : event.name;\n\t    // if no child has registered for this event,\n\t    // then there's no need to broadcast.\n\t    if (!this._eventsCount[event]) return;\n\t    var children = this.$children;\n\t    var args = toArray(arguments);\n\t    if (isSource) {\n\t      // use object event to indicate non-source emit\n\t      // on children\n\t      args[0] = { name: event, source: this };\n\t    }\n\t    for (var i = 0, l = children.length; i < l; i++) {\n\t      var child = children[i];\n\t      var shouldPropagate = child.$emit.apply(child, args);\n\t      if (shouldPropagate) {\n\t        child.$broadcast.apply(child, args);\n\t      }\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Recursively propagate an event up the parent chain.\n\t   *\n\t   * @param {String} event\n\t   * @param {...*} additional arguments\n\t   */\n\t\n\t  Vue.prototype.$dispatch = function (event) {\n\t    var shouldPropagate = this.$emit.apply(this, arguments);\n\t    if (!shouldPropagate) return;\n\t    var parent = this.$parent;\n\t    var args = toArray(arguments);\n\t    // use object event to indicate non-source emit\n\t    // on parents\n\t    args[0] = { name: event, source: this };\n\t    while (parent) {\n\t      shouldPropagate = parent.$emit.apply(parent, args);\n\t      parent = shouldPropagate ? parent.$parent : null;\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Modify the listener counts on all parents.\n\t   * This bookkeeping allows $broadcast to return early when\n\t   * no child has listened to a certain event.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {String} event\n\t   * @param {Number} count\n\t   */\n\t\n\t  var hookRE = /^hook:/;\n\t  function modifyListenerCount(vm, event, count) {\n\t    var parent = vm.$parent;\n\t    // hooks do not get broadcasted so no need\n\t    // to do bookkeeping for them\n\t    if (!parent || !count || hookRE.test(event)) return;\n\t    while (parent) {\n\t      parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;\n\t      parent = parent.$parent;\n\t    }\n\t  }\n\t}\n\t\n\tfunction lifecycleAPI (Vue) {\n\t  /**\n\t   * Set instance target element and kick off the compilation\n\t   * process. The passed in `el` can be a selector string, an\n\t   * existing Element, or a DocumentFragment (for block\n\t   * instances).\n\t   *\n\t   * @param {Element|DocumentFragment|string} el\n\t   * @public\n\t   */\n\t\n\t  Vue.prototype.$mount = function (el) {\n\t    if (this._isCompiled) {\n\t      (\"production\") !== 'production' && warn('$mount() should be called only once.', this);\n\t      return;\n\t    }\n\t    el = query(el);\n\t    if (!el) {\n\t      el = document.createElement('div');\n\t    }\n\t    this._compile(el);\n\t    this._initDOMHooks();\n\t    if (inDoc(this.$el)) {\n\t      this._callHook('attached');\n\t      ready.call(this);\n\t    } else {\n\t      this.$once('hook:attached', ready);\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Mark an instance as ready.\n\t   */\n\t\n\t  function ready() {\n\t    this._isAttached = true;\n\t    this._isReady = true;\n\t    this._callHook('ready');\n\t  }\n\t\n\t  /**\n\t   * Teardown the instance, simply delegate to the internal\n\t   * _destroy.\n\t   *\n\t   * @param {Boolean} remove\n\t   * @param {Boolean} deferCleanup\n\t   */\n\t\n\t  Vue.prototype.$destroy = function (remove, deferCleanup) {\n\t    this._destroy(remove, deferCleanup);\n\t  };\n\t\n\t  /**\n\t   * Partially compile a piece of DOM and return a\n\t   * decompile function.\n\t   *\n\t   * @param {Element|DocumentFragment} el\n\t   * @param {Vue} [host]\n\t   * @param {Object} [scope]\n\t   * @param {Fragment} [frag]\n\t   * @return {Function}\n\t   */\n\t\n\t  Vue.prototype.$compile = function (el, host, scope, frag) {\n\t    return compile(el, this.$options, true)(this, el, host, scope, frag);\n\t  };\n\t}\n\t\n\t/**\n\t * The exposed Vue constructor.\n\t *\n\t * API conventions:\n\t * - public API methods/properties are prefixed with `$`\n\t * - internal methods/properties are prefixed with `_`\n\t * - non-prefixed properties are assumed to be proxied user\n\t *   data.\n\t *\n\t * @constructor\n\t * @param {Object} [options]\n\t * @public\n\t */\n\t\n\tfunction Vue(options) {\n\t  this._init(options);\n\t}\n\t\n\t// install internals\n\tinitMixin(Vue);\n\tstateMixin(Vue);\n\teventsMixin(Vue);\n\tlifecycleMixin(Vue);\n\tmiscMixin(Vue);\n\t\n\t// install instance APIs\n\tdataAPI(Vue);\n\tdomAPI(Vue);\n\teventsAPI(Vue);\n\tlifecycleAPI(Vue);\n\t\n\tvar slot = {\n\t\n\t  priority: SLOT,\n\t  params: ['name'],\n\t\n\t  bind: function bind() {\n\t    // this was resolved during component transclusion\n\t    var name = this.params.name || 'default';\n\t    var content = this.vm._slotContents && this.vm._slotContents[name];\n\t    if (!content || !content.hasChildNodes()) {\n\t      this.fallback();\n\t    } else {\n\t      this.compile(content.cloneNode(true), this.vm._context, this.vm);\n\t    }\n\t  },\n\t\n\t  compile: function compile(content, context, host) {\n\t    if (content && context) {\n\t      if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {\n\t        // if the inserted slot has v-if\n\t        // inject fallback content as the v-else\n\t        var elseBlock = document.createElement('template');\n\t        elseBlock.setAttribute('v-else', '');\n\t        elseBlock.innerHTML = this.el.innerHTML;\n\t        // the else block should be compiled in child scope\n\t        elseBlock._context = this.vm;\n\t        content.appendChild(elseBlock);\n\t      }\n\t      var scope = host ? host._scope : this._scope;\n\t      this.unlink = context.$compile(content, host, scope, this._frag);\n\t    }\n\t    if (content) {\n\t      replace(this.el, content);\n\t    } else {\n\t      remove(this.el);\n\t    }\n\t  },\n\t\n\t  fallback: function fallback() {\n\t    this.compile(extractContent(this.el, true), this.vm);\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    if (this.unlink) {\n\t      this.unlink();\n\t    }\n\t  }\n\t};\n\t\n\tvar partial = {\n\t\n\t  priority: PARTIAL,\n\t\n\t  params: ['name'],\n\t\n\t  // watch changes to name for dynamic partials\n\t  paramWatchers: {\n\t    name: function name(value) {\n\t      vIf.remove.call(this);\n\t      if (value) {\n\t        this.insert(value);\n\t      }\n\t    }\n\t  },\n\t\n\t  bind: function bind() {\n\t    this.anchor = createAnchor('v-partial');\n\t    replace(this.el, this.anchor);\n\t    this.insert(this.params.name);\n\t  },\n\t\n\t  insert: function insert(id) {\n\t    var partial = resolveAsset(this.vm.$options, 'partials', id, true);\n\t    if (partial) {\n\t      this.factory = new FragmentFactory(this.vm, partial);\n\t      vIf.insert.call(this);\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    if (this.frag) {\n\t      this.frag.destroy();\n\t    }\n\t  }\n\t};\n\t\n\tvar elementDirectives = {\n\t  slot: slot,\n\t  partial: partial\n\t};\n\t\n\tvar convertArray = vFor._postProcess;\n\t\n\t/**\n\t * Limit filter for arrays\n\t *\n\t * @param {Number} n\n\t * @param {Number} offset (Decimal expected)\n\t */\n\t\n\tfunction limitBy(arr, n, offset) {\n\t  offset = offset ? parseInt(offset, 10) : 0;\n\t  n = toNumber(n);\n\t  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;\n\t}\n\t\n\t/**\n\t * Filter filter for arrays\n\t *\n\t * @param {String} search\n\t * @param {String} [delimiter]\n\t * @param {String} ...dataKeys\n\t */\n\t\n\tfunction filterBy(arr, search, delimiter) {\n\t  arr = convertArray(arr);\n\t  if (search == null) {\n\t    return arr;\n\t  }\n\t  if (typeof search === 'function') {\n\t    return arr.filter(search);\n\t  }\n\t  // cast to lowercase string\n\t  search = ('' + search).toLowerCase();\n\t  // allow optional `in` delimiter\n\t  // because why not\n\t  var n = delimiter === 'in' ? 3 : 2;\n\t  // extract and flatten keys\n\t  var keys = Array.prototype.concat.apply([], toArray(arguments, n));\n\t  var res = [];\n\t  var item, key, val, j;\n\t  for (var i = 0, l = arr.length; i < l; i++) {\n\t    item = arr[i];\n\t    val = item && item.$value || item;\n\t    j = keys.length;\n\t    if (j) {\n\t      while (j--) {\n\t        key = keys[j];\n\t        if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {\n\t          res.push(item);\n\t          break;\n\t        }\n\t      }\n\t    } else if (contains(item, search)) {\n\t      res.push(item);\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\t/**\n\t * Filter filter for arrays\n\t *\n\t * @param {String|Array<String>|Function} ...sortKeys\n\t * @param {Number} [order]\n\t */\n\t\n\tfunction orderBy(arr) {\n\t  var comparator = null;\n\t  var sortKeys = undefined;\n\t  arr = convertArray(arr);\n\t\n\t  // determine order (last argument)\n\t  var args = toArray(arguments, 1);\n\t  var order = args[args.length - 1];\n\t  if (typeof order === 'number') {\n\t    order = order < 0 ? -1 : 1;\n\t    args = args.length > 1 ? args.slice(0, -1) : args;\n\t  } else {\n\t    order = 1;\n\t  }\n\t\n\t  // determine sortKeys & comparator\n\t  var firstArg = args[0];\n\t  if (!firstArg) {\n\t    return arr;\n\t  } else if (typeof firstArg === 'function') {\n\t    // custom comparator\n\t    comparator = function (a, b) {\n\t      return firstArg(a, b) * order;\n\t    };\n\t  } else {\n\t    // string keys. flatten first\n\t    sortKeys = Array.prototype.concat.apply([], args);\n\t    comparator = function (a, b, i) {\n\t      i = i || 0;\n\t      return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);\n\t    };\n\t  }\n\t\n\t  function baseCompare(a, b, sortKeyIndex) {\n\t    var sortKey = sortKeys[sortKeyIndex];\n\t    if (sortKey) {\n\t      if (sortKey !== '$key') {\n\t        if (isObject(a) && '$value' in a) a = a.$value;\n\t        if (isObject(b) && '$value' in b) b = b.$value;\n\t      }\n\t      a = isObject(a) ? getPath(a, sortKey) : a;\n\t      b = isObject(b) ? getPath(b, sortKey) : b;\n\t    }\n\t    return a === b ? 0 : a > b ? order : -order;\n\t  }\n\t\n\t  // sort on a copy to avoid mutating original array\n\t  return arr.slice().sort(comparator);\n\t}\n\t\n\t/**\n\t * String contain helper\n\t *\n\t * @param {*} val\n\t * @param {String} search\n\t */\n\t\n\tfunction contains(val, search) {\n\t  var i;\n\t  if (isPlainObject(val)) {\n\t    var keys = Object.keys(val);\n\t    i = keys.length;\n\t    while (i--) {\n\t      if (contains(val[keys[i]], search)) {\n\t        return true;\n\t      }\n\t    }\n\t  } else if (isArray(val)) {\n\t    i = val.length;\n\t    while (i--) {\n\t      if (contains(val[i], search)) {\n\t        return true;\n\t      }\n\t    }\n\t  } else if (val != null) {\n\t    return val.toString().toLowerCase().indexOf(search) > -1;\n\t  }\n\t}\n\t\n\tvar digitsRE = /(\\d{3})(?=\\d)/g;\n\t\n\t// asset collections must be a plain object.\n\tvar filters = {\n\t\n\t  orderBy: orderBy,\n\t  filterBy: filterBy,\n\t  limitBy: limitBy,\n\t\n\t  /**\n\t   * Stringify value.\n\t   *\n\t   * @param {Number} indent\n\t   */\n\t\n\t  json: {\n\t    read: function read(value, indent) {\n\t      return typeof value === 'string' ? value : JSON.stringify(value, null, arguments.length > 1 ? indent : 2);\n\t    },\n\t    write: function write(value) {\n\t      try {\n\t        return JSON.parse(value);\n\t      } catch (e) {\n\t        return value;\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 'abc' => 'Abc'\n\t   */\n\t\n\t  capitalize: function capitalize(value) {\n\t    if (!value && value !== 0) return '';\n\t    value = value.toString();\n\t    return value.charAt(0).toUpperCase() + value.slice(1);\n\t  },\n\t\n\t  /**\n\t   * 'abc' => 'ABC'\n\t   */\n\t\n\t  uppercase: function uppercase(value) {\n\t    return value || value === 0 ? value.toString().toUpperCase() : '';\n\t  },\n\t\n\t  /**\n\t   * 'AbC' => 'abc'\n\t   */\n\t\n\t  lowercase: function lowercase(value) {\n\t    return value || value === 0 ? value.toString().toLowerCase() : '';\n\t  },\n\t\n\t  /**\n\t   * 12345 => $12,345.00\n\t   *\n\t   * @param {String} sign\n\t   * @param {Number} decimals Decimal places\n\t   */\n\t\n\t  currency: function currency(value, _currency, decimals) {\n\t    value = parseFloat(value);\n\t    if (!isFinite(value) || !value && value !== 0) return '';\n\t    _currency = _currency != null ? _currency : '$';\n\t    decimals = decimals != null ? decimals : 2;\n\t    var stringified = Math.abs(value).toFixed(decimals);\n\t    var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified;\n\t    var i = _int.length % 3;\n\t    var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';\n\t    var _float = decimals ? stringified.slice(-1 - decimals) : '';\n\t    var sign = value < 0 ? '-' : '';\n\t    return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;\n\t  },\n\t\n\t  /**\n\t   * 'item' => 'items'\n\t   *\n\t   * @params\n\t   *  an array of strings corresponding to\n\t   *  the single, double, triple ... forms of the word to\n\t   *  be pluralized. When the number to be pluralized\n\t   *  exceeds the length of the args, it will use the last\n\t   *  entry in the array.\n\t   *\n\t   *  e.g. ['single', 'double', 'triple', 'multiple']\n\t   */\n\t\n\t  pluralize: function pluralize(value) {\n\t    var args = toArray(arguments, 1);\n\t    var length = args.length;\n\t    if (length > 1) {\n\t      var index = value % 10 - 1;\n\t      return index in args ? args[index] : args[length - 1];\n\t    } else {\n\t      return args[0] + (value === 1 ? '' : 's');\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Debounce a handler function.\n\t   *\n\t   * @param {Function} handler\n\t   * @param {Number} delay = 300\n\t   * @return {Function}\n\t   */\n\t\n\t  debounce: function debounce(handler, delay) {\n\t    if (!handler) return;\n\t    if (!delay) {\n\t      delay = 300;\n\t    }\n\t    return _debounce(handler, delay);\n\t  }\n\t};\n\t\n\tfunction installGlobalAPI (Vue) {\n\t  /**\n\t   * Vue and every constructor that extends Vue has an\n\t   * associated options object, which can be accessed during\n\t   * compilation steps as `this.constructor.options`.\n\t   *\n\t   * These can be seen as the default options of every\n\t   * Vue instance.\n\t   */\n\t\n\t  Vue.options = {\n\t    directives: directives,\n\t    elementDirectives: elementDirectives,\n\t    filters: filters,\n\t    transitions: {},\n\t    components: {},\n\t    partials: {},\n\t    replace: true\n\t  };\n\t\n\t  /**\n\t   * Expose useful internals\n\t   */\n\t\n\t  Vue.util = util;\n\t  Vue.config = config;\n\t  Vue.set = set;\n\t  Vue['delete'] = del;\n\t  Vue.nextTick = nextTick;\n\t\n\t  /**\n\t   * The following are exposed for advanced usage / plugins\n\t   */\n\t\n\t  Vue.compiler = compiler;\n\t  Vue.FragmentFactory = FragmentFactory;\n\t  Vue.internalDirectives = internalDirectives;\n\t  Vue.parsers = {\n\t    path: path,\n\t    text: text,\n\t    template: template,\n\t    directive: directive,\n\t    expression: expression\n\t  };\n\t\n\t  /**\n\t   * Each instance constructor, including Vue, has a unique\n\t   * cid. This enables us to create wrapped \"child\n\t   * constructors\" for prototypal inheritance and cache them.\n\t   */\n\t\n\t  Vue.cid = 0;\n\t  var cid = 1;\n\t\n\t  /**\n\t   * Class inheritance\n\t   *\n\t   * @param {Object} extendOptions\n\t   */\n\t\n\t  Vue.extend = function (extendOptions) {\n\t    extendOptions = extendOptions || {};\n\t    var Super = this;\n\t    var isFirstExtend = Super.cid === 0;\n\t    if (isFirstExtend && extendOptions._Ctor) {\n\t      return extendOptions._Ctor;\n\t    }\n\t    var name = extendOptions.name || Super.options.name;\n\t    if (false) {\n\t      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n\t        warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');\n\t        name = null;\n\t      }\n\t    }\n\t    var Sub = createClass(name || 'VueComponent');\n\t    Sub.prototype = Object.create(Super.prototype);\n\t    Sub.prototype.constructor = Sub;\n\t    Sub.cid = cid++;\n\t    Sub.options = mergeOptions(Super.options, extendOptions);\n\t    Sub['super'] = Super;\n\t    // allow further extension\n\t    Sub.extend = Super.extend;\n\t    // create asset registers, so extended classes\n\t    // can have their private assets too.\n\t    config._assetTypes.forEach(function (type) {\n\t      Sub[type] = Super[type];\n\t    });\n\t    // enable recursive self-lookup\n\t    if (name) {\n\t      Sub.options.components[name] = Sub;\n\t    }\n\t    // cache constructor\n\t    if (isFirstExtend) {\n\t      extendOptions._Ctor = Sub;\n\t    }\n\t    return Sub;\n\t  };\n\t\n\t  /**\n\t   * A function that returns a sub-class constructor with the\n\t   * given name. This gives us much nicer output when\n\t   * logging instances in the console.\n\t   *\n\t   * @param {String} name\n\t   * @return {Function}\n\t   */\n\t\n\t  function createClass(name) {\n\t    /* eslint-disable no-new-func */\n\t    return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();\n\t    /* eslint-enable no-new-func */\n\t  }\n\t\n\t  /**\n\t   * Plugin system\n\t   *\n\t   * @param {Object} plugin\n\t   */\n\t\n\t  Vue.use = function (plugin) {\n\t    /* istanbul ignore if */\n\t    if (plugin.installed) {\n\t      return;\n\t    }\n\t    // additional parameters\n\t    var args = toArray(arguments, 1);\n\t    args.unshift(this);\n\t    if (typeof plugin.install === 'function') {\n\t      plugin.install.apply(plugin, args);\n\t    } else {\n\t      plugin.apply(null, args);\n\t    }\n\t    plugin.installed = true;\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Apply a global mixin by merging it into the default\n\t   * options.\n\t   */\n\t\n\t  Vue.mixin = function (mixin) {\n\t    Vue.options = mergeOptions(Vue.options, mixin);\n\t  };\n\t\n\t  /**\n\t   * Create asset registration methods with the following\n\t   * signature:\n\t   *\n\t   * @param {String} id\n\t   * @param {*} definition\n\t   */\n\t\n\t  config._assetTypes.forEach(function (type) {\n\t    Vue[type] = function (id, definition) {\n\t      if (!definition) {\n\t        return this.options[type + 's'][id];\n\t      } else {\n\t        /* istanbul ignore if */\n\t        if (false) {\n\t          if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {\n\t            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\n\t          }\n\t        }\n\t        if (type === 'component' && isPlainObject(definition)) {\n\t          if (!definition.name) {\n\t            definition.name = id;\n\t          }\n\t          definition = Vue.extend(definition);\n\t        }\n\t        this.options[type + 's'][id] = definition;\n\t        return definition;\n\t      }\n\t    };\n\t  });\n\t\n\t  // expose internal transition API\n\t  extend(Vue.transition, transition);\n\t}\n\t\n\tinstallGlobalAPI(Vue);\n\t\n\tVue.version = '1.0.26';\n\t\n\t// devtools global hook\n\t/* istanbul ignore next */\n\tsetTimeout(function () {\n\t  if (config.devtools) {\n\t    if (devtools) {\n\t      devtools.emit('init', Vue);\n\t    } else if (false) {\n\t      console.log('Download the Vue Devtools for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n\t    }\n\t  }\n\t}, 0);\n\t\n\tmodule.exports = Vue;\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.configRouter = configRouter;\n\t\n\tvar _App = __webpack_require__(35);\n\t\n\tvar _App2 = _interopRequireDefault(_App);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction configRouter(router) {\n\t    router.map({\n\t        '/index': {\n\t            component: __webpack_require__(6)\n\t        },\n\t        '/create': {\n\t            component: __webpack_require__(36)\n\t        },\n\t        '/edit/:questId': {\n\t            component: __webpack_require__(38)\n\t        },\n\t        '/preview/:questId': {\n\t            component: __webpack_require__(40)\n\t        },\n\t        '/data/:questId': {\n\t            component: __webpack_require__(37)\n\t        }\n\t    });\n\t    router.redirect({\n\t        '*': '/index'\n\t    });\n\t    router.start(_App2.default, 'app');\n\t}\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _stringify = __webpack_require__(3);\n\t\n\tvar _stringify2 = _interopRequireDefault(_stringify);\n\t\n\tvar _vuex = __webpack_require__(49);\n\t\n\tvar _vuex2 = _interopRequireDefault(_vuex);\n\t\n\tvar _vue = __webpack_require__(7);\n\t\n\tvar _vue2 = _interopRequireDefault(_vue);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_vue2.default.use(_vuex2.default);\n\t\n\tvar KEY = 'questionnaireList';\n\tvar questionnaire01 = {\n\t    \"title\": \"问卷调查一\",\n\t    \"deadline\": 1471622400000,\n\t    \"state\": \"未发布\",\n\t    \"questItemList\": [{\n\t        \"type\": \"radio\",\n\t        \"title\": \"性别\",\n\t        \"selections\": [\"男\", \"女\"],\n\t        \"name\": 1471528977004\n\t    }, {\n\t        \"type\": \"checkbox\",\n\t        \"title\": \"爱好\",\n\t        \"selections\": [\"篮球\", \"足球\", \"网球\"],\n\t        \"name\": 1471528987079\n\t    }, {\n\t        \"type\": \"textarea\",\n\t        \"title\": \"自我评价\"\n\t    }],\n\t    \"id\": 1471528999124\n\t};\n\tvar questionnaire02 = {\n\t    \"title\": \"问卷调查二\",\n\t    \"deadline\": 1471622400000,\n\t    \"state\": \"已发布\",\n\t    \"questItemList\": [{\n\t        \"type\": \"radio\",\n\t        \"title\": \"性别\",\n\t        \"selections\": [\"男\", \"女\"],\n\t        \"name\": 1471528977004\n\t    }, {\n\t        \"type\": \"checkbox\",\n\t        \"title\": \"爱好\",\n\t        \"selections\": [\"篮球\", \"足球\", \"网球\"],\n\t        \"name\": 1471528987079\n\t    }, {\n\t        \"type\": \"textarea\",\n\t        \"title\": \"自我评价\"\n\t    }],\n\t    \"id\": 1471528999124\n\t};\n\tvar questionnaire03 = {\n\t    \"title\": \"问卷调查三\",\n\t    \"deadline\": 1471622400000,\n\t    \"state\": \"已发布\",\n\t    \"questItemList\": [{\n\t        \"type\": \"radio\",\n\t        \"title\": \"性别\",\n\t        \"selections\": [\"男\", \"女\"],\n\t        \"name\": 1471528977004\n\t    }, {\n\t        \"type\": \"checkbox\",\n\t        \"title\": \"爱好\",\n\t        \"selections\": [\"篮球\", \"足球\", \"网球\"],\n\t        \"name\": 1471528987079\n\t    }, {\n\t        \"type\": \"textarea\",\n\t        \"title\": \"自我评价\"\n\t    }],\n\t    \"id\": 1471528999124\n\t};\n\tif (!localStorage.getItem(KEY)) {\n\t    localStorage.setItem(KEY, (0, _stringify2.default)([questionnaire01, questionnaire02, questionnaire03]));\n\t}\n\t\n\tvar state = {\n\t    questionnaireList: JSON.parse(localStorage.getItem(KEY)),\n\t    currentQuestionnaire: null };\n\t\n\tvar mutations = {\n\t    ADD_QUEST: function ADD_QUEST(state, item) {\n\t        state.questionnaireList.push(item);\n\t        state.currentQuestionnaire = item;\n\t        updateStorage(state);\n\t    },\n\t    RM_QUEST: function RM_QUEST(state, item) {\n\t        var index = state.questionnaireList.indexOf(item);\n\t        if (item !== -1) {\n\t            state.questionnaireList.splice(index, 1);\n\t            updateStorage(state);\n\t        } else {\n\t            throw new Error(\"该问卷不存在！\");\n\t        }\n\t    },\n\t    UPDATE_QUEST: function UPDATE_QUEST(state, item) {\n\t        var index = state.questionnaireList.indexOf(item);\n\t        if (index !== -1) {\n\t            state.questionnaireList.splice(index, 1, item);\n\t            state.currentQuestionnaire = item;\n\t            updateStorage(state);\n\t        } else {\n\t            throw new Error(\"该问卷不存在！\");\n\t        }\n\t    },\n\t    SET_QUEST: function SET_QUEST(state, item) {\n\t        if (state.currentQuestionnaire === item) {\n\t            return;\n\t        }\n\t        state.currentQuestionnaire = item;\n\t    }\n\t};\n\t\n\tfunction updateStorage(state) {\n\t    localStorage.setItem(KEY, (0, _stringify2.default)(state.questionnaireList));\n\t}\n\t\n\texports.default = new _vuex2.default.Store({\n\t    state: state,\n\t    mutations: mutations\n\t});\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _Header = __webpack_require__(39);\n\t\n\tvar _Header2 = _interopRequireDefault(_Header);\n\t\n\tvar _Index = __webpack_require__(6);\n\t\n\tvar _Index2 = _interopRequireDefault(_Index);\n\t\n\tvar _store = __webpack_require__(9);\n\t\n\tvar _store2 = _interopRequireDefault(_store);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t    data: function data() {\n\t        return {\n\t            msg: 'Hello Vue!'\n\t        };\n\t    },\n\t\n\t    components: {\n\t        'v-header': _Header2.default,\n\t        Index: _Index2.default\n\t    },\n\t    store: _store2.default\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar date = new Date();\n\t\n\texports.default = {\n\t    props: ['showCalendar'],\n\t    data: function data() {\n\t        return {\n\t            weekList: ['日', '一', '二', '三', '四', '五', '六'],\n\t            currentYear: date.getFullYear(),\n\t            currentMonth: date.getMonth() + 1\n\t        };\n\t    },\n\t\n\t    computed: {\n\t        yearList: function yearList() {\n\t            var yearList = [];\n\t            for (var i = 1900; i < 2051; i++) {\n\t                yearList.push(i);\n\t            }\n\t            return yearList;\n\t        },\n\t        monthList: function monthList() {\n\t            var monthList = [];\n\t            for (var i = 1; i <= 12; i++) {\n\t                monthList.push(i);\n\t            }\n\t            return monthList;\n\t        },\n\t        tableData: function tableData() {\n\t            var currentDateList = [];\n\t            var date = new Date(this.currentYear, this.currentMonth - 1, 1);\n\t            var oneDayMilliseconds = 24 * 60 * 60 * 1000;\n\t            var dateWeek = date.getDay();\n\t            var firstDate = date.getTime() - dateWeek * oneDayMilliseconds;\n\t            for (var i = 0; i < 6; i++) {\n\t                currentDateList[i] = [];\n\t                for (var m = 0; m < 7; m++) {\n\t                    currentDateList[i].push(new Date(firstDate));\n\t                    firstDate += oneDayMilliseconds;\n\t                }\n\t            }\n\t            return currentDateList;\n\t        }\n\t    },\n\t    methods: {\n\t        incrMonth: function incrMonth() {\n\t            if (this.currentMonth === 12) {\n\t                this.currentMonth = 1;\n\t                this.currentYear++;\n\t            } else {\n\t                this.currentMonth++;\n\t            }\n\t        },\n\t        decrMonth: function decrMonth() {\n\t            if (this.currentMonth === 1) {\n\t                this.currentMonth = 12;\n\t                this.currentYear--;\n\t            } else {\n\t                this.currentMonth--;\n\t            }\n\t        },\n\t        handleClick: function handleClick(event) {\n\t            if (event.target.dataset.date) {\n\t                var _date = new Date(parseInt(event.target.dataset.date));\n\t                this.currentYear = _date.getFullYear();\n\t                this.currentMonth = _date.getMonth() + 1;\n\t\n\t                this.$dispatch(\"date-change\", _date);\n\t                this.showCalendar = false;\n\t            }\n\t        }\n\t    }\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _stringify = __webpack_require__(3);\n\t\n\tvar _stringify2 = _interopRequireDefault(_stringify);\n\t\n\tvar _Calendar = __webpack_require__(5);\n\t\n\tvar _Calendar2 = _interopRequireDefault(_Calendar);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t    data: function data() {\n\t        return {\n\t            showSelections: false,\n\t            showMask: false,\n\t            showCalendar: false,\n\t            questionnaire: {\n\t                title: '',\n\t                deadline: '',\n\t                state: '',\n\t                questItemList: []\n\t            },\n\t            questItem: {},\n\t            typeMap: {\n\t                radio: '单选',\n\t                checkbox: '多选',\n\t                textarea: '问答'\n\t            }\n\t        };\n\t    },\n\t\n\t    methods: {\n\t        addItem: function addItem(event) {\n\t            var target = event.target;\n\t            if (target.nodeName.toLowerCase() === 'span') {\n\t                this.showMask = true;\n\t                this.questItem.type = target.dataset.type;\n\t            }\n\t        },\n\t        handleInput: function handleInput(event) {\n\t            var target = event.target;\n\t            if (target.nodeName.toLowerCase() !== 'button') {\n\t                return;\n\t            }\n\t            var itemTitle = this.$els.itemTitle;\n\t            var itemSelections = this.$els.itemSelections;\n\t            if (target.dataset.operation === \"confirm\") {\n\t                if (this.questItem.type === \"textarea\") {\n\t                    this.addTextarea(itemTitle);\n\t                } else {\n\t                    this.addSelections(itemTitle, itemSelections);\n\t                }\n\t            } else {\n\t                this.handleCancel();\n\t            }\n\t        },\n\t        addTextarea: function addTextarea(itemTitle) {\n\t            if (itemTitle.value.trim() === '') {\n\t                return;\n\t            }\n\t            this.questItem.title = itemTitle.value.trim();\n\t            this.questionnaire.questItemList.push(this.questItem);\n\t            this.handleCancel();\n\t        },\n\t        addSelections: function addSelections(itemTitle, itemSelections) {\n\t            if (itemTitle.value.trim() === '' || itemSelections.value.trim() === '') {\n\t                return;\n\t            }\n\t            this.questItem.title = itemTitle.value.trim();\n\t            this.questItem.selections = itemSelections.value.trim().split(/\\s+/);\n\t            this.questItem.name = Date.now();\n\t            this.questionnaire.questItemList.push(this.questItem);\n\t            this.handleCancel();\n\t        },\n\t        handleCancel: function handleCancel() {\n\t            this.$els.itemTitle.value = '';\n\t            this.$els.itemSelections.value = '';\n\t            this.questItem = {};\n\t            this.showMask = false;\n\t        },\n\t        handleItemOperation: function handleItemOperation(event, questItem) {\n\t            var operation = event.target.dataset.operation;\n\t            switch (operation) {\n\t                case 'up':\n\t                    this.moveUp(questItem);\n\t                    break;\n\t                case 'down':\n\t                    this.moveDown(questItem);\n\t                    break;\n\t                case 'remove':\n\t                    this.removeQuestItem(questItem);\n\t                    break;\n\t                case 'reuse':\n\t                    this.reuseQuestItem(questItem);\n\t                    break;\n\t                default:\n\t                    throw new Error(\"该操作\" + \"operation\" + \"不存在！\");\n\t            }\n\t        },\n\t        moveUp: function moveUp(questItem) {\n\t            var index = this.questionnaire.questItemList.indexOf(questItem);\n\t            this.questionnaire.questItemList.$remove(questItem);\n\t            this.questionnaire.questItemList.splice(index - 1, 0, questItem);\n\t        },\n\t        moveDown: function moveDown(questItem) {\n\t            var index = this.questionnaire.questItemList.indexOf(questItem);\n\t            this.moveUp(this.questionnaire.questItemList[index + 1]);\n\t        },\n\t        removeQuestItem: function removeQuestItem(questItem) {\n\t            this.questionnaire.questItemList.$remove(questItem);\n\t        },\n\t        reuseQuestItem: function reuseQuestItem(questItem) {\n\t            var index = this.questionnaire.questItemList.indexOf(questItem);\n\t\n\t            var newQuestItem = JSON.parse((0, _stringify2.default)(questItem));\n\t            if (newQuestItem.type !== 'textarea') {\n\t                newQuestItem.name = Date.now();\n\t            }\n\t            this.questionnaire.questItemList.splice(index + 1, 0, newQuestItem);\n\t        },\n\t        submit: function submit(event) {\n\t            var operation = event.target.dataset.operation;\n\t            var oneDayTime = 24 * 60 * 60 * 1000;\n\t            if (this.questionnaire.title.trim() === '') {\n\t                alert(\"问卷的标题不能为空！\");\n\t                return;\n\t            }\n\t            if (this.questionnaire.questItemList.length === 0) {\n\t                alert(\"请至少设置一个问题！\");\n\t                return;\n\t            }\n\t            if (!this.questionnaire.deadline || this.questionnaire.deadline < Date.now()) {\n\t                alert(\"问卷的截止时间必须在今天之后！\");\n\t                return;\n\t            }\n\t            if (operation === 'save') {\n\t                this.save();\n\t            } else {\n\t                this.publish();\n\t            }\n\t        }\n\t    },\n\t    components: {\n\t        Calendar: _Calendar2.default\n\t    },\n\t    events: {\n\t        'date-change': function dateChange(msg) {\n\t            var date = new Date(msg);\n\t            this.$els.deadline.value = date.toLocaleDateString();\n\t            this.questionnaire.deadline = date.getTime();\n\t        }\n\t    },\n\t    vuex: {\n\t        actions: {\n\t            save: function save(_ref) {\n\t                var dispatch = _ref.dispatch;\n\t\n\t                this.questionnaire.state = \"未发布\";\n\t                this.questionnaire.id = Date.now();\n\t                dispatch('ADD_QUEST', this.questionnaire);\n\t                this.$router.go('/preview/' + this.questionnaire.id);\n\t            },\n\t            publish: function publish(_ref2) {\n\t                var dispatch = _ref2.dispatch;\n\t\n\t                this.questionnaire.state = \"已发布\";\n\t                if (!this.questionnaire.id) {\n\t                    this.questionnaire.id = Date.now();\n\t                }\n\t                dispatch('ADD_QUEST', this.questionnaire);\n\t                this.$router.go('/preview/' + this.questionnaire.id);\n\t            }\n\t        }\n\t    }\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _echarts = __webpack_require__(50);\n\t\n\tvar _echarts2 = _interopRequireDefault(_echarts);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t    data: function data() {\n\t        return {\n\t            typeMap: {\n\t                radio: '单选',\n\t                checkbox: '多选',\n\t                textarea: '问答'\n\t            }\n\t        };\n\t    },\n\t\n\t    vuex: {\n\t        getters: {\n\t            questionnaire: function questionnaire(state) {\n\t                return state.currentQuestionnaire;\n\t            },\n\t            questionnaireList: function questionnaireList(state) {\n\t                return state.questionnaireList;\n\t            }\n\t        },\n\t        actions: {\n\t            setCurrentQuest: function setCurrentQuest(_ref, item) {\n\t                var dispatch = _ref.dispatch;\n\t\n\t                dispatch(\"SET_QUEST\", item);\n\t            }\n\t        }\n\t    },\n\t    route: {\n\t        data: function data(_ref2) {\n\t            var _this = this;\n\t\n\t            var to = _ref2.to;\n\t            var next = _ref2.next;\n\t\n\t            var id = to.params.questId;\n\t            if (!this.questionnaire) {\n\t                this.questionnaireList.forEach(function (item) {\n\t                    if (parseInt(item.id) === parseInt(id)) {\n\t                        _this.setCurrentQuest(item);\n\t                        return;\n\t                    }\n\t                });\n\t            }\n\t\n\t            next();\n\t        }\n\t    },\n\t    directives: {\n\t        'echarts': {\n\t            bind: function bind() {\n\t                var self = this;\n\t                this.vm.$nextTick(function () {\n\t                    self.instance = _echarts2.default.init(self.el);\n\t                });\n\t            },\n\t            update: function update(newVal, oldVal) {\n\t                var self = this;\n\t                var seriesData = [];\n\t                var option = {};\n\t\n\t                if (newVal.type !== 'textarea') {\n\t                    newVal.selections.forEach(function (item) {\n\t                        seriesData.push(parseInt(Math.random() * 100));\n\t                    });\n\t                    option = {\n\t                        grid: {\n\t                            top: 40,\n\t                            bottom: 25\n\t                        },\n\t                        title: {\n\t                            text: self.vm.typeMap[newVal.type] + '.' + newVal.title,\n\t                            textAlign: \"left\"\n\t                        },\n\t                        yAxis: {},\n\t                        xAxis: {\n\t                            data: newVal.selections\n\t                        },\n\t                        series: [{\n\t                            type: 'bar',\n\t                            data: seriesData\n\t                        }]\n\t                    };\n\t                } else {\n\t                    seriesData.push(parseInt(Math.random() * 100));\n\t                    seriesData.push(100 - seriesData[0]);\n\t                    option = {\n\t                        title: {\n\t                            text: self.vm.typeMap[newVal.type] + '.' + newVal.title,\n\t                            textAlign: \"left\"\n\t                        },\n\t                        series: [{\n\t                            type: 'pie',\n\t                            radius: \"60%\",\n\t                            data: [{ name: '有效回答', value: seriesData[0] }, { name: '无效回答', value: seriesData[1] }]\n\t                        }]\n\t                    };\n\t                }\n\t                this.vm.$nextTick(function () {\n\t                    self.instance.setOption(option);\n\t                });\n\t            },\n\t            unbind: function unbind() {\n\t                this.instance.dispose();\n\t            }\n\t        }\n\t    }\n\t};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _stringify = __webpack_require__(3);\n\t\n\tvar _stringify2 = _interopRequireDefault(_stringify);\n\t\n\tvar _Calendar = __webpack_require__(5);\n\t\n\tvar _Calendar2 = _interopRequireDefault(_Calendar);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t    data: function data() {\n\t        return {\n\t            showSelections: false,\n\t            showMask: false,\n\t            showCalendar: false,\n\t            questItem: {},\n\t            typeMap: {\n\t                radio: '单选',\n\t                checkbox: '多选',\n\t                textarea: '问答'\n\t            }\n\t        };\n\t    },\n\t\n\t    methods: {\n\t        addItem: function addItem(event) {\n\t            var target = event.target;\n\t            if (target.nodeName.toLowerCase() === 'span') {\n\t                this.showMask = true;\n\t                this.questItem.type = target.dataset.type;\n\t            }\n\t        },\n\t        handleInput: function handleInput(event) {\n\t            var target = event.target;\n\t            if (target.nodeName.toLowerCase() !== 'button') {\n\t                return;\n\t            }\n\t            var itemTitle = this.$els.itemTitle;\n\t            var itemSelections = this.$els.itemSelections;\n\t            if (target.dataset.operation === \"confirm\") {\n\t                if (this.questItem.type === \"textarea\") {\n\t                    this.addTextarea(itemTitle);\n\t                } else {\n\t                    this.addSelections(itemTitle, itemSelections);\n\t                }\n\t            } else {\n\t                this.handleCancel();\n\t            }\n\t        },\n\t        addTextarea: function addTextarea(itemTitle) {\n\t            if (itemTitle.value.trim() === '') {\n\t                return;\n\t            }\n\t            this.questItem.title = itemTitle.value.trim();\n\t            this.questionnaire.questItemList.push(this.questItem);\n\t            this.handleCancel();\n\t        },\n\t        addSelections: function addSelections(itemTitle, itemSelections) {\n\t            if (itemTitle.value.trim() === '' || itemSelections.value.trim() === '') {\n\t                return;\n\t            }\n\t            this.questItem.title = itemTitle.value.trim();\n\t            this.questItem.selections = itemSelections.value.trim().split(/\\s+/);\n\t            this.questItem.name = Date.now();\n\t            this.questionnaire.questItemList.push(this.questItem);\n\t            this.handleCancel();\n\t        },\n\t        handleCancel: function handleCancel() {\n\t            this.$els.itemTitle.value = '';\n\t            this.$els.itemSelections.value = '';\n\t            this.questItem = {};\n\t            this.showMask = false;\n\t        },\n\t        handleItemOperation: function handleItemOperation(event, questItem) {\n\t            var operation = event.target.dataset.operation;\n\t            switch (operation) {\n\t                case 'up':\n\t                    this.moveUp(questItem);\n\t                    break;\n\t                case 'down':\n\t                    this.moveDown(questItem);\n\t                    break;\n\t                case 'remove':\n\t                    this.removeQuestItem(questItem);\n\t                    break;\n\t                case 'reuse':\n\t                    this.reuseQuestItem(questItem);\n\t                    break;\n\t                default:\n\t                    throw new Error(\"该操作\" + \"operation\" + \"不存在！\");\n\t            }\n\t        },\n\t        moveUp: function moveUp(questItem) {\n\t            var index = this.questionnaire.questItemList.indexOf(questItem);\n\t            this.questionnaire.questItemList.$remove(questItem);\n\t            this.questionnaire.questItemList.splice(index - 1, 0, questItem);\n\t        },\n\t        moveDown: function moveDown(questItem) {\n\t            var index = this.questionnaire.questItemList.indexOf(questItem);\n\t            this.moveUp(this.questionnaire.questItemList[index + 1]);\n\t        },\n\t        removeQuestItem: function removeQuestItem(questItem) {\n\t            this.questionnaire.questItemList.$remove(questItem);\n\t        },\n\t        reuseQuestItem: function reuseQuestItem(questItem) {\n\t            var index = this.questionnaire.questItemList.indexOf(questItem);\n\t\n\t            var newQuestItem = JSON.parse((0, _stringify2.default)(questItem));\n\t            if (newQuestItem.type !== 'textarea') {\n\t                newQuestItem.name = Date.now();\n\t            }\n\t            this.questionnaire.questItemList.splice(index + 1, 0, newQuestItem);\n\t        },\n\t        submit: function submit(event) {\n\t            var operation = event.target.dataset.operation;\n\t            var oneDayTime = 24 * 60 * 60 * 1000;\n\t            if (this.questionnaire.title.trim() === '') {\n\t                alert(\"问卷的标题不能为空！\");\n\t                return;\n\t            }\n\t            if (this.questionnaire.questItemList.length === 0) {\n\t                alert(\"请至少设置一个问题！\");\n\t                return;\n\t            }\n\t            if (!this.questionnaire.deadline || this.questionnaire.deadline < Date.now()) {\n\t                alert(\"问卷的截止时间必须在今天之后！\");\n\t                return;\n\t            }\n\t            if (operation === 'save') {\n\t                this.save();\n\t            } else {\n\t                this.publish();\n\t            }\n\t        }\n\t    },\n\t    components: {\n\t        Calendar: _Calendar2.default\n\t    },\n\t    events: {\n\t        'date-change': function dateChange(msg) {\n\t            var date = new Date(msg);\n\t            this.$els.deadline.value = date.toLocaleDateString();\n\t            this.questionnaire.deadline = date.getTime();\n\t        }\n\t    },\n\t    vuex: {\n\t        actions: {\n\t            save: function save(_ref) {\n\t                var dispatch = _ref.dispatch;\n\t\n\t                this.questionnaire.state = \"未发布\";\n\t                dispatch('UPDATE_QUEST', this.questionnaire);\n\t                this.$router.go('/preview/' + this.questionnaire.id);\n\t            },\n\t            publish: function publish(_ref2) {\n\t                var dispatch = _ref2.dispatch;\n\t\n\t                this.questionnaire.state = \"已发布\";\n\t                dispatch('UPDATE_QUEST', this.questionnaire);\n\t                this.$router.go('/preview/' + this.questionnaire.id);\n\t            },\n\t            setCurrentQuest: function setCurrentQuest(_ref3, item) {\n\t                var dispatch = _ref3.dispatch;\n\t\n\t                dispatch(\"SET_QUEST\", item);\n\t            }\n\t        },\n\t        getters: {\n\t            questionnaire: function questionnaire(state) {\n\t                return state.currentQuestionnaire;\n\t            },\n\t            questionnaireList: function questionnaireList(state) {\n\t                return state.questionnaireList;\n\t            }\n\t        }\n\t    },\n\t    route: {\n\t        data: function data(_ref4) {\n\t            var _this = this;\n\t\n\t            var to = _ref4.to;\n\t            var next = _ref4.next;\n\t\n\t            var id = to.params.questId;\n\t            if (!this.questionnaire) {\n\t                this.questionnaireList.forEach(function (item) {\n\t                    if (parseInt(item.id) === parseInt(id)) {\n\t                        _this.setCurrentQuest(item);\n\t                        return;\n\t                    }\n\t                });\n\t            }\n\t            next();\n\t        }\n\t    }\n\t};\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = {\n\t    data: function data() {\n\t        return {\n\t            name: Date.now(),\n\t            checkedQuest: [] };\n\t    },\n\t\n\t    vuex: {\n\t        getters: {\n\t            questionnaireList: function questionnaireList(state) {\n\t                return state.questionnaireList;\n\t            }\n\t        },\n\t        actions: {\n\t            setQuest: function setQuest(_ref, item) {\n\t                var dispatch = _ref.dispatch;\n\t\n\t                dispatch('SET_QUEST', item);\n\t            },\n\t            removeQuest: function removeQuest(_ref2, item) {\n\t                var dispatch = _ref2.dispatch;\n\t\n\t                dispatch('RM_QUEST', item);\n\t            }\n\t        }\n\t    },\n\t    methods: {\n\t        createQuest: function createQuest() {\n\t            this.$router.go('/create');\n\t        },\n\t        handleOperation: function handleOperation(event, questionnaire) {\n\t            var operation = event.target.dataset.operation;\n\t            if (operation === \"edit\") {\n\t                this.setQuest(questionnaire);\n\t                this.$router.go('/edit/' + questionnaire.id);\n\t            } else if (operation === \"preview\") {\n\t                this.setQuest(questionnaire);\n\t                this.$router.go('/preview/' + questionnaire.id);\n\t            } else if (operation === \"checked\") {\n\t                this.handleChecked(questionnaire);\n\t            } else if (operation === \"data\") {\n\t                this.setQuest(questionnaire);\n\t                this.$router.go('/data/' + questionnaire.id);\n\t            }\n\t        },\n\t        handleChecked: function handleChecked(questionnaire) {\n\t            var index = this.checkedQuest.indexOf(questionnaire);\n\t\n\t            if (index === -1) {\n\t                this.checkedQuest.push(questionnaire);\n\t            } else {\n\t                this.checkedQuest.splice(index, 1);\n\t            }\n\t        },\n\t        createOrRm: function createOrRm(event) {\n\t            var operation = event.target.dataset.operation;\n\t            if (operation === 'create') {\n\t                this.createQuest();\n\t            } else if (operation === 'rmChecked') {\n\t                this.remove();\n\t            }\n\t        },\n\t        remove: function remove() {\n\t            while (this.checkedQuest.length > 0) {\n\t                var questionnaire = this.checkedQuest.shift();\n\t                this.removeQuest(questionnaire);\n\t            }\n\t        }\n\t    }\n\t};\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = {\n\t    data: function data() {\n\t        return {\n\t            typeMap: {\n\t                radio: '单选',\n\t                checkbox: '多选',\n\t                textarea: '问答'\n\t            }\n\t        };\n\t    },\n\t\n\t    vuex: {\n\t        getters: {\n\t            questionnaire: function questionnaire(state) {\n\t                return state.currentQuestionnaire;\n\t            },\n\t            questionnaireList: function questionnaireList(state) {\n\t                return state.questionnaireList;\n\t            }\n\t        },\n\t        actions: {\n\t            setCurrentQuest: function setCurrentQuest(_ref, item) {\n\t                var dispatch = _ref.dispatch;\n\t\n\t                dispatch(\"SET_QUEST\", item);\n\t            }\n\t        }\n\t    },\n\t    route: {\n\t        data: function data(_ref2) {\n\t            var _this = this;\n\t\n\t            var to = _ref2.to;\n\t            var next = _ref2.next;\n\t\n\t            var id = to.params.questId;\n\t            if (!this.questionnaire) {\n\t                this.questionnaireList.forEach(function (item) {\n\t                    if (parseInt(item.id) === parseInt(id)) {\n\t                        _this.setCurrentQuest(item);\n\t                        return;\n\t                    }\n\t                });\n\t            }\n\t            next();\n\t        }\n\t    }\n\t};\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar core  = __webpack_require__(19)\n\t  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});\n\tmodule.exports = function stringify(it){ // eslint-disable-line no-unused-vars\n\t  return $JSON.stringify.apply($JSON, arguments);\n\t};\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\tvar core = module.exports = {version: '2.4.0'};\n\tif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(1)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"#calendar{width:300px;border:1px solid #ccc;border-radius:3px;box-sizing:border-box;padding:10px;font-size:14px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}#calendar .calendar-selections{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-pack:distribute;justify-content:space-around;width:100%;height:30px}#calendar .calendar-selections span{display:inline-block;height:24px;line-height:24px;cursor:pointer}#calendar .calendar-selections_month,#calendar .calendar-selections_year{width:90px;height:24px}#calendar .calendar-selections_month option,#calendar .calendar-selections_year option,#calendar table{text-align:center}#calendar table{width:100%;border-collapse:collapse}#calendar table,#calendar td,#calendar th{border:none}#calendar tr{height:26px}#calendar td{cursor:pointer;-webkit-transition:background-color .2s;transition:background-color .2s}#calendar td:hover{background-color:#cce5ff}#calendar .not-current-month{color:#aaa}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(1)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"#create{width:10rem;border:.03rem solid #ccc;border-radius:.05rem;margin:.4rem auto;font-size:.16rem;box-sizing:border-box;padding:.1rem .2rem}#create .item-operation{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end}#create .item-operation button{width:.4rem;padding:.05rem 0;margin-right:.1rem;border-radius:.02rem}#create .questItem:hover{background-color:#cce5ff}#create .deadline{position:relative}#create #calendar{position:absolute;top:-240px;left:0;background-color:#fff}#create .deadline input{width:1.5rem;padding-left:.1rem;height:.25rem;border-radius:.02rem;border:1px solid #ccc}#create .submit{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-pack:distribute;justify-content:space-around;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin-top:.2rem}#create .submit button{width:.9rem;background-color:#007fff;margin-right:.2rem;padding:.1rem 0;color:#fff;border-radius:.03rem}#create .submit button:hover{background-color:#cce5ff;color:#555}#create .questItem{padding:.15rem .2rem;font-size:.17rem;-webkit-transition:background-color .1s;transition:background-color .1s}#create .questItem textarea{resize:none;width:3.3rem;height:1.7rem;border-radius:.03rem}#create .questItem-title{margin-bottom:.15rem}#create .questItem-title+div{margin-left:.2rem}#create .selection{margin-bottom:.15rem}#create .mask-prompt{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;position:absolute;width:4rem;height:2rem;top:40%;left:50%;margin-left:-2rem;margin-top:-1rem}#create .prompt{font-size:.12px;text-align:center;margin-top:.1rem}#create .prompt-header{width:100%;background-color:#007fff;height:.3rem;text-align:center;line-height:.3rem;color:#fff;font-weight:700;font-size:.18rem}#create .prompt-body{background-color:#fff;-webkit-box-flex:1;-ms-flex:1;flex:1;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:distribute;justify-content:space-around;padding:0 .5rem}#create .prompt-body label{display:inline-block;width:.85rem;text-align:right}#create .prompt-footer{height:.3rem;background-color:#fff;display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-pack:distribute;justify-content:space-around;align-item:center;padding:.1rem .5rem}#create .prompt-footer button{background-color:#007fff;text-align:center;width:.7rem;color:#fff;border-radius:.03rem}#create .mask{position:fixed;width:100%;height:100%;left:0;top:0;background-color:rgba(0,0,0,.15);z-index:10}#create .expand-transition{-webkit-transition:all .3s;transition:all .3s;width:100%;height:.3rem;overflow:hidden}#create .expand-enter,#create .expand-leave{height:0;opacity:0}#create .quest{border-bottom:2px solid #ccc}#create .quest-title_input{width:100%;height:.3rem;border:none;font-size:.25rem;text-align:center;font-weight:700;letter-spacing:.05rem}#create .quest-title{border-bottom:.02rem solid #ccc;padding-bottom:.1rem}#create .add{width:95%;margin:.1rem auto;border:.01px solid #ccc;padding:.1rem 0}#create .add-button{margin-top:.1rem}#create .add-button button{display:block;width:100%;background-color:#ddd;border-radius:3px;padding:.2rem 0;color:#444;font-size:.23rem;-webkit-transition:background-color .1s;transition:background-color .1s}#create .add-button button:hover{background-color:#efefef}#create .add-items{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}#create .add-items span{background-color:#ddd;color:#444;cursor:pointer;width:.85rem;text-align:center;padding:.05rem 0;border-radius:.02rem}#create .add-items span:hover{background-color:#efefef}#create .middle{margin:0 .4rem}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(1)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"#create .preview-deadline{font-size:.14rem;margin-top:.2rem;text-align:center}#create .quest-title_preview{text-align:center;letter-spacing:.05rem;font-size:.28rem;font-weight:700}#create .questItem-data{margin:.1rem 0;border:1px solid #ccc;border-radius:.03rem}#create .chart{min-height:2rem;width:4rem;margin:0 auto}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(1)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"#header{width:100%;height:.4rem;background-color:#007fff;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:#fff}#header h1{font-size:.22rem;font-weight:700;margin-left:.22rem}#header h1 a{color:#fff}#header h1:before{content:'\\\\F29C';margin-right:5px}#header h2{font-size:.18rem;font-weight:400;margin-left:.25rem}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(1)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"#index{width:100%}#index .col01{width:5%;text-align:left}#index .col02{width:30%}#index .buttons{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-pack:distribute;justify-content:space-around}#index .quest td{padding:.15rem 0;border-bottom:1px solid #cdcdcd}#index .quest:hover{background-color:#cce5ff}#index .last-row td{padding:.2rem 0}#index .last-row button{margin-left:.2rem}#index .center{text-align:center}#index .left{text-align:left}#index .full{width:10rem;margin:.2rem auto;border:.02rem solid #ccc;border-radius:.04rem}#index .full table{border-collapse:collapse;width:90%;margin:0 auto;text-align:center}#index .full thead{font-size:.18rem}#index .full tbody{font-size:.17rem}#index .full th{padding:.2rem 0}#index .full button{background-color:#fff;border:1px solid #ccc;border-radius:.02rem;width:.9rem;text-align:center;padding:.05rem 0}#index .full button:hover{background-color:#cce5ff}#index .empty{width:6rem;height:3rem;margin:.4rem auto;border:.03rem solid #ccc;font-size:.2rem;border-radius:.08rem;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}#index .empty button{font-size:.2rem;background-color:#007fff;border:none;border-radius:.04rem;color:#fff;width:2rem;text-align:center;padding:.1rem 0}#index .empty button:hover{background-color:#cce5ff}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(1)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"#create .preview-deadline{font-size:.14rem;margin-top:.2rem;text-align:center}#create .quest-title_preview{text-align:center;letter-spacing:.05rem;font-size:.28rem;font-weight:700}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(1)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"body,html{width:100%;height:100%;font-family:Helvetica,Hiragino Sans GB,Microsoft Yahei,\\\\\\\\5FAE\\\\8F6F\\\\96C5\\\\9ED1,Arial,sans-serif}body,button,div,h1,h2,h3,html,p{padding:0;margin:0;line-height:1}html{font-size:100px;min-width:980px}button{cursor:pointer;border:none;font-size:.16rem}button,input,textarea{outline:none}a{text-decoration:none}li{list-style:none}.checkbox,.radio{display:none}.checkbox+label,.radio+label{position:relative;font-size:16px;padding-left:23px;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.checkbox+label:before,.radio+label:before{position:absolute;content:\\\"\\\";top:48%;margin-top:-8px;left:0;width:16px;height:16px;border:1px solid silver;background-color:#fff}.checkbox+label:before{border-radius:3px}.radio+label:before{border-radius:50%}.checkbox:checked+label:after{position:absolute;content:\\\"\\\";width:5px;height:10px;top:48%;margin-top:-7px;left:6px;-webkit-transform:rotate(45deg);transform:rotate(45deg);border-bottom:2px solid #fff;border-right:2px solid #fff}.checkbox:checked+label:before{background-color:#3e97eb;border:1px solid #3e97eb}.radio:checked+label:before{border:1px solid #3e97eb}.radio:checked+label:after{position:absolute;content:\\\"\\\";width:6px;height:6px;top:50%;margin-top:-3px;left:6px;border-radius:50%;background-color:#3e97eb}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \" <div id=app> <v-header></v-header> <router-view keep-alive></router-view> </div> \";\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \" <div id=calendar> <div class=calendar-selections> <span class=calendar-selections_last @click=decrMonth> <i class=\\\"fa fa-chevron-left\\\"></i> </span> <select name=year class=calendar-selections_year v-model=currentYear> <option v-for=\\\"year in yearList\\\">{{year}}</option> </select> <select class=calendar-selections_month v-model=currentMonth> <option v-for=\\\"month in monthList\\\">{{month}}</option> </select> <span class=calendar-selelctions_next @click=incrMonth> <i class=\\\"fa fa-chevron-right\\\"></i> </span> </div> <table @click.stop=handleClick($event)> <thead> <tr><th v-for=\\\"week in weekList\\\">{{week}}</th></tr> </thead> <tbody> <tr v-for=\\\"row in tableData\\\"> <td v-for=\\\"date in row\\\" :class=\\\"{'not-current-month': date.getMonth()!==currentMonth-1}\\\" :data-date=date.getTime()> {{date.getDate()}} </td> </tr> </tbody> </table> </div> \";\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \" <div id=create> <div class=quest> <div class=quest-title> <input type=text class=quest-title_input placeholder=请输入问卷的标题 v-model=questionnaire.title /> </div> <div v-for=\\\"questItem in questionnaire.questItemList\\\" class=questItem track-by=$index> <p class=questItem-title> <span>{{$index+1}}、{{typeMap[questItem.type]}}：</span> <span v-text=questItem.title></span> </p> <div v-if=\\\"questItem.type==='textarea'\\\"> <textarea></textarea> </div> <div v-else> <div v-for=\\\"selection in questItem.selections\\\" class=selection> <input :type=questItem.type :name=questItem.name :id=questItem.name+$index :class=questItem.type /> <label v-text=selection :for=questItem.name+$index></label> </div> </div> <div class=item-operation @click=\\\"handleItemOperation($event, questItem)\\\"> <button type=button v-if=\\\"$index != 0\\\" data-operation=up>上移</button> <button type=button v-if=\\\"$index != questionnaire.questItemList.length-1\\\" data-operation=down>下移</button> <button type=button data-operation=remove>删除</button> <button type=button data-operation=reuse>复用</button> </div> </div> <div class=add> <div class=add-items v-show=showSelections transition=expand @click.stop=addItem($event)> <span data-type=radio>单选题</span> <span class=middle data-type=checkbox>多选题</span> <span data-type=textarea>文本题</span> </div> <div class=add-button> <button type=button @click.stop=\\\"showSelections=!showSelections\\\">添加问题</button> </div> </div> </div> <div class=mask v-if=showMask> <div class=mask-prompt> <div class=prompt-header>请输入详细信息</div> <div class=prompt-body> <div> <label>问题名称：</label> <input type=text placeholder=请输入标题 v-el:item-title/> </div> <div> <label>选项：</label> <input type=text placeholder=请输入选项 v-el:item-selections :disabled=\\\"questItem.type === 'textarea'\\\"/> <p class=prompt>*&nbsp;不同选项之间请以空格隔开</p> </div> </div> <div class=prompt-footer @click.stop=handleInput($event)> <button type=button data-operation=confirm>确定</button> <button type=button data-operation=cancel>取消</button> </div> </div> </div> <div class=submit> <div class=deadline> <label>问卷截止日期：</label> <input type=text placeholder=点击选择问卷截止日期 readonly=readonly v-el:deadline @click.stop=\\\"showCalendar=!showCalendar\\\"/> <calendar :show-calendar.sync=showCalendar v-if=showCalendar></calendar> </div> <div @click=submit($event)> <button type=button data-operation=save>保存问卷</button> <button type=button data-operation=publish>发布问卷</button> </div> </div> </div> \";\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \" <div id=create v-if=!$loadingRouteData> <div class=quest> <div class=quest-title> <h2 v-text=questionnaire.title class=quest-title_preview></h2> </div> <div v-for=\\\"questItem in questionnaire.questItemList\\\" class=questItem-data track-by=$index> <div class=chart v-echarts=questItem></div> </div> </div> <p class=preview-deadline>问卷截止日期：{{new Date(questionnaire.deadline).toLocaleDateString()}}</p> </div> \";\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \" <div id=create v-if=!$loadingRouteData> <div class=quest> <div class=quest-title> <input type=text class=quest-title_input placeholder=请输入问卷的标题 v-model=questionnaire.title /> </div> <div v-for=\\\"questItem in questionnaire.questItemList\\\" class=questItem track-by=$index> <p class=questItem-title> <span>{{$index+1}}、{{typeMap[questItem.type]}}：</span> <span v-text=questItem.title></span> </p> <div v-if=\\\"questItem.type==='textarea'\\\"> <textarea></textarea> </div> <div v-else> <div v-for=\\\"selection in questItem.selections\\\" class=selection> <input :type=questItem.type :name=questItem.name :id=questItem.name+$index :class=questItem.type /> <label v-text=selection :for=questItem.name+$index></label> </div> </div> <div class=item-operation @click=\\\"handleItemOperation($event, questItem)\\\"> <button type=button v-if=\\\"$index != 0\\\" data-operation=up>上移</button> <button type=button v-if=\\\"$index != questionnaire.questItemList.length-1\\\" data-operation=down>下移</button> <button type=button data-operation=remove>删除</button> <button type=button data-operation=reuse>复用</button> </div> </div> <div class=add> <div class=add-items v-show=showSelections transition=expand @click.stop=addItem($event)> <span data-type=radio>单选题</span> <span class=middle data-type=checkbox>多选题</span> <span data-type=textarea>文本题</span> </div> <div class=add-button> <button type=button @click.stop=\\\"showSelections=!showSelections\\\">添加问题</button> </div> </div> </div> <div class=mask v-if=showMask> <div class=mask-prompt> <div class=prompt-header>请输入详细信息</div> <div class=prompt-body> <div> <label>问题名称：</label> <input type=text placeholder=请输入标题 v-el:item-title/> </div> <div> <label>选项：</label> <input type=text placeholder=请输入选项 v-el:item-selections :disabled=\\\"questItem.type === 'textarea'\\\"/> <p class=prompt>*&nbsp;不同选项之间请以空格隔开</p> </div> </div> <div class=prompt-footer @click.stop=handleInput($event)> <button type=button data-operation=confirm>确定</button> <button type=button data-operation=cancel>取消</button> </div> </div> </div> <div class=submit> <div class=deadline> <label>问卷截止日期：</label> <input type=text placeholder=点击选择问卷截止日期 readonly=readonly v-el:deadline :value=\\\"new Date(questionnaire.deadline).toLocaleDateString()\\\" @click.stop=\\\"showCalendar=!showCalendar\\\"/> <calendar :show-calendar.sync=showCalendar v-if=showCalendar></calendar> </div> <div @click=submit($event)> <button type=button data-operation=save>保存问卷</button> <button type=button data-operation=publish>发布问卷</button> </div> </div> </div> \";\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \" <div id=header> <h1><a v-link=\\\"'#/index'\\\">问卷管理</a></h1> <h2>我的问卷</h2> </div> \";\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \" <div id=index> <div class=empty v-if=\\\"questionnaireList.length === 0\\\"> <button type=button @click.stop=createQuest>新建问卷</button> </div> <div class=full v-else> <table> <thead> <tr> <th></th><th>标题</th><th>截止时间</th><th>状态</th><th>操作</th> </tr> </thead> <tbody> <tr v-for=\\\"questionnaire in questionnaireList\\\" class=quest @click=\\\"handleOperation($event, questionnaire)\\\"> <td class=col01> <input type=checkbox :name=name :id=name+$index class=checkbox /> <label :for=name+$index data-operation=checked></label> </td> <td class=col02> <span v-text=questionnaire.title></span> </td> <td v-text=\\\"new Date(questionnaire.deadline).toLocaleDateString()\\\"></td> <td v-text=questionnaire.state></td> <td v-if=\\\"questionnaire.state==='未发布'\\\"> <button data-operation=preview>预览问卷</button>&nbsp;&nbsp;&nbsp; <button data-operation=edit>编辑问卷</button> </td> <td v-else> <button data-operation=preview>预览问卷</button>&nbsp;&nbsp;&nbsp; <button data-operation=data>数据统计</button> </td> </tr> <tr class=last-row @click=createOrRm($event)> <td colspan=2 class=left> <button type=button data-operation=rmChecked>删除</button> </td> <td colspan=3 class=center> <button type=button data-operation=create>新建问卷</button> </td> </tr> </tbody> </table> </div> </div> \";\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \" <div id=create v-if=!$loadingRouteData> <div class=quest> <div class=quest-title> <h2 v-text=questionnaire.title class=quest-title_preview></h2> </div> <div v-for=\\\"questItem in questionnaire.questItemList\\\" class=questItem track-by=$index> <p class=questItem-title> <span>{{$index+1}}、{{typeMap[questItem.type]}}：</span> <span v-text=questItem.title></span> </p> <div v-if=\\\"questItem.type==='textarea'\\\"> <textarea></textarea> </div> <div v-else> <div v-for=\\\"selection in questItem.selections\\\" class=selection> <input :type=questItem.type :name=questItem.name :id=questItem.name+$index :class=questItem.type /> <label v-text=selection :for=questItem.name+$index></label> </div> </div> </div> </div> <p class=preview-deadline>问卷截止日期：{{new Date(questionnaire.deadline).toLocaleDateString()}}</p> </div> \";\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\t__webpack_require__(48)\n\t__vue_script__ = __webpack_require__(10)\n\t__vue_template__ = __webpack_require__(27)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tif (__vue_template__) {\n\t(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n\t}\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\t__webpack_require__(43)\n\t__vue_script__ = __webpack_require__(12)\n\t__vue_template__ = __webpack_require__(29)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tif (__vue_template__) {\n\t(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n\t}\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\t__webpack_require__(44)\n\t__vue_script__ = __webpack_require__(13)\n\t__vue_template__ = __webpack_require__(30)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tif (__vue_template__) {\n\t(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n\t}\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\t__vue_script__ = __webpack_require__(14)\n\t__vue_template__ = __webpack_require__(31)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tif (__vue_template__) {\n\t(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n\t}\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\t__webpack_require__(45)\n\t__vue_script__ = __webpack_require__(15)\n\t__vue_template__ = __webpack_require__(32)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tif (__vue_template__) {\n\t(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n\t}\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\t__webpack_require__(47)\n\t__vue_script__ = __webpack_require__(17)\n\t__vue_template__ = __webpack_require__(34)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tif (__vue_template__) {\n\t(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n\t}\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * vue-router v0.7.13\n\t * (c) 2016 Evan You\n\t * Released under the MIT License.\n\t */\n\t(function (global, factory) {\n\t   true ? module.exports = factory() :\n\t  typeof define === 'function' && define.amd ? define(factory) :\n\t  global.VueRouter = factory();\n\t}(this, function () { 'use strict';\n\t\n\t  var babelHelpers = {};\n\t\n\t  babelHelpers.classCallCheck = function (instance, Constructor) {\n\t    if (!(instance instanceof Constructor)) {\n\t      throw new TypeError(\"Cannot call a class as a function\");\n\t    }\n\t  };\n\t  function Target(path, matcher, delegate) {\n\t    this.path = path;\n\t    this.matcher = matcher;\n\t    this.delegate = delegate;\n\t  }\n\t\n\t  Target.prototype = {\n\t    to: function to(target, callback) {\n\t      var delegate = this.delegate;\n\t\n\t      if (delegate && delegate.willAddRoute) {\n\t        target = delegate.willAddRoute(this.matcher.target, target);\n\t      }\n\t\n\t      this.matcher.add(this.path, target);\n\t\n\t      if (callback) {\n\t        if (callback.length === 0) {\n\t          throw new Error(\"You must have an argument in the function passed to `to`\");\n\t        }\n\t        this.matcher.addChild(this.path, target, callback, this.delegate);\n\t      }\n\t      return this;\n\t    }\n\t  };\n\t\n\t  function Matcher(target) {\n\t    this.routes = {};\n\t    this.children = {};\n\t    this.target = target;\n\t  }\n\t\n\t  Matcher.prototype = {\n\t    add: function add(path, handler) {\n\t      this.routes[path] = handler;\n\t    },\n\t\n\t    addChild: function addChild(path, target, callback, delegate) {\n\t      var matcher = new Matcher(target);\n\t      this.children[path] = matcher;\n\t\n\t      var match = generateMatch(path, matcher, delegate);\n\t\n\t      if (delegate && delegate.contextEntered) {\n\t        delegate.contextEntered(target, match);\n\t      }\n\t\n\t      callback(match);\n\t    }\n\t  };\n\t\n\t  function generateMatch(startingPath, matcher, delegate) {\n\t    return function (path, nestedCallback) {\n\t      var fullPath = startingPath + path;\n\t\n\t      if (nestedCallback) {\n\t        nestedCallback(generateMatch(fullPath, matcher, delegate));\n\t      } else {\n\t        return new Target(startingPath + path, matcher, delegate);\n\t      }\n\t    };\n\t  }\n\t\n\t  function addRoute(routeArray, path, handler) {\n\t    var len = 0;\n\t    for (var i = 0, l = routeArray.length; i < l; i++) {\n\t      len += routeArray[i].path.length;\n\t    }\n\t\n\t    path = path.substr(len);\n\t    var route = { path: path, handler: handler };\n\t    routeArray.push(route);\n\t  }\n\t\n\t  function eachRoute(baseRoute, matcher, callback, binding) {\n\t    var routes = matcher.routes;\n\t\n\t    for (var path in routes) {\n\t      if (routes.hasOwnProperty(path)) {\n\t        var routeArray = baseRoute.slice();\n\t        addRoute(routeArray, path, routes[path]);\n\t\n\t        if (matcher.children[path]) {\n\t          eachRoute(routeArray, matcher.children[path], callback, binding);\n\t        } else {\n\t          callback.call(binding, routeArray);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  function map (callback, addRouteCallback) {\n\t    var matcher = new Matcher();\n\t\n\t    callback(generateMatch(\"\", matcher, this.delegate));\n\t\n\t    eachRoute([], matcher, function (route) {\n\t      if (addRouteCallback) {\n\t        addRouteCallback(this, route);\n\t      } else {\n\t        this.add(route);\n\t      }\n\t    }, this);\n\t  }\n\t\n\t  var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\'];\n\t\n\t  var escapeRegex = new RegExp('(\\\\' + specials.join('|\\\\') + ')', 'g');\n\t\n\t  var noWarning = false;\n\t  function warn(msg) {\n\t    if (!noWarning && typeof console !== 'undefined') {\n\t      console.error('[vue-router] ' + msg);\n\t    }\n\t  }\n\t\n\t  function tryDecode(uri, asComponent) {\n\t    try {\n\t      return asComponent ? decodeURIComponent(uri) : decodeURI(uri);\n\t    } catch (e) {\n\t      warn('malformed URI' + (asComponent ? ' component: ' : ': ') + uri);\n\t    }\n\t  }\n\t\n\t  function isArray(test) {\n\t    return Object.prototype.toString.call(test) === \"[object Array]\";\n\t  }\n\t\n\t  // A Segment represents a segment in the original route description.\n\t  // Each Segment type provides an `eachChar` and `regex` method.\n\t  //\n\t  // The `eachChar` method invokes the callback with one or more character\n\t  // specifications. A character specification consumes one or more input\n\t  // characters.\n\t  //\n\t  // The `regex` method returns a regex fragment for the segment. If the\n\t  // segment is a dynamic of star segment, the regex fragment also includes\n\t  // a capture.\n\t  //\n\t  // A character specification contains:\n\t  //\n\t  // * `validChars`: a String with a list of all valid characters, or\n\t  // * `invalidChars`: a String with a list of all invalid characters\n\t  // * `repeat`: true if the character specification can repeat\n\t\n\t  function StaticSegment(string) {\n\t    this.string = string;\n\t  }\n\t  StaticSegment.prototype = {\n\t    eachChar: function eachChar(callback) {\n\t      var string = this.string,\n\t          ch;\n\t\n\t      for (var i = 0, l = string.length; i < l; i++) {\n\t        ch = string.charAt(i);\n\t        callback({ validChars: ch });\n\t      }\n\t    },\n\t\n\t    regex: function regex() {\n\t      return this.string.replace(escapeRegex, '\\\\$1');\n\t    },\n\t\n\t    generate: function generate() {\n\t      return this.string;\n\t    }\n\t  };\n\t\n\t  function DynamicSegment(name) {\n\t    this.name = name;\n\t  }\n\t  DynamicSegment.prototype = {\n\t    eachChar: function eachChar(callback) {\n\t      callback({ invalidChars: \"/\", repeat: true });\n\t    },\n\t\n\t    regex: function regex() {\n\t      return \"([^/]+)\";\n\t    },\n\t\n\t    generate: function generate(params) {\n\t      var val = params[this.name];\n\t      return val == null ? \":\" + this.name : val;\n\t    }\n\t  };\n\t\n\t  function StarSegment(name) {\n\t    this.name = name;\n\t  }\n\t  StarSegment.prototype = {\n\t    eachChar: function eachChar(callback) {\n\t      callback({ invalidChars: \"\", repeat: true });\n\t    },\n\t\n\t    regex: function regex() {\n\t      return \"(.+)\";\n\t    },\n\t\n\t    generate: function generate(params) {\n\t      var val = params[this.name];\n\t      return val == null ? \":\" + this.name : val;\n\t    }\n\t  };\n\t\n\t  function EpsilonSegment() {}\n\t  EpsilonSegment.prototype = {\n\t    eachChar: function eachChar() {},\n\t    regex: function regex() {\n\t      return \"\";\n\t    },\n\t    generate: function generate() {\n\t      return \"\";\n\t    }\n\t  };\n\t\n\t  function parse(route, names, specificity) {\n\t    // normalize route as not starting with a \"/\". Recognition will\n\t    // also normalize.\n\t    if (route.charAt(0) === \"/\") {\n\t      route = route.substr(1);\n\t    }\n\t\n\t    var segments = route.split(\"/\"),\n\t        results = [];\n\t\n\t    // A routes has specificity determined by the order that its different segments\n\t    // appear in. This system mirrors how the magnitude of numbers written as strings\n\t    // works.\n\t    // Consider a number written as: \"abc\". An example would be \"200\". Any other number written\n\t    // \"xyz\" will be smaller than \"abc\" so long as `a > z`. For instance, \"199\" is smaller\n\t    // then \"200\", even though \"y\" and \"z\" (which are both 9) are larger than \"0\" (the value\n\t    // of (`b` and `c`). This is because the leading symbol, \"2\", is larger than the other\n\t    // leading symbol, \"1\".\n\t    // The rule is that symbols to the left carry more weight than symbols to the right\n\t    // when a number is written out as a string. In the above strings, the leading digit\n\t    // represents how many 100's are in the number, and it carries more weight than the middle\n\t    // number which represents how many 10's are in the number.\n\t    // This system of number magnitude works well for route specificity, too. A route written as\n\t    // `a/b/c` will be more specific than `x/y/z` as long as `a` is more specific than\n\t    // `x`, irrespective of the other parts.\n\t    // Because of this similarity, we assign each type of segment a number value written as a\n\t    // string. We can find the specificity of compound routes by concatenating these strings\n\t    // together, from left to right. After we have looped through all of the segments,\n\t    // we convert the string to a number.\n\t    specificity.val = '';\n\t\n\t    for (var i = 0, l = segments.length; i < l; i++) {\n\t      var segment = segments[i],\n\t          match;\n\t\n\t      if (match = segment.match(/^:([^\\/]+)$/)) {\n\t        results.push(new DynamicSegment(match[1]));\n\t        names.push(match[1]);\n\t        specificity.val += '3';\n\t      } else if (match = segment.match(/^\\*([^\\/]+)$/)) {\n\t        results.push(new StarSegment(match[1]));\n\t        specificity.val += '2';\n\t        names.push(match[1]);\n\t      } else if (segment === \"\") {\n\t        results.push(new EpsilonSegment());\n\t        specificity.val += '1';\n\t      } else {\n\t        results.push(new StaticSegment(segment));\n\t        specificity.val += '4';\n\t      }\n\t    }\n\t\n\t    specificity.val = +specificity.val;\n\t\n\t    return results;\n\t  }\n\t\n\t  // A State has a character specification and (`charSpec`) and a list of possible\n\t  // subsequent states (`nextStates`).\n\t  //\n\t  // If a State is an accepting state, it will also have several additional\n\t  // properties:\n\t  //\n\t  // * `regex`: A regular expression that is used to extract parameters from paths\n\t  //   that reached this accepting state.\n\t  // * `handlers`: Information on how to convert the list of captures into calls\n\t  //   to registered handlers with the specified parameters\n\t  // * `types`: How many static, dynamic or star segments in this route. Used to\n\t  //   decide which route to use if multiple registered routes match a path.\n\t  //\n\t  // Currently, State is implemented naively by looping over `nextStates` and\n\t  // comparing a character specification against a character. A more efficient\n\t  // implementation would use a hash of keys pointing at one or more next states.\n\t\n\t  function State(charSpec) {\n\t    this.charSpec = charSpec;\n\t    this.nextStates = [];\n\t  }\n\t\n\t  State.prototype = {\n\t    get: function get(charSpec) {\n\t      var nextStates = this.nextStates;\n\t\n\t      for (var i = 0, l = nextStates.length; i < l; i++) {\n\t        var child = nextStates[i];\n\t\n\t        var isEqual = child.charSpec.validChars === charSpec.validChars;\n\t        isEqual = isEqual && child.charSpec.invalidChars === charSpec.invalidChars;\n\t\n\t        if (isEqual) {\n\t          return child;\n\t        }\n\t      }\n\t    },\n\t\n\t    put: function put(charSpec) {\n\t      var state;\n\t\n\t      // If the character specification already exists in a child of the current\n\t      // state, just return that state.\n\t      if (state = this.get(charSpec)) {\n\t        return state;\n\t      }\n\t\n\t      // Make a new state for the character spec\n\t      state = new State(charSpec);\n\t\n\t      // Insert the new state as a child of the current state\n\t      this.nextStates.push(state);\n\t\n\t      // If this character specification repeats, insert the new state as a child\n\t      // of itself. Note that this will not trigger an infinite loop because each\n\t      // transition during recognition consumes a character.\n\t      if (charSpec.repeat) {\n\t        state.nextStates.push(state);\n\t      }\n\t\n\t      // Return the new state\n\t      return state;\n\t    },\n\t\n\t    // Find a list of child states matching the next character\n\t    match: function match(ch) {\n\t      // DEBUG \"Processing `\" + ch + \"`:\"\n\t      var nextStates = this.nextStates,\n\t          child,\n\t          charSpec,\n\t          chars;\n\t\n\t      // DEBUG \"  \" + debugState(this)\n\t      var returned = [];\n\t\n\t      for (var i = 0, l = nextStates.length; i < l; i++) {\n\t        child = nextStates[i];\n\t\n\t        charSpec = child.charSpec;\n\t\n\t        if (typeof (chars = charSpec.validChars) !== 'undefined') {\n\t          if (chars.indexOf(ch) !== -1) {\n\t            returned.push(child);\n\t          }\n\t        } else if (typeof (chars = charSpec.invalidChars) !== 'undefined') {\n\t          if (chars.indexOf(ch) === -1) {\n\t            returned.push(child);\n\t          }\n\t        }\n\t      }\n\t\n\t      return returned;\n\t    }\n\t\n\t    /** IF DEBUG\n\t    , debug: function() {\n\t      var charSpec = this.charSpec,\n\t          debug = \"[\",\n\t          chars = charSpec.validChars || charSpec.invalidChars;\n\t       if (charSpec.invalidChars) { debug += \"^\"; }\n\t      debug += chars;\n\t      debug += \"]\";\n\t       if (charSpec.repeat) { debug += \"+\"; }\n\t       return debug;\n\t    }\n\t    END IF **/\n\t  };\n\t\n\t  /** IF DEBUG\n\t  function debug(log) {\n\t    console.log(log);\n\t  }\n\t\n\t  function debugState(state) {\n\t    return state.nextStates.map(function(n) {\n\t      if (n.nextStates.length === 0) { return \"( \" + n.debug() + \" [accepting] )\"; }\n\t      return \"( \" + n.debug() + \" <then> \" + n.nextStates.map(function(s) { return s.debug() }).join(\" or \") + \" )\";\n\t    }).join(\", \")\n\t  }\n\t  END IF **/\n\t\n\t  // Sort the routes by specificity\n\t  function sortSolutions(states) {\n\t    return states.sort(function (a, b) {\n\t      return b.specificity.val - a.specificity.val;\n\t    });\n\t  }\n\t\n\t  function recognizeChar(states, ch) {\n\t    var nextStates = [];\n\t\n\t    for (var i = 0, l = states.length; i < l; i++) {\n\t      var state = states[i];\n\t\n\t      nextStates = nextStates.concat(state.match(ch));\n\t    }\n\t\n\t    return nextStates;\n\t  }\n\t\n\t  var oCreate = Object.create || function (proto) {\n\t    function F() {}\n\t    F.prototype = proto;\n\t    return new F();\n\t  };\n\t\n\t  function RecognizeResults(queryParams) {\n\t    this.queryParams = queryParams || {};\n\t  }\n\t  RecognizeResults.prototype = oCreate({\n\t    splice: Array.prototype.splice,\n\t    slice: Array.prototype.slice,\n\t    push: Array.prototype.push,\n\t    length: 0,\n\t    queryParams: null\n\t  });\n\t\n\t  function findHandler(state, path, queryParams) {\n\t    var handlers = state.handlers,\n\t        regex = state.regex;\n\t    var captures = path.match(regex),\n\t        currentCapture = 1;\n\t    var result = new RecognizeResults(queryParams);\n\t\n\t    for (var i = 0, l = handlers.length; i < l; i++) {\n\t      var handler = handlers[i],\n\t          names = handler.names,\n\t          params = {};\n\t\n\t      for (var j = 0, m = names.length; j < m; j++) {\n\t        params[names[j]] = captures[currentCapture++];\n\t      }\n\t\n\t      result.push({ handler: handler.handler, params: params, isDynamic: !!names.length });\n\t    }\n\t\n\t    return result;\n\t  }\n\t\n\t  function addSegment(currentState, segment) {\n\t    segment.eachChar(function (ch) {\n\t      var state;\n\t\n\t      currentState = currentState.put(ch);\n\t    });\n\t\n\t    return currentState;\n\t  }\n\t\n\t  function decodeQueryParamPart(part) {\n\t    // http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1\n\t    part = part.replace(/\\+/gm, '%20');\n\t    return tryDecode(part, true);\n\t  }\n\t\n\t  // The main interface\n\t\n\t  var RouteRecognizer = function RouteRecognizer() {\n\t    this.rootState = new State();\n\t    this.names = {};\n\t  };\n\t\n\t  RouteRecognizer.prototype = {\n\t    add: function add(routes, options) {\n\t      var currentState = this.rootState,\n\t          regex = \"^\",\n\t          specificity = {},\n\t          handlers = [],\n\t          allSegments = [],\n\t          name;\n\t\n\t      var isEmpty = true;\n\t\n\t      for (var i = 0, l = routes.length; i < l; i++) {\n\t        var route = routes[i],\n\t            names = [];\n\t\n\t        var segments = parse(route.path, names, specificity);\n\t\n\t        allSegments = allSegments.concat(segments);\n\t\n\t        for (var j = 0, m = segments.length; j < m; j++) {\n\t          var segment = segments[j];\n\t\n\t          if (segment instanceof EpsilonSegment) {\n\t            continue;\n\t          }\n\t\n\t          isEmpty = false;\n\t\n\t          // Add a \"/\" for the new segment\n\t          currentState = currentState.put({ validChars: \"/\" });\n\t          regex += \"/\";\n\t\n\t          // Add a representation of the segment to the NFA and regex\n\t          currentState = addSegment(currentState, segment);\n\t          regex += segment.regex();\n\t        }\n\t\n\t        var handler = { handler: route.handler, names: names };\n\t        handlers.push(handler);\n\t      }\n\t\n\t      if (isEmpty) {\n\t        currentState = currentState.put({ validChars: \"/\" });\n\t        regex += \"/\";\n\t      }\n\t\n\t      currentState.handlers = handlers;\n\t      currentState.regex = new RegExp(regex + \"$\");\n\t      currentState.specificity = specificity;\n\t\n\t      if (name = options && options.as) {\n\t        this.names[name] = {\n\t          segments: allSegments,\n\t          handlers: handlers\n\t        };\n\t      }\n\t    },\n\t\n\t    handlersFor: function handlersFor(name) {\n\t      var route = this.names[name],\n\t          result = [];\n\t      if (!route) {\n\t        throw new Error(\"There is no route named \" + name);\n\t      }\n\t\n\t      for (var i = 0, l = route.handlers.length; i < l; i++) {\n\t        result.push(route.handlers[i]);\n\t      }\n\t\n\t      return result;\n\t    },\n\t\n\t    hasRoute: function hasRoute(name) {\n\t      return !!this.names[name];\n\t    },\n\t\n\t    generate: function generate(name, params) {\n\t      var route = this.names[name],\n\t          output = \"\";\n\t      if (!route) {\n\t        throw new Error(\"There is no route named \" + name);\n\t      }\n\t\n\t      var segments = route.segments;\n\t\n\t      for (var i = 0, l = segments.length; i < l; i++) {\n\t        var segment = segments[i];\n\t\n\t        if (segment instanceof EpsilonSegment) {\n\t          continue;\n\t        }\n\t\n\t        output += \"/\";\n\t        output += segment.generate(params);\n\t      }\n\t\n\t      if (output.charAt(0) !== '/') {\n\t        output = '/' + output;\n\t      }\n\t\n\t      if (params && params.queryParams) {\n\t        output += this.generateQueryString(params.queryParams);\n\t      }\n\t\n\t      return output;\n\t    },\n\t\n\t    generateQueryString: function generateQueryString(params) {\n\t      var pairs = [];\n\t      var keys = [];\n\t      for (var key in params) {\n\t        if (params.hasOwnProperty(key)) {\n\t          keys.push(key);\n\t        }\n\t      }\n\t      keys.sort();\n\t      for (var i = 0, len = keys.length; i < len; i++) {\n\t        key = keys[i];\n\t        var value = params[key];\n\t        if (value == null) {\n\t          continue;\n\t        }\n\t        var pair = encodeURIComponent(key);\n\t        if (isArray(value)) {\n\t          for (var j = 0, l = value.length; j < l; j++) {\n\t            var arrayPair = key + '[]' + '=' + encodeURIComponent(value[j]);\n\t            pairs.push(arrayPair);\n\t          }\n\t        } else {\n\t          pair += \"=\" + encodeURIComponent(value);\n\t          pairs.push(pair);\n\t        }\n\t      }\n\t\n\t      if (pairs.length === 0) {\n\t        return '';\n\t      }\n\t\n\t      return \"?\" + pairs.join(\"&\");\n\t    },\n\t\n\t    parseQueryString: function parseQueryString(queryString) {\n\t      var pairs = queryString.split(\"&\"),\n\t          queryParams = {};\n\t      for (var i = 0; i < pairs.length; i++) {\n\t        var pair = pairs[i].split('='),\n\t            key = decodeQueryParamPart(pair[0]),\n\t            keyLength = key.length,\n\t            isArray = false,\n\t            value;\n\t        if (pair.length === 1) {\n\t          value = 'true';\n\t        } else {\n\t          //Handle arrays\n\t          if (keyLength > 2 && key.slice(keyLength - 2) === '[]') {\n\t            isArray = true;\n\t            key = key.slice(0, keyLength - 2);\n\t            if (!queryParams[key]) {\n\t              queryParams[key] = [];\n\t            }\n\t          }\n\t          value = pair[1] ? decodeQueryParamPart(pair[1]) : '';\n\t        }\n\t        if (isArray) {\n\t          queryParams[key].push(value);\n\t        } else {\n\t          queryParams[key] = value;\n\t        }\n\t      }\n\t      return queryParams;\n\t    },\n\t\n\t    recognize: function recognize(path, silent) {\n\t      noWarning = silent;\n\t      var states = [this.rootState],\n\t          pathLen,\n\t          i,\n\t          l,\n\t          queryStart,\n\t          queryParams = {},\n\t          isSlashDropped = false;\n\t\n\t      queryStart = path.indexOf('?');\n\t      if (queryStart !== -1) {\n\t        var queryString = path.substr(queryStart + 1, path.length);\n\t        path = path.substr(0, queryStart);\n\t        if (queryString) {\n\t          queryParams = this.parseQueryString(queryString);\n\t        }\n\t      }\n\t\n\t      path = tryDecode(path);\n\t      if (!path) return;\n\t\n\t      // DEBUG GROUP path\n\t\n\t      if (path.charAt(0) !== \"/\") {\n\t        path = \"/\" + path;\n\t      }\n\t\n\t      pathLen = path.length;\n\t      if (pathLen > 1 && path.charAt(pathLen - 1) === \"/\") {\n\t        path = path.substr(0, pathLen - 1);\n\t        isSlashDropped = true;\n\t      }\n\t\n\t      for (i = 0, l = path.length; i < l; i++) {\n\t        states = recognizeChar(states, path.charAt(i));\n\t        if (!states.length) {\n\t          break;\n\t        }\n\t      }\n\t\n\t      // END DEBUG GROUP\n\t\n\t      var solutions = [];\n\t      for (i = 0, l = states.length; i < l; i++) {\n\t        if (states[i].handlers) {\n\t          solutions.push(states[i]);\n\t        }\n\t      }\n\t\n\t      states = sortSolutions(solutions);\n\t\n\t      var state = solutions[0];\n\t\n\t      if (state && state.handlers) {\n\t        // if a trailing slash was dropped and a star segment is the last segment\n\t        // specified, put the trailing slash back\n\t        if (isSlashDropped && state.regex.source.slice(-5) === \"(.+)$\") {\n\t          path = path + \"/\";\n\t        }\n\t        return findHandler(state, path, queryParams);\n\t      }\n\t    }\n\t  };\n\t\n\t  RouteRecognizer.prototype.map = map;\n\t\n\t  var genQuery = RouteRecognizer.prototype.generateQueryString;\n\t\n\t  // export default for holding the Vue reference\n\t  var exports$1 = {};\n\t  /**\n\t   * Warn stuff.\n\t   *\n\t   * @param {String} msg\n\t   */\n\t\n\t  function warn$1(msg) {\n\t    /* istanbul ignore next */\n\t    if (typeof console !== 'undefined') {\n\t      console.error('[vue-router] ' + msg);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Resolve a relative path.\n\t   *\n\t   * @param {String} base\n\t   * @param {String} relative\n\t   * @param {Boolean} append\n\t   * @return {String}\n\t   */\n\t\n\t  function resolvePath(base, relative, append) {\n\t    var query = base.match(/(\\?.*)$/);\n\t    if (query) {\n\t      query = query[1];\n\t      base = base.slice(0, -query.length);\n\t    }\n\t    // a query!\n\t    if (relative.charAt(0) === '?') {\n\t      return base + relative;\n\t    }\n\t    var stack = base.split('/');\n\t    // remove trailing segment if:\n\t    // - not appending\n\t    // - appending to trailing slash (last segment is empty)\n\t    if (!append || !stack[stack.length - 1]) {\n\t      stack.pop();\n\t    }\n\t    // resolve relative path\n\t    var segments = relative.replace(/^\\//, '').split('/');\n\t    for (var i = 0; i < segments.length; i++) {\n\t      var segment = segments[i];\n\t      if (segment === '.') {\n\t        continue;\n\t      } else if (segment === '..') {\n\t        stack.pop();\n\t      } else {\n\t        stack.push(segment);\n\t      }\n\t    }\n\t    // ensure leading slash\n\t    if (stack[0] !== '') {\n\t      stack.unshift('');\n\t    }\n\t    return stack.join('/');\n\t  }\n\t\n\t  /**\n\t   * Forgiving check for a promise\n\t   *\n\t   * @param {Object} p\n\t   * @return {Boolean}\n\t   */\n\t\n\t  function isPromise(p) {\n\t    return p && typeof p.then === 'function';\n\t  }\n\t\n\t  /**\n\t   * Retrive a route config field from a component instance\n\t   * OR a component contructor.\n\t   *\n\t   * @param {Function|Vue} component\n\t   * @param {String} name\n\t   * @return {*}\n\t   */\n\t\n\t  function getRouteConfig(component, name) {\n\t    var options = component && (component.$options || component.options);\n\t    return options && options.route && options.route[name];\n\t  }\n\t\n\t  /**\n\t   * Resolve an async component factory. Have to do a dirty\n\t   * mock here because of Vue core's internal API depends on\n\t   * an ID check.\n\t   *\n\t   * @param {Object} handler\n\t   * @param {Function} cb\n\t   */\n\t\n\t  var resolver = undefined;\n\t\n\t  function resolveAsyncComponent(handler, cb) {\n\t    if (!resolver) {\n\t      resolver = {\n\t        resolve: exports$1.Vue.prototype._resolveComponent,\n\t        $options: {\n\t          components: {\n\t            _: handler.component\n\t          }\n\t        }\n\t      };\n\t    } else {\n\t      resolver.$options.components._ = handler.component;\n\t    }\n\t    resolver.resolve('_', function (Component) {\n\t      handler.component = Component;\n\t      cb(Component);\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Map the dynamic segments in a path to params.\n\t   *\n\t   * @param {String} path\n\t   * @param {Object} params\n\t   * @param {Object} query\n\t   */\n\t\n\t  function mapParams(path, params, query) {\n\t    if (params === undefined) params = {};\n\t\n\t    path = path.replace(/:([^\\/]+)/g, function (_, key) {\n\t      var val = params[key];\n\t      /* istanbul ignore if */\n\t      if (!val) {\n\t        warn$1('param \"' + key + '\" not found when generating ' + 'path for \"' + path + '\" with params ' + JSON.stringify(params));\n\t      }\n\t      return val || '';\n\t    });\n\t    if (query) {\n\t      path += genQuery(query);\n\t    }\n\t    return path;\n\t  }\n\t\n\t  var hashRE = /#.*$/;\n\t\n\t  var HTML5History = (function () {\n\t    function HTML5History(_ref) {\n\t      var root = _ref.root;\n\t      var onChange = _ref.onChange;\n\t      babelHelpers.classCallCheck(this, HTML5History);\n\t\n\t      if (root && root !== '/') {\n\t        // make sure there's the starting slash\n\t        if (root.charAt(0) !== '/') {\n\t          root = '/' + root;\n\t        }\n\t        // remove trailing slash\n\t        this.root = root.replace(/\\/$/, '');\n\t        this.rootRE = new RegExp('^\\\\' + this.root);\n\t      } else {\n\t        this.root = null;\n\t      }\n\t      this.onChange = onChange;\n\t      // check base tag\n\t      var baseEl = document.querySelector('base');\n\t      this.base = baseEl && baseEl.getAttribute('href');\n\t    }\n\t\n\t    HTML5History.prototype.start = function start() {\n\t      var _this = this;\n\t\n\t      this.listener = function (e) {\n\t        var url = location.pathname + location.search;\n\t        if (_this.root) {\n\t          url = url.replace(_this.rootRE, '');\n\t        }\n\t        _this.onChange(url, e && e.state, location.hash);\n\t      };\n\t      window.addEventListener('popstate', this.listener);\n\t      this.listener();\n\t    };\n\t\n\t    HTML5History.prototype.stop = function stop() {\n\t      window.removeEventListener('popstate', this.listener);\n\t    };\n\t\n\t    HTML5History.prototype.go = function go(path, replace, append) {\n\t      var url = this.formatPath(path, append);\n\t      if (replace) {\n\t        history.replaceState({}, '', url);\n\t      } else {\n\t        // record scroll position by replacing current state\n\t        history.replaceState({\n\t          pos: {\n\t            x: window.pageXOffset,\n\t            y: window.pageYOffset\n\t          }\n\t        }, '', location.href);\n\t        // then push new state\n\t        history.pushState({}, '', url);\n\t      }\n\t      var hashMatch = path.match(hashRE);\n\t      var hash = hashMatch && hashMatch[0];\n\t      path = url\n\t      // strip hash so it doesn't mess up params\n\t      .replace(hashRE, '')\n\t      // remove root before matching\n\t      .replace(this.rootRE, '');\n\t      this.onChange(path, null, hash);\n\t    };\n\t\n\t    HTML5History.prototype.formatPath = function formatPath(path, append) {\n\t      return path.charAt(0) === '/'\n\t      // absolute path\n\t      ? this.root ? this.root + '/' + path.replace(/^\\//, '') : path : resolvePath(this.base || location.pathname, path, append);\n\t    };\n\t\n\t    return HTML5History;\n\t  })();\n\t\n\t  var HashHistory = (function () {\n\t    function HashHistory(_ref) {\n\t      var hashbang = _ref.hashbang;\n\t      var onChange = _ref.onChange;\n\t      babelHelpers.classCallCheck(this, HashHistory);\n\t\n\t      this.hashbang = hashbang;\n\t      this.onChange = onChange;\n\t    }\n\t\n\t    HashHistory.prototype.start = function start() {\n\t      var self = this;\n\t      this.listener = function () {\n\t        var path = location.hash;\n\t        var raw = path.replace(/^#!?/, '');\n\t        // always\n\t        if (raw.charAt(0) !== '/') {\n\t          raw = '/' + raw;\n\t        }\n\t        var formattedPath = self.formatPath(raw);\n\t        if (formattedPath !== path) {\n\t          location.replace(formattedPath);\n\t          return;\n\t        }\n\t        // determine query\n\t        // note it's possible to have queries in both the actual URL\n\t        // and the hash fragment itself.\n\t        var query = location.search && path.indexOf('?') > -1 ? '&' + location.search.slice(1) : location.search;\n\t        self.onChange(path.replace(/^#!?/, '') + query);\n\t      };\n\t      window.addEventListener('hashchange', this.listener);\n\t      this.listener();\n\t    };\n\t\n\t    HashHistory.prototype.stop = function stop() {\n\t      window.removeEventListener('hashchange', this.listener);\n\t    };\n\t\n\t    HashHistory.prototype.go = function go(path, replace, append) {\n\t      path = this.formatPath(path, append);\n\t      if (replace) {\n\t        location.replace(path);\n\t      } else {\n\t        location.hash = path;\n\t      }\n\t    };\n\t\n\t    HashHistory.prototype.formatPath = function formatPath(path, append) {\n\t      var isAbsoloute = path.charAt(0) === '/';\n\t      var prefix = '#' + (this.hashbang ? '!' : '');\n\t      return isAbsoloute ? prefix + path : prefix + resolvePath(location.hash.replace(/^#!?/, ''), path, append);\n\t    };\n\t\n\t    return HashHistory;\n\t  })();\n\t\n\t  var AbstractHistory = (function () {\n\t    function AbstractHistory(_ref) {\n\t      var onChange = _ref.onChange;\n\t      babelHelpers.classCallCheck(this, AbstractHistory);\n\t\n\t      this.onChange = onChange;\n\t      this.currentPath = '/';\n\t    }\n\t\n\t    AbstractHistory.prototype.start = function start() {\n\t      this.onChange('/');\n\t    };\n\t\n\t    AbstractHistory.prototype.stop = function stop() {\n\t      // noop\n\t    };\n\t\n\t    AbstractHistory.prototype.go = function go(path, replace, append) {\n\t      path = this.currentPath = this.formatPath(path, append);\n\t      this.onChange(path);\n\t    };\n\t\n\t    AbstractHistory.prototype.formatPath = function formatPath(path, append) {\n\t      return path.charAt(0) === '/' ? path : resolvePath(this.currentPath, path, append);\n\t    };\n\t\n\t    return AbstractHistory;\n\t  })();\n\t\n\t  /**\n\t   * Determine the reusability of an existing router view.\n\t   *\n\t   * @param {Directive} view\n\t   * @param {Object} handler\n\t   * @param {Transition} transition\n\t   */\n\t\n\t  function canReuse(view, handler, transition) {\n\t    var component = view.childVM;\n\t    if (!component || !handler) {\n\t      return false;\n\t    }\n\t    // important: check view.Component here because it may\n\t    // have been changed in activate hook\n\t    if (view.Component !== handler.component) {\n\t      return false;\n\t    }\n\t    var canReuseFn = getRouteConfig(component, 'canReuse');\n\t    return typeof canReuseFn === 'boolean' ? canReuseFn : canReuseFn ? canReuseFn.call(component, {\n\t      to: transition.to,\n\t      from: transition.from\n\t    }) : true; // defaults to true\n\t  }\n\t\n\t  /**\n\t   * Check if a component can deactivate.\n\t   *\n\t   * @param {Directive} view\n\t   * @param {Transition} transition\n\t   * @param {Function} next\n\t   */\n\t\n\t  function canDeactivate(view, transition, next) {\n\t    var fromComponent = view.childVM;\n\t    var hook = getRouteConfig(fromComponent, 'canDeactivate');\n\t    if (!hook) {\n\t      next();\n\t    } else {\n\t      transition.callHook(hook, fromComponent, next, {\n\t        expectBoolean: true\n\t      });\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Check if a component can activate.\n\t   *\n\t   * @param {Object} handler\n\t   * @param {Transition} transition\n\t   * @param {Function} next\n\t   */\n\t\n\t  function canActivate(handler, transition, next) {\n\t    resolveAsyncComponent(handler, function (Component) {\n\t      // have to check due to async-ness\n\t      if (transition.aborted) {\n\t        return;\n\t      }\n\t      // determine if this component can be activated\n\t      var hook = getRouteConfig(Component, 'canActivate');\n\t      if (!hook) {\n\t        next();\n\t      } else {\n\t        transition.callHook(hook, null, next, {\n\t          expectBoolean: true\n\t        });\n\t      }\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Call deactivate hooks for existing router-views.\n\t   *\n\t   * @param {Directive} view\n\t   * @param {Transition} transition\n\t   * @param {Function} next\n\t   */\n\t\n\t  function deactivate(view, transition, next) {\n\t    var component = view.childVM;\n\t    var hook = getRouteConfig(component, 'deactivate');\n\t    if (!hook) {\n\t      next();\n\t    } else {\n\t      transition.callHooks(hook, component, next);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Activate / switch component for a router-view.\n\t   *\n\t   * @param {Directive} view\n\t   * @param {Transition} transition\n\t   * @param {Number} depth\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  function activate(view, transition, depth, cb, reuse) {\n\t    var handler = transition.activateQueue[depth];\n\t    if (!handler) {\n\t      saveChildView(view);\n\t      if (view._bound) {\n\t        view.setComponent(null);\n\t      }\n\t      cb && cb();\n\t      return;\n\t    }\n\t\n\t    var Component = view.Component = handler.component;\n\t    var activateHook = getRouteConfig(Component, 'activate');\n\t    var dataHook = getRouteConfig(Component, 'data');\n\t    var waitForData = getRouteConfig(Component, 'waitForData');\n\t\n\t    view.depth = depth;\n\t    view.activated = false;\n\t\n\t    var component = undefined;\n\t    var loading = !!(dataHook && !waitForData);\n\t\n\t    // \"reuse\" is a flag passed down when the parent view is\n\t    // either reused via keep-alive or as a child of a kept-alive view.\n\t    // of course we can only reuse if the current kept-alive instance\n\t    // is of the correct type.\n\t    reuse = reuse && view.childVM && view.childVM.constructor === Component;\n\t\n\t    if (reuse) {\n\t      // just reuse\n\t      component = view.childVM;\n\t      component.$loadingRouteData = loading;\n\t    } else {\n\t      saveChildView(view);\n\t\n\t      // unbuild current component. this step also destroys\n\t      // and removes all nested child views.\n\t      view.unbuild(true);\n\t\n\t      // build the new component. this will also create the\n\t      // direct child view of the current one. it will register\n\t      // itself as view.childView.\n\t      component = view.build({\n\t        _meta: {\n\t          $loadingRouteData: loading\n\t        },\n\t        created: function created() {\n\t          this._routerView = view;\n\t        }\n\t      });\n\t\n\t      // handle keep-alive.\n\t      // when a kept-alive child vm is restored, we need to\n\t      // add its cached child views into the router's view list,\n\t      // and also properly update current view's child view.\n\t      if (view.keepAlive) {\n\t        component.$loadingRouteData = loading;\n\t        var cachedChildView = component._keepAliveRouterView;\n\t        if (cachedChildView) {\n\t          view.childView = cachedChildView;\n\t          component._keepAliveRouterView = null;\n\t        }\n\t      }\n\t    }\n\t\n\t    // cleanup the component in case the transition is aborted\n\t    // before the component is ever inserted.\n\t    var cleanup = function cleanup() {\n\t      component.$destroy();\n\t    };\n\t\n\t    // actually insert the component and trigger transition\n\t    var insert = function insert() {\n\t      if (reuse) {\n\t        cb && cb();\n\t        return;\n\t      }\n\t      var router = transition.router;\n\t      if (router._rendered || router._transitionOnLoad) {\n\t        view.transition(component);\n\t      } else {\n\t        // no transition on first render, manual transition\n\t        /* istanbul ignore if */\n\t        if (view.setCurrent) {\n\t          // 0.12 compat\n\t          view.setCurrent(component);\n\t        } else {\n\t          // 1.0\n\t          view.childVM = component;\n\t        }\n\t        component.$before(view.anchor, null, false);\n\t      }\n\t      cb && cb();\n\t    };\n\t\n\t    var afterData = function afterData() {\n\t      // activate the child view\n\t      if (view.childView) {\n\t        activate(view.childView, transition, depth + 1, null, reuse || view.keepAlive);\n\t      }\n\t      insert();\n\t    };\n\t\n\t    // called after activation hook is resolved\n\t    var afterActivate = function afterActivate() {\n\t      view.activated = true;\n\t      if (dataHook && waitForData) {\n\t        // wait until data loaded to insert\n\t        loadData(component, transition, dataHook, afterData, cleanup);\n\t      } else {\n\t        // load data and insert at the same time\n\t        if (dataHook) {\n\t          loadData(component, transition, dataHook);\n\t        }\n\t        afterData();\n\t      }\n\t    };\n\t\n\t    if (activateHook) {\n\t      transition.callHooks(activateHook, component, afterActivate, {\n\t        cleanup: cleanup,\n\t        postActivate: true\n\t      });\n\t    } else {\n\t      afterActivate();\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Reuse a view, just reload data if necessary.\n\t   *\n\t   * @param {Directive} view\n\t   * @param {Transition} transition\n\t   */\n\t\n\t  function reuse(view, transition) {\n\t    var component = view.childVM;\n\t    var dataHook = getRouteConfig(component, 'data');\n\t    if (dataHook) {\n\t      loadData(component, transition, dataHook);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Asynchronously load and apply data to component.\n\t   *\n\t   * @param {Vue} component\n\t   * @param {Transition} transition\n\t   * @param {Function} hook\n\t   * @param {Function} cb\n\t   * @param {Function} cleanup\n\t   */\n\t\n\t  function loadData(component, transition, hook, cb, cleanup) {\n\t    component.$loadingRouteData = true;\n\t    transition.callHooks(hook, component, function () {\n\t      component.$loadingRouteData = false;\n\t      component.$emit('route-data-loaded', component);\n\t      cb && cb();\n\t    }, {\n\t      cleanup: cleanup,\n\t      postActivate: true,\n\t      processData: function processData(data) {\n\t        // handle promise sugar syntax\n\t        var promises = [];\n\t        if (isPlainObject(data)) {\n\t          Object.keys(data).forEach(function (key) {\n\t            var val = data[key];\n\t            if (isPromise(val)) {\n\t              promises.push(val.then(function (resolvedVal) {\n\t                component.$set(key, resolvedVal);\n\t              }));\n\t            } else {\n\t              component.$set(key, val);\n\t            }\n\t          });\n\t        }\n\t        if (promises.length) {\n\t          return promises[0].constructor.all(promises);\n\t        }\n\t      }\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Save the child view for a kept-alive view so that\n\t   * we can restore it when it is switched back to.\n\t   *\n\t   * @param {Directive} view\n\t   */\n\t\n\t  function saveChildView(view) {\n\t    if (view.keepAlive && view.childVM && view.childView) {\n\t      view.childVM._keepAliveRouterView = view.childView;\n\t    }\n\t    view.childView = null;\n\t  }\n\t\n\t  /**\n\t   * Check plain object.\n\t   *\n\t   * @param {*} val\n\t   */\n\t\n\t  function isPlainObject(val) {\n\t    return Object.prototype.toString.call(val) === '[object Object]';\n\t  }\n\t\n\t  /**\n\t   * A RouteTransition object manages the pipeline of a\n\t   * router-view switching process. This is also the object\n\t   * passed into user route hooks.\n\t   *\n\t   * @param {Router} router\n\t   * @param {Route} to\n\t   * @param {Route} from\n\t   */\n\t\n\t  var RouteTransition = (function () {\n\t    function RouteTransition(router, to, from) {\n\t      babelHelpers.classCallCheck(this, RouteTransition);\n\t\n\t      this.router = router;\n\t      this.to = to;\n\t      this.from = from;\n\t      this.next = null;\n\t      this.aborted = false;\n\t      this.done = false;\n\t    }\n\t\n\t    /**\n\t     * Abort current transition and return to previous location.\n\t     */\n\t\n\t    RouteTransition.prototype.abort = function abort() {\n\t      if (!this.aborted) {\n\t        this.aborted = true;\n\t        // if the root path throws an error during validation\n\t        // on initial load, it gets caught in an infinite loop.\n\t        var abortingOnLoad = !this.from.path && this.to.path === '/';\n\t        if (!abortingOnLoad) {\n\t          this.router.replace(this.from.path || '/');\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Abort current transition and redirect to a new location.\n\t     *\n\t     * @param {String} path\n\t     */\n\t\n\t    RouteTransition.prototype.redirect = function redirect(path) {\n\t      if (!this.aborted) {\n\t        this.aborted = true;\n\t        if (typeof path === 'string') {\n\t          path = mapParams(path, this.to.params, this.to.query);\n\t        } else {\n\t          path.params = path.params || this.to.params;\n\t          path.query = path.query || this.to.query;\n\t        }\n\t        this.router.replace(path);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * A router view transition's pipeline can be described as\n\t     * follows, assuming we are transitioning from an existing\n\t     * <router-view> chain [Component A, Component B] to a new\n\t     * chain [Component A, Component C]:\n\t     *\n\t     *  A    A\n\t     *  | => |\n\t     *  B    C\n\t     *\n\t     * 1. Reusablity phase:\n\t     *   -> canReuse(A, A)\n\t     *   -> canReuse(B, C)\n\t     *   -> determine new queues:\n\t     *      - deactivation: [B]\n\t     *      - activation: [C]\n\t     *\n\t     * 2. Validation phase:\n\t     *   -> canDeactivate(B)\n\t     *   -> canActivate(C)\n\t     *\n\t     * 3. Activation phase:\n\t     *   -> deactivate(B)\n\t     *   -> activate(C)\n\t     *\n\t     * Each of these steps can be asynchronous, and any\n\t     * step can potentially abort the transition.\n\t     *\n\t     * @param {Function} cb\n\t     */\n\t\n\t    RouteTransition.prototype.start = function start(cb) {\n\t      var transition = this;\n\t\n\t      // determine the queue of views to deactivate\n\t      var deactivateQueue = [];\n\t      var view = this.router._rootView;\n\t      while (view) {\n\t        deactivateQueue.unshift(view);\n\t        view = view.childView;\n\t      }\n\t      var reverseDeactivateQueue = deactivateQueue.slice().reverse();\n\t\n\t      // determine the queue of route handlers to activate\n\t      var activateQueue = this.activateQueue = toArray(this.to.matched).map(function (match) {\n\t        return match.handler;\n\t      });\n\t\n\t      // 1. Reusability phase\n\t      var i = undefined,\n\t          reuseQueue = undefined;\n\t      for (i = 0; i < reverseDeactivateQueue.length; i++) {\n\t        if (!canReuse(reverseDeactivateQueue[i], activateQueue[i], transition)) {\n\t          break;\n\t        }\n\t      }\n\t      if (i > 0) {\n\t        reuseQueue = reverseDeactivateQueue.slice(0, i);\n\t        deactivateQueue = reverseDeactivateQueue.slice(i).reverse();\n\t        activateQueue = activateQueue.slice(i);\n\t      }\n\t\n\t      // 2. Validation phase\n\t      transition.runQueue(deactivateQueue, canDeactivate, function () {\n\t        transition.runQueue(activateQueue, canActivate, function () {\n\t          transition.runQueue(deactivateQueue, deactivate, function () {\n\t            // 3. Activation phase\n\t\n\t            // Update router current route\n\t            transition.router._onTransitionValidated(transition);\n\t\n\t            // trigger reuse for all reused views\n\t            reuseQueue && reuseQueue.forEach(function (view) {\n\t              return reuse(view, transition);\n\t            });\n\t\n\t            // the root of the chain that needs to be replaced\n\t            // is the top-most non-reusable view.\n\t            if (deactivateQueue.length) {\n\t              var _view = deactivateQueue[deactivateQueue.length - 1];\n\t              var depth = reuseQueue ? reuseQueue.length : 0;\n\t              activate(_view, transition, depth, cb);\n\t            } else {\n\t              cb();\n\t            }\n\t          });\n\t        });\n\t      });\n\t    };\n\t\n\t    /**\n\t     * Asynchronously and sequentially apply a function to a\n\t     * queue.\n\t     *\n\t     * @param {Array} queue\n\t     * @param {Function} fn\n\t     * @param {Function} cb\n\t     */\n\t\n\t    RouteTransition.prototype.runQueue = function runQueue(queue, fn, cb) {\n\t      var transition = this;\n\t      step(0);\n\t      function step(index) {\n\t        if (index >= queue.length) {\n\t          cb();\n\t        } else {\n\t          fn(queue[index], transition, function () {\n\t            step(index + 1);\n\t          });\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Call a user provided route transition hook and handle\n\t     * the response (e.g. if the user returns a promise).\n\t     *\n\t     * If the user neither expects an argument nor returns a\n\t     * promise, the hook is assumed to be synchronous.\n\t     *\n\t     * @param {Function} hook\n\t     * @param {*} [context]\n\t     * @param {Function} [cb]\n\t     * @param {Object} [options]\n\t     *                 - {Boolean} expectBoolean\n\t     *                 - {Boolean} postActive\n\t     *                 - {Function} processData\n\t     *                 - {Function} cleanup\n\t     */\n\t\n\t    RouteTransition.prototype.callHook = function callHook(hook, context, cb) {\n\t      var _ref = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\t\n\t      var _ref$expectBoolean = _ref.expectBoolean;\n\t      var expectBoolean = _ref$expectBoolean === undefined ? false : _ref$expectBoolean;\n\t      var _ref$postActivate = _ref.postActivate;\n\t      var postActivate = _ref$postActivate === undefined ? false : _ref$postActivate;\n\t      var processData = _ref.processData;\n\t      var cleanup = _ref.cleanup;\n\t\n\t      var transition = this;\n\t      var nextCalled = false;\n\t\n\t      // abort the transition\n\t      var abort = function abort() {\n\t        cleanup && cleanup();\n\t        transition.abort();\n\t      };\n\t\n\t      // handle errors\n\t      var onError = function onError(err) {\n\t        postActivate ? next() : abort();\n\t        if (err && !transition.router._suppress) {\n\t          warn$1('Uncaught error during transition: ');\n\t          throw err instanceof Error ? err : new Error(err);\n\t        }\n\t      };\n\t\n\t      // since promise swallows errors, we have to\n\t      // throw it in the next tick...\n\t      var onPromiseError = function onPromiseError(err) {\n\t        try {\n\t          onError(err);\n\t        } catch (e) {\n\t          setTimeout(function () {\n\t            throw e;\n\t          }, 0);\n\t        }\n\t      };\n\t\n\t      // advance the transition to the next step\n\t      var next = function next() {\n\t        if (nextCalled) {\n\t          warn$1('transition.next() should be called only once.');\n\t          return;\n\t        }\n\t        nextCalled = true;\n\t        if (transition.aborted) {\n\t          cleanup && cleanup();\n\t          return;\n\t        }\n\t        cb && cb();\n\t      };\n\t\n\t      var nextWithBoolean = function nextWithBoolean(res) {\n\t        if (typeof res === 'boolean') {\n\t          res ? next() : abort();\n\t        } else if (isPromise(res)) {\n\t          res.then(function (ok) {\n\t            ok ? next() : abort();\n\t          }, onPromiseError);\n\t        } else if (!hook.length) {\n\t          next();\n\t        }\n\t      };\n\t\n\t      var nextWithData = function nextWithData(data) {\n\t        var res = undefined;\n\t        try {\n\t          res = processData(data);\n\t        } catch (err) {\n\t          return onError(err);\n\t        }\n\t        if (isPromise(res)) {\n\t          res.then(next, onPromiseError);\n\t        } else {\n\t          next();\n\t        }\n\t      };\n\t\n\t      // expose a clone of the transition object, so that each\n\t      // hook gets a clean copy and prevent the user from\n\t      // messing with the internals.\n\t      var exposed = {\n\t        to: transition.to,\n\t        from: transition.from,\n\t        abort: abort,\n\t        next: processData ? nextWithData : next,\n\t        redirect: function redirect() {\n\t          transition.redirect.apply(transition, arguments);\n\t        }\n\t      };\n\t\n\t      // actually call the hook\n\t      var res = undefined;\n\t      try {\n\t        res = hook.call(context, exposed);\n\t      } catch (err) {\n\t        return onError(err);\n\t      }\n\t\n\t      if (expectBoolean) {\n\t        // boolean hooks\n\t        nextWithBoolean(res);\n\t      } else if (isPromise(res)) {\n\t        // promise\n\t        if (processData) {\n\t          res.then(nextWithData, onPromiseError);\n\t        } else {\n\t          res.then(next, onPromiseError);\n\t        }\n\t      } else if (processData && isPlainOjbect(res)) {\n\t        // data promise sugar\n\t        nextWithData(res);\n\t      } else if (!hook.length) {\n\t        next();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Call a single hook or an array of async hooks in series.\n\t     *\n\t     * @param {Array} hooks\n\t     * @param {*} context\n\t     * @param {Function} cb\n\t     * @param {Object} [options]\n\t     */\n\t\n\t    RouteTransition.prototype.callHooks = function callHooks(hooks, context, cb, options) {\n\t      var _this = this;\n\t\n\t      if (Array.isArray(hooks)) {\n\t        this.runQueue(hooks, function (hook, _, next) {\n\t          if (!_this.aborted) {\n\t            _this.callHook(hook, context, next, options);\n\t          }\n\t        }, cb);\n\t      } else {\n\t        this.callHook(hooks, context, cb, options);\n\t      }\n\t    };\n\t\n\t    return RouteTransition;\n\t  })();\n\t\n\t  function isPlainOjbect(val) {\n\t    return Object.prototype.toString.call(val) === '[object Object]';\n\t  }\n\t\n\t  function toArray(val) {\n\t    return val ? Array.prototype.slice.call(val) : [];\n\t  }\n\t\n\t  var internalKeysRE = /^(component|subRoutes|fullPath)$/;\n\t\n\t  /**\n\t   * Route Context Object\n\t   *\n\t   * @param {String} path\n\t   * @param {Router} router\n\t   */\n\t\n\t  var Route = function Route(path, router) {\n\t    var _this = this;\n\t\n\t    babelHelpers.classCallCheck(this, Route);\n\t\n\t    var matched = router._recognizer.recognize(path);\n\t    if (matched) {\n\t      // copy all custom fields from route configs\n\t      [].forEach.call(matched, function (match) {\n\t        for (var key in match.handler) {\n\t          if (!internalKeysRE.test(key)) {\n\t            _this[key] = match.handler[key];\n\t          }\n\t        }\n\t      });\n\t      // set query and params\n\t      this.query = matched.queryParams;\n\t      this.params = [].reduce.call(matched, function (prev, cur) {\n\t        if (cur.params) {\n\t          for (var key in cur.params) {\n\t            prev[key] = cur.params[key];\n\t          }\n\t        }\n\t        return prev;\n\t      }, {});\n\t    }\n\t    // expose path and router\n\t    this.path = path;\n\t    // for internal use\n\t    this.matched = matched || router._notFoundHandler;\n\t    // internal reference to router\n\t    Object.defineProperty(this, 'router', {\n\t      enumerable: false,\n\t      value: router\n\t    });\n\t    // Important: freeze self to prevent observation\n\t    Object.freeze(this);\n\t  };\n\t\n\t  function applyOverride (Vue) {\n\t    var _Vue$util = Vue.util;\n\t    var extend = _Vue$util.extend;\n\t    var isArray = _Vue$util.isArray;\n\t    var defineReactive = _Vue$util.defineReactive;\n\t\n\t    // override Vue's init and destroy process to keep track of router instances\n\t    var init = Vue.prototype._init;\n\t    Vue.prototype._init = function (options) {\n\t      options = options || {};\n\t      var root = options._parent || options.parent || this;\n\t      var router = root.$router;\n\t      var route = root.$route;\n\t      if (router) {\n\t        // expose router\n\t        this.$router = router;\n\t        router._children.push(this);\n\t        /* istanbul ignore if */\n\t        if (this._defineMeta) {\n\t          // 0.12\n\t          this._defineMeta('$route', route);\n\t        } else {\n\t          // 1.0\n\t          defineReactive(this, '$route', route);\n\t        }\n\t      }\n\t      init.call(this, options);\n\t    };\n\t\n\t    var destroy = Vue.prototype._destroy;\n\t    Vue.prototype._destroy = function () {\n\t      if (!this._isBeingDestroyed && this.$router) {\n\t        this.$router._children.$remove(this);\n\t      }\n\t      destroy.apply(this, arguments);\n\t    };\n\t\n\t    // 1.0 only: enable route mixins\n\t    var strats = Vue.config.optionMergeStrategies;\n\t    var hooksToMergeRE = /^(data|activate|deactivate)$/;\n\t\n\t    if (strats) {\n\t      strats.route = function (parentVal, childVal) {\n\t        if (!childVal) return parentVal;\n\t        if (!parentVal) return childVal;\n\t        var ret = {};\n\t        extend(ret, parentVal);\n\t        for (var key in childVal) {\n\t          var a = ret[key];\n\t          var b = childVal[key];\n\t          // for data, activate and deactivate, we need to merge them into\n\t          // arrays similar to lifecycle hooks.\n\t          if (a && hooksToMergeRE.test(key)) {\n\t            ret[key] = (isArray(a) ? a : [a]).concat(b);\n\t          } else {\n\t            ret[key] = b;\n\t          }\n\t        }\n\t        return ret;\n\t      };\n\t    }\n\t  }\n\t\n\t  function View (Vue) {\n\t\n\t    var _ = Vue.util;\n\t    var componentDef =\n\t    // 0.12\n\t    Vue.directive('_component') ||\n\t    // 1.0\n\t    Vue.internalDirectives.component;\n\t    // <router-view> extends the internal component directive\n\t    var viewDef = _.extend({}, componentDef);\n\t\n\t    // with some overrides\n\t    _.extend(viewDef, {\n\t\n\t      _isRouterView: true,\n\t\n\t      bind: function bind() {\n\t        var route = this.vm.$route;\n\t        /* istanbul ignore if */\n\t        if (!route) {\n\t          warn$1('<router-view> can only be used inside a ' + 'router-enabled app.');\n\t          return;\n\t        }\n\t        // force dynamic directive so v-component doesn't\n\t        // attempt to build right now\n\t        this._isDynamicLiteral = true;\n\t        // finally, init by delegating to v-component\n\t        componentDef.bind.call(this);\n\t\n\t        // locate the parent view\n\t        var parentView = undefined;\n\t        var parent = this.vm;\n\t        while (parent) {\n\t          if (parent._routerView) {\n\t            parentView = parent._routerView;\n\t            break;\n\t          }\n\t          parent = parent.$parent;\n\t        }\n\t        if (parentView) {\n\t          // register self as a child of the parent view,\n\t          // instead of activating now. This is so that the\n\t          // child's activate hook is called after the\n\t          // parent's has resolved.\n\t          this.parentView = parentView;\n\t          parentView.childView = this;\n\t        } else {\n\t          // this is the root view!\n\t          var router = route.router;\n\t          router._rootView = this;\n\t        }\n\t\n\t        // handle late-rendered view\n\t        // two possibilities:\n\t        // 1. root view rendered after transition has been\n\t        //    validated;\n\t        // 2. child view rendered after parent view has been\n\t        //    activated.\n\t        var transition = route.router._currentTransition;\n\t        if (!parentView && transition.done || parentView && parentView.activated) {\n\t          var depth = parentView ? parentView.depth + 1 : 0;\n\t          activate(this, transition, depth);\n\t        }\n\t      },\n\t\n\t      unbind: function unbind() {\n\t        if (this.parentView) {\n\t          this.parentView.childView = null;\n\t        }\n\t        componentDef.unbind.call(this);\n\t      }\n\t    });\n\t\n\t    Vue.elementDirective('router-view', viewDef);\n\t  }\n\t\n\t  var trailingSlashRE = /\\/$/;\n\t  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\t  var queryStringRE = /\\?.*$/;\n\t\n\t  // install v-link, which provides navigation support for\n\t  // HTML5 history mode\n\t  function Link (Vue) {\n\t    var _Vue$util = Vue.util;\n\t    var _bind = _Vue$util.bind;\n\t    var isObject = _Vue$util.isObject;\n\t    var addClass = _Vue$util.addClass;\n\t    var removeClass = _Vue$util.removeClass;\n\t\n\t    var onPriority = Vue.directive('on').priority;\n\t    var LINK_UPDATE = '__vue-router-link-update__';\n\t\n\t    var activeId = 0;\n\t\n\t    Vue.directive('link-active', {\n\t      priority: 9999,\n\t      bind: function bind() {\n\t        var _this = this;\n\t\n\t        var id = String(activeId++);\n\t        // collect v-links contained within this element.\n\t        // we need do this here before the parent-child relationship\n\t        // gets messed up by terminal directives (if, for, components)\n\t        var childLinks = this.el.querySelectorAll('[v-link]');\n\t        for (var i = 0, l = childLinks.length; i < l; i++) {\n\t          var link = childLinks[i];\n\t          var existingId = link.getAttribute(LINK_UPDATE);\n\t          var value = existingId ? existingId + ',' + id : id;\n\t          // leave a mark on the link element which can be persisted\n\t          // through fragment clones.\n\t          link.setAttribute(LINK_UPDATE, value);\n\t        }\n\t        this.vm.$on(LINK_UPDATE, this.cb = function (link, path) {\n\t          if (link.activeIds.indexOf(id) > -1) {\n\t            link.updateClasses(path, _this.el);\n\t          }\n\t        });\n\t      },\n\t      unbind: function unbind() {\n\t        this.vm.$off(LINK_UPDATE, this.cb);\n\t      }\n\t    });\n\t\n\t    Vue.directive('link', {\n\t      priority: onPriority - 2,\n\t\n\t      bind: function bind() {\n\t        var vm = this.vm;\n\t        /* istanbul ignore if */\n\t        if (!vm.$route) {\n\t          warn$1('v-link can only be used inside a router-enabled app.');\n\t          return;\n\t        }\n\t        this.router = vm.$route.router;\n\t        // update things when the route changes\n\t        this.unwatch = vm.$watch('$route', _bind(this.onRouteUpdate, this));\n\t        // check v-link-active ids\n\t        var activeIds = this.el.getAttribute(LINK_UPDATE);\n\t        if (activeIds) {\n\t          this.el.removeAttribute(LINK_UPDATE);\n\t          this.activeIds = activeIds.split(',');\n\t        }\n\t        // no need to handle click if link expects to be opened\n\t        // in a new window/tab.\n\t        /* istanbul ignore if */\n\t        if (this.el.tagName === 'A' && this.el.getAttribute('target') === '_blank') {\n\t          return;\n\t        }\n\t        // handle click\n\t        this.handler = _bind(this.onClick, this);\n\t        this.el.addEventListener('click', this.handler);\n\t      },\n\t\n\t      update: function update(target) {\n\t        this.target = target;\n\t        if (isObject(target)) {\n\t          this.append = target.append;\n\t          this.exact = target.exact;\n\t          this.prevActiveClass = this.activeClass;\n\t          this.activeClass = target.activeClass;\n\t        }\n\t        this.onRouteUpdate(this.vm.$route);\n\t      },\n\t\n\t      onClick: function onClick(e) {\n\t        // don't redirect with control keys\n\t        /* istanbul ignore if */\n\t        if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n\t        // don't redirect when preventDefault called\n\t        /* istanbul ignore if */\n\t        if (e.defaultPrevented) return;\n\t        // don't redirect on right click\n\t        /* istanbul ignore if */\n\t        if (e.button !== 0) return;\n\t\n\t        var target = this.target;\n\t        if (target) {\n\t          // v-link with expression, just go\n\t          e.preventDefault();\n\t          this.router.go(target);\n\t        } else {\n\t          // no expression, delegate for an <a> inside\n\t          var el = e.target;\n\t          while (el.tagName !== 'A' && el !== this.el) {\n\t            el = el.parentNode;\n\t          }\n\t          if (el.tagName === 'A' && sameOrigin(el)) {\n\t            e.preventDefault();\n\t            var path = el.pathname;\n\t            if (this.router.history.root) {\n\t              path = path.replace(this.router.history.rootRE, '');\n\t            }\n\t            this.router.go({\n\t              path: path,\n\t              replace: target && target.replace,\n\t              append: target && target.append\n\t            });\n\t          }\n\t        }\n\t      },\n\t\n\t      onRouteUpdate: function onRouteUpdate(route) {\n\t        // router.stringifyPath is dependent on current route\n\t        // and needs to be called again whenver route changes.\n\t        var newPath = this.router.stringifyPath(this.target);\n\t        if (this.path !== newPath) {\n\t          this.path = newPath;\n\t          this.updateActiveMatch();\n\t          this.updateHref();\n\t        }\n\t        if (this.activeIds) {\n\t          this.vm.$emit(LINK_UPDATE, this, route.path);\n\t        } else {\n\t          this.updateClasses(route.path, this.el);\n\t        }\n\t      },\n\t\n\t      updateActiveMatch: function updateActiveMatch() {\n\t        this.activeRE = this.path && !this.exact ? new RegExp('^' + this.path.replace(/\\/$/, '').replace(queryStringRE, '').replace(regexEscapeRE, '\\\\$&') + '(\\\\/|$)') : null;\n\t      },\n\t\n\t      updateHref: function updateHref() {\n\t        if (this.el.tagName !== 'A') {\n\t          return;\n\t        }\n\t        var path = this.path;\n\t        var router = this.router;\n\t        var isAbsolute = path.charAt(0) === '/';\n\t        // do not format non-hash relative paths\n\t        var href = path && (router.mode === 'hash' || isAbsolute) ? router.history.formatPath(path, this.append) : path;\n\t        if (href) {\n\t          this.el.href = href;\n\t        } else {\n\t          this.el.removeAttribute('href');\n\t        }\n\t      },\n\t\n\t      updateClasses: function updateClasses(path, el) {\n\t        var activeClass = this.activeClass || this.router._linkActiveClass;\n\t        // clear old class\n\t        if (this.prevActiveClass && this.prevActiveClass !== activeClass) {\n\t          toggleClasses(el, this.prevActiveClass, removeClass);\n\t        }\n\t        // remove query string before matching\n\t        var dest = this.path.replace(queryStringRE, '');\n\t        path = path.replace(queryStringRE, '');\n\t        // add new class\n\t        if (this.exact) {\n\t          if (dest === path ||\n\t          // also allow additional trailing slash\n\t          dest.charAt(dest.length - 1) !== '/' && dest === path.replace(trailingSlashRE, '')) {\n\t            toggleClasses(el, activeClass, addClass);\n\t          } else {\n\t            toggleClasses(el, activeClass, removeClass);\n\t          }\n\t        } else {\n\t          if (this.activeRE && this.activeRE.test(path)) {\n\t            toggleClasses(el, activeClass, addClass);\n\t          } else {\n\t            toggleClasses(el, activeClass, removeClass);\n\t          }\n\t        }\n\t      },\n\t\n\t      unbind: function unbind() {\n\t        this.el.removeEventListener('click', this.handler);\n\t        this.unwatch && this.unwatch();\n\t      }\n\t    });\n\t\n\t    function sameOrigin(link) {\n\t      return link.protocol === location.protocol && link.hostname === location.hostname && link.port === location.port;\n\t    }\n\t\n\t    // this function is copied from v-bind:class implementation until\n\t    // we properly expose it...\n\t    function toggleClasses(el, key, fn) {\n\t      key = key.trim();\n\t      if (key.indexOf(' ') === -1) {\n\t        fn(el, key);\n\t        return;\n\t      }\n\t      var keys = key.split(/\\s+/);\n\t      for (var i = 0, l = keys.length; i < l; i++) {\n\t        fn(el, keys[i]);\n\t      }\n\t    }\n\t  }\n\t\n\t  var historyBackends = {\n\t    abstract: AbstractHistory,\n\t    hash: HashHistory,\n\t    html5: HTML5History\n\t  };\n\t\n\t  // late bind during install\n\t  var Vue = undefined;\n\t\n\t  /**\n\t   * Router constructor\n\t   *\n\t   * @param {Object} [options]\n\t   */\n\t\n\t  var Router = (function () {\n\t    function Router() {\n\t      var _this = this;\n\t\n\t      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var _ref$hashbang = _ref.hashbang;\n\t      var hashbang = _ref$hashbang === undefined ? true : _ref$hashbang;\n\t      var _ref$abstract = _ref.abstract;\n\t      var abstract = _ref$abstract === undefined ? false : _ref$abstract;\n\t      var _ref$history = _ref.history;\n\t      var history = _ref$history === undefined ? false : _ref$history;\n\t      var _ref$saveScrollPosition = _ref.saveScrollPosition;\n\t      var saveScrollPosition = _ref$saveScrollPosition === undefined ? false : _ref$saveScrollPosition;\n\t      var _ref$transitionOnLoad = _ref.transitionOnLoad;\n\t      var transitionOnLoad = _ref$transitionOnLoad === undefined ? false : _ref$transitionOnLoad;\n\t      var _ref$suppressTransitionError = _ref.suppressTransitionError;\n\t      var suppressTransitionError = _ref$suppressTransitionError === undefined ? false : _ref$suppressTransitionError;\n\t      var _ref$root = _ref.root;\n\t      var root = _ref$root === undefined ? null : _ref$root;\n\t      var _ref$linkActiveClass = _ref.linkActiveClass;\n\t      var linkActiveClass = _ref$linkActiveClass === undefined ? 'v-link-active' : _ref$linkActiveClass;\n\t      babelHelpers.classCallCheck(this, Router);\n\t\n\t      /* istanbul ignore if */\n\t      if (!Router.installed) {\n\t        throw new Error('Please install the Router with Vue.use() before ' + 'creating an instance.');\n\t      }\n\t\n\t      // Vue instances\n\t      this.app = null;\n\t      this._children = [];\n\t\n\t      // route recognizer\n\t      this._recognizer = new RouteRecognizer();\n\t      this._guardRecognizer = new RouteRecognizer();\n\t\n\t      // state\n\t      this._started = false;\n\t      this._startCb = null;\n\t      this._currentRoute = {};\n\t      this._currentTransition = null;\n\t      this._previousTransition = null;\n\t      this._notFoundHandler = null;\n\t      this._notFoundRedirect = null;\n\t      this._beforeEachHooks = [];\n\t      this._afterEachHooks = [];\n\t\n\t      // trigger transition on initial render?\n\t      this._rendered = false;\n\t      this._transitionOnLoad = transitionOnLoad;\n\t\n\t      // history mode\n\t      this._root = root;\n\t      this._abstract = abstract;\n\t      this._hashbang = hashbang;\n\t\n\t      // check if HTML5 history is available\n\t      var hasPushState = typeof window !== 'undefined' && window.history && window.history.pushState;\n\t      this._history = history && hasPushState;\n\t      this._historyFallback = history && !hasPushState;\n\t\n\t      // create history object\n\t      var inBrowser = Vue.util.inBrowser;\n\t      this.mode = !inBrowser || this._abstract ? 'abstract' : this._history ? 'html5' : 'hash';\n\t\n\t      var History = historyBackends[this.mode];\n\t      this.history = new History({\n\t        root: root,\n\t        hashbang: this._hashbang,\n\t        onChange: function onChange(path, state, anchor) {\n\t          _this._match(path, state, anchor);\n\t        }\n\t      });\n\t\n\t      // other options\n\t      this._saveScrollPosition = saveScrollPosition;\n\t      this._linkActiveClass = linkActiveClass;\n\t      this._suppress = suppressTransitionError;\n\t    }\n\t\n\t    /**\n\t     * Allow directly passing components to a route\n\t     * definition.\n\t     *\n\t     * @param {String} path\n\t     * @param {Object} handler\n\t     */\n\t\n\t    // API ===================================================\n\t\n\t    /**\n\t    * Register a map of top-level paths.\n\t    *\n\t    * @param {Object} map\n\t    */\n\t\n\t    Router.prototype.map = function map(_map) {\n\t      for (var route in _map) {\n\t        this.on(route, _map[route]);\n\t      }\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Register a single root-level path\n\t     *\n\t     * @param {String} rootPath\n\t     * @param {Object} handler\n\t     *                 - {String} component\n\t     *                 - {Object} [subRoutes]\n\t     *                 - {Boolean} [forceRefresh]\n\t     *                 - {Function} [before]\n\t     *                 - {Function} [after]\n\t     */\n\t\n\t    Router.prototype.on = function on(rootPath, handler) {\n\t      if (rootPath === '*') {\n\t        this._notFound(handler);\n\t      } else {\n\t        this._addRoute(rootPath, handler, []);\n\t      }\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Set redirects.\n\t     *\n\t     * @param {Object} map\n\t     */\n\t\n\t    Router.prototype.redirect = function redirect(map) {\n\t      for (var path in map) {\n\t        this._addRedirect(path, map[path]);\n\t      }\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Set aliases.\n\t     *\n\t     * @param {Object} map\n\t     */\n\t\n\t    Router.prototype.alias = function alias(map) {\n\t      for (var path in map) {\n\t        this._addAlias(path, map[path]);\n\t      }\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Set global before hook.\n\t     *\n\t     * @param {Function} fn\n\t     */\n\t\n\t    Router.prototype.beforeEach = function beforeEach(fn) {\n\t      this._beforeEachHooks.push(fn);\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Set global after hook.\n\t     *\n\t     * @param {Function} fn\n\t     */\n\t\n\t    Router.prototype.afterEach = function afterEach(fn) {\n\t      this._afterEachHooks.push(fn);\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Navigate to a given path.\n\t     * The path can be an object describing a named path in\n\t     * the format of { name: '...', params: {}, query: {}}\n\t     * The path is assumed to be already decoded, and will\n\t     * be resolved against root (if provided)\n\t     *\n\t     * @param {String|Object} path\n\t     * @param {Boolean} [replace]\n\t     */\n\t\n\t    Router.prototype.go = function go(path) {\n\t      var replace = false;\n\t      var append = false;\n\t      if (Vue.util.isObject(path)) {\n\t        replace = path.replace;\n\t        append = path.append;\n\t      }\n\t      path = this.stringifyPath(path);\n\t      if (path) {\n\t        this.history.go(path, replace, append);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Short hand for replacing current path\n\t     *\n\t     * @param {String} path\n\t     */\n\t\n\t    Router.prototype.replace = function replace(path) {\n\t      if (typeof path === 'string') {\n\t        path = { path: path };\n\t      }\n\t      path.replace = true;\n\t      this.go(path);\n\t    };\n\t\n\t    /**\n\t     * Start the router.\n\t     *\n\t     * @param {VueConstructor} App\n\t     * @param {String|Element} container\n\t     * @param {Function} [cb]\n\t     */\n\t\n\t    Router.prototype.start = function start(App, container, cb) {\n\t      /* istanbul ignore if */\n\t      if (this._started) {\n\t        warn$1('already started.');\n\t        return;\n\t      }\n\t      this._started = true;\n\t      this._startCb = cb;\n\t      if (!this.app) {\n\t        /* istanbul ignore if */\n\t        if (!App || !container) {\n\t          throw new Error('Must start vue-router with a component and a ' + 'root container.');\n\t        }\n\t        /* istanbul ignore if */\n\t        if (App instanceof Vue) {\n\t          throw new Error('Must start vue-router with a component, not a ' + 'Vue instance.');\n\t        }\n\t        this._appContainer = container;\n\t        var Ctor = this._appConstructor = typeof App === 'function' ? App : Vue.extend(App);\n\t        // give it a name for better debugging\n\t        Ctor.options.name = Ctor.options.name || 'RouterApp';\n\t      }\n\t\n\t      // handle history fallback in browsers that do not\n\t      // support HTML5 history API\n\t      if (this._historyFallback) {\n\t        var _location = window.location;\n\t        var _history = new HTML5History({ root: this._root });\n\t        var path = _history.root ? _location.pathname.replace(_history.rootRE, '') : _location.pathname;\n\t        if (path && path !== '/') {\n\t          _location.assign((_history.root || '') + '/' + this.history.formatPath(path) + _location.search);\n\t          return;\n\t        }\n\t      }\n\t\n\t      this.history.start();\n\t    };\n\t\n\t    /**\n\t     * Stop listening to route changes.\n\t     */\n\t\n\t    Router.prototype.stop = function stop() {\n\t      this.history.stop();\n\t      this._started = false;\n\t    };\n\t\n\t    /**\n\t     * Normalize named route object / string paths into\n\t     * a string.\n\t     *\n\t     * @param {Object|String|Number} path\n\t     * @return {String}\n\t     */\n\t\n\t    Router.prototype.stringifyPath = function stringifyPath(path) {\n\t      var generatedPath = '';\n\t      if (path && typeof path === 'object') {\n\t        if (path.name) {\n\t          var extend = Vue.util.extend;\n\t          var currentParams = this._currentTransition && this._currentTransition.to.params;\n\t          var targetParams = path.params || {};\n\t          var params = currentParams ? extend(extend({}, currentParams), targetParams) : targetParams;\n\t          generatedPath = encodeURI(this._recognizer.generate(path.name, params));\n\t        } else if (path.path) {\n\t          generatedPath = encodeURI(path.path);\n\t        }\n\t        if (path.query) {\n\t          // note: the generated query string is pre-URL-encoded by the recognizer\n\t          var query = this._recognizer.generateQueryString(path.query);\n\t          if (generatedPath.indexOf('?') > -1) {\n\t            generatedPath += '&' + query.slice(1);\n\t          } else {\n\t            generatedPath += query;\n\t          }\n\t        }\n\t      } else {\n\t        generatedPath = encodeURI(path ? path + '' : '');\n\t      }\n\t      return generatedPath;\n\t    };\n\t\n\t    // Internal methods ======================================\n\t\n\t    /**\n\t    * Add a route containing a list of segments to the internal\n\t    * route recognizer. Will be called recursively to add all\n\t    * possible sub-routes.\n\t    *\n\t    * @param {String} path\n\t    * @param {Object} handler\n\t    * @param {Array} segments\n\t    */\n\t\n\t    Router.prototype._addRoute = function _addRoute(path, handler, segments) {\n\t      guardComponent(path, handler);\n\t      handler.path = path;\n\t      handler.fullPath = (segments.reduce(function (path, segment) {\n\t        return path + segment.path;\n\t      }, '') + path).replace('//', '/');\n\t      segments.push({\n\t        path: path,\n\t        handler: handler\n\t      });\n\t      this._recognizer.add(segments, {\n\t        as: handler.name\n\t      });\n\t      // add sub routes\n\t      if (handler.subRoutes) {\n\t        for (var subPath in handler.subRoutes) {\n\t          // recursively walk all sub routes\n\t          this._addRoute(subPath, handler.subRoutes[subPath],\n\t          // pass a copy in recursion to avoid mutating\n\t          // across branches\n\t          segments.slice());\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Set the notFound route handler.\n\t     *\n\t     * @param {Object} handler\n\t     */\n\t\n\t    Router.prototype._notFound = function _notFound(handler) {\n\t      guardComponent('*', handler);\n\t      this._notFoundHandler = [{ handler: handler }];\n\t    };\n\t\n\t    /**\n\t     * Add a redirect record.\n\t     *\n\t     * @param {String} path\n\t     * @param {String} redirectPath\n\t     */\n\t\n\t    Router.prototype._addRedirect = function _addRedirect(path, redirectPath) {\n\t      if (path === '*') {\n\t        this._notFoundRedirect = redirectPath;\n\t      } else {\n\t        this._addGuard(path, redirectPath, this.replace);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Add an alias record.\n\t     *\n\t     * @param {String} path\n\t     * @param {String} aliasPath\n\t     */\n\t\n\t    Router.prototype._addAlias = function _addAlias(path, aliasPath) {\n\t      this._addGuard(path, aliasPath, this._match);\n\t    };\n\t\n\t    /**\n\t     * Add a path guard.\n\t     *\n\t     * @param {String} path\n\t     * @param {String} mappedPath\n\t     * @param {Function} handler\n\t     */\n\t\n\t    Router.prototype._addGuard = function _addGuard(path, mappedPath, _handler) {\n\t      var _this2 = this;\n\t\n\t      this._guardRecognizer.add([{\n\t        path: path,\n\t        handler: function handler(match, query) {\n\t          var realPath = mapParams(mappedPath, match.params, query);\n\t          _handler.call(_this2, realPath);\n\t        }\n\t      }]);\n\t    };\n\t\n\t    /**\n\t     * Check if a path matches any redirect records.\n\t     *\n\t     * @param {String} path\n\t     * @return {Boolean} - if true, will skip normal match.\n\t     */\n\t\n\t    Router.prototype._checkGuard = function _checkGuard(path) {\n\t      var matched = this._guardRecognizer.recognize(path, true);\n\t      if (matched) {\n\t        matched[0].handler(matched[0], matched.queryParams);\n\t        return true;\n\t      } else if (this._notFoundRedirect) {\n\t        matched = this._recognizer.recognize(path);\n\t        if (!matched) {\n\t          this.replace(this._notFoundRedirect);\n\t          return true;\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Match a URL path and set the route context on vm,\n\t     * triggering view updates.\n\t     *\n\t     * @param {String} path\n\t     * @param {Object} [state]\n\t     * @param {String} [anchor]\n\t     */\n\t\n\t    Router.prototype._match = function _match(path, state, anchor) {\n\t      var _this3 = this;\n\t\n\t      if (this._checkGuard(path)) {\n\t        return;\n\t      }\n\t\n\t      var currentRoute = this._currentRoute;\n\t      var currentTransition = this._currentTransition;\n\t\n\t      if (currentTransition) {\n\t        if (currentTransition.to.path === path) {\n\t          // do nothing if we have an active transition going to the same path\n\t          return;\n\t        } else if (currentRoute.path === path) {\n\t          // We are going to the same path, but we also have an ongoing but\n\t          // not-yet-validated transition. Abort that transition and reset to\n\t          // prev transition.\n\t          currentTransition.aborted = true;\n\t          this._currentTransition = this._prevTransition;\n\t          return;\n\t        } else {\n\t          // going to a totally different path. abort ongoing transition.\n\t          currentTransition.aborted = true;\n\t        }\n\t      }\n\t\n\t      // construct new route and transition context\n\t      var route = new Route(path, this);\n\t      var transition = new RouteTransition(this, route, currentRoute);\n\t\n\t      // current transition is updated right now.\n\t      // however, current route will only be updated after the transition has\n\t      // been validated.\n\t      this._prevTransition = currentTransition;\n\t      this._currentTransition = transition;\n\t\n\t      if (!this.app) {\n\t        (function () {\n\t          // initial render\n\t          var router = _this3;\n\t          _this3.app = new _this3._appConstructor({\n\t            el: _this3._appContainer,\n\t            created: function created() {\n\t              this.$router = router;\n\t            },\n\t            _meta: {\n\t              $route: route\n\t            }\n\t          });\n\t        })();\n\t      }\n\t\n\t      // check global before hook\n\t      var beforeHooks = this._beforeEachHooks;\n\t      var startTransition = function startTransition() {\n\t        transition.start(function () {\n\t          _this3._postTransition(route, state, anchor);\n\t        });\n\t      };\n\t\n\t      if (beforeHooks.length) {\n\t        transition.runQueue(beforeHooks, function (hook, _, next) {\n\t          if (transition === _this3._currentTransition) {\n\t            transition.callHook(hook, null, next, {\n\t              expectBoolean: true\n\t            });\n\t          }\n\t        }, startTransition);\n\t      } else {\n\t        startTransition();\n\t      }\n\t\n\t      if (!this._rendered && this._startCb) {\n\t        this._startCb.call(null);\n\t      }\n\t\n\t      // HACK:\n\t      // set rendered to true after the transition start, so\n\t      // that components that are acitvated synchronously know\n\t      // whether it is the initial render.\n\t      this._rendered = true;\n\t    };\n\t\n\t    /**\n\t     * Set current to the new transition.\n\t     * This is called by the transition object when the\n\t     * validation of a route has succeeded.\n\t     *\n\t     * @param {Transition} transition\n\t     */\n\t\n\t    Router.prototype._onTransitionValidated = function _onTransitionValidated(transition) {\n\t      // set current route\n\t      var route = this._currentRoute = transition.to;\n\t      // update route context for all children\n\t      if (this.app.$route !== route) {\n\t        this.app.$route = route;\n\t        this._children.forEach(function (child) {\n\t          child.$route = route;\n\t        });\n\t      }\n\t      // call global after hook\n\t      if (this._afterEachHooks.length) {\n\t        this._afterEachHooks.forEach(function (hook) {\n\t          return hook.call(null, {\n\t            to: transition.to,\n\t            from: transition.from\n\t          });\n\t        });\n\t      }\n\t      this._currentTransition.done = true;\n\t    };\n\t\n\t    /**\n\t     * Handle stuff after the transition.\n\t     *\n\t     * @param {Route} route\n\t     * @param {Object} [state]\n\t     * @param {String} [anchor]\n\t     */\n\t\n\t    Router.prototype._postTransition = function _postTransition(route, state, anchor) {\n\t      // handle scroll positions\n\t      // saved scroll positions take priority\n\t      // then we check if the path has an anchor\n\t      var pos = state && state.pos;\n\t      if (pos && this._saveScrollPosition) {\n\t        Vue.nextTick(function () {\n\t          window.scrollTo(pos.x, pos.y);\n\t        });\n\t      } else if (anchor) {\n\t        Vue.nextTick(function () {\n\t          var el = document.getElementById(anchor.slice(1));\n\t          if (el) {\n\t            window.scrollTo(window.scrollX, el.offsetTop);\n\t          }\n\t        });\n\t      }\n\t    };\n\t\n\t    return Router;\n\t  })();\n\t\n\t  function guardComponent(path, handler) {\n\t    var comp = handler.component;\n\t    if (Vue.util.isPlainObject(comp)) {\n\t      comp = handler.component = Vue.extend(comp);\n\t    }\n\t    /* istanbul ignore if */\n\t    if (typeof comp !== 'function') {\n\t      handler.component = null;\n\t      warn$1('invalid component for route \"' + path + '\".');\n\t    }\n\t  }\n\t\n\t  /* Installation */\n\t\n\t  Router.installed = false;\n\t\n\t  /**\n\t   * Installation interface.\n\t   * Install the necessary directives.\n\t   */\n\t\n\t  Router.install = function (externalVue) {\n\t    /* istanbul ignore if */\n\t    if (Router.installed) {\n\t      warn$1('already installed.');\n\t      return;\n\t    }\n\t    Vue = externalVue;\n\t    applyOverride(Vue);\n\t    View(Vue);\n\t    Link(Vue);\n\t    exports$1.Vue = Vue;\n\t    Router.installed = true;\n\t  };\n\t\n\t  // auto install\n\t  /* istanbul ignore if */\n\t  if (typeof window !== 'undefined' && window.Vue) {\n\t    window.Vue.use(Router);\n\t  }\n\t\n\t  return Router;\n\t\n\t}));\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(20);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(2)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Calendar.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Calendar.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(21);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(2)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Create.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Create.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(22);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(2)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Data.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Data.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(23);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(2)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Header.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Header.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(24);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(2)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Index.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Index.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(25);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(2)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Preview.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Preview.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(26);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(2)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./App.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!./../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./App.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * Vuex v1.0.0-rc.2\n\t * (c) 2016 Evan You\n\t * Released under the MIT License.\n\t */\n\t(function (global, factory) {\n\t   true ? module.exports = factory() :\n\t  typeof define === 'function' && define.amd ? define(factory) :\n\t  (global.Vuex = factory());\n\t}(this, function () { 'use strict';\n\t\n\t  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n\t    return typeof obj;\n\t  } : function (obj) {\n\t    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n\t  };\n\t\n\t  var classCallCheck = function (instance, Constructor) {\n\t    if (!(instance instanceof Constructor)) {\n\t      throw new TypeError(\"Cannot call a class as a function\");\n\t    }\n\t  };\n\t\n\t  var createClass = function () {\n\t    function defineProperties(target, props) {\n\t      for (var i = 0; i < props.length; i++) {\n\t        var descriptor = props[i];\n\t        descriptor.enumerable = descriptor.enumerable || false;\n\t        descriptor.configurable = true;\n\t        if (\"value\" in descriptor) descriptor.writable = true;\n\t        Object.defineProperty(target, descriptor.key, descriptor);\n\t      }\n\t    }\n\t\n\t    return function (Constructor, protoProps, staticProps) {\n\t      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t      if (staticProps) defineProperties(Constructor, staticProps);\n\t      return Constructor;\n\t    };\n\t  }();\n\t\n\t  var toConsumableArray = function (arr) {\n\t    if (Array.isArray(arr)) {\n\t      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\t\n\t      return arr2;\n\t    } else {\n\t      return Array.from(arr);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Merge an array of objects into one.\n\t   *\n\t   * @param {Array<Object>} arr\n\t   * @return {Object}\n\t   */\n\t\n\t  function mergeObjects(arr) {\n\t    return arr.reduce(function (prev, obj) {\n\t      Object.keys(obj).forEach(function (key) {\n\t        var existing = prev[key];\n\t        if (existing) {\n\t          // allow multiple mutation objects to contain duplicate\n\t          // handlers for the same mutation type\n\t          if (Array.isArray(existing)) {\n\t            prev[key] = existing.concat(obj[key]);\n\t          } else {\n\t            prev[key] = [existing].concat(obj[key]);\n\t          }\n\t        } else {\n\t          prev[key] = obj[key];\n\t        }\n\t      });\n\t      return prev;\n\t    }, {});\n\t  }\n\t\n\t  /**\n\t   * Check whether the given value is Object or not\n\t   *\n\t   * @param {*} obj\n\t   * @return {Boolean}\n\t   */\n\t\n\t  function isObject(obj) {\n\t    return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';\n\t  }\n\t\n\t  /**\n\t   * Get state sub tree by given keys.\n\t   *\n\t   * @param {Object} state\n\t   * @param {Array<String>} nestedKeys\n\t   * @return {Object}\n\t   */\n\t  function getNestedState(state, nestedKeys) {\n\t    return nestedKeys.reduce(function (state, key) {\n\t      return state[key];\n\t    }, state);\n\t  }\n\t\n\t  /**\n\t   * Hacks to get access to Vue internals.\n\t   * Maybe we should expose these...\n\t   */\n\t\n\t  var Watcher = void 0;\n\t  function getWatcher(vm) {\n\t    if (!Watcher) {\n\t      var noop = function noop() {};\n\t      var unwatch = vm.$watch(noop, noop);\n\t      Watcher = vm._watchers[0].constructor;\n\t      unwatch();\n\t    }\n\t    return Watcher;\n\t  }\n\t\n\t  var Dep = void 0;\n\t  function getDep(vm) {\n\t    if (!Dep) {\n\t      Dep = vm._data.__ob__.dep.constructor;\n\t    }\n\t    return Dep;\n\t  }\n\t\n\t  var hook = typeof window !== 'undefined' && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\t\n\t  function devtoolPlugin(store) {\n\t    if (!hook) return;\n\t\n\t    hook.emit('vuex:init', store);\n\t\n\t    hook.on('vuex:travel-to-state', function (targetState) {\n\t      store.replaceState(targetState);\n\t    });\n\t\n\t    store.subscribe(function (mutation, state) {\n\t      hook.emit('vuex:mutation', mutation, state);\n\t    });\n\t  }\n\t\n\t  function override (Vue) {\n\t    var version = Number(Vue.version.split('.')[0]);\n\t\n\t    if (version >= 2) {\n\t      var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1;\n\t      Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit });\n\t    } else {\n\t      (function () {\n\t        // override init and inject vuex init procedure\n\t        // for 1.x backwards compatibility.\n\t        var _init = Vue.prototype._init;\n\t        Vue.prototype._init = function () {\n\t          var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t          options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;\n\t          _init.call(this, options);\n\t        };\n\t      })();\n\t    }\n\t\n\t    /**\n\t     * Vuex init hook, injected into each instances init hooks list.\n\t     */\n\t\n\t    function vuexInit() {\n\t      var options = this.$options;\n\t      var store = options.store;\n\t      var vuex = options.vuex;\n\t      // store injection\n\t\n\t      if (store) {\n\t        this.$store = store;\n\t      } else if (options.parent && options.parent.$store) {\n\t        this.$store = options.parent.$store;\n\t      }\n\t      // vuex option handling\n\t      if (vuex) {\n\t        if (!this.$store) {\n\t          console.warn('[vuex] store not injected. make sure to ' + 'provide the store option in your root component.');\n\t        }\n\t        var state = vuex.state;\n\t        var actions = vuex.actions;\n\t        var getters = vuex.getters;\n\t        // handle deprecated state option\n\t\n\t        if (state && !getters) {\n\t          console.warn('[vuex] vuex.state option will been deprecated in 1.0. ' + 'Use vuex.getters instead.');\n\t          getters = state;\n\t        }\n\t        // getters\n\t        if (getters) {\n\t          options.computed = options.computed || {};\n\t          for (var key in getters) {\n\t            defineVuexGetter(this, key, getters[key]);\n\t          }\n\t        }\n\t        // actions\n\t        if (actions) {\n\t          options.methods = options.methods || {};\n\t          for (var _key in actions) {\n\t            options.methods[_key] = makeBoundAction(this.$store, actions[_key], _key);\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Setter for all getter properties.\n\t     */\n\t\n\t    function setter() {\n\t      throw new Error('vuex getter properties are read-only.');\n\t    }\n\t\n\t    /**\n\t     * Define a Vuex getter on an instance.\n\t     *\n\t     * @param {Vue} vm\n\t     * @param {String} key\n\t     * @param {Function} getter\n\t     */\n\t\n\t    function defineVuexGetter(vm, key, getter) {\n\t      if (typeof getter !== 'function') {\n\t        console.warn('[vuex] Getter bound to key \\'vuex.getters.' + key + '\\' is not a function.');\n\t      } else {\n\t        Object.defineProperty(vm, key, {\n\t          enumerable: true,\n\t          configurable: true,\n\t          get: makeComputedGetter(vm.$store, getter),\n\t          set: setter\n\t        });\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Make a computed getter, using the same caching mechanism of computed\n\t     * properties. In addition, it is cached on the raw getter function using\n\t     * the store's unique cache id. This makes the same getter shared\n\t     * across all components use the same underlying watcher, and makes\n\t     * the getter evaluated only once during every flush.\n\t     *\n\t     * @param {Store} store\n\t     * @param {Function} getter\n\t     */\n\t\n\t    function makeComputedGetter(store, getter) {\n\t      var id = store._getterCacheId;\n\t\n\t      // cached\n\t      if (getter[id]) {\n\t        return getter[id];\n\t      }\n\t      var vm = store._vm;\n\t      var Watcher = getWatcher(vm);\n\t      var Dep = getDep(vm);\n\t      var watcher = new Watcher(vm, function (vm) {\n\t        return getter(vm.state);\n\t      }, null, { lazy: true });\n\t      var computedGetter = function computedGetter() {\n\t        if (watcher.dirty) {\n\t          watcher.evaluate();\n\t        }\n\t        if (Dep.target) {\n\t          watcher.depend();\n\t        }\n\t        return watcher.value;\n\t      };\n\t      getter[id] = computedGetter;\n\t      return computedGetter;\n\t    }\n\t\n\t    /**\n\t     * Make a bound-to-store version of a raw action function.\n\t     *\n\t     * @param {Store} store\n\t     * @param {Function} action\n\t     * @param {String} key\n\t     */\n\t\n\t    function makeBoundAction(store, action, key) {\n\t      if (typeof action !== 'function') {\n\t        console.warn('[vuex] Action bound to key \\'vuex.actions.' + key + '\\' is not a function.');\n\t      }\n\t      return function vuexBoundAction() {\n\t        for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n\t          args[_key2] = arguments[_key2];\n\t        }\n\t\n\t        return action.call.apply(action, [this, store].concat(args));\n\t      };\n\t    }\n\t\n\t    // option merging\n\t    var merge = Vue.config.optionMergeStrategies.computed;\n\t    Vue.config.optionMergeStrategies.vuex = function (toVal, fromVal) {\n\t      if (!toVal) return fromVal;\n\t      if (!fromVal) return toVal;\n\t      return {\n\t        getters: merge(toVal.getters, fromVal.getters),\n\t        state: merge(toVal.state, fromVal.state),\n\t        actions: merge(toVal.actions, fromVal.actions)\n\t      };\n\t    };\n\t  }\n\t\n\t  var Vue = void 0;\n\t  var uid = 0;\n\t\n\t  var Store = function () {\n\t\n\t    /**\n\t     * @param {Object} options\n\t     *        - {Object} state\n\t     *        - {Object} actions\n\t     *        - {Object} mutations\n\t     *        - {Array} plugins\n\t     *        - {Boolean} strict\n\t     */\n\t\n\t    function Store() {\n\t      var _this = this;\n\t\n\t      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var _ref$state = _ref.state;\n\t      var state = _ref$state === undefined ? {} : _ref$state;\n\t      var _ref$mutations = _ref.mutations;\n\t      var mutations = _ref$mutations === undefined ? {} : _ref$mutations;\n\t      var _ref$modules = _ref.modules;\n\t      var modules = _ref$modules === undefined ? {} : _ref$modules;\n\t      var _ref$plugins = _ref.plugins;\n\t      var plugins = _ref$plugins === undefined ? [] : _ref$plugins;\n\t      var _ref$strict = _ref.strict;\n\t      var strict = _ref$strict === undefined ? false : _ref$strict;\n\t      classCallCheck(this, Store);\n\t\n\t      this._getterCacheId = 'vuex_store_' + uid++;\n\t      this._dispatching = false;\n\t      this._rootMutations = this._mutations = mutations;\n\t      this._modules = modules;\n\t      this._subscribers = [];\n\t      // bind dispatch to self\n\t      var dispatch = this.dispatch;\n\t      this.dispatch = function () {\n\t        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t          args[_key] = arguments[_key];\n\t        }\n\t\n\t        dispatch.apply(_this, args);\n\t      };\n\t      // use a Vue instance to store the state tree\n\t      // suppress warnings just in case the user has added\n\t      // some funky global mixins\n\t      if (!Vue) {\n\t        throw new Error('[vuex] must call Vue.use(Vuex) before creating a store instance.');\n\t      }\n\t      var silent = Vue.config.silent;\n\t      Vue.config.silent = true;\n\t      this._vm = new Vue({\n\t        data: {\n\t          state: state\n\t        }\n\t      });\n\t      Vue.config.silent = silent;\n\t      this._setupModuleState(state, modules);\n\t      this._setupModuleMutations(modules);\n\t      // add extra warnings in strict mode\n\t      if (strict) {\n\t        this._setupMutationCheck();\n\t      }\n\t      // apply plugins\n\t      devtoolPlugin(this);\n\t      plugins.forEach(function (plugin) {\n\t        return plugin(_this);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Getter for the entire state tree.\n\t     * Read only.\n\t     *\n\t     * @return {Object}\n\t     */\n\t\n\t    createClass(Store, [{\n\t      key: 'replaceState',\n\t\n\t\n\t      /**\n\t       * Replace root state.\n\t       *\n\t       * @param {Object} state\n\t       */\n\t\n\t      value: function replaceState(state) {\n\t        this._dispatching = true;\n\t        this._vm.state = state;\n\t        this._dispatching = false;\n\t      }\n\t\n\t      /**\n\t       * Dispatch an action.\n\t       *\n\t       * @param {String} type\n\t       */\n\t\n\t    }, {\n\t      key: 'dispatch',\n\t      value: function dispatch(type) {\n\t        var _this2 = this;\n\t\n\t        for (var _len2 = arguments.length, payload = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t          payload[_key2 - 1] = arguments[_key2];\n\t        }\n\t\n\t        var silent = false;\n\t        var isObjectStyleDispatch = false;\n\t        // compatibility for object actions, e.g. FSA\n\t        if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type.type && arguments.length === 1) {\n\t          isObjectStyleDispatch = true;\n\t          payload = type;\n\t          if (type.silent) silent = true;\n\t          type = type.type;\n\t        }\n\t        var handler = this._mutations[type];\n\t        var state = this.state;\n\t        if (handler) {\n\t          this._dispatching = true;\n\t          // apply the mutation\n\t          if (Array.isArray(handler)) {\n\t            handler.forEach(function (h) {\n\t              isObjectStyleDispatch ? h(state, payload) : h.apply(undefined, [state].concat(toConsumableArray(payload)));\n\t            });\n\t          } else {\n\t            isObjectStyleDispatch ? handler(state, payload) : handler.apply(undefined, [state].concat(toConsumableArray(payload)));\n\t          }\n\t          this._dispatching = false;\n\t          if (!silent) {\n\t            (function () {\n\t              var mutation = isObjectStyleDispatch ? payload : { type: type, payload: payload };\n\t              _this2._subscribers.forEach(function (sub) {\n\t                return sub(mutation, state);\n\t              });\n\t            })();\n\t          }\n\t        } else {\n\t          console.warn('[vuex] Unknown mutation: ' + type);\n\t        }\n\t      }\n\t\n\t      /**\n\t       * Watch state changes on the store.\n\t       * Same API as Vue's $watch, except when watching a function,\n\t       * the function gets the state as the first argument.\n\t       *\n\t       * @param {Function} fn\n\t       * @param {Function} cb\n\t       * @param {Object} [options]\n\t       */\n\t\n\t    }, {\n\t      key: 'watch',\n\t      value: function watch(fn, cb, options) {\n\t        var _this3 = this;\n\t\n\t        if (typeof fn !== 'function') {\n\t          console.error('Vuex store.watch only accepts function.');\n\t          return;\n\t        }\n\t        return this._vm.$watch(function () {\n\t          return fn(_this3.state);\n\t        }, cb, options);\n\t      }\n\t\n\t      /**\n\t       * Subscribe to state changes. Fires after every mutation.\n\t       */\n\t\n\t    }, {\n\t      key: 'subscribe',\n\t      value: function subscribe(fn) {\n\t        var subs = this._subscribers;\n\t        if (subs.indexOf(fn) < 0) {\n\t          subs.push(fn);\n\t        }\n\t        return function () {\n\t          var i = subs.indexOf(fn);\n\t          if (i > -1) {\n\t            subs.splice(i, 1);\n\t          }\n\t        };\n\t      }\n\t\n\t      /**\n\t       * Hot update mutations & modules.\n\t       *\n\t       * @param {Object} options\n\t       *        - {Object} [mutations]\n\t       *        - {Object} [modules]\n\t       */\n\t\n\t    }, {\n\t      key: 'hotUpdate',\n\t      value: function hotUpdate() {\n\t        var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t        var mutations = _ref2.mutations;\n\t        var modules = _ref2.modules;\n\t\n\t        this._rootMutations = this._mutations = mutations || this._rootMutations;\n\t        this._setupModuleMutations(modules || this._modules);\n\t      }\n\t\n\t      /**\n\t       * Attach sub state tree of each module to the root tree.\n\t       *\n\t       * @param {Object} state\n\t       * @param {Object} modules\n\t       */\n\t\n\t    }, {\n\t      key: '_setupModuleState',\n\t      value: function _setupModuleState(state, modules) {\n\t        var _this4 = this;\n\t\n\t        if (!isObject(modules)) return;\n\t\n\t        Object.keys(modules).forEach(function (key) {\n\t          var module = modules[key];\n\t\n\t          // set this module's state\n\t          Vue.set(state, key, module.state || {});\n\t\n\t          // retrieve nested modules\n\t          _this4._setupModuleState(state[key], module.modules);\n\t        });\n\t      }\n\t\n\t      /**\n\t       * Bind mutations for each module to its sub tree and\n\t       * merge them all into one final mutations map.\n\t       *\n\t       * @param {Object} updatedModules\n\t       */\n\t\n\t    }, {\n\t      key: '_setupModuleMutations',\n\t      value: function _setupModuleMutations(updatedModules) {\n\t        var modules = this._modules;\n\t        Object.keys(updatedModules).forEach(function (key) {\n\t          modules[key] = updatedModules[key];\n\t        });\n\t        var updatedMutations = this._createModuleMutations(modules, []);\n\t        this._mutations = mergeObjects([this._rootMutations].concat(toConsumableArray(updatedMutations)));\n\t      }\n\t\n\t      /**\n\t       * Helper method for _setupModuleMutations.\n\t       * The method retrieve nested sub modules and\n\t       * bind each mutations to its sub tree recursively.\n\t       *\n\t       * @param {Object} modules\n\t       * @param {Array<String>} nestedKeys\n\t       * @return {Array<Object>}\n\t       */\n\t\n\t    }, {\n\t      key: '_createModuleMutations',\n\t      value: function _createModuleMutations(modules, nestedKeys) {\n\t        var _this5 = this;\n\t\n\t        if (!isObject(modules)) return [];\n\t\n\t        return Object.keys(modules).map(function (key) {\n\t          var module = modules[key];\n\t          var newNestedKeys = nestedKeys.concat(key);\n\t\n\t          // retrieve nested modules\n\t          var nestedMutations = _this5._createModuleMutations(module.modules, newNestedKeys);\n\t\n\t          if (!module || !module.mutations) {\n\t            return mergeObjects(nestedMutations);\n\t          }\n\t\n\t          // bind mutations to sub state tree\n\t          var mutations = {};\n\t          Object.keys(module.mutations).forEach(function (name) {\n\t            var original = module.mutations[name];\n\t            mutations[name] = function (state) {\n\t              for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n\t                args[_key3 - 1] = arguments[_key3];\n\t              }\n\t\n\t              original.apply(undefined, [getNestedState(state, newNestedKeys)].concat(args));\n\t            };\n\t          });\n\t\n\t          // merge mutations of this module and nested modules\n\t          return mergeObjects([mutations].concat(toConsumableArray(nestedMutations)));\n\t        });\n\t      }\n\t\n\t      /**\n\t       * Setup mutation check: if the vuex instance's state is mutated\n\t       * outside of a mutation handler, we throw en error. This effectively\n\t       * enforces all mutations to the state to be trackable and hot-reloadble.\n\t       * However, this comes at a run time cost since we are doing a deep\n\t       * watch on the entire state tree, so it is only enalbed with the\n\t       * strict option is set to true.\n\t       */\n\t\n\t    }, {\n\t      key: '_setupMutationCheck',\n\t      value: function _setupMutationCheck() {\n\t        var _this6 = this;\n\t\n\t        var Watcher = getWatcher(this._vm);\n\t        /* eslint-disable no-new */\n\t        new Watcher(this._vm, 'state', function () {\n\t          if (!_this6._dispatching) {\n\t            throw new Error('[vuex] Do not mutate vuex store state outside mutation handlers.');\n\t          }\n\t        }, { deep: true, sync: true });\n\t        /* eslint-enable no-new */\n\t      }\n\t    }, {\n\t      key: 'state',\n\t      get: function get() {\n\t        return this._vm.state;\n\t      },\n\t      set: function set(v) {\n\t        throw new Error('[vuex] Use store.replaceState() to explicit replace store state.');\n\t      }\n\t    }]);\n\t    return Store;\n\t  }();\n\t\n\t  function install(_Vue) {\n\t    if (Vue) {\n\t      console.warn('[vuex] already installed. Vue.use(Vuex) should be called only once.');\n\t      return;\n\t    }\n\t    Vue = _Vue;\n\t    override(Vue);\n\t  }\n\t\n\t  // auto install in dist mode\n\t  if (typeof window !== 'undefined' && window.Vue) {\n\t    install(window.Vue);\n\t  }\n\t\n\t  var index = {\n\t    Store: Store,\n\t    install: install\n\t  };\n\t\n\t  return index;\n\t\n\t}));\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;/* WEBPACK VAR INJECTION */(function(global) {(function (root, factory) {\n\t    if (true) {\n\t        // AMD. Register as an anonymous module.\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof module === 'object' && module.exports) {\n\t        // Node. Does not work with strict CommonJS, but\n\t        // only CommonJS-like environments that support module.exports,\n\t        // like Node.\n\t        module.exports = factory();\n\t    } else {\n\t        // Browser globals (root is window)\n\t        root.echarts = factory();\n\t    }\n\t}(this, function () {var require, define;\n\t(function () {\n\t    var mods = {};\n\t\n\t    define = function (id, deps, factory) {\n\t        mods[id] = {\n\t            id: id,\n\t            deps: deps,\n\t            factory: factory,\n\t            defined: 0,\n\t            exports: {},\n\t            require: createRequire(id)\n\t        };\n\t    };\n\t\n\t    require = createRequire('');\n\t\n\t    function normalize(id, baseId) {\n\t        if (!baseId) {\n\t            return id;\n\t        }\n\t\n\t        if (id.indexOf('.') === 0) {\n\t            var basePath = baseId.split('/');\n\t            var namePath = id.split('/');\n\t            var baseLen = basePath.length - 1;\n\t            var nameLen = namePath.length;\n\t            var cutBaseTerms = 0;\n\t            var cutNameTerms = 0;\n\t\n\t            pathLoop: for (var i = 0; i < nameLen; i++) {\n\t                switch (namePath[i]) {\n\t                    case '..':\n\t                        if (cutBaseTerms < baseLen) {\n\t                            cutBaseTerms++;\n\t                            cutNameTerms++;\n\t                        }\n\t                        else {\n\t                            break pathLoop;\n\t                        }\n\t                        break;\n\t                    case '.':\n\t                        cutNameTerms++;\n\t                        break;\n\t                    default:\n\t                        break pathLoop;\n\t                }\n\t            }\n\t\n\t            basePath.length = baseLen - cutBaseTerms;\n\t            namePath = namePath.slice(cutNameTerms);\n\t\n\t            return basePath.concat(namePath).join('/');\n\t        }\n\t\n\t        return id;\n\t    }\n\t\n\t    function createRequire(baseId) {\n\t        var cacheMods = {};\n\t\n\t        function localRequire(id, callback) {\n\t            if (typeof id === 'string') {\n\t                var exports = cacheMods[id];\n\t                if (!exports) {\n\t                    exports = getModExports(normalize(id, baseId));\n\t                    cacheMods[id] = exports;\n\t                }\n\t\n\t                return exports;\n\t            }\n\t            else if (id instanceof Array) {\n\t                callback = callback || function () {};\n\t                callback.apply(this, getModsExports(id, callback, baseId));\n\t            }\n\t        };\n\t\n\t        return localRequire;\n\t    }\n\t\n\t    function getModsExports(ids, factory, baseId) {\n\t        var es = [];\n\t        var mod = mods[baseId];\n\t\n\t        for (var i = 0, l = Math.min(ids.length, factory.length); i < l; i++) {\n\t            var id = normalize(ids[i], baseId);\n\t            var arg;\n\t            switch (id) {\n\t                case 'require':\n\t                    arg = (mod && mod.require) || require;\n\t                    break;\n\t                case 'exports':\n\t                    arg = mod.exports;\n\t                    break;\n\t                case 'module':\n\t                    arg = mod;\n\t                    break;\n\t                default:\n\t                    arg = getModExports(id);\n\t            }\n\t            es.push(arg);\n\t        }\n\t\n\t        return es;\n\t    }\n\t\n\t    function getModExports(id) {\n\t        var mod = mods[id];\n\t        if (!mod) {\n\t            throw new Error('No ' + id);\n\t        }\n\t\n\t        if (!mod.defined) {\n\t            var factory = mod.factory;\n\t            var factoryReturn = factory.apply(\n\t                this,\n\t                getModsExports(mod.deps || [], factory, id)\n\t            );\n\t            if (typeof factoryReturn !== 'undefined') {\n\t                mod.exports = factoryReturn;\n\t            }\n\t            mod.defined = 1;\n\t        }\n\t\n\t        return mod.exports;\n\t    }\n\t}());\n\tdefine('echarts/chart/pie', ['require', 'zrender/core/util', '../echarts', './pie/PieSeries', './pie/PieView', '../action/createDataSelectAction', '../visual/dataColor', './pie/pieLayout', '../processor/dataFilter'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var echarts = require('../echarts');\n\t    require('./pie/PieSeries');\n\t    require('./pie/PieView');\n\t    require('../action/createDataSelectAction')('pie', [\n\t        {\n\t            type: 'pieToggleSelect',\n\t            event: 'pieselectchanged',\n\t            method: 'toggleSelected'\n\t        },\n\t        {\n\t            type: 'pieSelect',\n\t            event: 'pieselected',\n\t            method: 'select'\n\t        },\n\t        {\n\t            type: 'pieUnSelect',\n\t            event: 'pieunselected',\n\t            method: 'unSelect'\n\t        }\n\t    ]);\n\t    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'pie'));\n\t    echarts.registerLayout(zrUtil.curry(require('./pie/pieLayout'), 'pie'));\n\t    echarts.registerProcessor(zrUtil.curry(require('../processor/dataFilter'), 'pie'));\n\t});\n\tdefine('echarts/chart/bar', ['require', 'zrender/core/util', '../coord/cartesian/Grid', './bar/BarSeries', './bar/BarView', '../layout/barGrid', '../echarts', '../component/grid'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    require('../coord/cartesian/Grid');\n\t    require('./bar/BarSeries');\n\t    require('./bar/BarView');\n\t    var barLayoutGrid = require('../layout/barGrid');\n\t    var echarts = require('../echarts');\n\t    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n\t    // Visual coding for legend\n\t    echarts.registerVisual(function (ecModel) {\n\t        ecModel.eachSeriesByType('bar', function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t            data.setVisual('legendSymbol', 'roundRect');\n\t        });\n\t    });\n\t    // In case developer forget to include grid component\n\t    require('../component/grid');\n\t});\n\tdefine('echarts/component/title', ['require', '../echarts', '../util/graphic', '../util/layout'], function (require) {\n\t    'use strict';\n\t    var echarts = require('../echarts');\n\t    var graphic = require('../util/graphic');\n\t    var layout = require('../util/layout');\n\t    // Model\n\t    echarts.extendComponentModel({\n\t        type: 'title',\n\t        layoutMode: {\n\t            type: 'box',\n\t            ignoreSize: true\n\t        },\n\t        defaultOption: {\n\t            zlevel: 0,\n\t            z: 6,\n\t            show: true,\n\t            text: '',\n\t            target: 'blank',\n\t            subtext: '',\n\t            subtarget: 'blank',\n\t            left: 0,\n\t            top: 0,\n\t            backgroundColor: 'rgba(0,0,0,0)',\n\t            borderColor: '#ccc',\n\t            borderWidth: 0,\n\t            padding: 5,\n\t            itemGap: 10,\n\t            textStyle: {\n\t                fontSize: 18,\n\t                fontWeight: 'bolder',\n\t                color: '#333'\n\t            },\n\t            subtextStyle: { color: '#aaa' }\n\t        }\n\t    });\n\t    // View\n\t    echarts.extendComponentView({\n\t        type: 'title',\n\t        render: function (titleModel, ecModel, api) {\n\t            this.group.removeAll();\n\t            if (!titleModel.get('show')) {\n\t                return;\n\t            }\n\t            var group = this.group;\n\t            var textStyleModel = titleModel.getModel('textStyle');\n\t            var subtextStyleModel = titleModel.getModel('subtextStyle');\n\t            var textAlign = titleModel.get('textAlign');\n\t            var textBaseline = titleModel.get('textBaseline');\n\t            var textEl = new graphic.Text({\n\t                    style: {\n\t                        text: titleModel.get('text'),\n\t                        textFont: textStyleModel.getFont(),\n\t                        fill: textStyleModel.getTextColor()\n\t                    },\n\t                    z2: 10\n\t                });\n\t            var textRect = textEl.getBoundingRect();\n\t            var subText = titleModel.get('subtext');\n\t            var subTextEl = new graphic.Text({\n\t                    style: {\n\t                        text: subText,\n\t                        textFont: subtextStyleModel.getFont(),\n\t                        fill: subtextStyleModel.getTextColor(),\n\t                        y: textRect.height + titleModel.get('itemGap'),\n\t                        textBaseline: 'top'\n\t                    },\n\t                    z2: 10\n\t                });\n\t            var link = titleModel.get('link');\n\t            var sublink = titleModel.get('sublink');\n\t            textEl.silent = !link;\n\t            subTextEl.silent = !sublink;\n\t            if (link) {\n\t                textEl.on('click', function () {\n\t                    window.open(link, '_' + titleModel.get('target'));\n\t                });\n\t            }\n\t            if (sublink) {\n\t                subTextEl.on('click', function () {\n\t                    window.open(sublink, '_' + titleModel.get('subtarget'));\n\t                });\n\t            }\n\t            group.add(textEl);\n\t            subText && group.add(subTextEl);\n\t            // If no subText, but add subTextEl, there will be an empty line.\n\t            var groupRect = group.getBoundingRect();\n\t            var layoutOption = titleModel.getBoxLayoutParams();\n\t            layoutOption.width = groupRect.width;\n\t            layoutOption.height = groupRect.height;\n\t            var layoutRect = layout.getLayoutRect(layoutOption, {\n\t                    width: api.getWidth(),\n\t                    height: api.getHeight()\n\t                }, titleModel.get('padding'));\n\t            // Adjust text align based on position\n\t            if (!textAlign) {\n\t                // Align left if title is on the left. center and right is same\n\t                textAlign = titleModel.get('left') || titleModel.get('right');\n\t                if (textAlign === 'middle') {\n\t                    textAlign = 'center';\n\t                }\n\t                // Adjust layout by text align\n\t                if (textAlign === 'right') {\n\t                    layoutRect.x += layoutRect.width;\n\t                } else if (textAlign === 'center') {\n\t                    layoutRect.x += layoutRect.width / 2;\n\t                }\n\t            }\n\t            if (!textBaseline) {\n\t                textBaseline = titleModel.get('top') || titleModel.get('bottom');\n\t                if (textBaseline === 'center') {\n\t                    textBaseline = 'middle';\n\t                }\n\t                if (textBaseline === 'bottom') {\n\t                    layoutRect.y += layoutRect.height;\n\t                } else if (textBaseline === 'middle') {\n\t                    layoutRect.y += layoutRect.height / 2;\n\t                }\n\t                textBaseline = textBaseline || 'top';\n\t            }\n\t            group.attr('position', [\n\t                layoutRect.x,\n\t                layoutRect.y\n\t            ]);\n\t            var alignStyle = {\n\t                    textAlign: textAlign,\n\t                    textVerticalAlign: textBaseline\n\t                };\n\t            textEl.setStyle(alignStyle);\n\t            subTextEl.setStyle(alignStyle);\n\t            // Render background\n\t            // Get groupRect again because textAlign has been changed\n\t            groupRect = group.getBoundingRect();\n\t            var padding = layoutRect.margin;\n\t            var style = titleModel.getItemStyle([\n\t                    'color',\n\t                    'opacity'\n\t                ]);\n\t            style.fill = titleModel.get('backgroundColor');\n\t            var rect = new graphic.Rect({\n\t                    shape: {\n\t                        x: groupRect.x - padding[3],\n\t                        y: groupRect.y - padding[0],\n\t                        width: groupRect.width + padding[1] + padding[3],\n\t                        height: groupRect.height + padding[0] + padding[2]\n\t                    },\n\t                    style: style,\n\t                    silent: true\n\t                });\n\t            graphic.subPixelOptimizeRect(rect);\n\t            group.add(rect);\n\t        }\n\t    });\n\t});\n\tdefine('echarts/component/grid', ['require', '../util/graphic', 'zrender/core/util', '../echarts', '../coord/cartesian/Grid', './axis'], function (require) {\n\t    'use strict';\n\t    var graphic = require('../util/graphic');\n\t    var zrUtil = require('zrender/core/util');\n\t    var echarts = require('../echarts');\n\t    require('../coord/cartesian/Grid');\n\t    require('./axis');\n\t    // Grid view\n\t    echarts.extendComponentView({\n\t        type: 'grid',\n\t        render: function (gridModel, ecModel) {\n\t            this.group.removeAll();\n\t            if (gridModel.get('show')) {\n\t                this.group.add(new graphic.Rect({\n\t                    shape: gridModel.coordinateSystem.getRect(),\n\t                    style: zrUtil.defaults({ fill: gridModel.get('backgroundColor') }, gridModel.getItemStyle()),\n\t                    silent: true\n\t                }));\n\t            }\n\t        }\n\t    });\n\t    echarts.registerPreprocessor(function (option) {\n\t        // Only create grid when need\n\t        if (option.xAxis && option.yAxis && !option.grid) {\n\t            option.grid = {};\n\t        }\n\t    });\n\t});\n\tdefine('echarts/scale/Time', ['require', 'zrender/core/util', '../util/number', '../util/format', './Interval'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var numberUtil = require('../util/number');\n\t    var formatUtil = require('../util/format');\n\t    var IntervalScale = require('./Interval');\n\t    var intervalScaleProto = IntervalScale.prototype;\n\t    var mathCeil = Math.ceil;\n\t    var mathFloor = Math.floor;\n\t    var ONE_SECOND = 1000;\n\t    var ONE_MINUTE = ONE_SECOND * 60;\n\t    var ONE_HOUR = ONE_MINUTE * 60;\n\t    var ONE_DAY = ONE_HOUR * 24;\n\t    // FIXME 公用？\n\t    var bisect = function (a, x, lo, hi) {\n\t        while (lo < hi) {\n\t            var mid = lo + hi >>> 1;\n\t            if (a[mid][2] < x) {\n\t                lo = mid + 1;\n\t            } else {\n\t                hi = mid;\n\t            }\n\t        }\n\t        return lo;\n\t    };\n\t    /**\n\t     * @alias module:echarts/coord/scale/Time\n\t     * @constructor\n\t     */\n\t    var TimeScale = IntervalScale.extend({\n\t            type: 'time',\n\t            getLabel: function (val) {\n\t                var stepLvl = this._stepLvl;\n\t                var date = new Date(val);\n\t                return formatUtil.formatTime(stepLvl[0], date);\n\t            },\n\t            niceExtent: function (approxTickNum, fixMin, fixMax) {\n\t                var extent = this._extent;\n\t                // If extent start and end are same, expand them\n\t                if (extent[0] === extent[1]) {\n\t                    // Expand extent\n\t                    extent[0] -= ONE_DAY;\n\t                    extent[1] += ONE_DAY;\n\t                }\n\t                // If there are no data and extent are [Infinity, -Infinity]\n\t                if (extent[1] === -Infinity && extent[0] === Infinity) {\n\t                    var d = new Date();\n\t                    extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n\t                    extent[0] = extent[1] - ONE_DAY;\n\t                }\n\t                this.niceTicks(approxTickNum);\n\t                // var extent = this._extent;\n\t                var interval = this._interval;\n\t                if (!fixMin) {\n\t                    extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n\t                }\n\t                if (!fixMax) {\n\t                    extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n\t                }\n\t            },\n\t            niceTicks: function (approxTickNum) {\n\t                approxTickNum = approxTickNum || 10;\n\t                var extent = this._extent;\n\t                var span = extent[1] - extent[0];\n\t                var approxInterval = span / approxTickNum;\n\t                var scaleLevelsLen = scaleLevels.length;\n\t                var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\t                var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n\t                var interval = level[2];\n\t                // Same with interval scale if span is much larger than 1 year\n\t                if (level[0] === 'year') {\n\t                    var yearSpan = span / interval;\n\t                    // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t                    // var niceYearSpan = numberUtil.nice(yearSpan, false);\n\t                    var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\t                    interval *= yearStep;\n\t                }\n\t                var niceExtent = [\n\t                        mathCeil(extent[0] / interval) * interval,\n\t                        mathFloor(extent[1] / interval) * interval\n\t                    ];\n\t                this._stepLvl = level;\n\t                // Interval will be used in getTicks\n\t                this._interval = interval;\n\t                this._niceExtent = niceExtent;\n\t            },\n\t            parse: function (val) {\n\t                // val might be float.\n\t                return +numberUtil.parseDate(val);\n\t            }\n\t        });\n\t    zrUtil.each([\n\t        'contain',\n\t        'normalize'\n\t    ], function (methodName) {\n\t        TimeScale.prototype[methodName] = function (val) {\n\t            return intervalScaleProto[methodName].call(this, this.parse(val));\n\t        };\n\t    });\n\t    // Steps from d3\n\t    var scaleLevels = [\n\t            [\n\t                'hh:mm:ss',\n\t                1,\n\t                ONE_SECOND\n\t            ],\n\t            [\n\t                'hh:mm:ss',\n\t                5,\n\t                ONE_SECOND * 5\n\t            ],\n\t            [\n\t                'hh:mm:ss',\n\t                10,\n\t                ONE_SECOND * 10\n\t            ],\n\t            [\n\t                'hh:mm:ss',\n\t                15,\n\t                ONE_SECOND * 15\n\t            ],\n\t            [\n\t                'hh:mm:ss',\n\t                30,\n\t                ONE_SECOND * 30\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                1,\n\t                ONE_MINUTE\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                5,\n\t                ONE_MINUTE * 5\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                10,\n\t                ONE_MINUTE * 10\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                15,\n\t                ONE_MINUTE * 15\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                30,\n\t                ONE_MINUTE * 30\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                1,\n\t                ONE_HOUR\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                2,\n\t                ONE_HOUR * 2\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                6,\n\t                ONE_HOUR * 6\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                12,\n\t                ONE_HOUR * 12\n\t            ],\n\t            [\n\t                'MM-dd\\nyyyy',\n\t                1,\n\t                ONE_DAY\n\t            ],\n\t            [\n\t                'week',\n\t                7,\n\t                ONE_DAY * 7\n\t            ],\n\t            [\n\t                'month',\n\t                1,\n\t                ONE_DAY * 31\n\t            ],\n\t            [\n\t                'quarter',\n\t                3,\n\t                ONE_DAY * 380 / 4\n\t            ],\n\t            [\n\t                'half-year',\n\t                6,\n\t                ONE_DAY * 380 / 2\n\t            ],\n\t            [\n\t                'year',\n\t                1,\n\t                ONE_DAY * 380\n\t            ]\n\t        ];\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    TimeScale.create = function () {\n\t        return new TimeScale();\n\t    };\n\t    return TimeScale;\n\t});\n\tdefine('echarts/echarts', ['require', 'zrender/core/env', './model/Global', './ExtensionAPI', './CoordinateSystem', './model/OptionManager', './model/Component', './model/Series', './view/Component', './view/Chart', './util/graphic', 'zrender', 'zrender/core/util', 'zrender/tool/color', 'zrender/mixin/Eventful', 'zrender/core/timsort', './visual/seriesColor', './preprocessor/backwardCompat', './loading/default', './data/List', './model/Model', './util/number', './util/format', 'zrender/core/matrix', 'zrender/core/vector'], function (require) {\n\t    var env = require('zrender/core/env');\n\t    var GlobalModel = require('./model/Global');\n\t    var ExtensionAPI = require('./ExtensionAPI');\n\t    var CoordinateSystemManager = require('./CoordinateSystem');\n\t    var OptionManager = require('./model/OptionManager');\n\t    var ComponentModel = require('./model/Component');\n\t    var SeriesModel = require('./model/Series');\n\t    var ComponentView = require('./view/Component');\n\t    var ChartView = require('./view/Chart');\n\t    var graphic = require('./util/graphic');\n\t    var zrender = require('zrender');\n\t    var zrUtil = require('zrender/core/util');\n\t    var colorTool = require('zrender/tool/color');\n\t    var Eventful = require('zrender/mixin/Eventful');\n\t    var timsort = require('zrender/core/timsort');\n\t    var each = zrUtil.each;\n\t    var PRIORITY_PROCESSOR_FILTER = 1000;\n\t    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\t    var PRIORITY_VISUAL_LAYOUT = 1000;\n\t    var PRIORITY_VISUAL_GLOBAL = 2000;\n\t    var PRIORITY_VISUAL_CHART = 3000;\n\t    var PRIORITY_VISUAL_COMPONENT = 4000;\n\t    var PRIORITY_VISUAL_BRUSH = 5000;\n\t    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n\t    // where they must not be invoked nestedly, except the only case: invoke\n\t    // dispatchAction with updateMethod \"none\" in main process.\n\t    // This flag is used to carry out this rule.\n\t    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n\t    var IN_MAIN_PROCESS = '__flag_in_main_process';\n\t    var HAS_GRADIENT_OR_PATTERN_BG = '_hasGradientOrPatternBg';\n\t    var OPTION_UPDATED = '_optionUpdated';\n\t    function createRegisterEventWithLowercaseName(method) {\n\t        return function (eventName, handler, context) {\n\t            // Event name is all lowercase\n\t            eventName = eventName && eventName.toLowerCase();\n\t            Eventful.prototype[method].call(this, eventName, handler, context);\n\t        };\n\t    }\n\t    /**\n\t     * @module echarts~MessageCenter\n\t     */\n\t    function MessageCenter() {\n\t        Eventful.call(this);\n\t    }\n\t    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n\t    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n\t    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n\t    zrUtil.mixin(MessageCenter, Eventful);\n\t    /**\n\t     * @module echarts~ECharts\n\t     */\n\t    function ECharts(dom, theme, opts) {\n\t        opts = opts || {};\n\t        // Get theme by name\n\t        if (typeof theme === 'string') {\n\t            theme = themeStorage[theme];\n\t        }\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id;\n\t        /**\n\t         * Group id\n\t         * @type {string}\n\t         */\n\t        this.group;\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         * @private\n\t         */\n\t        this._dom = dom;\n\t        /**\n\t         * @type {module:zrender/ZRender}\n\t         * @private\n\t         */\n\t        this._zr = zrender.init(dom, {\n\t            renderer: opts.renderer || 'canvas',\n\t            devicePixelRatio: opts.devicePixelRatio\n\t        });\n\t        /**\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._theme = zrUtil.clone(theme);\n\t        /**\n\t         * @type {Array.<module:echarts/view/Chart>}\n\t         * @private\n\t         */\n\t        this._chartsViews = [];\n\t        /**\n\t         * @type {Object.<string, module:echarts/view/Chart>}\n\t         * @private\n\t         */\n\t        this._chartsMap = {};\n\t        /**\n\t         * @type {Array.<module:echarts/view/Component>}\n\t         * @private\n\t         */\n\t        this._componentsViews = [];\n\t        /**\n\t         * @type {Object.<string, module:echarts/view/Component>}\n\t         * @private\n\t         */\n\t        this._componentsMap = {};\n\t        /**\n\t         * @type {module:echarts/ExtensionAPI}\n\t         * @private\n\t         */\n\t        this._api = new ExtensionAPI(this);\n\t        /**\n\t         * @type {module:echarts/CoordinateSystem}\n\t         * @private\n\t         */\n\t        this._coordSysMgr = new CoordinateSystemManager();\n\t        Eventful.call(this);\n\t        /**\n\t         * @type {module:echarts~MessageCenter}\n\t         * @private\n\t         */\n\t        this._messageCenter = new MessageCenter();\n\t        // Init mouse events\n\t        this._initEvents();\n\t        // In case some people write `window.onresize = chart.resize`\n\t        this.resize = zrUtil.bind(this.resize, this);\n\t        // Can't dispatch action during rendering procedure\n\t        this._pendingActions = [];\n\t        // Sort on demand\n\t        function prioritySortFunc(a, b) {\n\t            return a.prio - b.prio;\n\t        }\n\t        timsort(visualFuncs, prioritySortFunc);\n\t        timsort(dataProcessorFuncs, prioritySortFunc);\n\t        this._zr.animation.on('frame', this._onframe, this);\n\t    }\n\t    var echartsProto = ECharts.prototype;\n\t    echartsProto._onframe = function () {\n\t        // Lazy update\n\t        if (this[OPTION_UPDATED]) {\n\t            this[IN_MAIN_PROCESS] = true;\n\t            updateMethods.prepareAndUpdate.call(this);\n\t            this[IN_MAIN_PROCESS] = false;\n\t            this[OPTION_UPDATED] = false;\n\t        }\n\t    };\n\t    /**\n\t     * @return {HTMLDomElement}\n\t     */\n\t    echartsProto.getDom = function () {\n\t        return this._dom;\n\t    };\n\t    /**\n\t     * @return {module:zrender~ZRender}\n\t     */\n\t    echartsProto.getZr = function () {\n\t        return this._zr;\n\t    };\n\t    /**\n\t     * @param {Object} option\n\t     * @param {boolean} notMerge\n\t     * @param {boolean} [lazyUpdate=false] Useful when setOption frequently.\n\t     */\n\t    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n\t        if (true) {\n\t            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n\t        }\n\t        this[IN_MAIN_PROCESS] = true;\n\t        if (!this._model || notMerge) {\n\t            var optionManager = new OptionManager(this._api);\n\t            var theme = this._theme;\n\t            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n\t            ecModel.init(null, null, theme, optionManager);\n\t        }\n\t        this._model.setOption(option, optionPreprocessorFuncs);\n\t        if (lazyUpdate) {\n\t            this[OPTION_UPDATED] = true;\n\t        } else {\n\t            updateMethods.prepareAndUpdate.call(this);\n\t            this._zr.refreshImmediately();\n\t            this[OPTION_UPDATED] = false;\n\t        }\n\t        this[IN_MAIN_PROCESS] = false;\n\t        this._flushPendingActions();\n\t    };\n\t    /**\n\t     * @DEPRECATED\n\t     */\n\t    echartsProto.setTheme = function () {\n\t        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n\t    };\n\t    /**\n\t     * @return {module:echarts/model/Global}\n\t     */\n\t    echartsProto.getModel = function () {\n\t        return this._model;\n\t    };\n\t    /**\n\t     * @return {Object}\n\t     */\n\t    echartsProto.getOption = function () {\n\t        return this._model && this._model.getOption();\n\t    };\n\t    /**\n\t     * @return {number}\n\t     */\n\t    echartsProto.getWidth = function () {\n\t        return this._zr.getWidth();\n\t    };\n\t    /**\n\t     * @return {number}\n\t     */\n\t    echartsProto.getHeight = function () {\n\t        return this._zr.getHeight();\n\t    };\n\t    /**\n\t     * Get canvas which has all thing rendered\n\t     * @param {Object} opts\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getRenderedCanvas = function (opts) {\n\t        if (!env.canvasSupported) {\n\t            return;\n\t        }\n\t        opts = opts || {};\n\t        opts.pixelRatio = opts.pixelRatio || 1;\n\t        opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');\n\t        var zr = this._zr;\n\t        var list = zr.storage.getDisplayList();\n\t        // Stop animations\n\t        zrUtil.each(list, function (el) {\n\t            el.stopAnimation(true);\n\t        });\n\t        return zr.painter.getRenderedCanvas(opts);\n\t    };\n\t    /**\n\t     * @return {string}\n\t     * @param {Object} opts\n\t     * @param {string} [opts.type='png']\n\t     * @param {string} [opts.pixelRatio=1]\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getDataURL = function (opts) {\n\t        opts = opts || {};\n\t        var excludeComponents = opts.excludeComponents;\n\t        var ecModel = this._model;\n\t        var excludesComponentViews = [];\n\t        var self = this;\n\t        each(excludeComponents, function (componentType) {\n\t            ecModel.eachComponent({ mainType: componentType }, function (component) {\n\t                var view = self._componentsMap[component.__viewId];\n\t                if (!view.group.ignore) {\n\t                    excludesComponentViews.push(view);\n\t                    view.group.ignore = true;\n\t                }\n\t            });\n\t        });\n\t        var url = this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));\n\t        each(excludesComponentViews, function (view) {\n\t            view.group.ignore = false;\n\t        });\n\t        return url;\n\t    };\n\t    /**\n\t     * @return {string}\n\t     * @param {Object} opts\n\t     * @param {string} [opts.type='png']\n\t     * @param {string} [opts.pixelRatio=1]\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getConnectedDataURL = function (opts) {\n\t        if (!env.canvasSupported) {\n\t            return;\n\t        }\n\t        var groupId = this.group;\n\t        var mathMin = Math.min;\n\t        var mathMax = Math.max;\n\t        var MAX_NUMBER = Infinity;\n\t        if (connectedGroups[groupId]) {\n\t            var left = MAX_NUMBER;\n\t            var top = MAX_NUMBER;\n\t            var right = -MAX_NUMBER;\n\t            var bottom = -MAX_NUMBER;\n\t            var canvasList = [];\n\t            var dpr = opts && opts.pixelRatio || 1;\n\t            for (var id in instances) {\n\t                var chart = instances[id];\n\t                if (chart.group === groupId) {\n\t                    var canvas = chart.getRenderedCanvas(zrUtil.clone(opts));\n\t                    var boundingRect = chart.getDom().getBoundingClientRect();\n\t                    left = mathMin(boundingRect.left, left);\n\t                    top = mathMin(boundingRect.top, top);\n\t                    right = mathMax(boundingRect.right, right);\n\t                    bottom = mathMax(boundingRect.bottom, bottom);\n\t                    canvasList.push({\n\t                        dom: canvas,\n\t                        left: boundingRect.left,\n\t                        top: boundingRect.top\n\t                    });\n\t                }\n\t            }\n\t            left *= dpr;\n\t            top *= dpr;\n\t            right *= dpr;\n\t            bottom *= dpr;\n\t            var width = right - left;\n\t            var height = bottom - top;\n\t            var targetCanvas = zrUtil.createCanvas();\n\t            targetCanvas.width = width;\n\t            targetCanvas.height = height;\n\t            var zr = zrender.init(targetCanvas);\n\t            each(canvasList, function (item) {\n\t                var img = new graphic.Image({\n\t                        style: {\n\t                            x: item.left * dpr - left,\n\t                            y: item.top * dpr - top,\n\t                            image: item.dom\n\t                        }\n\t                    });\n\t                zr.add(img);\n\t            });\n\t            zr.refreshImmediately();\n\t            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n\t        } else {\n\t            return this.getDataURL(opts);\n\t        }\n\t    };\n\t    var updateMethods = {\n\t            update: function (payload) {\n\t                // console.time && console.time('update');\n\t                var ecModel = this._model;\n\t                var api = this._api;\n\t                var coordSysMgr = this._coordSysMgr;\n\t                var zr = this._zr;\n\t                // update before setOption\n\t                if (!ecModel) {\n\t                    return;\n\t                }\n\t                // Fixme First time update ?\n\t                ecModel.restoreData();\n\t                // TODO\n\t                // Save total ecModel here for undo/redo (after restoring data and before processing data).\n\t                // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\t                // Create new coordinate system each update\n\t                // In LineView may save the old coordinate system and use it to get the orignal point\n\t                coordSysMgr.create(this._model, this._api);\n\t                processData.call(this, ecModel, api);\n\t                stackSeriesData.call(this, ecModel);\n\t                coordSysMgr.update(ecModel, api);\n\t                doVisualEncoding.call(this, ecModel, payload);\n\t                doRender.call(this, ecModel, payload);\n\t                // Set background\n\t                var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\t                var painter = zr.painter;\n\t                // TODO all use clearColor ?\n\t                if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n\t                    zr.configLayer(0, { clearColor: backgroundColor });\n\t                } else {\n\t                    // In IE8\n\t                    if (!env.canvasSupported) {\n\t                        var colorArr = colorTool.parse(backgroundColor);\n\t                        backgroundColor = colorTool.stringify(colorArr, 'rgb');\n\t                        if (colorArr[3] === 0) {\n\t                            backgroundColor = 'transparent';\n\t                        }\n\t                    }\n\t                    if (backgroundColor.colorStops || backgroundColor.image) {\n\t                        // Gradient background\n\t                        // FIXME Fixed layer？\n\t                        zr.configLayer(0, { clearColor: backgroundColor });\n\t                        this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\t                        this._dom.style.background = 'transparent';\n\t                    } else {\n\t                        if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n\t                            zr.configLayer(0, { clearColor: null });\n\t                        }\n\t                        this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\t                        this._dom.style.background = backgroundColor;\n\t                    }\n\t                }    // console.time && console.timeEnd('update');\n\t            },\n\t            updateView: function (payload) {\n\t                var ecModel = this._model;\n\t                // update before setOption\n\t                if (!ecModel) {\n\t                    return;\n\t                }\n\t                ecModel.eachSeries(function (seriesModel) {\n\t                    seriesModel.getData().clearAllVisual();\n\t                });\n\t                doVisualEncoding.call(this, ecModel, payload);\n\t                invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n\t            },\n\t            updateVisual: function (payload) {\n\t                var ecModel = this._model;\n\t                // update before setOption\n\t                if (!ecModel) {\n\t                    return;\n\t                }\n\t                ecModel.eachSeries(function (seriesModel) {\n\t                    seriesModel.getData().clearAllVisual();\n\t                });\n\t                doVisualEncoding.call(this, ecModel, payload);\n\t                invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n\t            },\n\t            updateLayout: function (payload) {\n\t                var ecModel = this._model;\n\t                // update before setOption\n\t                if (!ecModel) {\n\t                    return;\n\t                }\n\t                doLayout.call(this, ecModel, payload);\n\t                invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n\t            },\n\t            highlight: function (payload) {\n\t                toggleHighlight.call(this, 'highlight', payload);\n\t            },\n\t            downplay: function (payload) {\n\t                toggleHighlight.call(this, 'downplay', payload);\n\t            },\n\t            prepareAndUpdate: function (payload) {\n\t                var ecModel = this._model;\n\t                prepareView.call(this, 'component', ecModel);\n\t                prepareView.call(this, 'chart', ecModel);\n\t                updateMethods.update.call(this, payload);\n\t            }\n\t        };\n\t    /**\n\t     * @param {Object} payload\n\t     * @private\n\t     */\n\t    function toggleHighlight(method, payload) {\n\t        var ecModel = this._model;\n\t        // dispatchAction before setOption\n\t        if (!ecModel) {\n\t            return;\n\t        }\n\t        ecModel.eachComponent({\n\t            mainType: 'series',\n\t            query: payload\n\t        }, function (seriesModel, index) {\n\t            var chartView = this._chartsMap[seriesModel.__viewId];\n\t            if (chartView && chartView.__alive) {\n\t                chartView[method](seriesModel, ecModel, this._api, payload);\n\t            }\n\t        }, this);\n\t    }\n\t    /**\n\t     * Resize the chart\n\t     */\n\t    echartsProto.resize = function () {\n\t        if (true) {\n\t            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n\t        }\n\t        this[IN_MAIN_PROCESS] = true;\n\t        this._zr.resize();\n\t        var optionChanged = this._model && this._model.resetOption('media');\n\t        updateMethods[optionChanged ? 'prepareAndUpdate' : 'update'].call(this);\n\t        // Resize loading effect\n\t        this._loadingFX && this._loadingFX.resize();\n\t        this[IN_MAIN_PROCESS] = false;\n\t        this._flushPendingActions();\n\t    };\n\t    /**\n\t     * Show loading effect\n\t     * @param  {string} [name='default']\n\t     * @param  {Object} [cfg]\n\t     */\n\t    echartsProto.showLoading = function (name, cfg) {\n\t        if (zrUtil.isObject(name)) {\n\t            cfg = name;\n\t            name = '';\n\t        }\n\t        name = name || 'default';\n\t        this.hideLoading();\n\t        if (!loadingEffects[name]) {\n\t            if (true) {\n\t                console.warn('Loading effects ' + name + ' not exists.');\n\t            }\n\t            return;\n\t        }\n\t        var el = loadingEffects[name](this._api, cfg);\n\t        var zr = this._zr;\n\t        this._loadingFX = el;\n\t        zr.add(el);\n\t    };\n\t    /**\n\t     * Hide loading effect\n\t     */\n\t    echartsProto.hideLoading = function () {\n\t        this._loadingFX && this._zr.remove(this._loadingFX);\n\t        this._loadingFX = null;\n\t    };\n\t    /**\n\t     * @param {Object} eventObj\n\t     * @return {Object}\n\t     */\n\t    echartsProto.makeActionFromEvent = function (eventObj) {\n\t        var payload = zrUtil.extend({}, eventObj);\n\t        payload.type = eventActionMap[eventObj.type];\n\t        return payload;\n\t    };\n\t    /**\n\t     * @pubilc\n\t     * @param {Object} payload\n\t     * @param {string} [payload.type] Action type\n\t     * @param {boolean} [silent=false] Whether trigger event.\n\t     */\n\t    echartsProto.dispatchAction = function (payload, silent) {\n\t        var actionWrap = actions[payload.type];\n\t        if (!actionWrap) {\n\t            return;\n\t        }\n\t        var actionInfo = actionWrap.actionInfo;\n\t        var updateMethod = actionInfo.update || 'update';\n\t        // if (__DEV__) {\n\t        //     zrUtil.assert(\n\t        //         !this[IN_MAIN_PROCESS],\n\t        //         '`dispatchAction` should not be called during main process.'\n\t        //         + 'unless updateMathod is \"none\".'\n\t        //     );\n\t        // }\n\t        // May dispatchAction in rendering procedure\n\t        if (this[IN_MAIN_PROCESS]) {\n\t            this._pendingActions.push(payload);\n\t            return;\n\t        }\n\t        this[IN_MAIN_PROCESS] = true;\n\t        var payloads = [payload];\n\t        var batched = false;\n\t        // Batch action\n\t        if (payload.batch) {\n\t            batched = true;\n\t            payloads = zrUtil.map(payload.batch, function (item) {\n\t                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n\t                item.batch = null;\n\t                return item;\n\t            });\n\t        }\n\t        var eventObjBatch = [];\n\t        var eventObj;\n\t        var isHighlightOrDownplay = payload.type === 'highlight' || payload.type === 'downplay';\n\t        for (var i = 0; i < payloads.length; i++) {\n\t            var batchItem = payloads[i];\n\t            // Action can specify the event by return it.\n\t            eventObj = actionWrap.action(batchItem, this._model);\n\t            // Emit event outside\n\t            eventObj = eventObj || zrUtil.extend({}, batchItem);\n\t            // Convert type to eventType\n\t            eventObj.type = actionInfo.event || eventObj.type;\n\t            eventObjBatch.push(eventObj);\n\t            // Highlight and downplay are special.\n\t            isHighlightOrDownplay && updateMethods[updateMethod].call(this, batchItem);\n\t        }\n\t        if (updateMethod !== 'none' && !isHighlightOrDownplay) {\n\t            // Still dirty\n\t            if (this[OPTION_UPDATED]) {\n\t                // FIXME Pass payload ?\n\t                updateMethods.prepareAndUpdate.call(this, payload);\n\t                this[OPTION_UPDATED] = false;\n\t            } else {\n\t                updateMethods[updateMethod].call(this, payload);\n\t            }\n\t        }\n\t        // Follow the rule of action batch\n\t        if (batched) {\n\t            eventObj = {\n\t                type: actionInfo.event || payload.type,\n\t                batch: eventObjBatch\n\t            };\n\t        } else {\n\t            eventObj = eventObjBatch[0];\n\t        }\n\t        this[IN_MAIN_PROCESS] = false;\n\t        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n\t        this._flushPendingActions();\n\t    };\n\t    echartsProto._flushPendingActions = function () {\n\t        var pendingActions = this._pendingActions;\n\t        while (pendingActions.length) {\n\t            var payload = pendingActions.shift();\n\t            this.dispatchAction(payload);\n\t        }\n\t    };\n\t    /**\n\t     * Register event\n\t     * @method\n\t     */\n\t    echartsProto.on = createRegisterEventWithLowercaseName('on');\n\t    echartsProto.off = createRegisterEventWithLowercaseName('off');\n\t    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\t    /**\n\t     * @param {string} methodName\n\t     * @private\n\t     */\n\t    function invokeUpdateMethod(methodName, ecModel, payload) {\n\t        var api = this._api;\n\t        // Update all components\n\t        each(this._componentsViews, function (component) {\n\t            var componentModel = component.__model;\n\t            component[methodName](componentModel, ecModel, api, payload);\n\t            updateZ(componentModel, component);\n\t        }, this);\n\t        // Upate all charts\n\t        ecModel.eachSeries(function (seriesModel, idx) {\n\t            var chart = this._chartsMap[seriesModel.__viewId];\n\t            chart[methodName](seriesModel, ecModel, api, payload);\n\t            updateZ(seriesModel, chart);\n\t            updateProgressiveAndBlend(seriesModel, chart);\n\t        }, this);\n\t        // If use hover layer\n\t        updateHoverLayerStatus(this._zr, ecModel);\n\t    }\n\t    /**\n\t     * Prepare view instances of charts and components\n\t     * @param  {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function prepareView(type, ecModel) {\n\t        var isComponent = type === 'component';\n\t        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n\t        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n\t        var zr = this._zr;\n\t        for (var i = 0; i < viewList.length; i++) {\n\t            viewList[i].__alive = false;\n\t        }\n\t        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n\t            if (isComponent) {\n\t                if (componentType === 'series') {\n\t                    return;\n\t                }\n\t            } else {\n\t                model = componentType;\n\t            }\n\t            // Consider: id same and type changed.\n\t            var viewId = model.id + '_' + model.type;\n\t            var view = viewMap[viewId];\n\t            if (!view) {\n\t                var classType = ComponentModel.parseClassType(model.type);\n\t                var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);\n\t                if (Clazz) {\n\t                    view = new Clazz();\n\t                    view.init(ecModel, this._api);\n\t                    viewMap[viewId] = view;\n\t                    viewList.push(view);\n\t                    zr.add(view.group);\n\t                } else {\n\t                    // Error\n\t                    return;\n\t                }\n\t            }\n\t            model.__viewId = viewId;\n\t            view.__alive = true;\n\t            view.__id = viewId;\n\t            view.__model = model;\n\t        }, this);\n\t        for (var i = 0; i < viewList.length;) {\n\t            var view = viewList[i];\n\t            if (!view.__alive) {\n\t                zr.remove(view.group);\n\t                view.dispose(ecModel, this._api);\n\t                viewList.splice(i, 1);\n\t                delete viewMap[view.__id];\n\t            } else {\n\t                i++;\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * Processor data in each series\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function processData(ecModel, api) {\n\t        each(dataProcessorFuncs, function (process) {\n\t            process.func(ecModel, api);\n\t        });\n\t    }\n\t    /**\n\t     * @private\n\t     */\n\t    function stackSeriesData(ecModel) {\n\t        var stackedDataMap = {};\n\t        ecModel.eachSeries(function (series) {\n\t            var stack = series.get('stack');\n\t            var data = series.getData();\n\t            if (stack && data.type === 'list') {\n\t                var previousStack = stackedDataMap[stack];\n\t                if (previousStack) {\n\t                    data.stackedOn = previousStack;\n\t                }\n\t                stackedDataMap[stack] = data;\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * Layout before each chart render there series, special visual encoding stage\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function doLayout(ecModel, payload) {\n\t        var api = this._api;\n\t        each(visualFuncs, function (visual) {\n\t            if (visual.isLayout) {\n\t                visual.func(ecModel, api, payload);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * Encode visual infomation from data after data processing\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function doVisualEncoding(ecModel, payload) {\n\t        var api = this._api;\n\t        ecModel.clearColorPalette();\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            seriesModel.clearColorPalette();\n\t        });\n\t        each(visualFuncs, function (visual) {\n\t            visual.func(ecModel, api, payload);\n\t        });\n\t    }\n\t    /**\n\t     * Render each chart and component\n\t     * @private\n\t     */\n\t    function doRender(ecModel, payload) {\n\t        var api = this._api;\n\t        // Render all components\n\t        each(this._componentsViews, function (componentView) {\n\t            var componentModel = componentView.__model;\n\t            componentView.render(componentModel, ecModel, api, payload);\n\t            updateZ(componentModel, componentView);\n\t        }, this);\n\t        each(this._chartsViews, function (chart) {\n\t            chart.__alive = false;\n\t        }, this);\n\t        // Render all charts\n\t        ecModel.eachSeries(function (seriesModel, idx) {\n\t            var chartView = this._chartsMap[seriesModel.__viewId];\n\t            chartView.__alive = true;\n\t            chartView.render(seriesModel, ecModel, api, payload);\n\t            chartView.group.silent = !!seriesModel.get('silent');\n\t            updateZ(seriesModel, chartView);\n\t            updateProgressiveAndBlend(seriesModel, chartView);\n\t        }, this);\n\t        // If use hover layer\n\t        updateHoverLayerStatus(this._zr, ecModel);\n\t        // Remove groups of unrendered charts\n\t        each(this._chartsViews, function (chart) {\n\t            if (!chart.__alive) {\n\t                chart.remove(ecModel, api);\n\t            }\n\t        }, this);\n\t    }\n\t    var MOUSE_EVENT_NAMES = [\n\t            'click',\n\t            'dblclick',\n\t            'mouseover',\n\t            'mouseout',\n\t            'mousemove',\n\t            'mousedown',\n\t            'mouseup',\n\t            'globalout'\n\t        ];\n\t    /**\n\t     * @private\n\t     */\n\t    echartsProto._initEvents = function () {\n\t        each(MOUSE_EVENT_NAMES, function (eveName) {\n\t            this._zr.on(eveName, function (e) {\n\t                var ecModel = this.getModel();\n\t                var el = e.target;\n\t                if (el && el.dataIndex != null) {\n\t                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n\t                    var params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n\t                    params.event = e;\n\t                    params.type = eveName;\n\t                    this.trigger(eveName, params);\n\t                }    // If element has custom eventData of components\n\t                else if (el && el.eventData) {\n\t                    this.trigger(eveName, el.eventData);\n\t                }\n\t            }, this);\n\t        }, this);\n\t        each(eventActionMap, function (actionType, eventType) {\n\t            this._messageCenter.on(eventType, function (event) {\n\t                this.trigger(eventType, event);\n\t            }, this);\n\t        }, this);\n\t    };\n\t    /**\n\t     * @return {boolean}\n\t     */\n\t    echartsProto.isDisposed = function () {\n\t        return this._disposed;\n\t    };\n\t    /**\n\t     * Clear\n\t     */\n\t    echartsProto.clear = function () {\n\t        this.setOption({ series: [] }, true);\n\t    };\n\t    /**\n\t     * Dispose instance\n\t     */\n\t    echartsProto.dispose = function () {\n\t        if (this._disposed) {\n\t            if (true) {\n\t                console.warn('Instance ' + this.id + ' has been disposed');\n\t            }\n\t            return;\n\t        }\n\t        this._disposed = true;\n\t        var api = this._api;\n\t        var ecModel = this._model;\n\t        each(this._componentsViews, function (component) {\n\t            component.dispose(ecModel, api);\n\t        });\n\t        each(this._chartsViews, function (chart) {\n\t            chart.dispose(ecModel, api);\n\t        });\n\t        // Dispose after all views disposed\n\t        this._zr.dispose();\n\t        delete instances[this.id];\n\t    };\n\t    zrUtil.mixin(ECharts, Eventful);\n\t    function updateHoverLayerStatus(zr, ecModel) {\n\t        var storage = zr.storage;\n\t        var elCount = 0;\n\t        storage.traverse(function (el) {\n\t            if (!el.isGroup) {\n\t                elCount++;\n\t            }\n\t        });\n\t        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n\t            storage.traverse(function (el) {\n\t                if (!el.isGroup) {\n\t                    el.useHoverLayer = true;\n\t                }\n\t            });\n\t        }\n\t    }\n\t    /**\n\t     * Update chart progressive and blend.\n\t     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n\t     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n\t     */\n\t    function updateProgressiveAndBlend(seriesModel, chartView) {\n\t        // Progressive configuration\n\t        var elCount = 0;\n\t        chartView.group.traverse(function (el) {\n\t            if (el.type !== 'group' && !el.ignore) {\n\t                elCount++;\n\t            }\n\t        });\n\t        var frameDrawNum = +seriesModel.get('progressive');\n\t        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n\t        if (needProgressive) {\n\t            chartView.group.traverse(function (el) {\n\t                // FIXME marker and other components\n\t                if (!el.isGroup) {\n\t                    el.progressive = needProgressive ? Math.floor(elCount++ / frameDrawNum) : -1;\n\t                    if (needProgressive) {\n\t                        el.stopAnimation(true);\n\t                    }\n\t                }\n\t            });\n\t        }\n\t        // Blend configration\n\t        var blendMode = seriesModel.get('blendMode') || null;\n\t        if (true) {\n\t            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n\t                console.warn('Only canvas support blendMode');\n\t            }\n\t        }\n\t        chartView.group.traverse(function (el) {\n\t            // FIXME marker and other components\n\t            if (!el.isGroup) {\n\t                el.setStyle('blend', blendMode);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n\t     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n\t     */\n\t    function updateZ(model, view) {\n\t        var z = model.get('z');\n\t        var zlevel = model.get('zlevel');\n\t        // Set z and zlevel\n\t        view.group.traverse(function (el) {\n\t            if (el.type !== 'group') {\n\t                z != null && (el.z = z);\n\t                zlevel != null && (el.zlevel = zlevel);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * @type {Array.<Function>}\n\t     * @inner\n\t     */\n\t    var actions = [];\n\t    /**\n\t     * Map eventType to actionType\n\t     * @type {Object}\n\t     */\n\t    var eventActionMap = {};\n\t    /**\n\t     * Data processor functions of each stage\n\t     * @type {Array.<Object.<string, Function>>}\n\t     * @inner\n\t     */\n\t    var dataProcessorFuncs = [];\n\t    /**\n\t     * @type {Array.<Function>}\n\t     * @inner\n\t     */\n\t    var optionPreprocessorFuncs = [];\n\t    /**\n\t     * Visual encoding functions of each stage\n\t     * @type {Array.<Object.<string, Function>>}\n\t     * @inner\n\t     */\n\t    var visualFuncs = [];\n\t    /**\n\t     * Theme storage\n\t     * @type {Object.<key, Object>}\n\t     */\n\t    var themeStorage = {};\n\t    /**\n\t     * Loading effects\n\t     */\n\t    var loadingEffects = {};\n\t    var instances = {};\n\t    var connectedGroups = {};\n\t    var idBase = new Date() - 0;\n\t    var groupIdBase = new Date() - 0;\n\t    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n\t    /**\n\t     * @alias module:echarts\n\t     */\n\t    var echarts = {\n\t            version: '3.2.3',\n\t            dependencies: { zrender: '3.1.3' }\n\t        };\n\t    function enableConnect(chart) {\n\t        var STATUS_PENDING = 0;\n\t        var STATUS_UPDATING = 1;\n\t        var STATUS_UPDATED = 2;\n\t        var STATUS_KEY = '__connectUpdateStatus';\n\t        function updateConnectedChartsStatus(charts, status) {\n\t            for (var i = 0; i < charts.length; i++) {\n\t                var otherChart = charts[i];\n\t                otherChart[STATUS_KEY] = status;\n\t            }\n\t        }\n\t        zrUtil.each(eventActionMap, function (actionType, eventType) {\n\t            chart._messageCenter.on(eventType, function (event) {\n\t                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n\t                    var action = chart.makeActionFromEvent(event);\n\t                    var otherCharts = [];\n\t                    for (var id in instances) {\n\t                        var otherChart = instances[id];\n\t                        if (otherChart !== chart && otherChart.group === chart.group) {\n\t                            otherCharts.push(otherChart);\n\t                        }\n\t                    }\n\t                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n\t                    each(otherCharts, function (otherChart) {\n\t                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n\t                            otherChart.dispatchAction(action);\n\t                        }\n\t                    });\n\t                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n\t                }\n\t            });\n\t        });\n\t    }\n\t    /**\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} [theme]\n\t     * @param {Object} opts\n\t     */\n\t    echarts.init = function (dom, theme, opts) {\n\t        if (true) {\n\t            // Check version\n\t            if (zrender.version.replace('.', '') - 0 < echarts.dependencies.zrender.replace('.', '') - 0) {\n\t                throw new Error('ZRender ' + zrender.version + ' is too old for ECharts ' + echarts.version + '. Current version need ZRender ' + echarts.dependencies.zrender + '+');\n\t            }\n\t            if (!dom) {\n\t                throw new Error('Initialize failed: invalid dom.');\n\t            }\n\t            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {\n\t                console.warn('Can\\'t get dom width or height');\n\t            }\n\t        }\n\t        var chart = new ECharts(dom, theme, opts);\n\t        chart.id = 'ec_' + idBase++;\n\t        instances[chart.id] = chart;\n\t        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n\t        enableConnect(chart);\n\t        return chart;\n\t    };\n\t    /**\n\t     * @return {string|Array.<module:echarts~ECharts>} groupId\n\t     */\n\t    echarts.connect = function (groupId) {\n\t        // Is array of charts\n\t        if (zrUtil.isArray(groupId)) {\n\t            var charts = groupId;\n\t            groupId = null;\n\t            // If any chart has group\n\t            zrUtil.each(charts, function (chart) {\n\t                if (chart.group != null) {\n\t                    groupId = chart.group;\n\t                }\n\t            });\n\t            groupId = groupId || 'g_' + groupIdBase++;\n\t            zrUtil.each(charts, function (chart) {\n\t                chart.group = groupId;\n\t            });\n\t        }\n\t        connectedGroups[groupId] = true;\n\t        return groupId;\n\t    };\n\t    /**\n\t     * @return {string} groupId\n\t     */\n\t    echarts.disConnect = function (groupId) {\n\t        connectedGroups[groupId] = false;\n\t    };\n\t    /**\n\t     * Dispose a chart instance\n\t     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n\t     */\n\t    echarts.dispose = function (chart) {\n\t        if (zrUtil.isDom(chart)) {\n\t            chart = echarts.getInstanceByDom(chart);\n\t        } else if (typeof chart === 'string') {\n\t            chart = instances[chart];\n\t        }\n\t        if (chart instanceof ECharts && !chart.isDisposed()) {\n\t            chart.dispose();\n\t        }\n\t    };\n\t    /**\n\t     * @param  {HTMLDomElement} dom\n\t     * @return {echarts~ECharts}\n\t     */\n\t    echarts.getInstanceByDom = function (dom) {\n\t        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n\t        return instances[key];\n\t    };\n\t    /**\n\t     * @param {string} key\n\t     * @return {echarts~ECharts}\n\t     */\n\t    echarts.getInstanceById = function (key) {\n\t        return instances[key];\n\t    };\n\t    /**\n\t     * Register theme\n\t     */\n\t    echarts.registerTheme = function (name, theme) {\n\t        themeStorage[name] = theme;\n\t    };\n\t    /**\n\t     * Register option preprocessor\n\t     * @param {Function} preprocessorFunc\n\t     */\n\t    echarts.registerPreprocessor = function (preprocessorFunc) {\n\t        optionPreprocessorFuncs.push(preprocessorFunc);\n\t    };\n\t    /**\n\t     * @param {number} [priority=1000]\n\t     * @param {Function} processorFunc\n\t     */\n\t    echarts.registerProcessor = function (priority, processorFunc) {\n\t        if (typeof priority === 'function') {\n\t            processorFunc = priority;\n\t            priority = PRIORITY_PROCESSOR_FILTER;\n\t        }\n\t        if (true) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown processor priority');\n\t            }\n\t        }\n\t        dataProcessorFuncs.push({\n\t            prio: priority,\n\t            func: processorFunc\n\t        });\n\t    };\n\t    /**\n\t     * Usage:\n\t     * registerAction('someAction', 'someEvent', function () { ... });\n\t     * registerAction('someAction', function () { ... });\n\t     * registerAction(\n\t     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n\t     *     function () { ... }\n\t     * );\n\t     *\n\t     * @param {(string|Object)} actionInfo\n\t     * @param {string} actionInfo.type\n\t     * @param {string} [actionInfo.event]\n\t     * @param {string} [actionInfo.update]\n\t     * @param {string} [eventName]\n\t     * @param {Function} action\n\t     */\n\t    echarts.registerAction = function (actionInfo, eventName, action) {\n\t        if (typeof eventName === 'function') {\n\t            action = eventName;\n\t            eventName = '';\n\t        }\n\t        var actionType = zrUtil.isObject(actionInfo) ? actionInfo.type : [\n\t                actionInfo,\n\t                actionInfo = { event: eventName }\n\t            ][0];\n\t        // Event name is all lowercase\n\t        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n\t        eventName = actionInfo.event;\n\t        if (!actions[actionType]) {\n\t            actions[actionType] = {\n\t                action: action,\n\t                actionInfo: actionInfo\n\t            };\n\t        }\n\t        eventActionMap[eventName] = actionType;\n\t    };\n\t    /**\n\t     * @param {string} type\n\t     * @param {*} CoordinateSystem\n\t     */\n\t    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n\t        CoordinateSystemManager.register(type, CoordinateSystem);\n\t    };\n\t    /**\n\t     * Layout is a special stage of visual encoding\n\t     * Most visual encoding like color are common for different chart\n\t     * But each chart has it's own layout algorithm\n\t     *\n\t     * @param {number} [priority=1000]\n\t     * @param {Function} layoutFunc\n\t     */\n\t    echarts.registerLayout = function (priority, layoutFunc) {\n\t        if (typeof priority === 'function') {\n\t            layoutFunc = priority;\n\t            priority = PRIORITY_VISUAL_LAYOUT;\n\t        }\n\t        if (true) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown layout priority');\n\t            }\n\t        }\n\t        visualFuncs.push({\n\t            prio: priority,\n\t            func: layoutFunc,\n\t            isLayout: true\n\t        });\n\t    };\n\t    /**\n\t     * @param {number} [priority=3000]\n\t     * @param {Function} visualFunc\n\t     */\n\t    echarts.registerVisual = function (priority, visualFunc) {\n\t        if (typeof priority === 'function') {\n\t            visualFunc = priority;\n\t            priority = PRIORITY_VISUAL_CHART;\n\t        }\n\t        if (true) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown visual priority');\n\t            }\n\t        }\n\t        visualFuncs.push({\n\t            prio: priority,\n\t            func: visualFunc\n\t        });\n\t    };\n\t    /**\n\t     * @param {string} name\n\t     */\n\t    echarts.registerLoading = function (name, loadingFx) {\n\t        loadingEffects[name] = loadingFx;\n\t    };\n\t    var parseClassType = ComponentModel.parseClassType;\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendComponentModel = function (opts, superClass) {\n\t        var Clazz = ComponentModel;\n\t        if (superClass) {\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendComponentView = function (opts, superClass) {\n\t        var Clazz = ComponentView;\n\t        if (superClass) {\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendSeriesModel = function (opts, superClass) {\n\t        var Clazz = SeriesModel;\n\t        if (superClass) {\n\t            superClass = 'series.' + superClass.replace('series.', '');\n\t            var classType = parseClassType(superClass);\n\t            Clazz = SeriesModel.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendChartView = function (opts, superClass) {\n\t        var Clazz = ChartView;\n\t        if (superClass) {\n\t            superClass.replace('series.', '');\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ChartView.getClass(classType.main, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t    /**\n\t     * ZRender need a canvas context to do measureText.\n\t     * But in node environment canvas may be created by node-canvas.\n\t     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n\t     *\n\t     * Be careful of using it in the browser.\n\t     *\n\t     * @param {Function} creator\n\t     * @example\n\t     *     var Canvas = require('canvas');\n\t     *     var echarts = require('echarts');\n\t     *     echarts.setCanvasCreator(function () {\n\t     *         // Small size is enough.\n\t     *         return new Canvas(32, 32);\n\t     *     });\n\t     */\n\t    echarts.setCanvasCreator = function (creator) {\n\t        zrUtil.createCanvas = creator;\n\t    };\n\t    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, require('./visual/seriesColor'));\n\t    echarts.registerPreprocessor(require('./preprocessor/backwardCompat'));\n\t    echarts.registerLoading('default', require('./loading/default'));\n\t    // Default action\n\t    echarts.registerAction({\n\t        type: 'highlight',\n\t        event: 'highlight',\n\t        update: 'highlight'\n\t    }, zrUtil.noop);\n\t    echarts.registerAction({\n\t        type: 'downplay',\n\t        event: 'downplay',\n\t        update: 'downplay'\n\t    }, zrUtil.noop);\n\t    // --------\n\t    // Exports\n\t    // --------\n\t    //\n\t    echarts.List = require('./data/List');\n\t    echarts.Model = require('./model/Model');\n\t    echarts.graphic = require('./util/graphic');\n\t    echarts.number = require('./util/number');\n\t    echarts.format = require('./util/format');\n\t    echarts.matrix = require('zrender/core/matrix');\n\t    echarts.vector = require('zrender/core/vector');\n\t    echarts.color = require('zrender/tool/color');\n\t    echarts.util = {};\n\t    each([\n\t        'map',\n\t        'each',\n\t        'filter',\n\t        'indexOf',\n\t        'inherits',\n\t        'reduce',\n\t        'filter',\n\t        'bind',\n\t        'curry',\n\t        'isArray',\n\t        'isString',\n\t        'isObject',\n\t        'isFunction',\n\t        'extend',\n\t        'defaults'\n\t    ], function (name) {\n\t        echarts.util[name] = zrUtil[name];\n\t    });\n\t    // PRIORITY\n\t    echarts.PRIORITY = {\n\t        PROCESSOR: {\n\t            FILTER: PRIORITY_PROCESSOR_FILTER,\n\t            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n\t        },\n\t        VISUAL: {\n\t            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n\t            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n\t            CHART: PRIORITY_VISUAL_CHART,\n\t            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n\t            BRUSH: PRIORITY_VISUAL_BRUSH\n\t        }\n\t    };\n\t    return echarts;\n\t});\n\tdefine('echarts/scale/Log', ['require', 'zrender/core/util', './Scale', '../util/number', './Interval'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var Scale = require('./Scale');\n\t    var numberUtil = require('../util/number');\n\t    // Use some method of IntervalScale\n\t    var IntervalScale = require('./Interval');\n\t    var scaleProto = Scale.prototype;\n\t    var intervalScaleProto = IntervalScale.prototype;\n\t    var mathFloor = Math.floor;\n\t    var mathCeil = Math.ceil;\n\t    var mathPow = Math.pow;\n\t    var mathLog = Math.log;\n\t    var LogScale = Scale.extend({\n\t            type: 'log',\n\t            base: 10,\n\t            getTicks: function () {\n\t                return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n\t                    return numberUtil.round(mathPow(this.base, val));\n\t                }, this);\n\t            },\n\t            getLabel: intervalScaleProto.getLabel,\n\t            scale: function (val) {\n\t                val = scaleProto.scale.call(this, val);\n\t                return mathPow(this.base, val);\n\t            },\n\t            setExtent: function (start, end) {\n\t                var base = this.base;\n\t                start = mathLog(start) / mathLog(base);\n\t                end = mathLog(end) / mathLog(base);\n\t                intervalScaleProto.setExtent.call(this, start, end);\n\t            },\n\t            getExtent: function () {\n\t                var base = this.base;\n\t                var extent = scaleProto.getExtent.call(this);\n\t                extent[0] = mathPow(base, extent[0]);\n\t                extent[1] = mathPow(base, extent[1]);\n\t                return extent;\n\t            },\n\t            unionExtent: function (extent) {\n\t                var base = this.base;\n\t                extent[0] = mathLog(extent[0]) / mathLog(base);\n\t                extent[1] = mathLog(extent[1]) / mathLog(base);\n\t                scaleProto.unionExtent.call(this, extent);\n\t            },\n\t            niceTicks: function (approxTickNum) {\n\t                approxTickNum = approxTickNum || 10;\n\t                var extent = this._extent;\n\t                var span = extent[1] - extent[0];\n\t                if (span === Infinity || span <= 0) {\n\t                    return;\n\t                }\n\t                var interval = numberUtil.quantity(span);\n\t                var err = approxTickNum / span * interval;\n\t                // Filter ticks to get closer to the desired count.\n\t                if (err <= 0.5) {\n\t                    interval *= 10;\n\t                }\n\t                // Interval should be integer\n\t                while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n\t                    interval *= 10;\n\t                }\n\t                var niceExtent = [\n\t                        numberUtil.round(mathCeil(extent[0] / interval) * interval),\n\t                        numberUtil.round(mathFloor(extent[1] / interval) * interval)\n\t                    ];\n\t                this._interval = interval;\n\t                this._niceExtent = niceExtent;\n\t            },\n\t            niceExtent: intervalScaleProto.niceExtent\n\t        });\n\t    zrUtil.each([\n\t        'contain',\n\t        'normalize'\n\t    ], function (methodName) {\n\t        LogScale.prototype[methodName] = function (val) {\n\t            val = mathLog(val) / mathLog(this.base);\n\t            return scaleProto[methodName].call(this, val);\n\t        };\n\t    });\n\t    LogScale.create = function () {\n\t        return new LogScale();\n\t    };\n\t    return LogScale;\n\t});\n\tdefine('echarts/chart/pie/PieView', ['require', '../../util/graphic', 'zrender/core/util', '../../view/Chart'], function (require) {\n\t    var graphic = require('../../util/graphic');\n\t    var zrUtil = require('zrender/core/util');\n\t    /**\n\t     * @param {module:echarts/model/Series} seriesModel\n\t     * @param {boolean} hasAnimation\n\t     * @inner\n\t     */\n\t    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n\t        var data = seriesModel.getData();\n\t        var dataIndex = this.dataIndex;\n\t        var name = data.getName(dataIndex);\n\t        var selectedOffset = seriesModel.get('selectedOffset');\n\t        api.dispatchAction({\n\t            type: 'pieToggleSelect',\n\t            from: uid,\n\t            name: name,\n\t            seriesId: seriesModel.id\n\t        });\n\t        data.each(function (idx) {\n\t            toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n\t        });\n\t    }\n\t    /**\n\t     * @param {module:zrender/graphic/Sector} el\n\t     * @param {Object} layout\n\t     * @param {boolean} isSelected\n\t     * @param {number} selectedOffset\n\t     * @param {boolean} hasAnimation\n\t     * @inner\n\t     */\n\t    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n\t        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\t        var dx = Math.cos(midAngle);\n\t        var dy = Math.sin(midAngle);\n\t        var offset = isSelected ? selectedOffset : 0;\n\t        var position = [\n\t                dx * offset,\n\t                dy * offset\n\t            ];\n\t        hasAnimation ? el.animate().when(200, { position: position }).start('bounceOut') : el.attr('position', position);\n\t    }\n\t    /**\n\t     * Piece of pie including Sector, Label, LabelLine\n\t     * @constructor\n\t     * @extends {module:zrender/graphic/Group}\n\t     */\n\t    function PiePiece(data, idx) {\n\t        graphic.Group.call(this);\n\t        var sector = new graphic.Sector({ z2: 2 });\n\t        var polyline = new graphic.Polyline();\n\t        var text = new graphic.Text();\n\t        this.add(sector);\n\t        this.add(polyline);\n\t        this.add(text);\n\t        this.updateData(data, idx, true);\n\t        // Hover to change label and labelLine\n\t        function onEmphasis() {\n\t            polyline.ignore = polyline.hoverIgnore;\n\t            text.ignore = text.hoverIgnore;\n\t        }\n\t        function onNormal() {\n\t            polyline.ignore = polyline.normalIgnore;\n\t            text.ignore = text.normalIgnore;\n\t        }\n\t        this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n\t    }\n\t    var piePieceProto = PiePiece.prototype;\n\t    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n\t        var textStyleModel = labelModel.getModel('textStyle');\n\t        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\t        return {\n\t            fill: textStyleModel.getTextColor() || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n\t            opacity: data.getItemVisual(idx, 'opacity'),\n\t            textFont: textStyleModel.getFont(),\n\t            text: zrUtil.retrieve(data.hostModel.getFormattedLabel(idx, state), data.getName(idx))\n\t        };\n\t    }\n\t    piePieceProto.updateData = function (data, idx, firstCreate) {\n\t        var sector = this.childAt(0);\n\t        var seriesModel = data.hostModel;\n\t        var itemModel = data.getItemModel(idx);\n\t        var layout = data.getItemLayout(idx);\n\t        var sectorShape = zrUtil.extend({}, layout);\n\t        sectorShape.label = null;\n\t        if (firstCreate) {\n\t            sector.setShape(sectorShape);\n\t            sector.shape.endAngle = layout.startAngle;\n\t            graphic.updateProps(sector, { shape: { endAngle: layout.endAngle } }, seriesModel, idx);\n\t        } else {\n\t            graphic.updateProps(sector, { shape: sectorShape }, seriesModel, idx);\n\t        }\n\t        // Update common style\n\t        var itemStyleModel = itemModel.getModel('itemStyle');\n\t        var visualColor = data.getItemVisual(idx, 'color');\n\t        sector.useStyle(zrUtil.defaults({\n\t            lineJoin: 'bevel',\n\t            fill: visualColor\n\t        }, itemStyleModel.getModel('normal').getItemStyle()));\n\t        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\t        // Toggle selected\n\t        toggleItemSelected(this, data.getItemLayout(idx), itemModel.get('selected'), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n\t        function onEmphasis() {\n\t            // Sector may has animation of updating data. Force to move to the last frame\n\t            // Or it may stopped on the wrong shape\n\t            sector.stopAnimation(true);\n\t            sector.animateTo({ shape: { r: layout.r + 10 } }, 300, 'elasticOut');\n\t        }\n\t        function onNormal() {\n\t            sector.stopAnimation(true);\n\t            sector.animateTo({ shape: { r: layout.r } }, 300, 'elasticOut');\n\t        }\n\t        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\t        if (itemModel.get('hoverAnimation') && seriesModel.ifEnableAnimation()) {\n\t            sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n\t        }\n\t        this._updateLabel(data, idx);\n\t        graphic.setHoverStyle(this);\n\t    };\n\t    piePieceProto._updateLabel = function (data, idx) {\n\t        var labelLine = this.childAt(1);\n\t        var labelText = this.childAt(2);\n\t        var seriesModel = data.hostModel;\n\t        var itemModel = data.getItemModel(idx);\n\t        var layout = data.getItemLayout(idx);\n\t        var labelLayout = layout.label;\n\t        var visualColor = data.getItemVisual(idx, 'color');\n\t        graphic.updateProps(labelLine, {\n\t            shape: {\n\t                points: labelLayout.linePoints || [\n\t                    [\n\t                        labelLayout.x,\n\t                        labelLayout.y\n\t                    ],\n\t                    [\n\t                        labelLayout.x,\n\t                        labelLayout.y\n\t                    ],\n\t                    [\n\t                        labelLayout.x,\n\t                        labelLayout.y\n\t                    ]\n\t                ]\n\t            }\n\t        }, seriesModel, idx);\n\t        graphic.updateProps(labelText, {\n\t            style: {\n\t                x: labelLayout.x,\n\t                y: labelLayout.y\n\t            }\n\t        }, seriesModel, idx);\n\t        labelText.attr({\n\t            style: {\n\t                textVerticalAlign: labelLayout.verticalAlign,\n\t                textAlign: labelLayout.textAlign,\n\t                textFont: labelLayout.font\n\t            },\n\t            rotation: labelLayout.rotation,\n\t            origin: [\n\t                labelLayout.x,\n\t                labelLayout.y\n\t            ],\n\t            z2: 10\n\t        });\n\t        var labelModel = itemModel.getModel('label.normal');\n\t        var labelHoverModel = itemModel.getModel('label.emphasis');\n\t        var labelLineModel = itemModel.getModel('labelLine.normal');\n\t        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n\t        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n\t        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n\t        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n\t        labelText.hoverIgnore = !labelHoverModel.get('show');\n\t        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n\t        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\t        // Default use item visual color\n\t        labelLine.setStyle({\n\t            stroke: visualColor,\n\t            opacity: data.getItemVisual(idx, 'opacity')\n\t        });\n\t        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\t        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n\t        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\t        var smooth = labelLineModel.get('smooth');\n\t        if (smooth && smooth === true) {\n\t            smooth = 0.4;\n\t        }\n\t        labelLine.setShape({ smooth: smooth });\n\t    };\n\t    zrUtil.inherits(PiePiece, graphic.Group);\n\t    // Pie view\n\t    var Pie = require('../../view/Chart').extend({\n\t            type: 'pie',\n\t            init: function () {\n\t                var sectorGroup = new graphic.Group();\n\t                this._sectorGroup = sectorGroup;\n\t            },\n\t            render: function (seriesModel, ecModel, api, payload) {\n\t                if (payload && payload.from === this.uid) {\n\t                    return;\n\t                }\n\t                var data = seriesModel.getData();\n\t                var oldData = this._data;\n\t                var group = this.group;\n\t                var hasAnimation = ecModel.get('animation');\n\t                var isFirstRender = !oldData;\n\t                var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n\t                var selectedMode = seriesModel.get('selectedMode');\n\t                data.diff(oldData).add(function (idx) {\n\t                    var piePiece = new PiePiece(data, idx);\n\t                    if (isFirstRender) {\n\t                        piePiece.eachChild(function (child) {\n\t                            child.stopAnimation(true);\n\t                        });\n\t                    }\n\t                    selectedMode && piePiece.on('click', onSectorClick);\n\t                    data.setItemGraphicEl(idx, piePiece);\n\t                    group.add(piePiece);\n\t                }).update(function (newIdx, oldIdx) {\n\t                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\t                    piePiece.updateData(data, newIdx);\n\t                    piePiece.off('click');\n\t                    selectedMode && piePiece.on('click', onSectorClick);\n\t                    group.add(piePiece);\n\t                    data.setItemGraphicEl(newIdx, piePiece);\n\t                }).remove(function (idx) {\n\t                    var piePiece = oldData.getItemGraphicEl(idx);\n\t                    group.remove(piePiece);\n\t                }).execute();\n\t                if (hasAnimation && isFirstRender && data.count() > 0) {\n\t                    var shape = data.getItemLayout(0);\n\t                    var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\t                    var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n\t                    group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n\t                }\n\t                this._data = data;\n\t            },\n\t            _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n\t                var clipPath = new graphic.Sector({\n\t                        shape: {\n\t                            cx: cx,\n\t                            cy: cy,\n\t                            r0: 0,\n\t                            r: r,\n\t                            startAngle: startAngle,\n\t                            endAngle: startAngle,\n\t                            clockwise: clockwise\n\t                        }\n\t                    });\n\t                graphic.initProps(clipPath, { shape: { endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2 } }, seriesModel, cb);\n\t                return clipPath;\n\t            }\n\t        });\n\t    return Pie;\n\t});\n\tdefine('echarts/chart/pie/PieSeries', ['require', '../../data/List', 'zrender/core/util', '../../util/model', '../../data/helper/completeDimensions', '../../component/helper/selectableMixin', '../../echarts'], function (require) {\n\t    'use strict';\n\t    var List = require('../../data/List');\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../../util/model');\n\t    var completeDimensions = require('../../data/helper/completeDimensions');\n\t    var dataSelectableMixin = require('../../component/helper/selectableMixin');\n\t    var PieSeries = require('../../echarts').extendSeriesModel({\n\t            type: 'series.pie',\n\t            init: function (option) {\n\t                PieSeries.superApply(this, 'init', arguments);\n\t                // Enable legend selection for each data item\n\t                // Use a function instead of direct access because data reference may changed\n\t                this.legendDataProvider = function () {\n\t                    return this._dataBeforeProcessed;\n\t                };\n\t                this.updateSelectedMap(option.data);\n\t                this._defaultLabelLine(option);\n\t            },\n\t            mergeOption: function (newOption) {\n\t                PieSeries.superCall(this, 'mergeOption', newOption);\n\t                this.updateSelectedMap(this.option.data);\n\t            },\n\t            getInitialData: function (option, ecModel) {\n\t                var dimensions = completeDimensions(['value'], option.data);\n\t                var list = new List(dimensions, this);\n\t                list.initData(option.data);\n\t                return list;\n\t            },\n\t            getDataParams: function (dataIndex) {\n\t                var data = this._data;\n\t                var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n\t                var sum = data.getSum('value');\n\t                // FIXME toFixed?\n\t                //\n\t                // Percent is 0 if sum is 0\n\t                params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\t                params.$vars.push('percent');\n\t                return params;\n\t            },\n\t            _defaultLabelLine: function (option) {\n\t                // Extend labelLine emphasis\n\t                modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\t                var labelLineNormalOpt = option.labelLine.normal;\n\t                var labelLineEmphasisOpt = option.labelLine.emphasis;\n\t                // Not show label line if `label.normal.show = false`\n\t                labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.normal.show;\n\t                labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.label.emphasis.show;\n\t            },\n\t            defaultOption: {\n\t                zlevel: 0,\n\t                z: 2,\n\t                legendHoverLink: true,\n\t                hoverAnimation: true,\n\t                center: [\n\t                    '50%',\n\t                    '50%'\n\t                ],\n\t                radius: [\n\t                    0,\n\t                    '75%'\n\t                ],\n\t                clockwise: true,\n\t                startAngle: 90,\n\t                minAngle: 0,\n\t                selectedOffset: 10,\n\t                avoidLabelOverlap: true,\n\t                label: {\n\t                    normal: {\n\t                        rotate: false,\n\t                        show: true,\n\t                        position: 'outer'\n\t                    },\n\t                    emphasis: {}\n\t                },\n\t                labelLine: {\n\t                    normal: {\n\t                        show: true,\n\t                        length: 15,\n\t                        length2: 15,\n\t                        smooth: false,\n\t                        lineStyle: {\n\t                            width: 1,\n\t                            type: 'solid'\n\t                        }\n\t                    }\n\t                },\n\t                itemStyle: {\n\t                    normal: { borderWidth: 1 },\n\t                    emphasis: {}\n\t                },\n\t                animationEasing: 'cubicOut',\n\t                data: []\n\t            }\n\t        });\n\t    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\t    return PieSeries;\n\t});\n\tdefine('echarts/action/createDataSelectAction', ['require', '../echarts', 'zrender/core/util'], function (require) {\n\t    var echarts = require('../echarts');\n\t    var zrUtil = require('zrender/core/util');\n\t    return function (seriesType, actionInfos) {\n\t        zrUtil.each(actionInfos, function (actionInfo) {\n\t            actionInfo.update = 'updateView';\n\t            /**\n\t             * @payload\n\t             * @property {string} seriesName\n\t             * @property {string} name\n\t             */\n\t            echarts.registerAction(actionInfo, function (payload, ecModel) {\n\t                var selected = {};\n\t                ecModel.eachComponent({\n\t                    mainType: 'series',\n\t                    subType: seriesType,\n\t                    query: payload\n\t                }, function (seriesModel) {\n\t                    if (seriesModel[actionInfo.method]) {\n\t                        seriesModel[actionInfo.method](payload.name);\n\t                    }\n\t                    var data = seriesModel.getData();\n\t                    // Create selected map\n\t                    data.each(function (idx) {\n\t                        var name = data.getName(idx);\n\t                        selected[name] = seriesModel.isSelected(name) || false;\n\t                    });\n\t                });\n\t                return {\n\t                    name: payload.name,\n\t                    selected: selected\n\t                };\n\t            });\n\t        });\n\t    };\n\t});\n\tdefine('zrender/core/util', ['require'], function (require) {\n\t    // 用于处理merge时无法遍历Date等对象的问题\n\t    var BUILTIN_OBJECT = {\n\t            '[object Function]': 1,\n\t            '[object RegExp]': 1,\n\t            '[object Date]': 1,\n\t            '[object Error]': 1,\n\t            '[object CanvasGradient]': 1,\n\t            '[object CanvasPattern]': 1,\n\t            '[object Image]': 1\n\t        };\n\t    var objToString = Object.prototype.toString;\n\t    var arrayProto = Array.prototype;\n\t    var nativeForEach = arrayProto.forEach;\n\t    var nativeFilter = arrayProto.filter;\n\t    var nativeSlice = arrayProto.slice;\n\t    var nativeMap = arrayProto.map;\n\t    var nativeReduce = arrayProto.reduce;\n\t    /**\n\t     * @param {*} source\n\t     * @return {*} 拷贝后的新对象\n\t     */\n\t    function clone(source) {\n\t        if (typeof source == 'object' && source !== null) {\n\t            var result = source;\n\t            if (source instanceof Array) {\n\t                result = [];\n\t                for (var i = 0, len = source.length; i < len; i++) {\n\t                    result[i] = clone(source[i]);\n\t                }\n\t            } else if (!isBuildInObject(source) && !isDom(source)) {\n\t                result = {};\n\t                for (var key in source) {\n\t                    if (source.hasOwnProperty(key)) {\n\t                        result[key] = clone(source[key]);\n\t                    }\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t        return source;\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolean} [overwrite=false]\n\t     */\n\t    function merge(target, source, overwrite) {\n\t        // We should escapse that source is string\n\t        // and enter for ... in ...\n\t        if (!isObject(source) || !isObject(target)) {\n\t            return overwrite ? clone(source) : target;\n\t        }\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                var targetProp = target[key];\n\t                var sourceProp = source[key];\n\t                if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuildInObject(sourceProp) && !isBuildInObject(targetProp)) {\n\t                    // 如果需要递归覆盖，就递归调用merge\n\t                    merge(targetProp, sourceProp, overwrite);\n\t                } else if (overwrite || !(key in target)) {\n\t                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n\t                    // NOTE，在 target[key] 不存在的时候也是直接覆盖\n\t                    target[key] = clone(source[key], true);\n\t                }\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t    /**\n\t     * @param {Array} targetAndSources The first item is target, and the rests are source.\n\t     * @param {boolean} [overwrite=false]\n\t     * @return {*} target\n\t     */\n\t    function mergeAll(targetAndSources, overwrite) {\n\t        var result = targetAndSources[0];\n\t        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n\t            result = merge(result, targetAndSources[i], overwrite);\n\t        }\n\t        return result;\n\t    }\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function extend(target, source) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolen} [overlay=false]\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function defaults(target, source, overlay) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t    function createCanvas() {\n\t        return document.createElement('canvas');\n\t    }\n\t    // FIXME\n\t    var _ctx;\n\t    function getContext() {\n\t        if (!_ctx) {\n\t            // Use util.createCanvas instead of createCanvas\n\t            // because createCanvas may be overwritten in different environment\n\t            _ctx = util.createCanvas().getContext('2d');\n\t        }\n\t        return _ctx;\n\t    }\n\t    /**\n\t     * 查询数组中元素的index\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function indexOf(array, value) {\n\t        if (array) {\n\t            if (array.indexOf) {\n\t                return array.indexOf(value);\n\t            }\n\t            for (var i = 0, len = array.length; i < len; i++) {\n\t                if (array[i] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t    /**\n\t     * 构造类继承关系\n\t     *\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} clazz 源类\n\t     * @param {Function} baseClazz 基类\n\t     */\n\t    function inherits(clazz, baseClazz) {\n\t        var clazzPrototype = clazz.prototype;\n\t        function F() {\n\t        }\n\t        F.prototype = baseClazz.prototype;\n\t        clazz.prototype = new F();\n\t        for (var prop in clazzPrototype) {\n\t            clazz.prototype[prop] = clazzPrototype[prop];\n\t        }\n\t        clazz.prototype.constructor = clazz;\n\t        clazz.superClass = baseClazz;\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Function} target\n\t     * @param {Object|Function} sorce\n\t     * @param {boolean} overlay\n\t     */\n\t    function mixin(target, source, overlay) {\n\t        target = 'prototype' in target ? target.prototype : target;\n\t        source = 'prototype' in source ? source.prototype : source;\n\t        defaults(target, source, overlay);\n\t    }\n\t    /**\n\t     * @param {Array|TypedArray} data\n\t     */\n\t    function isArrayLike(data) {\n\t        if (!data) {\n\t            return;\n\t        }\n\t        if (typeof data == 'string') {\n\t            return false;\n\t        }\n\t        return typeof data.length == 'number';\n\t    }\n\t    /**\n\t     * 数组或对象遍历\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     */\n\t    function each(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.forEach && obj.forEach === nativeForEach) {\n\t            obj.forEach(cb, context);\n\t        } else if (obj.length === +obj.length) {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                cb.call(context, obj[i], i, obj);\n\t            }\n\t        } else {\n\t            for (var key in obj) {\n\t                if (obj.hasOwnProperty(key)) {\n\t                    cb.call(context, obj[key], key, obj);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * 数组映射\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function map(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.map && obj.map === nativeMap) {\n\t            return obj.map(cb, context);\n\t        } else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                result.push(cb.call(context, obj[i], i, obj));\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {Object} [memo]\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function reduce(obj, cb, memo, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.reduce && obj.reduce === nativeReduce) {\n\t            return obj.reduce(cb, memo, context);\n\t        } else {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                memo = cb.call(context, memo, obj[i], i, obj);\n\t            }\n\t            return memo;\n\t        }\n\t    }\n\t    /**\n\t     * 数组过滤\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function filter(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.filter && obj.filter === nativeFilter) {\n\t            return obj.filter(cb, context);\n\t        } else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                if (cb.call(context, obj[i], i, obj)) {\n\t                    result.push(obj[i]);\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t    /**\n\t     * 数组项查找\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function find(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        for (var i = 0, len = obj.length; i < len; i++) {\n\t            if (cb.call(context, obj[i], i, obj)) {\n\t                return obj[i];\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @param {*} context\n\t     * @return {Function}\n\t     */\n\t    function bind(func, context) {\n\t        var args = nativeSlice.call(arguments, 2);\n\t        return function () {\n\t            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @return {Function}\n\t     */\n\t    function curry(func) {\n\t        var args = nativeSlice.call(arguments, 1);\n\t        return function () {\n\t            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isArray(value) {\n\t        return objToString.call(value) === '[object Array]';\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isFunction(value) {\n\t        return typeof value === 'function';\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isString(value) {\n\t        return objToString.call(value) === '[object String]';\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isObject(value) {\n\t        // Avoid a V8 JIT bug in Chrome 19-20.\n\t        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t        var type = typeof value;\n\t        return type === 'function' || !!value && type == 'object';\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isBuildInObject(value) {\n\t        return !!BUILTIN_OBJECT[objToString.call(value)];\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isDom(value) {\n\t        return value && value.nodeType === 1 && typeof value.nodeName == 'string';\n\t    }\n\t    /**\n\t     * If value1 is not null, then return value1, otherwise judget rest of values.\n\t     * @memberOf module:zrender/core/util\n\t     * @return {*} Final value\n\t     */\n\t    function retrieve(values) {\n\t        for (var i = 0, len = arguments.length; i < len; i++) {\n\t            if (arguments[i] != null) {\n\t                return arguments[i];\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} arr\n\t     * @param {number} startIndex\n\t     * @param {number} endIndex\n\t     * @return {Array}\n\t     */\n\t    function slice() {\n\t        return Function.call.apply(nativeSlice, arguments);\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {boolean} condition\n\t     * @param {string} message\n\t     */\n\t    function assert(condition, message) {\n\t        if (!condition) {\n\t            throw new Error(message);\n\t        }\n\t    }\n\t    var util = {\n\t            inherits: inherits,\n\t            mixin: mixin,\n\t            clone: clone,\n\t            merge: merge,\n\t            mergeAll: mergeAll,\n\t            extend: extend,\n\t            defaults: defaults,\n\t            getContext: getContext,\n\t            createCanvas: createCanvas,\n\t            indexOf: indexOf,\n\t            slice: slice,\n\t            find: find,\n\t            isArrayLike: isArrayLike,\n\t            each: each,\n\t            map: map,\n\t            reduce: reduce,\n\t            filter: filter,\n\t            bind: bind,\n\t            curry: curry,\n\t            isArray: isArray,\n\t            isString: isString,\n\t            isObject: isObject,\n\t            isFunction: isFunction,\n\t            isBuildInObject: isBuildInObject,\n\t            isDom: isDom,\n\t            retrieve: retrieve,\n\t            assert: assert,\n\t            noop: function () {\n\t            }\n\t        };\n\t    return util;\n\t});\n\tdefine('echarts/visual/dataColor', ['require'], function (require) {\n\t    return function (seriesType, ecModel) {\n\t        // Pie and funnel may use diferrent scope\n\t        var paletteScope = {};\n\t        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n\t            var dataAll = seriesModel.getRawData();\n\t            var idxMap = {};\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                var data = seriesModel.getData();\n\t                data.each(function (idx) {\n\t                    var rawIdx = data.getRawIndex(idx);\n\t                    idxMap[rawIdx] = idx;\n\t                });\n\t                dataAll.each(function (rawIdx) {\n\t                    // FIXME Performance\n\t                    var itemModel = dataAll.getItemModel(rawIdx);\n\t                    var filteredIdx = idxMap[rawIdx];\n\t                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\t                    var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\t                    if (!singleDataColor) {\n\t                        var color = itemModel.get('itemStyle.normal.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n\t                        // Legend may use the visual info in data before processed\n\t                        dataAll.setItemVisual(rawIdx, 'color', color);\n\t                        // Data is not filtered\n\t                        if (filteredIdx != null) {\n\t                            data.setItemVisual(filteredIdx, 'color', color);\n\t                        }\n\t                    } else {\n\t                        // Set data all color for legend\n\t                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n\t                    }\n\t                });\n\t            }\n\t        });\n\t    };\n\t});\n\tdefine('echarts/chart/pie/pieLayout', ['require', '../../util/number', './labelLayout', 'zrender/core/util'], function (require) {\n\t    var numberUtil = require('../../util/number');\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var labelLayout = require('./labelLayout');\n\t    var zrUtil = require('zrender/core/util');\n\t    var PI2 = Math.PI * 2;\n\t    var RADIAN = Math.PI / 180;\n\t    return function (seriesType, ecModel, api, payload) {\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t            var center = seriesModel.get('center');\n\t            var radius = seriesModel.get('radius');\n\t            if (!zrUtil.isArray(radius)) {\n\t                radius = [\n\t                    0,\n\t                    radius\n\t                ];\n\t            }\n\t            if (!zrUtil.isArray(center)) {\n\t                center = [\n\t                    center,\n\t                    center\n\t                ];\n\t            }\n\t            var width = api.getWidth();\n\t            var height = api.getHeight();\n\t            var size = Math.min(width, height);\n\t            var cx = parsePercent(center[0], width);\n\t            var cy = parsePercent(center[1], height);\n\t            var r0 = parsePercent(radius[0], size / 2);\n\t            var r = parsePercent(radius[1], size / 2);\n\t            var data = seriesModel.getData();\n\t            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\t            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\t            var sum = data.getSum('value');\n\t            // Sum may be 0\n\t            var unitRadian = Math.PI / (sum || data.count()) * 2;\n\t            var clockwise = seriesModel.get('clockwise');\n\t            var roseType = seriesModel.get('roseType');\n\t            // [0...max]\n\t            var extent = data.getDataExtent('value');\n\t            extent[0] = 0;\n\t            // In the case some sector angle is smaller than minAngle\n\t            var restAngle = PI2;\n\t            var valueSumLargerThanMinAngle = 0;\n\t            var currentAngle = startAngle;\n\t            var dir = clockwise ? 1 : -1;\n\t            data.each('value', function (value, idx) {\n\t                var angle;\n\t                // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n\t                if (roseType !== 'area') {\n\t                    angle = sum === 0 ? unitRadian : value * unitRadian;\n\t                } else {\n\t                    angle = PI2 / (data.count() || 1);\n\t                }\n\t                if (angle < minAngle) {\n\t                    angle = minAngle;\n\t                    restAngle -= minAngle;\n\t                } else {\n\t                    valueSumLargerThanMinAngle += value;\n\t                }\n\t                var endAngle = currentAngle + dir * angle;\n\t                data.setItemLayout(idx, {\n\t                    angle: angle,\n\t                    startAngle: currentAngle,\n\t                    endAngle: endAngle,\n\t                    clockwise: clockwise,\n\t                    cx: cx,\n\t                    cy: cy,\n\t                    r0: r0,\n\t                    r: roseType ? numberUtil.linearMap(value, extent, [\n\t                        r0,\n\t                        r\n\t                    ]) : r\n\t                });\n\t                currentAngle = endAngle;\n\t            }, true);\n\t            // Some sector is constrained by minAngle\n\t            // Rest sectors needs recalculate angle\n\t            if (restAngle < PI2) {\n\t                // Average the angle if rest angle is not enough after all angles is\n\t                // Constrained by minAngle\n\t                if (restAngle <= 0.001) {\n\t                    var angle = PI2 / data.count();\n\t                    data.each(function (idx) {\n\t                        var layout = data.getItemLayout(idx);\n\t                        layout.startAngle = startAngle + dir * idx * angle;\n\t                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n\t                    });\n\t                } else {\n\t                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n\t                    currentAngle = startAngle;\n\t                    data.each('value', function (value, idx) {\n\t                        var layout = data.getItemLayout(idx);\n\t                        var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n\t                        layout.startAngle = currentAngle;\n\t                        layout.endAngle = currentAngle + dir * angle;\n\t                        currentAngle += angle;\n\t                    });\n\t                }\n\t            }\n\t            labelLayout(seriesModel, r, width, height);\n\t        });\n\t    };\n\t});\n\tdefine('echarts/processor/dataFilter', [], function () {\n\t    return function (seriesType, ecModel) {\n\t        var legendModels = ecModel.findComponents({ mainType: 'legend' });\n\t        if (!legendModels || !legendModels.length) {\n\t            return;\n\t        }\n\t        ecModel.eachSeriesByType(seriesType, function (series) {\n\t            var data = series.getData();\n\t            data.filterSelf(function (idx) {\n\t                var name = data.getName(idx);\n\t                // If in any legend component the status is not selected.\n\t                for (var i = 0; i < legendModels.length; i++) {\n\t                    if (!legendModels[i].isSelected(name)) {\n\t                        return false;\n\t                    }\n\t                }\n\t                return true;\n\t            }, this);\n\t        }, this);\n\t    };\n\t});\n\tdefine('echarts/coord/cartesian/Grid', ['require', 'exports', '../../util/layout', '../../coord/axisHelper', 'zrender/core/util', './Cartesian2D', './Axis2D', './GridModel', '../../CoordinateSystem'], function (require, factory) {\n\t    var layout = require('../../util/layout');\n\t    var axisHelper = require('../../coord/axisHelper');\n\t    var zrUtil = require('zrender/core/util');\n\t    var Cartesian2D = require('./Cartesian2D');\n\t    var Axis2D = require('./Axis2D');\n\t    var each = zrUtil.each;\n\t    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n\t    var niceScaleExtent = axisHelper.niceScaleExtent;\n\t    // 依赖 GridModel, AxisModel 做预处理\n\t    require('./GridModel');\n\t    /**\n\t     * Check if the axis is used in the specified grid\n\t     * @inner\n\t     */\n\t    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n\t        return axisModel.findGridModel() === gridModel;\n\t    }\n\t    function getLabelUnionRect(axis) {\n\t        var axisModel = axis.model;\n\t        var labels = axisModel.getFormattedLabels();\n\t        var rect;\n\t        var step = 1;\n\t        var labelCount = labels.length;\n\t        if (labelCount > 40) {\n\t            // Simple optimization for large amount of labels\n\t            step = Math.ceil(labelCount / 40);\n\t        }\n\t        for (var i = 0; i < labelCount; i += step) {\n\t            if (!axis.isLabelIgnored(i)) {\n\t                var singleRect = axisModel.getTextRect(labels[i]);\n\t                // FIXME consider label rotate\n\t                rect ? rect.union(singleRect) : rect = singleRect;\n\t            }\n\t        }\n\t        return rect;\n\t    }\n\t    function Grid(gridModel, ecModel, api) {\n\t        /**\n\t         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n\t         * @private\n\t         */\n\t        this._coordsMap = {};\n\t        /**\n\t         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n\t         * @private\n\t         */\n\t        this._coordsList = [];\n\t        /**\n\t         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n\t         * @private\n\t         */\n\t        this._axesMap = {};\n\t        /**\n\t         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n\t         * @private\n\t         */\n\t        this._axesList = [];\n\t        this._initCartesian(gridModel, ecModel, api);\n\t        this._model = gridModel;\n\t    }\n\t    var gridProto = Grid.prototype;\n\t    gridProto.type = 'grid';\n\t    gridProto.getRect = function () {\n\t        return this._rect;\n\t    };\n\t    gridProto.update = function (ecModel, api) {\n\t        var axesMap = this._axesMap;\n\t        this._updateScale(ecModel, this._model);\n\t        function ifAxisCanNotOnZero(otherAxisDim) {\n\t            var axes = axesMap[otherAxisDim];\n\t            for (var idx in axes) {\n\t                var axis = axes[idx];\n\t                if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n\t                    return true;\n\t                }\n\t            }\n\t            return false;\n\t        }\n\t        each(axesMap.x, function (xAxis) {\n\t            niceScaleExtent(xAxis, xAxis.model);\n\t        });\n\t        each(axesMap.y, function (yAxis) {\n\t            niceScaleExtent(yAxis, yAxis.model);\n\t        });\n\t        // Fix configuration\n\t        each(axesMap.x, function (xAxis) {\n\t            // onZero can not be enabled in these two situations\n\t            // 1. When any other axis is a category axis\n\t            // 2. When any other axis not across 0 point\n\t            if (ifAxisCanNotOnZero('y')) {\n\t                xAxis.onZero = false;\n\t            }\n\t        });\n\t        each(axesMap.y, function (yAxis) {\n\t            if (ifAxisCanNotOnZero('x')) {\n\t                yAxis.onZero = false;\n\t            }\n\t        });\n\t        // Resize again if containLabel is enabled\n\t        // FIXME It may cause getting wrong grid size in data processing stage\n\t        this.resize(this._model, api);\n\t    };\n\t    /**\n\t     * Resize the grid\n\t     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    gridProto.resize = function (gridModel, api) {\n\t        var gridRect = layout.getLayoutRect(gridModel.getBoxLayoutParams(), {\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            });\n\t        this._rect = gridRect;\n\t        var axesList = this._axesList;\n\t        adjustAxes();\n\t        // Minus label size\n\t        if (gridModel.get('containLabel')) {\n\t            each(axesList, function (axis) {\n\t                if (!axis.model.get('axisLabel.inside')) {\n\t                    var labelUnionRect = getLabelUnionRect(axis);\n\t                    if (labelUnionRect) {\n\t                        var dim = axis.isHorizontal() ? 'height' : 'width';\n\t                        var margin = axis.model.get('axisLabel.margin');\n\t                        gridRect[dim] -= labelUnionRect[dim] + margin;\n\t                        if (axis.position === 'top') {\n\t                            gridRect.y += labelUnionRect.height + margin;\n\t                        } else if (axis.position === 'left') {\n\t                            gridRect.x += labelUnionRect.width + margin;\n\t                        }\n\t                    }\n\t                }\n\t            });\n\t            adjustAxes();\n\t        }\n\t        function adjustAxes() {\n\t            each(axesList, function (axis) {\n\t                var isHorizontal = axis.isHorizontal();\n\t                var extent = isHorizontal ? [\n\t                        0,\n\t                        gridRect.width\n\t                    ] : [\n\t                        0,\n\t                        gridRect.height\n\t                    ];\n\t                var idx = axis.inverse ? 1 : 0;\n\t                axis.setExtent(extent[idx], extent[1 - idx]);\n\t                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n\t            });\n\t        }\n\t    };\n\t    /**\n\t     * @param {string} axisType\n\t     * @param {ndumber} [axisIndex]\n\t     */\n\t    gridProto.getAxis = function (axisType, axisIndex) {\n\t        var axesMapOnDim = this._axesMap[axisType];\n\t        if (axesMapOnDim != null) {\n\t            if (axisIndex == null) {\n\t                // Find first axis\n\t                for (var name in axesMapOnDim) {\n\t                    return axesMapOnDim[name];\n\t                }\n\t            }\n\t            return axesMapOnDim[axisIndex];\n\t        }\n\t    };\n\t    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n\t        if (xAxisIndex != null && yAxisIndex != null) {\n\t            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n\t            return this._coordsMap[key];\n\t        } else {\n\t            // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\t            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n\t                if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n\t                    return coordList[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t    /**\n\t     * Initialize cartesian coordinate systems\n\t     * @private\n\t     */\n\t    gridProto._initCartesian = function (gridModel, ecModel, api) {\n\t        var axisPositionUsed = {\n\t                left: false,\n\t                right: false,\n\t                top: false,\n\t                bottom: false\n\t            };\n\t        var axesMap = {\n\t                x: {},\n\t                y: {}\n\t            };\n\t        var axesCount = {\n\t                x: 0,\n\t                y: 0\n\t            };\n\t        /// Create axis\n\t        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n\t        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\t        if (!axesCount.x || !axesCount.y) {\n\t            // Roll back when there no either x or y axis\n\t            this._axesMap = {};\n\t            this._axesList = [];\n\t            return;\n\t        }\n\t        this._axesMap = axesMap;\n\t        /// Create cartesian2d\n\t        each(axesMap.x, function (xAxis, xAxisIndex) {\n\t            each(axesMap.y, function (yAxis, yAxisIndex) {\n\t                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n\t                var cartesian = new Cartesian2D(key);\n\t                cartesian.grid = this;\n\t                this._coordsMap[key] = cartesian;\n\t                this._coordsList.push(cartesian);\n\t                cartesian.addAxis(xAxis);\n\t                cartesian.addAxis(yAxis);\n\t            }, this);\n\t        }, this);\n\t        function createAxisCreator(axisType) {\n\t            return function (axisModel, idx) {\n\t                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n\t                    return;\n\t                }\n\t                var axisPosition = axisModel.get('position');\n\t                if (axisType === 'x') {\n\t                    // Fix position\n\t                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n\t                        // Default bottom of X\n\t                        axisPosition = 'bottom';\n\t                        if (axisPositionUsed[axisPosition]) {\n\t                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n\t                        }\n\t                    }\n\t                } else {\n\t                    // Fix position\n\t                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n\t                        // Default left of Y\n\t                        axisPosition = 'left';\n\t                        if (axisPositionUsed[axisPosition]) {\n\t                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n\t                        }\n\t                    }\n\t                }\n\t                axisPositionUsed[axisPosition] = true;\n\t                var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [\n\t                        0,\n\t                        0\n\t                    ], axisModel.get('type'), axisPosition);\n\t                var isCategory = axis.type === 'category';\n\t                axis.onBand = isCategory && axisModel.get('boundaryGap');\n\t                axis.inverse = axisModel.get('inverse');\n\t                axis.onZero = axisModel.get('axisLine.onZero');\n\t                // Inject axis into axisModel\n\t                axisModel.axis = axis;\n\t                // Inject axisModel into axis\n\t                axis.model = axisModel;\n\t                // Inject grid info axis\n\t                axis.grid = this;\n\t                // Index of axis, can be used as key\n\t                axis.index = idx;\n\t                this._axesList.push(axis);\n\t                axesMap[axisType][idx] = axis;\n\t                axesCount[axisType]++;\n\t            };\n\t        }\n\t    };\n\t    /**\n\t     * Update cartesian properties from series\n\t     * @param  {module:echarts/model/Option} option\n\t     * @private\n\t     */\n\t    gridProto._updateScale = function (ecModel, gridModel) {\n\t        // Reset scale\n\t        zrUtil.each(this._axesList, function (axis) {\n\t            axis.scale.setExtent(Infinity, -Infinity);\n\t        });\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            if (isCartesian2D(seriesModel)) {\n\t                var axesModels = findAxesModels(seriesModel, ecModel);\n\t                var xAxisModel = axesModels[0];\n\t                var yAxisModel = axesModels[1];\n\t                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n\t                    return;\n\t                }\n\t                var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n\t                var data = seriesModel.getData();\n\t                var xAxis = cartesian.getAxis('x');\n\t                var yAxis = cartesian.getAxis('y');\n\t                if (data.type === 'list') {\n\t                    unionExtent(data, xAxis, seriesModel);\n\t                    unionExtent(data, yAxis, seriesModel);\n\t                }\n\t            }\n\t        }, this);\n\t        function unionExtent(data, axis, seriesModel) {\n\t            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n\t                axis.scale.unionExtent(data.getDataExtent(dim, axis.scale.type !== 'ordinal'));\n\t            });\n\t        }\n\t    };\n\t    /**\n\t     * @inner\n\t     */\n\t    function updateAxisTransfrom(axis, coordBase) {\n\t        var axisExtent = axis.getExtent();\n\t        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\t        // Fast transform\n\t        axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n\t            return coord + coordBase;\n\t        } : function (coord) {\n\t            return axisExtentSum - coord + coordBase;\n\t        };\n\t        axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n\t            return coord - coordBase;\n\t        } : function (coord) {\n\t            return axisExtentSum - coord + coordBase;\n\t        };\n\t    }\n\t    var axesTypes = [\n\t            'xAxis',\n\t            'yAxis'\n\t        ];\n\t    /**\n\t     * @inner\n\t     */\n\t    function findAxesModels(seriesModel, ecModel) {\n\t        return zrUtil.map(axesTypes, function (axisType) {\n\t            var axisModel = ecModel.queryComponents({\n\t                    mainType: axisType,\n\t                    index: seriesModel.get(axisType + 'Index'),\n\t                    id: seriesModel.get(axisType + 'Id')\n\t                })[0];\n\t            if (true) {\n\t                if (!axisModel) {\n\t                    throw new Error(axisType + ' \"' + zrUtil.retrieve(seriesModel.get(axisType + 'Index'), seriesModel.get(axisType + 'Id'), 0) + '\" not found');\n\t                }\n\t            }\n\t            return axisModel;\n\t        });\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function isCartesian2D(seriesModel) {\n\t        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n\t    }\n\t    Grid.create = function (ecModel, api) {\n\t        var grids = [];\n\t        ecModel.eachComponent('grid', function (gridModel, idx) {\n\t            var grid = new Grid(gridModel, ecModel, api);\n\t            grid.name = 'grid_' + idx;\n\t            grid.resize(gridModel, api);\n\t            gridModel.coordinateSystem = grid;\n\t            grids.push(grid);\n\t        });\n\t        // Inject the coordinateSystems into seriesModel\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            if (!isCartesian2D(seriesModel)) {\n\t                return;\n\t            }\n\t            var axesModels = findAxesModels(seriesModel, ecModel);\n\t            var xAxisModel = axesModels[0];\n\t            var yAxisModel = axesModels[1];\n\t            var gridModel = xAxisModel.findGridModel();\n\t            if (true) {\n\t                if (!gridModel) {\n\t                    throw new Error('Grid \"' + zrUtil.retrieve(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '\" not found');\n\t                }\n\t                if (xAxisModel.findGridModel() !== yAxisModel.findGridModel()) {\n\t                    throw new Error('xAxis and yAxis must use the same grid');\n\t                }\n\t            }\n\t            var grid = gridModel.coordinateSystem;\n\t            seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n\t        });\n\t        return grids;\n\t    };\n\t    // For deciding which dimensions to use when creating list data\n\t    Grid.dimensions = Cartesian2D.prototype.dimensions;\n\t    require('../../CoordinateSystem').register('cartesian2d', Grid);\n\t    return Grid;\n\t});\n\tdefine('echarts/chart/bar/BarSeries', ['require', '../../model/Series', '../helper/createListFromArray'], function (require) {\n\t    'use strict';\n\t    var SeriesModel = require('../../model/Series');\n\t    var createListFromArray = require('../helper/createListFromArray');\n\t    return SeriesModel.extend({\n\t        type: 'series.bar',\n\t        dependencies: [\n\t            'grid',\n\t            'polar'\n\t        ],\n\t        getInitialData: function (option, ecModel) {\n\t            if (true) {\n\t                var coordSys = option.coordinateSystem;\n\t                if (coordSys !== 'cartesian2d') {\n\t                    throw new Error('Bar only support cartesian2d coordinateSystem');\n\t                }\n\t            }\n\t            return createListFromArray(option.data, this, ecModel);\n\t        },\n\t        getMarkerPosition: function (value) {\n\t            var coordSys = this.coordinateSystem;\n\t            if (coordSys) {\n\t                // PENDING if clamp ?\n\t                var pt = coordSys.dataToPoint(value, true);\n\t                var data = this.getData();\n\t                var offset = data.getLayout('offset');\n\t                var size = data.getLayout('size');\n\t                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n\t                pt[offsetIndex] += offset + size / 2;\n\t                return pt;\n\t            }\n\t            return [\n\t                NaN,\n\t                NaN\n\t            ];\n\t        },\n\t        brushSelector: 'rect',\n\t        defaultOption: {\n\t            zlevel: 0,\n\t            z: 2,\n\t            coordinateSystem: 'cartesian2d',\n\t            legendHoverLink: true,\n\t            barMinHeight: 0,\n\t            itemStyle: {\n\t                normal: {},\n\t                emphasis: {}\n\t            }\n\t        }\n\t    });\n\t});\n\tdefine('echarts/chart/bar/BarView', ['require', 'zrender/core/util', '../../util/graphic', '../../model/Model', './barItemStyle', '../../echarts'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var graphic = require('../../util/graphic');\n\t    zrUtil.extend(require('../../model/Model').prototype, require('./barItemStyle'));\n\t    function fixLayoutWithLineWidth(layout, lineWidth) {\n\t        var signX = layout.width > 0 ? 1 : -1;\n\t        var signY = layout.height > 0 ? 1 : -1;\n\t        // In case width or height are too small.\n\t        lineWidth = Math.min(lineWidth, Math.abs(layout.width), Math.abs(layout.height));\n\t        layout.x += signX * lineWidth / 2;\n\t        layout.y += signY * lineWidth / 2;\n\t        layout.width -= signX * lineWidth;\n\t        layout.height -= signY * lineWidth;\n\t    }\n\t    return require('../../echarts').extendChartView({\n\t        type: 'bar',\n\t        render: function (seriesModel, ecModel, api) {\n\t            var coordinateSystemType = seriesModel.get('coordinateSystem');\n\t            if (coordinateSystemType === 'cartesian2d') {\n\t                this._renderOnCartesian(seriesModel, ecModel, api);\n\t            }\n\t            return this.group;\n\t        },\n\t        _renderOnCartesian: function (seriesModel, ecModel, api) {\n\t            var group = this.group;\n\t            var data = seriesModel.getData();\n\t            var oldData = this._data;\n\t            var cartesian = seriesModel.coordinateSystem;\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var isHorizontal = baseAxis.isHorizontal();\n\t            var enableAnimation = seriesModel.get('animation');\n\t            var barBorderWidthQuery = [\n\t                    'itemStyle',\n\t                    'normal',\n\t                    'barBorderWidth'\n\t                ];\n\t            function createRect(dataIndex, isUpdate) {\n\t                var layout = data.getItemLayout(dataIndex);\n\t                var lineWidth = data.getItemModel(dataIndex).get(barBorderWidthQuery) || 0;\n\t                fixLayoutWithLineWidth(layout, lineWidth);\n\t                var rect = new graphic.Rect({ shape: zrUtil.extend({}, layout) });\n\t                // Animation\n\t                if (enableAnimation) {\n\t                    var rectShape = rect.shape;\n\t                    var animateProperty = isHorizontal ? 'height' : 'width';\n\t                    var animateTarget = {};\n\t                    rectShape[animateProperty] = 0;\n\t                    animateTarget[animateProperty] = layout[animateProperty];\n\t                    graphic[isUpdate ? 'updateProps' : 'initProps'](rect, { shape: animateTarget }, seriesModel, dataIndex);\n\t                }\n\t                return rect;\n\t            }\n\t            data.diff(oldData).add(function (dataIndex) {\n\t                // 空数据\n\t                if (!data.hasValue(dataIndex)) {\n\t                    return;\n\t                }\n\t                var rect = createRect(dataIndex);\n\t                data.setItemGraphicEl(dataIndex, rect);\n\t                group.add(rect);\n\t            }).update(function (newIndex, oldIndex) {\n\t                var rect = oldData.getItemGraphicEl(oldIndex);\n\t                // 空数据\n\t                if (!data.hasValue(newIndex)) {\n\t                    group.remove(rect);\n\t                    return;\n\t                }\n\t                if (!rect) {\n\t                    rect = createRect(newIndex, true);\n\t                }\n\t                var layout = data.getItemLayout(newIndex);\n\t                var lineWidth = data.getItemModel(newIndex).get(barBorderWidthQuery) || 0;\n\t                fixLayoutWithLineWidth(layout, lineWidth);\n\t                graphic.updateProps(rect, { shape: layout }, seriesModel, newIndex);\n\t                data.setItemGraphicEl(newIndex, rect);\n\t                // Add back\n\t                group.add(rect);\n\t            }).remove(function (idx) {\n\t                var rect = oldData.getItemGraphicEl(idx);\n\t                if (rect) {\n\t                    // Not show text when animating\n\t                    rect.style.text = '';\n\t                    graphic.updateProps(rect, { shape: { width: 0 } }, seriesModel, idx, function () {\n\t                        group.remove(rect);\n\t                    });\n\t                }\n\t            }).execute();\n\t            this._updateStyle(seriesModel, data, isHorizontal);\n\t            this._data = data;\n\t        },\n\t        _updateStyle: function (seriesModel, data, isHorizontal) {\n\t            function setLabel(style, model, color, labelText, labelPositionOutside) {\n\t                graphic.setText(style, model, color);\n\t                style.text = labelText;\n\t                if (style.textPosition === 'outside') {\n\t                    style.textPosition = labelPositionOutside;\n\t                }\n\t            }\n\t            data.eachItemGraphicEl(function (rect, idx) {\n\t                var itemModel = data.getItemModel(idx);\n\t                var color = data.getItemVisual(idx, 'color');\n\t                var opacity = data.getItemVisual(idx, 'opacity');\n\t                var layout = data.getItemLayout(idx);\n\t                var itemStyleModel = itemModel.getModel('itemStyle.normal');\n\t                var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\t                rect.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n\t                rect.useStyle(zrUtil.defaults({\n\t                    fill: color,\n\t                    opacity: opacity\n\t                }, itemStyleModel.getBarItemStyle()));\n\t                var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n\t                var labelModel = itemModel.getModel('label.normal');\n\t                var hoverLabelModel = itemModel.getModel('label.emphasis');\n\t                var rectStyle = rect.style;\n\t                if (labelModel.get('show')) {\n\t                    setLabel(rectStyle, labelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'normal'), seriesModel.getRawValue(idx)), labelPositionOutside);\n\t                } else {\n\t                    rectStyle.text = '';\n\t                }\n\t                if (hoverLabelModel.get('show')) {\n\t                    setLabel(hoverStyle, hoverLabelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'emphasis'), seriesModel.getRawValue(idx)), labelPositionOutside);\n\t                } else {\n\t                    hoverStyle.text = '';\n\t                }\n\t                graphic.setHoverStyle(rect, hoverStyle);\n\t            });\n\t        },\n\t        remove: function (ecModel, api) {\n\t            var group = this.group;\n\t            if (ecModel.get('animation')) {\n\t                if (this._data) {\n\t                    this._data.eachItemGraphicEl(function (el) {\n\t                        // Not show text when animating\n\t                        el.style.text = '';\n\t                        graphic.updateProps(el, { shape: { width: 0 } }, ecModel, el.dataIndex, function () {\n\t                            group.remove(el);\n\t                        });\n\t                    });\n\t                }\n\t            } else {\n\t                group.removeAll();\n\t            }\n\t        }\n\t    });\n\t});\n\tdefine('echarts/layout/barGrid', ['require', 'zrender/core/util', '../util/number'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var numberUtil = require('../util/number');\n\t    var parsePercent = numberUtil.parsePercent;\n\t    function getSeriesStackId(seriesModel) {\n\t        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n\t    }\n\t    function getAxisKey(axis) {\n\t        return axis.dim + axis.index;\n\t    }\n\t    function calBarWidthAndOffset(barSeries, api) {\n\t        // Columns info on each category axis. Key is cartesian name\n\t        var columnsMap = {};\n\t        zrUtil.each(barSeries, function (seriesModel, idx) {\n\t            var data = seriesModel.getData();\n\t            var cartesian = seriesModel.coordinateSystem;\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var axisExtent = baseAxis.getExtent();\n\t            var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n\t            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n\t                    bandWidth: bandWidth,\n\t                    remainedWidth: bandWidth,\n\t                    autoWidthCount: 0,\n\t                    categoryGap: '20%',\n\t                    gap: '30%',\n\t                    stacks: {}\n\t                };\n\t            var stacks = columnsOnAxis.stacks;\n\t            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n\t            var stackId = getSeriesStackId(seriesModel);\n\t            if (!stacks[stackId]) {\n\t                columnsOnAxis.autoWidthCount++;\n\t            }\n\t            stacks[stackId] = stacks[stackId] || {\n\t                width: 0,\n\t                maxWidth: 0\n\t            };\n\t            var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n\t            var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n\t            var barGap = seriesModel.get('barGap');\n\t            var barCategoryGap = seriesModel.get('barCategoryGap');\n\t            // TODO\n\t            if (barWidth && !stacks[stackId].width) {\n\t                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n\t                stacks[stackId].width = barWidth;\n\t                columnsOnAxis.remainedWidth -= barWidth;\n\t            }\n\t            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n\t            barGap != null && (columnsOnAxis.gap = barGap);\n\t            barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n\t        });\n\t        var result = {};\n\t        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n\t            result[coordSysName] = {};\n\t            var stacks = columnsOnAxis.stacks;\n\t            var bandWidth = columnsOnAxis.bandWidth;\n\t            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n\t            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n\t            var remainedWidth = columnsOnAxis.remainedWidth;\n\t            var autoWidthCount = columnsOnAxis.autoWidthCount;\n\t            var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n\t            autoWidth = Math.max(autoWidth, 0);\n\t            // Find if any auto calculated bar exceeded maxBarWidth\n\t            zrUtil.each(stacks, function (column, stack) {\n\t                var maxWidth = column.maxWidth;\n\t                if (!column.width && maxWidth && maxWidth < autoWidth) {\n\t                    maxWidth = Math.min(maxWidth, remainedWidth);\n\t                    remainedWidth -= maxWidth;\n\t                    column.width = maxWidth;\n\t                    autoWidthCount--;\n\t                }\n\t            });\n\t            // Recalculate width again\n\t            autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n\t            autoWidth = Math.max(autoWidth, 0);\n\t            var widthSum = 0;\n\t            var lastColumn;\n\t            zrUtil.each(stacks, function (column, idx) {\n\t                if (!column.width) {\n\t                    column.width = autoWidth;\n\t                }\n\t                lastColumn = column;\n\t                widthSum += column.width * (1 + barGapPercent);\n\t            });\n\t            if (lastColumn) {\n\t                widthSum -= lastColumn.width * barGapPercent;\n\t            }\n\t            var offset = -widthSum / 2;\n\t            zrUtil.each(stacks, function (column, stackId) {\n\t                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n\t                    offset: offset,\n\t                    width: column.width\n\t                };\n\t                offset += column.width * (1 + barGapPercent);\n\t            });\n\t        });\n\t        return result;\n\t    }\n\t    /**\n\t     * @param {string} seriesType\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    function barLayoutGrid(seriesType, ecModel, api) {\n\t        var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n\t                return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n\t            }));\n\t        var lastStackCoords = {};\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t            var cartesian = seriesModel.coordinateSystem;\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var stackId = getSeriesStackId(seriesModel);\n\t            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n\t            var columnOffset = columnLayoutInfo.offset;\n\t            var columnWidth = columnLayoutInfo.width;\n\t            var valueAxis = cartesian.getOtherAxis(baseAxis);\n\t            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n\t            var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];\n\t            var coords = cartesian.dataToPoints(data, true);\n\t            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n\t            data.setLayout({\n\t                offset: columnOffset,\n\t                size: columnWidth\n\t            });\n\t            data.each(valueAxis.dim, function (value, idx) {\n\t                // 空数据\n\t                if (isNaN(value)) {\n\t                    return;\n\t                }\n\t                if (!lastStackCoords[stackId][idx]) {\n\t                    lastStackCoords[stackId][idx] = {\n\t                        p: valueAxisStart,\n\t                        n: valueAxisStart\n\t                    };\n\t                }\n\t                var sign = value >= 0 ? 'p' : 'n';\n\t                var coord = coords[idx];\n\t                var lastCoord = lastStackCoords[stackId][idx][sign];\n\t                var x, y, width, height;\n\t                if (valueAxis.isHorizontal()) {\n\t                    x = lastCoord;\n\t                    y = coord[1] + columnOffset;\n\t                    width = coord[0] - lastCoord;\n\t                    height = columnWidth;\n\t                    if (Math.abs(width) < barMinHeight) {\n\t                        width = (width < 0 ? -1 : 1) * barMinHeight;\n\t                    }\n\t                    lastStackCoords[stackId][idx][sign] += width;\n\t                } else {\n\t                    x = coord[0] + columnOffset;\n\t                    y = lastCoord;\n\t                    width = columnWidth;\n\t                    height = coord[1] - lastCoord;\n\t                    if (Math.abs(height) < barMinHeight) {\n\t                        // Include zero to has a positive bar\n\t                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n\t                    }\n\t                    lastStackCoords[stackId][idx][sign] += height;\n\t                }\n\t                data.setItemLayout(idx, {\n\t                    x: x,\n\t                    y: y,\n\t                    width: width,\n\t                    height: height\n\t                });\n\t            }, true);\n\t        }, this);\n\t    }\n\t    return barLayoutGrid;\n\t});\n\tdefine('echarts/util/graphic', ['require', 'zrender/core/util', 'zrender/tool/path', 'zrender/graphic/Path', 'zrender/tool/color', 'zrender/core/matrix', 'zrender/core/vector', 'zrender/graphic/Gradient', 'zrender/container/Group', 'zrender/graphic/Image', 'zrender/graphic/Text', 'zrender/graphic/shape/Circle', 'zrender/graphic/shape/Sector', 'zrender/graphic/shape/Ring', 'zrender/graphic/shape/Polygon', 'zrender/graphic/shape/Polyline', 'zrender/graphic/shape/Rect', 'zrender/graphic/shape/Line', 'zrender/graphic/shape/BezierCurve', 'zrender/graphic/shape/Arc', 'zrender/graphic/CompoundPath', 'zrender/graphic/LinearGradient', 'zrender/graphic/RadialGradient', 'zrender/core/BoundingRect'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var pathTool = require('zrender/tool/path');\n\t    var round = Math.round;\n\t    var Path = require('zrender/graphic/Path');\n\t    var colorTool = require('zrender/tool/color');\n\t    var matrix = require('zrender/core/matrix');\n\t    var vector = require('zrender/core/vector');\n\t    var Gradient = require('zrender/graphic/Gradient');\n\t    var graphic = {};\n\t    graphic.Group = require('zrender/container/Group');\n\t    graphic.Image = require('zrender/graphic/Image');\n\t    graphic.Text = require('zrender/graphic/Text');\n\t    graphic.Circle = require('zrender/graphic/shape/Circle');\n\t    graphic.Sector = require('zrender/graphic/shape/Sector');\n\t    graphic.Ring = require('zrender/graphic/shape/Ring');\n\t    graphic.Polygon = require('zrender/graphic/shape/Polygon');\n\t    graphic.Polyline = require('zrender/graphic/shape/Polyline');\n\t    graphic.Rect = require('zrender/graphic/shape/Rect');\n\t    graphic.Line = require('zrender/graphic/shape/Line');\n\t    graphic.BezierCurve = require('zrender/graphic/shape/BezierCurve');\n\t    graphic.Arc = require('zrender/graphic/shape/Arc');\n\t    graphic.CompoundPath = require('zrender/graphic/CompoundPath');\n\t    graphic.LinearGradient = require('zrender/graphic/LinearGradient');\n\t    graphic.RadialGradient = require('zrender/graphic/RadialGradient');\n\t    graphic.BoundingRect = require('zrender/core/BoundingRect');\n\t    /**\n\t     * Extend shape with parameters\n\t     */\n\t    graphic.extendShape = function (opts) {\n\t        return Path.extend(opts);\n\t    };\n\t    /**\n\t     * Extend path\n\t     */\n\t    graphic.extendPath = function (pathData, opts) {\n\t        return pathTool.extendFromString(pathData, opts);\n\t    };\n\t    /**\n\t     * Create a path element from path data string\n\t     * @param {string} pathData\n\t     * @param {Object} opts\n\t     * @param {module:zrender/core/BoundingRect} rect\n\t     * @param {string} [layout=cover] 'center' or 'cover'\n\t     */\n\t    graphic.makePath = function (pathData, opts, rect, layout) {\n\t        var path = pathTool.createFromString(pathData, opts);\n\t        var boundingRect = path.getBoundingRect();\n\t        if (rect) {\n\t            var aspect = boundingRect.width / boundingRect.height;\n\t            if (layout === 'center') {\n\t                // Set rect to center, keep width / height ratio.\n\t                var width = rect.height * aspect;\n\t                var height;\n\t                if (width <= rect.width) {\n\t                    height = rect.height;\n\t                } else {\n\t                    width = rect.width;\n\t                    height = width / aspect;\n\t                }\n\t                var cx = rect.x + rect.width / 2;\n\t                var cy = rect.y + rect.height / 2;\n\t                rect.x = cx - width / 2;\n\t                rect.y = cy - height / 2;\n\t                rect.width = width;\n\t                rect.height = height;\n\t            }\n\t            this.resizePath(path, rect);\n\t        }\n\t        return path;\n\t    };\n\t    graphic.mergePath = pathTool.mergePath, graphic.resizePath = function (path, rect) {\n\t        if (!path.applyTransform) {\n\t            return;\n\t        }\n\t        var pathRect = path.getBoundingRect();\n\t        var m = pathRect.calculateTransform(rect);\n\t        path.applyTransform(m);\n\t    };\n\t    /**\n\t     * Sub pixel optimize line for canvas\n\t     *\n\t     * @param {Object} param\n\t     * @param {Object} [param.shape]\n\t     * @param {number} [param.shape.x1]\n\t     * @param {number} [param.shape.y1]\n\t     * @param {number} [param.shape.x2]\n\t     * @param {number} [param.shape.y2]\n\t     * @param {Object} [param.style]\n\t     * @param {number} [param.style.lineWidth]\n\t     * @return {Object} Modified param\n\t     */\n\t    graphic.subPixelOptimizeLine = function (param) {\n\t        var subPixelOptimize = graphic.subPixelOptimize;\n\t        var shape = param.shape;\n\t        var lineWidth = param.style.lineWidth;\n\t        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n\t            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n\t        }\n\t        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n\t            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n\t        }\n\t        return param;\n\t    };\n\t    /**\n\t     * Sub pixel optimize rect for canvas\n\t     *\n\t     * @param {Object} param\n\t     * @param {Object} [param.shape]\n\t     * @param {number} [param.shape.x]\n\t     * @param {number} [param.shape.y]\n\t     * @param {number} [param.shape.width]\n\t     * @param {number} [param.shape.height]\n\t     * @param {Object} [param.style]\n\t     * @param {number} [param.style.lineWidth]\n\t     * @return {Object} Modified param\n\t     */\n\t    graphic.subPixelOptimizeRect = function (param) {\n\t        var subPixelOptimize = graphic.subPixelOptimize;\n\t        var shape = param.shape;\n\t        var lineWidth = param.style.lineWidth;\n\t        var originX = shape.x;\n\t        var originY = shape.y;\n\t        var originWidth = shape.width;\n\t        var originHeight = shape.height;\n\t        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n\t        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n\t        shape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x, originWidth === 0 ? 0 : 1);\n\t        shape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y, originHeight === 0 ? 0 : 1);\n\t        return param;\n\t    };\n\t    /**\n\t     * Sub pixel optimize for canvas\n\t     *\n\t     * @param {number} position Coordinate, such as x, y\n\t     * @param {number} lineWidth Should be nonnegative integer.\n\t     * @param {boolean=} positiveOrNegative Default false (negative).\n\t     * @return {number} Optimized position.\n\t     */\n\t    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n\t        // Assure that (position + lineWidth / 2) is near integer edge,\n\t        // otherwise line will be fuzzy in canvas.\n\t        var doubledPosition = round(position * 2);\n\t        return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n\t    };\n\t    function hasFillOrStroke(fillOrStroke) {\n\t        return fillOrStroke != null && fillOrStroke != 'none';\n\t    }\n\t    function liftColor(color) {\n\t        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n\t    }\n\t    /**\n\t     * @private\n\t     */\n\t    function cacheElementStl(el) {\n\t        if (el.__hoverStlDirty) {\n\t            var stroke = el.style.stroke;\n\t            var fill = el.style.fill;\n\t            // Create hoverStyle on mouseover\n\t            var hoverStyle = el.__hoverStl;\n\t            hoverStyle.fill = hoverStyle.fill || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n\t            hoverStyle.stroke = hoverStyle.stroke || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\t            var normalStyle = {};\n\t            for (var name in hoverStyle) {\n\t                if (hoverStyle.hasOwnProperty(name)) {\n\t                    normalStyle[name] = el.style[name];\n\t                }\n\t            }\n\t            el.__normalStl = normalStyle;\n\t            el.__hoverStlDirty = false;\n\t        }\n\t    }\n\t    /**\n\t     * @private\n\t     */\n\t    function doSingleEnterHover(el) {\n\t        if (el.__isHover) {\n\t            return;\n\t        }\n\t        cacheElementStl(el);\n\t        if (el.useHoverLayer) {\n\t            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n\t        } else {\n\t            el.setStyle(el.__hoverStl);\n\t            el.z2 += 1;\n\t        }\n\t        el.__isHover = true;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function doSingleLeaveHover(el) {\n\t        if (!el.__isHover) {\n\t            return;\n\t        }\n\t        var normalStl = el.__normalStl;\n\t        if (el.useHoverLayer) {\n\t            el.__zr && el.__zr.removeHover(el);\n\t        } else {\n\t            normalStl && el.setStyle(normalStl);\n\t            el.z2 -= 1;\n\t        }\n\t        el.__isHover = false;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function doEnterHover(el) {\n\t        el.type === 'group' ? el.traverse(function (child) {\n\t            if (child.type !== 'group') {\n\t                doSingleEnterHover(child);\n\t            }\n\t        }) : doSingleEnterHover(el);\n\t    }\n\t    function doLeaveHover(el) {\n\t        el.type === 'group' ? el.traverse(function (child) {\n\t            if (child.type !== 'group') {\n\t                doSingleLeaveHover(child);\n\t            }\n\t        }) : doSingleLeaveHover(el);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function setElementHoverStl(el, hoverStl) {\n\t        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n\t        // Often used when item group has a label element and it's hoverStyle is different\n\t        el.__hoverStl = el.hoverStyle || hoverStl || {};\n\t        el.__hoverStlDirty = true;\n\t        if (el.__isHover) {\n\t            cacheElementStl(el);\n\t        }\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function onElementMouseOver() {\n\t        // Only if element is not in emphasis status\n\t        !this.__isEmphasis && doEnterHover(this);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function onElementMouseOut() {\n\t        // Only if element is not in emphasis status\n\t        !this.__isEmphasis && doLeaveHover(this);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function enterEmphasis() {\n\t        this.__isEmphasis = true;\n\t        doEnterHover(this);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function leaveEmphasis() {\n\t        this.__isEmphasis = false;\n\t        doLeaveHover(this);\n\t    }\n\t    /**\n\t     * Set hover style of element\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} [hoverStyle]\n\t     */\n\t    graphic.setHoverStyle = function (el, hoverStyle) {\n\t        el.type === 'group' ? el.traverse(function (child) {\n\t            if (child.type !== 'group') {\n\t                setElementHoverStl(child, hoverStyle);\n\t            }\n\t        }) : setElementHoverStl(el, hoverStyle);\n\t        // Remove previous bound handlers\n\t        el.on('mouseover', onElementMouseOver).on('mouseout', onElementMouseOut);\n\t        // Emphasis, normal can be triggered manually\n\t        el.on('emphasis', enterEmphasis).on('normal', leaveEmphasis);\n\t    };\n\t    /**\n\t     * Set text option in the style\n\t     * @param {Object} textStyle\n\t     * @param {module:echarts/model/Model} labelModel\n\t     * @param {string} color\n\t     */\n\t    graphic.setText = function (textStyle, labelModel, color) {\n\t        var labelPosition = labelModel.getShallow('position') || 'inside';\n\t        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n\t        var textStyleModel = labelModel.getModel('textStyle');\n\t        zrUtil.extend(textStyle, {\n\t            textDistance: labelModel.getShallow('distance') || 5,\n\t            textFont: textStyleModel.getFont(),\n\t            textPosition: labelPosition,\n\t            textFill: textStyleModel.getTextColor() || labelColor\n\t        });\n\t    };\n\t    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n\t        if (typeof dataIndex === 'function') {\n\t            cb = dataIndex;\n\t            dataIndex = null;\n\t        }\n\t        var animationEnabled = animatableModel && (animatableModel.ifEnableAnimation ? animatableModel.ifEnableAnimation() : animatableModel.getShallow('animation'));\n\t        if (animationEnabled) {\n\t            var postfix = isUpdate ? 'Update' : '';\n\t            var duration = animatableModel && animatableModel.getShallow('animationDuration' + postfix);\n\t            var animationEasing = animatableModel && animatableModel.getShallow('animationEasing' + postfix);\n\t            var animationDelay = animatableModel && animatableModel.getShallow('animationDelay' + postfix);\n\t            if (typeof animationDelay === 'function') {\n\t                animationDelay = animationDelay(dataIndex);\n\t            }\n\t            duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb) : (el.attr(props), cb && cb());\n\t        } else {\n\t            el.attr(props);\n\t            cb && cb();\n\t        }\n\t    }\n\t    /**\n\t     * Update graphic element properties with or without animation according to the configuration in series\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} props\n\t     * @param {module:echarts/model/Model} [animatableModel]\n\t     * @param {number} [dataIndex]\n\t     * @param {Function} [cb]\n\t     * @example\n\t     *     graphic.updateProps(el, {\n\t     *         position: [100, 100]\n\t     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n\t     *     // Or\n\t     *     graphic.updateProps(el, {\n\t     *         position: [100, 100]\n\t     *     }, seriesModel, function () { console.log('Animation done!'); });\n\t     */\n\t    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n\t        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n\t    };\n\t    /**\n\t     * Init graphic element properties with or without animation according to the configuration in series\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} props\n\t     * @param {module:echarts/model/Model} [animatableModel]\n\t     * @param {number} [dataIndex]\n\t     * @param {Function} cb\n\t     */\n\t    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n\t        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n\t    };\n\t    /**\n\t     * Get transform matrix of target (param target),\n\t     * in coordinate of its ancestor (param ancestor)\n\t     *\n\t     * @param {module:zrender/mixin/Transformable} target\n\t     * @param {module:zrender/mixin/Transformable} [ancestor]\n\t     */\n\t    graphic.getTransform = function (target, ancestor) {\n\t        var mat = matrix.identity([]);\n\t        while (target && target !== ancestor) {\n\t            matrix.mul(mat, target.getLocalTransform(), mat);\n\t            target = target.parent;\n\t        }\n\t        return mat;\n\t    };\n\t    /**\n\t     * Apply transform to an vertex.\n\t     * @param {Array.<number>} vertex [x, y]\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n\t     * @param {boolean=} invert Whether use invert matrix.\n\t     * @return {Array.<number>} [x, y]\n\t     */\n\t    graphic.applyTransform = function (vertex, transform, invert) {\n\t        if (invert) {\n\t            transform = matrix.invert([], transform);\n\t        }\n\t        return vector.applyTransform([], vertex, transform);\n\t    };\n\t    /**\n\t     * @param {string} direction 'left' 'right' 'top' 'bottom'\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n\t     * @param {boolean=} invert Whether use invert matrix.\n\t     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n\t     */\n\t    graphic.transformDirection = function (direction, transform, invert) {\n\t        // Pick a base, ensure that transform result will not be (0, 0).\n\t        var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);\n\t        var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\t        var vertex = [\n\t                direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n\t                direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n\t            ];\n\t        vertex = graphic.applyTransform(vertex, transform, invert);\n\t        return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n\t    };\n\t    /**\n\t     * Apply group transition animation from g1 to g2\n\t     */\n\t    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n\t        if (!g1 || !g2) {\n\t            return;\n\t        }\n\t        function getElMap(g) {\n\t            var elMap = {};\n\t            g.traverse(function (el) {\n\t                if (!el.isGroup && el.anid) {\n\t                    elMap[el.anid] = el;\n\t                }\n\t            });\n\t            return elMap;\n\t        }\n\t        function getAnimatableProps(el) {\n\t            var obj = {\n\t                    position: vector.clone(el.position),\n\t                    rotation: el.rotation\n\t                };\n\t            if (el.shape) {\n\t                obj.shape = zrUtil.extend({}, el.shape);\n\t            }\n\t            return obj;\n\t        }\n\t        var elMap1 = getElMap(g1);\n\t        g2.traverse(function (el) {\n\t            if (!el.isGroup && el.anid) {\n\t                var oldEl = elMap1[el.anid];\n\t                if (oldEl) {\n\t                    var newProp = getAnimatableProps(el);\n\t                    el.attr(getAnimatableProps(oldEl));\n\t                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n\t                }    // else {\n\t                     //     if (el.previousProps) {\n\t                     //         graphic.updateProps\n\t                     //     }\n\t                     // }\n\t            }\n\t        });\n\t    };\n\t    return graphic;\n\t});\n\tdefine('echarts/component/axis', ['require', '../coord/cartesian/AxisModel', './axis/AxisView'], function (require) {\n\t    'use strict';\n\t    require('../coord/cartesian/AxisModel');\n\t    require('./axis/AxisView');\n\t});\n\tdefine('echarts/util/layout', ['require', 'zrender/core/util', 'zrender/core/BoundingRect', './number', './format'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var BoundingRect = require('zrender/core/BoundingRect');\n\t    var numberUtil = require('./number');\n\t    var formatUtil = require('./format');\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var each = zrUtil.each;\n\t    var layout = {};\n\t    var LOCATION_PARAMS = [\n\t            'left',\n\t            'right',\n\t            'top',\n\t            'bottom',\n\t            'width',\n\t            'height'\n\t        ];\n\t    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n\t        var x = 0;\n\t        var y = 0;\n\t        if (maxWidth == null) {\n\t            maxWidth = Infinity;\n\t        }\n\t        if (maxHeight == null) {\n\t            maxHeight = Infinity;\n\t        }\n\t        var currentLineMaxSize = 0;\n\t        group.eachChild(function (child, idx) {\n\t            var position = child.position;\n\t            var rect = child.getBoundingRect();\n\t            var nextChild = group.childAt(idx + 1);\n\t            var nextChildRect = nextChild && nextChild.getBoundingRect();\n\t            var nextX;\n\t            var nextY;\n\t            if (orient === 'horizontal') {\n\t                var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n\t                nextX = x + moveX;\n\t                // Wrap when width exceeds maxWidth or meet a `newline` group\n\t                if (nextX > maxWidth || child.newline) {\n\t                    x = 0;\n\t                    nextX = moveX;\n\t                    y += currentLineMaxSize + gap;\n\t                    currentLineMaxSize = rect.height;\n\t                } else {\n\t                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n\t                }\n\t            } else {\n\t                var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n\t                nextY = y + moveY;\n\t                // Wrap when width exceeds maxHeight or meet a `newline` group\n\t                if (nextY > maxHeight || child.newline) {\n\t                    x += currentLineMaxSize + gap;\n\t                    y = 0;\n\t                    nextY = moveY;\n\t                    currentLineMaxSize = rect.width;\n\t                } else {\n\t                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n\t                }\n\t            }\n\t            if (child.newline) {\n\t                return;\n\t            }\n\t            position[0] = x;\n\t            position[1] = y;\n\t            orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n\t        });\n\t    }\n\t    /**\n\t     * VBox or HBox layouting\n\t     * @param {string} orient\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.box = boxLayout;\n\t    /**\n\t     * VBox layouting\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\t    /**\n\t     * HBox layouting\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\t    /**\n\t     * If x or x2 is not specified or 'center' 'left' 'right',\n\t     * the width would be as long as possible.\n\t     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n\t     * the height would be as long as possible.\n\t     *\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.x]\n\t     * @param {number|string} [positionInfo.y]\n\t     * @param {number|string} [positionInfo.x2]\n\t     * @param {number|string} [positionInfo.y2]\n\t     * @param {Object} containerRect\n\t     * @param {string|number} margin\n\t     * @return {Object} {width, height}\n\t     */\n\t    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n\t        var containerWidth = containerRect.width;\n\t        var containerHeight = containerRect.height;\n\t        var x = parsePercent(positionInfo.x, containerWidth);\n\t        var y = parsePercent(positionInfo.y, containerHeight);\n\t        var x2 = parsePercent(positionInfo.x2, containerWidth);\n\t        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\t        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n\t        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n\t        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n\t        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\t        margin = formatUtil.normalizeCssArray(margin || 0);\n\t        return {\n\t            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n\t            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n\t        };\n\t    };\n\t    /**\n\t     * Parse position info.\n\t     *\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.left]\n\t     * @param {number|string} [positionInfo.top]\n\t     * @param {number|string} [positionInfo.right]\n\t     * @param {number|string} [positionInfo.bottom]\n\t     * @param {number|string} [positionInfo.width]\n\t     * @param {number|string} [positionInfo.height]\n\t     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n\t     * @param {Object} containerRect\n\t     * @param {string|number} [margin]\n\t     *\n\t     * @return {module:zrender/core/BoundingRect}\n\t     */\n\t    layout.getLayoutRect = function (positionInfo, containerRect, margin) {\n\t        margin = formatUtil.normalizeCssArray(margin || 0);\n\t        var containerWidth = containerRect.width;\n\t        var containerHeight = containerRect.height;\n\t        var left = parsePercent(positionInfo.left, containerWidth);\n\t        var top = parsePercent(positionInfo.top, containerHeight);\n\t        var right = parsePercent(positionInfo.right, containerWidth);\n\t        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n\t        var width = parsePercent(positionInfo.width, containerWidth);\n\t        var height = parsePercent(positionInfo.height, containerHeight);\n\t        var verticalMargin = margin[2] + margin[0];\n\t        var horizontalMargin = margin[1] + margin[3];\n\t        var aspect = positionInfo.aspect;\n\t        // If width is not specified, calculate width from left and right\n\t        if (isNaN(width)) {\n\t            width = containerWidth - right - horizontalMargin - left;\n\t        }\n\t        if (isNaN(height)) {\n\t            height = containerHeight - bottom - verticalMargin - top;\n\t        }\n\t        // If width and height are not given\n\t        // 1. Graph should not exceeds the container\n\t        // 2. Aspect must be keeped\n\t        // 3. Graph should take the space as more as possible\n\t        if (isNaN(width) && isNaN(height)) {\n\t            if (aspect > containerWidth / containerHeight) {\n\t                width = containerWidth * 0.8;\n\t            } else {\n\t                height = containerHeight * 0.8;\n\t            }\n\t        }\n\t        if (aspect != null) {\n\t            // Calculate width or height with given aspect\n\t            if (isNaN(width)) {\n\t                width = aspect * height;\n\t            }\n\t            if (isNaN(height)) {\n\t                height = width / aspect;\n\t            }\n\t        }\n\t        // If left is not specified, calculate left from right and width\n\t        if (isNaN(left)) {\n\t            left = containerWidth - right - width - horizontalMargin;\n\t        }\n\t        if (isNaN(top)) {\n\t            top = containerHeight - bottom - height - verticalMargin;\n\t        }\n\t        // Align left and top\n\t        switch (positionInfo.left || positionInfo.right) {\n\t        case 'center':\n\t            left = containerWidth / 2 - width / 2 - margin[3];\n\t            break;\n\t        case 'right':\n\t            left = containerWidth - width - horizontalMargin;\n\t            break;\n\t        }\n\t        switch (positionInfo.top || positionInfo.bottom) {\n\t        case 'middle':\n\t        case 'center':\n\t            top = containerHeight / 2 - height / 2 - margin[0];\n\t            break;\n\t        case 'bottom':\n\t            top = containerHeight - height - verticalMargin;\n\t            break;\n\t        }\n\t        // If something is wrong and left, top, width, height are calculated as NaN\n\t        left = left || 0;\n\t        top = top || 0;\n\t        if (isNaN(width)) {\n\t            // Width may be NaN if only one value is given except width\n\t            width = containerWidth - left - (right || 0);\n\t        }\n\t        if (isNaN(height)) {\n\t            // Height may be NaN if only one value is given except height\n\t            height = containerHeight - top - (bottom || 0);\n\t        }\n\t        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n\t        rect.margin = margin;\n\t        return rect;\n\t    };\n\t    /**\n\t     * Position group of component in viewport\n\t     *  Group position is specified by either\n\t     *  {left, top}, {right, bottom}\n\t     *  If all properties exists, right and bottom will be igonred.\n\t     *\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.left]\n\t     * @param {number|string} [positionInfo.top]\n\t     * @param {number|string} [positionInfo.right]\n\t     * @param {number|string} [positionInfo.bottom]\n\t     * @param {Object} containerRect\n\t     * @param {string|number} margin\n\t     */\n\t    layout.positionGroup = function (group, positionInfo, containerRect, margin) {\n\t        var groupRect = group.getBoundingRect();\n\t        positionInfo = zrUtil.extend(zrUtil.clone(positionInfo), {\n\t            width: groupRect.width,\n\t            height: groupRect.height\n\t        });\n\t        positionInfo = layout.getLayoutRect(positionInfo, containerRect, margin);\n\t        group.attr('position', [\n\t            positionInfo.x - groupRect.x,\n\t            positionInfo.y - groupRect.y\n\t        ]);\n\t    };\n\t    /**\n\t     * Consider Case:\n\t     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n\t     * through setOption or media query, using normal zrUtil.merge will cause\n\t     * {right: 0} does not take effect.\n\t     *\n\t     * @example\n\t     * ComponentModel.extend({\n\t     *     init: function () {\n\t     *         ...\n\t     *         var inputPositionParams = layout.getLayoutParams(option);\n\t     *         this.mergeOption(inputPositionParams);\n\t     *     },\n\t     *     mergeOption: function (newOption) {\n\t     *         newOption && zrUtil.merge(thisOption, newOption, true);\n\t     *         layout.mergeLayoutParam(thisOption, newOption);\n\t     *     }\n\t     * });\n\t     *\n\t     * @param {Object} targetOption\n\t     * @param {Object} newOption\n\t     * @param {Object|string} [opt]\n\t     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.\n\t     */\n\t    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n\t        !zrUtil.isObject(opt) && (opt = {});\n\t        var hNames = [\n\t                'width',\n\t                'left',\n\t                'right'\n\t            ];\n\t        // Order by priority.\n\t        var vNames = [\n\t                'height',\n\t                'top',\n\t                'bottom'\n\t            ];\n\t        // Order by priority.\n\t        var hResult = merge(hNames);\n\t        var vResult = merge(vNames);\n\t        copy(hNames, targetOption, hResult);\n\t        copy(vNames, targetOption, vResult);\n\t        function merge(names) {\n\t            var newParams = {};\n\t            var newValueCount = 0;\n\t            var merged = {};\n\t            var mergedValueCount = 0;\n\t            var enoughParamNumber = opt.ignoreSize ? 1 : 2;\n\t            each(names, function (name) {\n\t                merged[name] = targetOption[name];\n\t            });\n\t            each(names, function (name) {\n\t                // Consider case: newOption.width is null, which is\n\t                // set by user for removing width setting.\n\t                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n\t                hasValue(newParams, name) && newValueCount++;\n\t                hasValue(merged, name) && mergedValueCount++;\n\t            });\n\t            // Case: newOption: {width: ..., right: ...},\n\t            // or targetOption: {right: ...} and newOption: {width: ...},\n\t            // There is no conflict when merged only has params count\n\t            // little than enoughParamNumber.\n\t            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n\t                return merged;\n\t            }    // Case: newOption: {width: ..., right: ...},\n\t                 // Than we can make sure user only want those two, and ignore\n\t                 // all origin params in targetOption.\n\t            else if (newValueCount >= enoughParamNumber) {\n\t                return newParams;\n\t            } else {\n\t                // Chose another param from targetOption by priority.\n\t                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.\n\t                for (var i = 0; i < names.length; i++) {\n\t                    var name = names[i];\n\t                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n\t                        newParams[name] = targetOption[name];\n\t                        break;\n\t                    }\n\t                }\n\t                return newParams;\n\t            }\n\t        }\n\t        function hasProp(obj, name) {\n\t            return obj.hasOwnProperty(name);\n\t        }\n\t        function hasValue(obj, name) {\n\t            return obj[name] != null && obj[name] !== 'auto';\n\t        }\n\t        function copy(names, target, source) {\n\t            each(names, function (name) {\n\t                target[name] = source[name];\n\t            });\n\t        }\n\t    };\n\t    /**\n\t     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n\t     * @param {Object} source\n\t     * @return {Object} Result contains those props.\n\t     */\n\t    layout.getLayoutParams = function (source) {\n\t        return layout.copyLayoutParams({}, source);\n\t    };\n\t    /**\n\t     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n\t     * @param {Object} source\n\t     * @return {Object} Result contains those props.\n\t     */\n\t    layout.copyLayoutParams = function (target, source) {\n\t        source && target && each(LOCATION_PARAMS, function (name) {\n\t            source.hasOwnProperty(name) && (target[name] = source[name]);\n\t        });\n\t        return target;\n\t    };\n\t    return layout;\n\t});\n\tdefine('echarts/util/number', ['require'], function (require) {\n\t    var number = {};\n\t    var RADIAN_EPSILON = 0.0001;\n\t    function _trim(str) {\n\t        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n\t    }\n\t    /**\n\t     * Linear mapping a value from domain to range\n\t     * @memberOf module:echarts/util/number\n\t     * @param  {(number|Array.<number>)} val\n\t     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n\t     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n\t     * @param  {boolean} clamp\n\t     * @return {(number|Array.<number>}\n\t     */\n\t    number.linearMap = function (val, domain, range, clamp) {\n\t        var subDomain = domain[1] - domain[0];\n\t        var subRange = range[1] - range[0];\n\t        if (subDomain === 0) {\n\t            return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;\n\t        }\n\t        // Avoid accuracy problem in edge, such as\n\t        // 146.39 - 62.83 === 83.55999999999999.\n\t        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n\t        // It is a little verbose for efficiency considering this method\n\t        // is a hotspot.\n\t        if (clamp) {\n\t            if (subDomain > 0) {\n\t                if (val <= domain[0]) {\n\t                    return range[0];\n\t                } else if (val >= domain[1]) {\n\t                    return range[1];\n\t                }\n\t            } else {\n\t                if (val >= domain[0]) {\n\t                    return range[0];\n\t                } else if (val <= domain[1]) {\n\t                    return range[1];\n\t                }\n\t            }\n\t        } else {\n\t            if (val === domain[0]) {\n\t                return range[0];\n\t            }\n\t            if (val === domain[1]) {\n\t                return range[1];\n\t            }\n\t        }\n\t        return (val - domain[0]) / subDomain * subRange + range[0];\n\t    };\n\t    /**\n\t     * Convert a percent string to absolute number.\n\t     * Returns NaN if percent is not a valid string or number\n\t     * @memberOf module:echarts/util/number\n\t     * @param {string|number} percent\n\t     * @param {number} all\n\t     * @return {number}\n\t     */\n\t    number.parsePercent = function (percent, all) {\n\t        switch (percent) {\n\t        case 'center':\n\t        case 'middle':\n\t            percent = '50%';\n\t            break;\n\t        case 'left':\n\t        case 'top':\n\t            percent = '0%';\n\t            break;\n\t        case 'right':\n\t        case 'bottom':\n\t            percent = '100%';\n\t            break;\n\t        }\n\t        if (typeof percent === 'string') {\n\t            if (_trim(percent).match(/%$/)) {\n\t                return parseFloat(percent) / 100 * all;\n\t            }\n\t            return parseFloat(percent);\n\t        }\n\t        return percent == null ? NaN : +percent;\n\t    };\n\t    /**\n\t     * Fix rounding error of float numbers\n\t     * @param {number} x\n\t     * @return {number}\n\t     */\n\t    number.round = function (x, precision) {\n\t        if (precision == null) {\n\t            precision = 10;\n\t        }\n\t        // PENDING\n\t        return +(+x).toFixed(precision);\n\t    };\n\t    number.asc = function (arr) {\n\t        arr.sort(function (a, b) {\n\t            return a - b;\n\t        });\n\t        return arr;\n\t    };\n\t    /**\n\t     * Get precision\n\t     * @param {number} val\n\t     */\n\t    number.getPrecision = function (val) {\n\t        val = +val;\n\t        if (isNaN(val)) {\n\t            return 0;\n\t        }\n\t        // It is much faster than methods converting number to string as follows\n\t        //      var tmp = val.toString();\n\t        //      return tmp.length - 1 - tmp.indexOf('.');\n\t        // especially when precision is low\n\t        var e = 1;\n\t        var count = 0;\n\t        while (Math.round(val * e) / e !== val) {\n\t            e *= 10;\n\t            count++;\n\t        }\n\t        return count;\n\t    };\n\t    number.getPrecisionSafe = function (val) {\n\t        var str = val.toString();\n\t        var dotIndex = str.indexOf('.');\n\t        if (dotIndex < 0) {\n\t            return 0;\n\t        }\n\t        return str.length - 1 - dotIndex;\n\t    };\n\t    /**\n\t     * @param {Array.<number>} dataExtent\n\t     * @param {Array.<number>} pixelExtent\n\t     * @return {number}  precision\n\t     */\n\t    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n\t        var log = Math.log;\n\t        var LN10 = Math.LN10;\n\t        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n\t        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n\t        return Math.max(-dataQuantity + sizeQuantity, 0);\n\t    };\n\t    // Number.MAX_SAFE_INTEGER, ie do not support.\n\t    number.MAX_SAFE_INTEGER = 9007199254740991;\n\t    /**\n\t     * To 0 - 2 * PI, considering negative radian.\n\t     * @param {number} radian\n\t     * @return {number}\n\t     */\n\t    number.remRadian = function (radian) {\n\t        var pi2 = Math.PI * 2;\n\t        return (radian % pi2 + pi2) % pi2;\n\t    };\n\t    /**\n\t     * @param {type} radian\n\t     * @return {boolean}\n\t     */\n\t    number.isRadianAroundZero = function (val) {\n\t        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n\t    };\n\t    /**\n\t     * @param {string|Date|number} value\n\t     * @return {Date} date\n\t     */\n\t    number.parseDate = function (value) {\n\t        if (value instanceof Date) {\n\t            return value;\n\t        } else if (typeof value === 'string') {\n\t            // Treat as ISO format. See issue #3623\n\t            var ret = new Date(value);\n\t            if (isNaN(+ret)) {\n\t                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local\n\t                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));\n\t            }\n\t            return ret;\n\t        }\n\t        return new Date(Math.round(value));\n\t    };\n\t    /**\n\t     * Quantity of a number. e.g. 0.1, 1, 10, 100\n\t     * @param  {number} val\n\t     * @return {number}\n\t     */\n\t    number.quantity = function (val) {\n\t        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));\n\t    };\n\t    // \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t    /**\n\t     * find a “nice” number approximately equal to x. Round the number if round = true, take ceiling if round = false\n\t     * The primary observation is that the “nicest” numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n\t     * @param  {number} val\n\t     * @param  {boolean} round\n\t     * @return {number}\n\t     */\n\t    number.nice = function (val, round) {\n\t        var exp10 = number.quantity(val);\n\t        var f = val / exp10;\n\t        // between 1 and 10\n\t        var nf;\n\t        if (round) {\n\t            if (f < 1.5) {\n\t                nf = 1;\n\t            } else if (f < 2.5) {\n\t                nf = 2;\n\t            } else if (f < 4) {\n\t                nf = 3;\n\t            } else if (f < 7) {\n\t                nf = 5;\n\t            } else {\n\t                nf = 10;\n\t            }\n\t        } else {\n\t            if (f < 1) {\n\t                nf = 1;\n\t            } else if (f < 2) {\n\t                nf = 2;\n\t            } else if (f < 3) {\n\t                nf = 3;\n\t            } else if (f < 5) {\n\t                nf = 5;\n\t            } else {\n\t                nf = 10;\n\t            }\n\t        }\n\t        return nf * exp10;\n\t    };\n\t    return number;\n\t});\n\tdefine('echarts/util/format', ['require', 'zrender/core/util', './number', 'zrender/contain/text'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var numberUtil = require('./number');\n\t    var textContain = require('zrender/contain/text');\n\t    var formatUtil = {};\n\t    /**\n\t     * 每三位默认加,格式化\n\t     * @type {string|number} x\n\t     */\n\t    formatUtil.addCommas = function (x) {\n\t        if (isNaN(x)) {\n\t            return '-';\n\t        }\n\t        x = (x + '').split('.');\n\t        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g, '$1,') + (x.length > 1 ? '.' + x[1] : '');\n\t    };\n\t    /**\n\t     * @param {string} str\n\t     * @return {string} str\n\t     */\n\t    formatUtil.toCamelCase = function (str) {\n\t        return str.toLowerCase().replace(/-(.)/g, function (match, group1) {\n\t            return group1.toUpperCase();\n\t        });\n\t    };\n\t    /**\n\t     * Normalize css liked array configuration\n\t     * e.g.\n\t     *  3 => [3, 3, 3, 3]\n\t     *  [4, 2] => [4, 2, 4, 2]\n\t     *  [4, 3, 2] => [4, 3, 2, 3]\n\t     * @param {number|Array.<number>} val\n\t     */\n\t    formatUtil.normalizeCssArray = function (val) {\n\t        var len = val.length;\n\t        if (typeof val === 'number') {\n\t            return [\n\t                val,\n\t                val,\n\t                val,\n\t                val\n\t            ];\n\t        } else if (len === 2) {\n\t            // vertical | horizontal\n\t            return [\n\t                val[0],\n\t                val[1],\n\t                val[0],\n\t                val[1]\n\t            ];\n\t        } else if (len === 3) {\n\t            // top | horizontal | bottom\n\t            return [\n\t                val[0],\n\t                val[1],\n\t                val[2],\n\t                val[1]\n\t            ];\n\t        }\n\t        return val;\n\t    };\n\t    formatUtil.encodeHTML = function (source) {\n\t        return String(source).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;');\n\t    };\n\t    var TPL_VAR_ALIAS = [\n\t            'a',\n\t            'b',\n\t            'c',\n\t            'd',\n\t            'e',\n\t            'f',\n\t            'g'\n\t        ];\n\t    var wrapVar = function (varName, seriesIdx) {\n\t        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n\t    };\n\t    /**\n\t     * Template formatter\n\t     * @param  {string} tpl\n\t     * @param  {Array.<Object>|Object} paramsList\n\t     * @return {string}\n\t     */\n\t    formatUtil.formatTpl = function (tpl, paramsList) {\n\t        if (!zrUtil.isArray(paramsList)) {\n\t            paramsList = [paramsList];\n\t        }\n\t        var seriesLen = paramsList.length;\n\t        if (!seriesLen) {\n\t            return '';\n\t        }\n\t        var $vars = paramsList[0].$vars || [];\n\t        for (var i = 0; i < $vars.length; i++) {\n\t            var alias = TPL_VAR_ALIAS[i];\n\t            tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));\n\t        }\n\t        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n\t            for (var k = 0; k < $vars.length; k++) {\n\t                tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), paramsList[seriesIdx][$vars[k]]);\n\t            }\n\t        }\n\t        return tpl;\n\t    };\n\t    /**\n\t     * @param {string} str\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    var s2d = function (str) {\n\t        return str < 10 ? '0' + str : str;\n\t    };\n\t    /**\n\t     * ISO Date format\n\t     * @param {string} tpl\n\t     * @param {number} value\n\t     * @inner\n\t     */\n\t    formatUtil.formatTime = function (tpl, value) {\n\t        if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {\n\t            tpl = 'MM-dd\\nyyyy';\n\t        }\n\t        var date = numberUtil.parseDate(value);\n\t        var y = date.getFullYear();\n\t        var M = date.getMonth() + 1;\n\t        var d = date.getDate();\n\t        var h = date.getHours();\n\t        var m = date.getMinutes();\n\t        var s = date.getSeconds();\n\t        tpl = tpl.replace('MM', s2d(M)).toLowerCase().replace('yyyy', y).replace('yy', y % 100).replace('dd', s2d(d)).replace('d', d).replace('hh', s2d(h)).replace('h', h).replace('mm', s2d(m)).replace('m', m).replace('ss', s2d(s)).replace('s', s);\n\t        return tpl;\n\t    };\n\t    /**\n\t     * Capital first\n\t     * @param {string} str\n\t     * @return {string}\n\t     */\n\t    formatUtil.capitalFirst = function (str) {\n\t        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n\t    };\n\t    formatUtil.truncateText = textContain.truncateText;\n\t    return formatUtil;\n\t});\n\tdefine('echarts/scale/Interval', ['require', '../util/number', '../util/format', './Scale'], function (require) {\n\t    var numberUtil = require('../util/number');\n\t    var formatUtil = require('../util/format');\n\t    var Scale = require('./Scale');\n\t    var mathFloor = Math.floor;\n\t    var mathCeil = Math.ceil;\n\t    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n\t    var roundingErrorFix = numberUtil.round;\n\t    /**\n\t     * @alias module:echarts/coord/scale/Interval\n\t     * @constructor\n\t     */\n\t    var IntervalScale = Scale.extend({\n\t            type: 'interval',\n\t            _interval: 0,\n\t            setExtent: function (start, end) {\n\t                var thisExtent = this._extent;\n\t                //start,end may be a Number like '25',so...\n\t                if (!isNaN(start)) {\n\t                    thisExtent[0] = parseFloat(start);\n\t                }\n\t                if (!isNaN(end)) {\n\t                    thisExtent[1] = parseFloat(end);\n\t                }\n\t            },\n\t            unionExtent: function (other) {\n\t                var extent = this._extent;\n\t                other[0] < extent[0] && (extent[0] = other[0]);\n\t                other[1] > extent[1] && (extent[1] = other[1]);\n\t                // unionExtent may called by it's sub classes\n\t                IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n\t            },\n\t            getInterval: function () {\n\t                if (!this._interval) {\n\t                    this.niceTicks();\n\t                }\n\t                return this._interval;\n\t            },\n\t            setInterval: function (interval) {\n\t                this._interval = interval;\n\t                // Dropped auto calculated niceExtent and use user setted extent\n\t                // We assume user wan't to set both interval, min, max to get a better result\n\t                this._niceExtent = this._extent.slice();\n\t            },\n\t            getTicks: function () {\n\t                if (!this._interval) {\n\t                    this.niceTicks();\n\t                }\n\t                var interval = this._interval;\n\t                var extent = this._extent;\n\t                var ticks = [];\n\t                // Consider this case: using dataZoom toolbox, zoom and zoom.\n\t                var safeLimit = 10000;\n\t                if (interval) {\n\t                    var niceExtent = this._niceExtent;\n\t                    var precision = getPrecisionSafe(interval) + 2;\n\t                    if (extent[0] < niceExtent[0]) {\n\t                        ticks.push(extent[0]);\n\t                    }\n\t                    var tick = niceExtent[0];\n\t                    while (tick <= niceExtent[1]) {\n\t                        ticks.push(tick);\n\t                        // Avoid rounding error\n\t                        tick = roundingErrorFix(tick + interval, precision);\n\t                        if (ticks.length > safeLimit) {\n\t                            return [];\n\t                        }\n\t                    }\n\t                    if (extent[1] > niceExtent[1]) {\n\t                        ticks.push(extent[1]);\n\t                    }\n\t                }\n\t                return ticks;\n\t            },\n\t            getTicksLabels: function () {\n\t                var labels = [];\n\t                var ticks = this.getTicks();\n\t                for (var i = 0; i < ticks.length; i++) {\n\t                    labels.push(this.getLabel(ticks[i]));\n\t                }\n\t                return labels;\n\t            },\n\t            getLabel: function (data) {\n\t                return formatUtil.addCommas(data);\n\t            },\n\t            niceTicks: function (splitNumber) {\n\t                splitNumber = splitNumber || 5;\n\t                var extent = this._extent;\n\t                var span = extent[1] - extent[0];\n\t                if (!isFinite(span)) {\n\t                    return;\n\t                }\n\t                // User may set axis min 0 and data are all negative\n\t                // FIXME If it needs to reverse ?\n\t                if (span < 0) {\n\t                    span = -span;\n\t                    extent.reverse();\n\t                }\n\t                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t                // var niceSpan = numberUtil.nice(span, false);\n\t                var step = roundingErrorFix(numberUtil.nice(span / splitNumber, true), Math.max(getPrecisionSafe(extent[0]), getPrecisionSafe(extent[1])) + 2);\n\t                var precision = getPrecisionSafe(step) + 2;\n\t                // Niced extent inside original extent\n\t                var niceExtent = [\n\t                        roundingErrorFix(mathCeil(extent[0] / step) * step, precision),\n\t                        roundingErrorFix(mathFloor(extent[1] / step) * step, precision)\n\t                    ];\n\t                this._interval = step;\n\t                this._niceExtent = niceExtent;\n\t            },\n\t            niceExtent: function (splitNumber, fixMin, fixMax) {\n\t                var extent = this._extent;\n\t                // If extent start and end are same, expand them\n\t                if (extent[0] === extent[1]) {\n\t                    if (extent[0] !== 0) {\n\t                        // Expand extent\n\t                        var expandSize = extent[0];\n\t                        // In the fowllowing case\n\t                        //      Axis has been fixed max 100\n\t                        //      Plus data are all 100 and axis extent are [100, 100].\n\t                        // Extend to the both side will cause expanded max is larger than fixed max.\n\t                        // So only expand to the smaller side.\n\t                        if (!fixMax) {\n\t                            extent[1] += expandSize / 2;\n\t                            extent[0] -= expandSize / 2;\n\t                        } else {\n\t                            extent[0] -= expandSize / 2;\n\t                        }\n\t                    } else {\n\t                        extent[1] = 1;\n\t                    }\n\t                }\n\t                var span = extent[1] - extent[0];\n\t                // If there are no data and extent are [Infinity, -Infinity]\n\t                if (!isFinite(span)) {\n\t                    extent[0] = 0;\n\t                    extent[1] = 1;\n\t                }\n\t                this.niceTicks(splitNumber);\n\t                // var extent = this._extent;\n\t                var interval = this._interval;\n\t                if (!fixMin) {\n\t                    extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);\n\t                }\n\t                if (!fixMax) {\n\t                    extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);\n\t                }\n\t            }\n\t        });\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    IntervalScale.create = function () {\n\t        return new IntervalScale();\n\t    };\n\t    return IntervalScale;\n\t});\n\tdefine('zrender/core/env', [], function () {\n\t    var env = {};\n\t    if (typeof navigator === 'undefined') {\n\t        // In node\n\t        env = {\n\t            browser: {},\n\t            os: {},\n\t            node: true,\n\t            canvasSupported: true\n\t        };\n\t    } else {\n\t        env = detect(navigator.userAgent);\n\t    }\n\t    return env;\n\t    // Zepto.js\n\t    // (c) 2010-2013 Thomas Fuchs\n\t    // Zepto.js may be freely distributed under the MIT license.\n\t    function detect(ua) {\n\t        var os = {};\n\t        var browser = {};\n\t        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n\t        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n\t        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\t        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n\t        // var touchpad = webos && ua.match(/TouchPad/);\n\t        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n\t        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n\t        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n\t        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n\t        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n\t        // var playbook = ua.match(/PlayBook/);\n\t        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\t        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n\t        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n\t        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\t        var ie = ua.match(/MSIE\\s([\\d.]+)/) || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n\t        var edge = ua.match(/Edge\\/([\\d.]+)/);\n\t        // IE 12 and 12+\n\t        // Todo: clean this up with a better OS/browser seperation:\n\t        // - discern (more) between multiple browsers on android\n\t        // - decide if kindle fire in silk mode is android or not\n\t        // - Firefox on Android doesn't specify the Android version\n\t        // - possibly devide in os, device and browser hashes\n\t        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\t        // if (android) os.android = true, os.version = android[2];\n\t        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n\t        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n\t        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n\t        // if (webos) os.webos = true, os.version = webos[2];\n\t        // if (touchpad) os.touchpad = true;\n\t        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n\t        // if (bb10) os.bb10 = true, os.version = bb10[2];\n\t        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n\t        // if (playbook) browser.playbook = true;\n\t        // if (kindle) os.kindle = true, os.version = kindle[1];\n\t        // if (silk) browser.silk = true, browser.version = silk[1];\n\t        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n\t        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\t        if (firefox)\n\t            browser.firefox = true, browser.version = firefox[1];\n\t        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n\t        // if (webview) browser.webview = true;\n\t        if (ie) {\n\t            browser.ie = true;\n\t            browser.version = ie[1];\n\t        }\n\t        if (ie) {\n\t            browser.ie = true;\n\t            browser.version = ie[1];\n\t        }\n\t        if (edge) {\n\t            browser.edge = true;\n\t            browser.version = edge[1];\n\t        }\n\t        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n\t        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n\t        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n\t        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n\t        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\t        return {\n\t            browser: browser,\n\t            os: os,\n\t            node: false,\n\t            canvasSupported: document.createElement('canvas').getContext ? true : false,\n\t            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n\t            pointerEventsSupported: 'onpointerdown' in window && (browser.edge || browser.ie && browser.version >= 10)\n\t        };\n\t    }\n\t});\n\tdefine('echarts/ExtensionAPI', ['require', 'zrender/core/util'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var echartsAPIList = [\n\t            'getDom',\n\t            'getZr',\n\t            'getWidth',\n\t            'getHeight',\n\t            'dispatchAction',\n\t            'isDisposed',\n\t            'on',\n\t            'off',\n\t            'getDataURL',\n\t            'getConnectedDataURL',\n\t            'getModel',\n\t            'getOption'\n\t        ];\n\t    function ExtensionAPI(chartInstance) {\n\t        zrUtil.each(echartsAPIList, function (name) {\n\t            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n\t        }, this);\n\t    }\n\t    return ExtensionAPI;\n\t});\n\tdefine('echarts/model/Global', ['require', 'zrender/core/util', '../util/model', './Model', './Component', './globalDefault', './mixin/colorPalette'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../util/model');\n\t    var Model = require('./Model');\n\t    var each = zrUtil.each;\n\t    var filter = zrUtil.filter;\n\t    var map = zrUtil.map;\n\t    var isArray = zrUtil.isArray;\n\t    var indexOf = zrUtil.indexOf;\n\t    var isObject = zrUtil.isObject;\n\t    var ComponentModel = require('./Component');\n\t    var globalDefault = require('./globalDefault');\n\t    var OPTION_INNER_KEY = '\u0000_ec_inner';\n\t    /**\n\t     * @alias module:echarts/model/Global\n\t     *\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} parentModel\n\t     * @param {Object} theme\n\t     */\n\t    var GlobalModel = Model.extend({\n\t            constructor: GlobalModel,\n\t            init: function (option, parentModel, theme, optionManager) {\n\t                theme = theme || {};\n\t                this.option = null;\n\t                // Mark as not initialized.\n\t                /**\n\t             * @type {module:echarts/model/Model}\n\t             * @private\n\t             */\n\t                this._theme = new Model(theme);\n\t                /**\n\t             * @type {module:echarts/model/OptionManager}\n\t             */\n\t                this._optionManager = optionManager;\n\t            },\n\t            setOption: function (option, optionPreprocessorFuncs) {\n\t                zrUtil.assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');\n\t                this._optionManager.setOption(option, optionPreprocessorFuncs);\n\t                this.resetOption();\n\t            },\n\t            resetOption: function (type) {\n\t                var optionChanged = false;\n\t                var optionManager = this._optionManager;\n\t                if (!type || type === 'recreate') {\n\t                    var baseOption = optionManager.mountOption(type === 'recreate');\n\t                    if (!this.option || type === 'recreate') {\n\t                        initBase.call(this, baseOption);\n\t                    } else {\n\t                        this.restoreData();\n\t                        this.mergeOption(baseOption);\n\t                    }\n\t                    optionChanged = true;\n\t                }\n\t                if (type === 'timeline' || type === 'media') {\n\t                    this.restoreData();\n\t                }\n\t                if (!type || type === 'recreate' || type === 'timeline') {\n\t                    var timelineOption = optionManager.getTimelineOption(this);\n\t                    timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n\t                }\n\t                if (!type || type === 'recreate' || type === 'media') {\n\t                    var mediaOptions = optionManager.getMediaOption(this, this._api);\n\t                    if (mediaOptions.length) {\n\t                        each(mediaOptions, function (mediaOption) {\n\t                            this.mergeOption(mediaOption, optionChanged = true);\n\t                        }, this);\n\t                    }\n\t                }\n\t                return optionChanged;\n\t            },\n\t            mergeOption: function (newOption) {\n\t                var option = this.option;\n\t                var componentsMap = this._componentsMap;\n\t                var newCptTypes = [];\n\t                // 如果不存在对应的 component model 则直接 merge\n\t                each(newOption, function (componentOption, mainType) {\n\t                    if (componentOption == null) {\n\t                        return;\n\t                    }\n\t                    if (!ComponentModel.hasClass(mainType)) {\n\t                        option[mainType] = option[mainType] == null ? zrUtil.clone(componentOption) : zrUtil.merge(option[mainType], componentOption, true);\n\t                    } else {\n\t                        newCptTypes.push(mainType);\n\t                    }\n\t                });\n\t                // FIXME OPTION 同步是否要改回原来的\n\t                ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n\t                this._seriesIndices = this._seriesIndices || [];\n\t                function visitComponent(mainType, dependencies) {\n\t                    var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\t                    var mapResult = modelUtil.mappingToExists(componentsMap[mainType], newCptOptionList);\n\t                    makeKeyInfo(mainType, mapResult);\n\t                    var dependentModels = getComponentsByTypes(componentsMap, dependencies);\n\t                    option[mainType] = [];\n\t                    componentsMap[mainType] = [];\n\t                    each(mapResult, function (resultItem, index) {\n\t                        var componentModel = resultItem.exist;\n\t                        var newCptOption = resultItem.option;\n\t                        zrUtil.assert(isObject(newCptOption) || componentModel, 'Empty component definition');\n\t                        // Consider where is no new option and should be merged using {},\n\t                        // see removeEdgeAndAdd in topologicalTravel and\n\t                        // ComponentModel.getAllClassMainTypes.\n\t                        if (!newCptOption) {\n\t                            componentModel.mergeOption({}, this);\n\t                            componentModel.optionUpdated({}, false);\n\t                        } else {\n\t                            var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\n\t                            if (componentModel && componentModel instanceof ComponentModelClass) {\n\t                                componentModel.mergeOption(newCptOption, this);\n\t                                componentModel.optionUpdated(newCptOption, false);\n\t                            } else {\n\t                                // PENDING Global as parent ?\n\t                                var extraOpt = zrUtil.extend({\n\t                                        dependentModels: dependentModels,\n\t                                        componentIndex: index\n\t                                    }, resultItem.keyInfo);\n\t                                componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);\n\t                                componentModel.init(newCptOption, this, this, extraOpt);\n\t                                // Call optionUpdated after init.\n\t                                // newCptOption has been used as componentModel.option\n\t                                // and may be merged with theme and default, so pass null\n\t                                // to avoid confusion.\n\t                                componentModel.optionUpdated(null, true);\n\t                            }\n\t                        }\n\t                        componentsMap[mainType][index] = componentModel;\n\t                        option[mainType][index] = componentModel.option;\n\t                    }, this);\n\t                    // Backup series for filtering.\n\t                    if (mainType === 'series') {\n\t                        this._seriesIndices = createSeriesIndices(componentsMap.series);\n\t                    }\n\t                }\n\t            },\n\t            getOption: function () {\n\t                var option = zrUtil.clone(this.option);\n\t                each(option, function (opts, mainType) {\n\t                    if (ComponentModel.hasClass(mainType)) {\n\t                        var opts = modelUtil.normalizeToArray(opts);\n\t                        for (var i = opts.length - 1; i >= 0; i--) {\n\t                            // Remove options with inner id.\n\t                            if (modelUtil.isIdInner(opts[i])) {\n\t                                opts.splice(i, 1);\n\t                            }\n\t                        }\n\t                        option[mainType] = opts;\n\t                    }\n\t                });\n\t                delete option[OPTION_INNER_KEY];\n\t                return option;\n\t            },\n\t            getTheme: function () {\n\t                return this._theme;\n\t            },\n\t            getComponent: function (mainType, idx) {\n\t                var list = this._componentsMap[mainType];\n\t                if (list) {\n\t                    return list[idx || 0];\n\t                }\n\t            },\n\t            queryComponents: function (condition) {\n\t                var mainType = condition.mainType;\n\t                if (!mainType) {\n\t                    return [];\n\t                }\n\t                var index = condition.index;\n\t                var id = condition.id;\n\t                var name = condition.name;\n\t                var cpts = this._componentsMap[mainType];\n\t                if (!cpts || !cpts.length) {\n\t                    return [];\n\t                }\n\t                var result;\n\t                if (index != null) {\n\t                    if (!isArray(index)) {\n\t                        index = [index];\n\t                    }\n\t                    result = filter(map(index, function (idx) {\n\t                        return cpts[idx];\n\t                    }), function (val) {\n\t                        return !!val;\n\t                    });\n\t                } else if (id != null) {\n\t                    var isIdArray = isArray(id);\n\t                    result = filter(cpts, function (cpt) {\n\t                        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;\n\t                    });\n\t                } else if (name != null) {\n\t                    var isNameArray = isArray(name);\n\t                    result = filter(cpts, function (cpt) {\n\t                        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;\n\t                    });\n\t                } else {\n\t                    // Return all components with mainType\n\t                    result = cpts;\n\t                }\n\t                return filterBySubType(result, condition);\n\t            },\n\t            findComponents: function (condition) {\n\t                var query = condition.query;\n\t                var mainType = condition.mainType;\n\t                var queryCond = getQueryCond(query);\n\t                var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap[mainType];\n\t                return doFilter(filterBySubType(result, condition));\n\t                function getQueryCond(q) {\n\t                    var indexAttr = mainType + 'Index';\n\t                    var idAttr = mainType + 'Id';\n\t                    var nameAttr = mainType + 'Name';\n\t                    return q && (q.hasOwnProperty(indexAttr) || q.hasOwnProperty(idAttr) || q.hasOwnProperty(nameAttr)) ? {\n\t                        mainType: mainType,\n\t                        index: q[indexAttr],\n\t                        id: q[idAttr],\n\t                        name: q[nameAttr]\n\t                    } : null;\n\t                }\n\t                function doFilter(res) {\n\t                    return condition.filter ? filter(res, condition.filter) : res;\n\t                }\n\t            },\n\t            eachComponent: function (mainType, cb, context) {\n\t                var componentsMap = this._componentsMap;\n\t                if (typeof mainType === 'function') {\n\t                    context = cb;\n\t                    cb = mainType;\n\t                    each(componentsMap, function (components, componentType) {\n\t                        each(components, function (component, index) {\n\t                            cb.call(context, componentType, component, index);\n\t                        });\n\t                    });\n\t                } else if (zrUtil.isString(mainType)) {\n\t                    each(componentsMap[mainType], cb, context);\n\t                } else if (isObject(mainType)) {\n\t                    var queryResult = this.findComponents(mainType);\n\t                    each(queryResult, cb, context);\n\t                }\n\t            },\n\t            getSeriesByName: function (name) {\n\t                var series = this._componentsMap.series;\n\t                return filter(series, function (oneSeries) {\n\t                    return oneSeries.name === name;\n\t                });\n\t            },\n\t            getSeriesByIndex: function (seriesIndex) {\n\t                return this._componentsMap.series[seriesIndex];\n\t            },\n\t            getSeriesByType: function (subType) {\n\t                var series = this._componentsMap.series;\n\t                return filter(series, function (oneSeries) {\n\t                    return oneSeries.subType === subType;\n\t                });\n\t            },\n\t            getSeries: function () {\n\t                return this._componentsMap.series.slice();\n\t            },\n\t            eachSeries: function (cb, context) {\n\t                assertSeriesInitialized(this);\n\t                each(this._seriesIndices, function (rawSeriesIndex) {\n\t                    var series = this._componentsMap.series[rawSeriesIndex];\n\t                    cb.call(context, series, rawSeriesIndex);\n\t                }, this);\n\t            },\n\t            eachRawSeries: function (cb, context) {\n\t                each(this._componentsMap.series, cb, context);\n\t            },\n\t            eachSeriesByType: function (subType, cb, context) {\n\t                assertSeriesInitialized(this);\n\t                each(this._seriesIndices, function (rawSeriesIndex) {\n\t                    var series = this._componentsMap.series[rawSeriesIndex];\n\t                    if (series.subType === subType) {\n\t                        cb.call(context, series, rawSeriesIndex);\n\t                    }\n\t                }, this);\n\t            },\n\t            eachRawSeriesByType: function (subType, cb, context) {\n\t                return each(this.getSeriesByType(subType), cb, context);\n\t            },\n\t            isSeriesFiltered: function (seriesModel) {\n\t                assertSeriesInitialized(this);\n\t                return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n\t            },\n\t            filterSeries: function (cb, context) {\n\t                assertSeriesInitialized(this);\n\t                var filteredSeries = filter(this._componentsMap.series, cb, context);\n\t                this._seriesIndices = createSeriesIndices(filteredSeries);\n\t            },\n\t            restoreData: function () {\n\t                var componentsMap = this._componentsMap;\n\t                this._seriesIndices = createSeriesIndices(componentsMap.series);\n\t                var componentTypes = [];\n\t                each(componentsMap, function (components, componentType) {\n\t                    componentTypes.push(componentType);\n\t                });\n\t                ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {\n\t                    each(componentsMap[componentType], function (component) {\n\t                        component.restoreData();\n\t                    });\n\t                });\n\t            }\n\t        });\n\t    /**\n\t     * @inner\n\t     */\n\t    function mergeTheme(option, theme) {\n\t        for (var name in theme) {\n\t            // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理\n\t            if (!ComponentModel.hasClass(name)) {\n\t                if (typeof theme[name] === 'object') {\n\t                    option[name] = !option[name] ? zrUtil.clone(theme[name]) : zrUtil.merge(option[name], theme[name], false);\n\t                } else {\n\t                    if (option[name] == null) {\n\t                        option[name] = theme[name];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t    function initBase(baseOption) {\n\t        baseOption = baseOption;\n\t        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n\t        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n\t        this.option = {};\n\t        this.option[OPTION_INNER_KEY] = 1;\n\t        /**\n\t         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n\t         * @private\n\t         */\n\t        this._componentsMap = {};\n\t        /**\n\t         * Mapping between filtered series list and raw series list.\n\t         * key: filtered series indices, value: raw series indices.\n\t         * @type {Array.<nubmer>}\n\t         * @private\n\t         */\n\t        this._seriesIndices = null;\n\t        mergeTheme(baseOption, this._theme.option);\n\t        // TODO Needs clone when merging to the unexisted property\n\t        zrUtil.merge(baseOption, globalDefault, false);\n\t        this.mergeOption(baseOption);\n\t    }\n\t    /**\n\t     * @inner\n\t     * @param {Array.<string>|string} types model types\n\t     * @return {Object} key: {string} type, value: {Array.<Object>} models\n\t     */\n\t    function getComponentsByTypes(componentsMap, types) {\n\t        if (!zrUtil.isArray(types)) {\n\t            types = types ? [types] : [];\n\t        }\n\t        var ret = {};\n\t        each(types, function (type) {\n\t            ret[type] = (componentsMap[type] || []).slice();\n\t        });\n\t        return ret;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function makeKeyInfo(mainType, mapResult) {\n\t        // We use this id to hash component models and view instances\n\t        // in echarts. id can be specified by user, or auto generated.\n\t        // The id generation rule ensures new view instance are able\n\t        // to mapped to old instance when setOption are called in\n\t        // no-merge mode. So we generate model id by name and plus\n\t        // type in view id.\n\t        // name can be duplicated among components, which is convenient\n\t        // to specify multi components (like series) by one name.\n\t        // Ensure that each id is distinct.\n\t        var idMap = {};\n\t        each(mapResult, function (item, index) {\n\t            var existCpt = item.exist;\n\t            existCpt && (idMap[existCpt.id] = item);\n\t        });\n\t        each(mapResult, function (item, index) {\n\t            var opt = item.option;\n\t            zrUtil.assert(!opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item, 'id duplicates: ' + (opt && opt.id));\n\t            opt && opt.id != null && (idMap[opt.id] = item);\n\t            // Complete subType\n\t            if (isObject(opt)) {\n\t                var subType = determineSubType(mainType, opt, item.exist);\n\t                item.keyInfo = {\n\t                    mainType: mainType,\n\t                    subType: subType\n\t                };\n\t            }\n\t        });\n\t        // Make name and id.\n\t        each(mapResult, function (item, index) {\n\t            var existCpt = item.exist;\n\t            var opt = item.option;\n\t            var keyInfo = item.keyInfo;\n\t            if (!isObject(opt)) {\n\t                return;\n\t            }\n\t            // name can be overwitten. Consider case: axis.name = '20km'.\n\t            // But id generated by name will not be changed, which affect\n\t            // only in that case: setOption with 'not merge mode' and view\n\t            // instance will be recreated, which can be accepted.\n\t            keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name : '\u0000-';\n\t            if (existCpt) {\n\t                keyInfo.id = existCpt.id;\n\t            } else if (opt.id != null) {\n\t                keyInfo.id = opt.id + '';\n\t            } else {\n\t                // Consider this situatoin:\n\t                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n\t                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n\t                // Series with the same name between optionA and optionB\n\t                // should be mapped.\n\t                var idNum = 0;\n\t                do {\n\t                    keyInfo.id = '\u0000' + keyInfo.name + '\u0000' + idNum++;\n\t                } while (idMap[keyInfo.id]);\n\t            }\n\t            idMap[keyInfo.id] = item;\n\t        });\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function determineSubType(mainType, newCptOption, existComponent) {\n\t        var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType : ComponentModel.determineSubType(mainType, newCptOption);\n\t        // tooltip, markline, markpoint may always has no subType\n\t        return subType;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function createSeriesIndices(seriesModels) {\n\t        return map(seriesModels, function (series) {\n\t            return series.componentIndex;\n\t        }) || [];\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function filterBySubType(components, condition) {\n\t        // Using hasOwnProperty for restrict. Consider\n\t        // subType is undefined in user payload.\n\t        return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {\n\t            return cpt.subType === condition.subType;\n\t        }) : components;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function assertSeriesInitialized(ecModel) {\n\t        // Components that use _seriesIndices should depends on series component,\n\t        // which make sure that their initialization is after series.\n\t        if (true) {\n\t            if (!ecModel._seriesIndices) {\n\t                throw new Error('Series has not been initialized yet.');\n\t            }\n\t        }\n\t    }\n\t    zrUtil.mixin(GlobalModel, require('./mixin/colorPalette'));\n\t    return GlobalModel;\n\t});\n\tdefine('echarts/model/OptionManager', ['require', 'zrender/core/util', '../util/model', './Component'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../util/model');\n\t    var ComponentModel = require('./Component');\n\t    var each = zrUtil.each;\n\t    var clone = zrUtil.clone;\n\t    var map = zrUtil.map;\n\t    var merge = zrUtil.merge;\n\t    var QUERY_REG = /^(min|max)?(.+)$/;\n\t    /**\n\t     * TERM EXPLANATIONS:\n\t     *\n\t     * [option]:\n\t     *\n\t     *     An object that contains definitions of components. For example:\n\t     *     var option = {\n\t     *         title: {...},\n\t     *         legend: {...},\n\t     *         visualMap: {...},\n\t     *         series: [\n\t     *             {data: [...]},\n\t     *             {data: [...]},\n\t     *             ...\n\t     *         ]\n\t     *     };\n\t     *\n\t     * [rawOption]:\n\t     *\n\t     *     An object input to echarts.setOption. 'rawOption' may be an\n\t     *     'option', or may be an object contains multi-options. For example:\n\t     *     var option = {\n\t     *         baseOption: {\n\t     *             title: {...},\n\t     *             legend: {...},\n\t     *             series: [\n\t     *                 {data: [...]},\n\t     *                 {data: [...]},\n\t     *                 ...\n\t     *             ]\n\t     *         },\n\t     *         timeline: {...},\n\t     *         options: [\n\t     *             {title: {...}, series: {data: [...]}},\n\t     *             {title: {...}, series: {data: [...]}},\n\t     *             ...\n\t     *         ],\n\t     *         media: [\n\t     *             {\n\t     *                 query: {maxWidth: 320},\n\t     *                 option: {series: {x: 20}, visualMap: {show: false}}\n\t     *             },\n\t     *             {\n\t     *                 query: {minWidth: 320, maxWidth: 720},\n\t     *                 option: {series: {x: 500}, visualMap: {show: true}}\n\t     *             },\n\t     *             {\n\t     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n\t     *             }\n\t     *         ]\n\t     *     };\n\t     *\n\t     * @alias module:echarts/model/OptionManager\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    function OptionManager(api) {\n\t        /**\n\t         * @private\n\t         * @type {module:echarts/ExtensionAPI}\n\t         */\n\t        this._api = api;\n\t        /**\n\t         * @private\n\t         * @type {Array.<number>}\n\t         */\n\t        this._timelineOptions = [];\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._mediaList = [];\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._mediaDefault;\n\t        /**\n\t         * -1, means default.\n\t         * empty means no media.\n\t         * @private\n\t         * @type {Array.<number>}\n\t         */\n\t        this._currentMediaIndices = [];\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._optionBackup;\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._newBaseOption;\n\t    }\n\t    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n\t    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n\t    // rawOption cloned and backuped when timeline changed, which does no\n\t    // good to performance. What's more, that both timeline and setOption\n\t    // method supply 'notMerge' brings complex and some problems.\n\t    // Consider this case:\n\t    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n\t    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\t    OptionManager.prototype = {\n\t        constructor: OptionManager,\n\t        setOption: function (rawOption, optionPreprocessorFuncs) {\n\t            rawOption = clone(rawOption, true);\n\t            // FIXME\n\t            // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。\n\t            var oldOptionBackup = this._optionBackup;\n\t            var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);\n\t            this._newBaseOption = newParsedOption.baseOption;\n\t            // For setOption at second time (using merge mode);\n\t            if (oldOptionBackup) {\n\t                // Only baseOption can be merged.\n\t                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\t                // For simplicity, timeline options and media options do not support merge,\n\t                // that is, if you `setOption` twice and both has timeline options, the latter\n\t                // timeline opitons will not be merged to the formers, but just substitude them.\n\t                if (newParsedOption.timelineOptions.length) {\n\t                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n\t                }\n\t                if (newParsedOption.mediaList.length) {\n\t                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n\t                }\n\t                if (newParsedOption.mediaDefault) {\n\t                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n\t                }\n\t            } else {\n\t                this._optionBackup = newParsedOption;\n\t            }\n\t        },\n\t        mountOption: function (isRecreate) {\n\t            var optionBackup = this._optionBackup;\n\t            // TODO\n\t            // 如果没有reset功能则不clone。\n\t            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n\t            this._mediaList = map(optionBackup.mediaList, clone);\n\t            this._mediaDefault = clone(optionBackup.mediaDefault);\n\t            this._currentMediaIndices = [];\n\t            return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);\n\t        },\n\t        getTimelineOption: function (ecModel) {\n\t            var option;\n\t            var timelineOptions = this._timelineOptions;\n\t            if (timelineOptions.length) {\n\t                // getTimelineOption can only be called after ecModel inited,\n\t                // so we can get currentIndex from timelineModel.\n\t                var timelineModel = ecModel.getComponent('timeline');\n\t                if (timelineModel) {\n\t                    option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);\n\t                }\n\t            }\n\t            return option;\n\t        },\n\t        getMediaOption: function (ecModel) {\n\t            var ecWidth = this._api.getWidth();\n\t            var ecHeight = this._api.getHeight();\n\t            var mediaList = this._mediaList;\n\t            var mediaDefault = this._mediaDefault;\n\t            var indices = [];\n\t            var result = [];\n\t            // No media defined.\n\t            if (!mediaList.length && !mediaDefault) {\n\t                return result;\n\t            }\n\t            // Multi media may be applied, the latter defined media has higher priority.\n\t            for (var i = 0, len = mediaList.length; i < len; i++) {\n\t                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n\t                    indices.push(i);\n\t                }\n\t            }\n\t            // FIXME\n\t            // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。\n\t            if (!indices.length && mediaDefault) {\n\t                indices = [-1];\n\t            }\n\t            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n\t                result = map(indices, function (index) {\n\t                    return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\n\t                });\n\t            }\n\t            // Otherwise return nothing.\n\t            this._currentMediaIndices = indices;\n\t            return result;\n\t        }\n\t    };\n\t    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n\t        var timelineOptions = [];\n\t        var mediaList = [];\n\t        var mediaDefault;\n\t        var baseOption;\n\t        // Compatible with ec2.\n\t        var timelineOpt = rawOption.timeline;\n\t        if (rawOption.baseOption) {\n\t            baseOption = rawOption.baseOption;\n\t        }\n\t        // For timeline\n\t        if (timelineOpt || rawOption.options) {\n\t            baseOption = baseOption || {};\n\t            timelineOptions = (rawOption.options || []).slice();\n\t        }\n\t        // For media query\n\t        if (rawOption.media) {\n\t            baseOption = baseOption || {};\n\t            var media = rawOption.media;\n\t            each(media, function (singleMedia) {\n\t                if (singleMedia && singleMedia.option) {\n\t                    if (singleMedia.query) {\n\t                        mediaList.push(singleMedia);\n\t                    } else if (!mediaDefault) {\n\t                        // Use the first media default.\n\t                        mediaDefault = singleMedia;\n\t                    }\n\t                }\n\t            });\n\t        }\n\t        // For normal option\n\t        if (!baseOption) {\n\t            baseOption = rawOption;\n\t        }\n\t        // Set timelineOpt to baseOption in ec3,\n\t        // which is convenient for merge option.\n\t        if (!baseOption.timeline) {\n\t            baseOption.timeline = timelineOpt;\n\t        }\n\t        // Preprocess.\n\t        each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {\n\t            return media.option;\n\t        })), function (option) {\n\t            each(optionPreprocessorFuncs, function (preProcess) {\n\t                preProcess(option, isNew);\n\t            });\n\t        });\n\t        return {\n\t            baseOption: baseOption,\n\t            timelineOptions: timelineOptions,\n\t            mediaDefault: mediaDefault,\n\t            mediaList: mediaList\n\t        };\n\t    }\n\t    /**\n\t     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n\t     * Support: width, height, aspectRatio\n\t     * Can use max or min as prefix.\n\t     */\n\t    function applyMediaQuery(query, ecWidth, ecHeight) {\n\t        var realMap = {\n\t                width: ecWidth,\n\t                height: ecHeight,\n\t                aspectratio: ecWidth / ecHeight\n\t            };\n\t        var applicatable = true;\n\t        zrUtil.each(query, function (value, attr) {\n\t            var matched = attr.match(QUERY_REG);\n\t            if (!matched || !matched[1] || !matched[2]) {\n\t                return;\n\t            }\n\t            var operator = matched[1];\n\t            var realAttr = matched[2].toLowerCase();\n\t            if (!compare(realMap[realAttr], value, operator)) {\n\t                applicatable = false;\n\t            }\n\t        });\n\t        return applicatable;\n\t    }\n\t    function compare(real, expect, operator) {\n\t        if (operator === 'min') {\n\t            return real >= expect;\n\t        } else if (operator === 'max') {\n\t            return real <= expect;\n\t        } else {\n\t            // Equals\n\t            return real === expect;\n\t        }\n\t    }\n\t    function indicesEquals(indices1, indices2) {\n\t        // indices is always order by asc and has only finite number.\n\t        return indices1.join(',') === indices2.join(',');\n\t    }\n\t    /**\n\t     * Consider case:\n\t     * `chart.setOption(opt1);`\n\t     * Then user do some interaction like dataZoom, dataView changing.\n\t     * `chart.setOption(opt2);`\n\t     * Then user press 'reset button' in toolbox.\n\t     *\n\t     * After doing that all of the interaction effects should be reset, the\n\t     * chart should be the same as the result of invoke\n\t     * `chart.setOption(opt1); chart.setOption(opt2);`.\n\t     *\n\t     * Although it is not able ensure that\n\t     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n\t     * `chart.setOption(merge(opt1, opt2));` exactly,\n\t     * this might be the only simple way to implement that feature.\n\t     *\n\t     * MEMO: We've considered some other approaches:\n\t     * 1. Each model handle its self restoration but not uniform treatment.\n\t     *     (Too complex in logic and error-prone)\n\t     * 2. Use a shadow ecModel. (Performace expensive)\n\t     */\n\t    function mergeOption(oldOption, newOption) {\n\t        newOption = newOption || {};\n\t        each(newOption, function (newCptOpt, mainType) {\n\t            if (newCptOpt == null) {\n\t                return;\n\t            }\n\t            var oldCptOpt = oldOption[mainType];\n\t            if (!ComponentModel.hasClass(mainType)) {\n\t                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n\t            } else {\n\t                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n\t                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\t                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\t                oldOption[mainType] = map(mapResult, function (item) {\n\t                    return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;\n\t                });\n\t            }\n\t        });\n\t    }\n\t    return OptionManager;\n\t});\n\tdefine('echarts/CoordinateSystem', ['require'], function (require) {\n\t    'use strict';\n\t    var coordinateSystemCreators = {};\n\t    function CoordinateSystemManager() {\n\t        this._coordinateSystems = [];\n\t    }\n\t    CoordinateSystemManager.prototype = {\n\t        constructor: CoordinateSystemManager,\n\t        create: function (ecModel, api) {\n\t            var coordinateSystems = [];\n\t            for (var type in coordinateSystemCreators) {\n\t                var list = coordinateSystemCreators[type].create(ecModel, api);\n\t                list && (coordinateSystems = coordinateSystems.concat(list));\n\t            }\n\t            this._coordinateSystems = coordinateSystems;\n\t        },\n\t        update: function (ecModel, api) {\n\t            var coordinateSystems = this._coordinateSystems;\n\t            for (var i = 0; i < coordinateSystems.length; i++) {\n\t                // FIXME MUST have\n\t                coordinateSystems[i].update && coordinateSystems[i].update(ecModel, api);\n\t            }\n\t        }\n\t    };\n\t    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n\t        coordinateSystemCreators[type] = coordinateSystemCreator;\n\t    };\n\t    CoordinateSystemManager.get = function (type) {\n\t        return coordinateSystemCreators[type];\n\t    };\n\t    return CoordinateSystemManager;\n\t});\n\tdefine('echarts/model/Series', ['require', 'zrender/core/util', '../util/format', '../util/model', './Component', './mixin/colorPalette', 'zrender/core/env'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var formatUtil = require('../util/format');\n\t    var modelUtil = require('../util/model');\n\t    var ComponentModel = require('./Component');\n\t    var colorPaletteMixin = require('./mixin/colorPalette');\n\t    var env = require('zrender/core/env');\n\t    var encodeHTML = formatUtil.encodeHTML;\n\t    var addCommas = formatUtil.addCommas;\n\t    var SeriesModel = ComponentModel.extend({\n\t            type: 'series.__base__',\n\t            seriesIndex: 0,\n\t            coordinateSystem: null,\n\t            defaultOption: null,\n\t            legendDataProvider: null,\n\t            visualColorAccessPath: 'itemStyle.normal.color',\n\t            init: function (option, parentModel, ecModel, extraOpt) {\n\t                /**\n\t             * @type {number}\n\t             * @readOnly\n\t             */\n\t                this.seriesIndex = this.componentIndex;\n\t                this.mergeDefaultAndTheme(option, ecModel);\n\t                /**\n\t             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n\t             * @private\n\t             */\n\t                this._dataBeforeProcessed = this.getInitialData(option, ecModel);\n\t                // If we reverse the order (make this._data firstly, and then make\n\t                // this._dataBeforeProcessed by cloneShallow), cloneShallow will\n\t                // cause this._data.graph.data !== this._data when using\n\t                // module:echarts/data/Graph or module:echarts/data/Tree.\n\t                // See module:echarts/data/helper/linkList\n\t                this._data = this._dataBeforeProcessed.cloneShallow();\n\t            },\n\t            mergeDefaultAndTheme: function (option, ecModel) {\n\t                zrUtil.merge(option, ecModel.getTheme().get(this.subType));\n\t                zrUtil.merge(option, this.getDefaultOption());\n\t                // Default label emphasis `position` and `show`\n\t                // FIXME Set label in mergeOption\n\t                modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\t                this.fillDataTextStyle(option.data);\n\t            },\n\t            mergeOption: function (newSeriesOption, ecModel) {\n\t                newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n\t                this.fillDataTextStyle(newSeriesOption.data);\n\t                var data = this.getInitialData(newSeriesOption, ecModel);\n\t                // TODO Merge data?\n\t                if (data) {\n\t                    this._data = data;\n\t                    this._dataBeforeProcessed = data.cloneShallow();\n\t                }\n\t            },\n\t            fillDataTextStyle: function (data) {\n\t                // Default data label emphasis `position` and `show`\n\t                // FIXME Tree structure data ?\n\t                // FIXME Performance ?\n\t                if (data) {\n\t                    for (var i = 0; i < data.length; i++) {\n\t                        if (data[i] && data[i].label) {\n\t                            modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            getInitialData: function () {\n\t            },\n\t            getData: function (dataType) {\n\t                return dataType == null ? this._data : this._data.getLinkedData(dataType);\n\t            },\n\t            setData: function (data) {\n\t                this._data = data;\n\t            },\n\t            getRawData: function () {\n\t                return this._dataBeforeProcessed;\n\t            },\n\t            coordDimToDataDim: function (coordDim) {\n\t                return [coordDim];\n\t            },\n\t            dataDimToCoordDim: function (dataDim) {\n\t                return dataDim;\n\t            },\n\t            getBaseAxis: function () {\n\t                var coordSys = this.coordinateSystem;\n\t                return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n\t            },\n\t            formatTooltip: function (dataIndex, multipleSeries, dataType) {\n\t                function formatArrayValue(value) {\n\t                    return zrUtil.map(value, function (val, idx) {\n\t                        var dimInfo = data.getDimensionInfo(idx);\n\t                        var dimType = dimInfo && dimInfo.type;\n\t                        if (dimType === 'ordinal') {\n\t                            return val;\n\t                        } else if (dimType === 'time') {\n\t                            return multipleSeries ? '' : formatUtil.formatTime('yyyy/mm/dd hh:mm:ss', val);\n\t                        } else {\n\t                            return addCommas(val);\n\t                        }\n\t                    }).filter(function (val) {\n\t                        return !!val;\n\t                    }).join(', ');\n\t                }\n\t                var data = this._data;\n\t                var value = this.getRawValue(dataIndex);\n\t                var formattedValue = zrUtil.isArray(value) ? formatArrayValue(value) : addCommas(value);\n\t                var name = data.getName(dataIndex);\n\t                var color = data.getItemVisual(dataIndex, 'color');\n\t                var colorEl = '<span style=\"display:inline-block;margin-right:5px;' + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '\"></span>';\n\t                var seriesName = this.name;\n\t                // FIXME\n\t                if (seriesName === '\u0000-') {\n\t                    // Not show '-'\n\t                    seriesName = '';\n\t                }\n\t                return !multipleSeries ? (seriesName && encodeHTML(seriesName) + '<br />') + colorEl + (name ? encodeHTML(name) + ' : ' + formattedValue : formattedValue) : colorEl + encodeHTML(this.name) + ' : ' + formattedValue;\n\t            },\n\t            ifEnableAnimation: function () {\n\t                if (env.node) {\n\t                    return false;\n\t                }\n\t                var animationEnabled = this.getShallow('animation');\n\t                if (animationEnabled) {\n\t                    if (this.getData().count() > this.getShallow('animationThreshold')) {\n\t                        animationEnabled = false;\n\t                    }\n\t                }\n\t                return animationEnabled;\n\t            },\n\t            restoreData: function () {\n\t                this._data = this._dataBeforeProcessed.cloneShallow();\n\t            },\n\t            getColorFromPalette: function (name, scope) {\n\t                var ecModel = this.ecModel;\n\t                // PENDING\n\t                var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n\t                if (!color) {\n\t                    color = ecModel.getColorFromPalette(name, scope);\n\t                }\n\t                return color;\n\t            },\n\t            getAxisTooltipDataIndex: null\n\t        });\n\t    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n\t    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\t    return SeriesModel;\n\t});\n\tdefine('echarts/model/Component', ['require', './Model', 'zrender/core/util', '../util/component', '../util/clazz', '../util/layout', './mixin/boxLayout'], function (require) {\n\t    var Model = require('./Model');\n\t    var zrUtil = require('zrender/core/util');\n\t    var arrayPush = Array.prototype.push;\n\t    var componentUtil = require('../util/component');\n\t    var clazzUtil = require('../util/clazz');\n\t    var layout = require('../util/layout');\n\t    /**\n\t     * @alias module:echarts/model/Component\n\t     * @constructor\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} parentModel\n\t     * @param {module:echarts/model/Model} ecModel\n\t     */\n\t    var ComponentModel = Model.extend({\n\t            type: 'component',\n\t            id: '',\n\t            name: '',\n\t            mainType: '',\n\t            subType: '',\n\t            componentIndex: 0,\n\t            defaultOption: null,\n\t            ecModel: null,\n\t            dependentModels: [],\n\t            uid: null,\n\t            layoutMode: null,\n\t            $constructor: function (option, parentModel, ecModel, extraOpt) {\n\t                Model.call(this, option, parentModel, ecModel, extraOpt);\n\t                // Set dependentModels, componentIndex, name, id, mainType, subType.\n\t                zrUtil.extend(this, extraOpt);\n\t                this.uid = componentUtil.getUID('componentModel');\n\t            },\n\t            init: function (option, parentModel, ecModel, extraOpt) {\n\t                this.mergeDefaultAndTheme(option, ecModel);\n\t            },\n\t            mergeDefaultAndTheme: function (option, ecModel) {\n\t                var layoutMode = this.layoutMode;\n\t                var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};\n\t                var themeModel = ecModel.getTheme();\n\t                zrUtil.merge(option, themeModel.get(this.mainType));\n\t                zrUtil.merge(option, this.getDefaultOption());\n\t                if (layoutMode) {\n\t                    layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n\t                }\n\t            },\n\t            mergeOption: function (option) {\n\t                zrUtil.merge(this.option, option, true);\n\t                var layoutMode = this.layoutMode;\n\t                if (layoutMode) {\n\t                    layout.mergeLayoutParam(this.option, option, layoutMode);\n\t                }\n\t            },\n\t            optionUpdated: function (newCptOption, isInit) {\n\t            },\n\t            getDefaultOption: function () {\n\t                if (!this.hasOwnProperty('__defaultOption')) {\n\t                    var optList = [];\n\t                    var Class = this.constructor;\n\t                    while (Class) {\n\t                        var opt = Class.prototype.defaultOption;\n\t                        opt && optList.push(opt);\n\t                        Class = Class.superClass;\n\t                    }\n\t                    var defaultOption = {};\n\t                    for (var i = optList.length - 1; i >= 0; i--) {\n\t                        defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n\t                    }\n\t                    this.__defaultOption = defaultOption;\n\t                }\n\t                return this.__defaultOption;\n\t            }\n\t        });\n\t    // Reset ComponentModel.extend, add preConstruct.\n\t    // clazzUtil.enableClassExtend(\n\t    //     ComponentModel,\n\t    //     function (option, parentModel, ecModel, extraOpt) {\n\t    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n\t    //         zrUtil.extend(this, extraOpt);\n\t    //         this.uid = componentUtil.getUID('componentModel');\n\t    //         // this.setReadOnly([\n\t    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n\t    //         //     'dependentModels', 'componentIndex'\n\t    //         // ]);\n\t    //     }\n\t    // );\n\t    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(ComponentModel, { registerWhenExtend: true });\n\t    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\t    // Add capability of ComponentModel.topologicalTravel.\n\t    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\t    function getDependencies(componentType) {\n\t        var deps = [];\n\t        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n\t            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n\t        });\n\t        // Ensure main type\n\t        return zrUtil.map(deps, function (type) {\n\t            return clazzUtil.parseClassType(type).main;\n\t        });\n\t    }\n\t    zrUtil.mixin(ComponentModel, require('./mixin/boxLayout'));\n\t    return ComponentModel;\n\t});\n\tdefine('echarts/view/Component', ['require', 'zrender/container/Group', '../util/component', '../util/clazz'], function (require) {\n\t    var Group = require('zrender/container/Group');\n\t    var componentUtil = require('../util/component');\n\t    var clazzUtil = require('../util/clazz');\n\t    var Component = function () {\n\t        /**\n\t         * @type {module:zrender/container/Group}\n\t         * @readOnly\n\t         */\n\t        this.group = new Group();\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        this.uid = componentUtil.getUID('viewComponent');\n\t    };\n\t    Component.prototype = {\n\t        constructor: Component,\n\t        init: function (ecModel, api) {\n\t        },\n\t        render: function (componentModel, ecModel, api, payload) {\n\t        },\n\t        dispose: function () {\n\t        }\n\t    };\n\t    var componentProto = Component.prototype;\n\t    componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function (seriesModel, ecModel, api, payload) {\n\t    };\n\t    // Enable Component.extend.\n\t    clazzUtil.enableClassExtend(Component);\n\t    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(Component, { registerWhenExtend: true });\n\t    return Component;\n\t});\n\tdefine('echarts/view/Chart', ['require', 'zrender/container/Group', '../util/component', '../util/clazz'], function (require) {\n\t    var Group = require('zrender/container/Group');\n\t    var componentUtil = require('../util/component');\n\t    var clazzUtil = require('../util/clazz');\n\t    function Chart() {\n\t        /**\n\t         * @type {module:zrender/container/Group}\n\t         * @readOnly\n\t         */\n\t        this.group = new Group();\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        this.uid = componentUtil.getUID('viewChart');\n\t    }\n\t    Chart.prototype = {\n\t        type: 'chart',\n\t        init: function (ecModel, api) {\n\t        },\n\t        render: function (seriesModel, ecModel, api, payload) {\n\t        },\n\t        highlight: function (seriesModel, ecModel, api, payload) {\n\t            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n\t        },\n\t        downplay: function (seriesModel, ecModel, api, payload) {\n\t            toggleHighlight(seriesModel.getData(), payload, 'normal');\n\t        },\n\t        remove: function (ecModel, api) {\n\t            this.group.removeAll();\n\t        },\n\t        dispose: function () {\n\t        }\n\t    };\n\t    var chartProto = Chart.prototype;\n\t    chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function (seriesModel, ecModel, api, payload) {\n\t        this.render(seriesModel, ecModel, api, payload);\n\t    };\n\t    /**\n\t     * Set state of single element\n\t     * @param  {module:zrender/Element} el\n\t     * @param  {string} state\n\t     */\n\t    function elSetState(el, state) {\n\t        if (el) {\n\t            el.trigger(state);\n\t            if (el.type === 'group') {\n\t                for (var i = 0; i < el.childCount(); i++) {\n\t                    elSetState(el.childAt(i), state);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @param  {module:echarts/data/List} data\n\t     * @param  {Object} payload\n\t     * @param  {string} state 'normal'|'emphasis'\n\t     * @inner\n\t     */\n\t    function toggleHighlight(data, payload, state) {\n\t        var dataIndex = payload && payload.dataIndex;\n\t        var name = payload && payload.name;\n\t        if (dataIndex != null) {\n\t            var dataIndices = dataIndex instanceof Array ? dataIndex : [dataIndex];\n\t            for (var i = 0, len = dataIndices.length; i < len; i++) {\n\t                elSetState(data.getItemGraphicEl(dataIndices[i]), state);\n\t            }\n\t        } else if (name) {\n\t            var names = name instanceof Array ? name : [name];\n\t            for (var i = 0, len = names.length; i < len; i++) {\n\t                var dataIndex = data.indexOfName(names[i]);\n\t                elSetState(data.getItemGraphicEl(dataIndex), state);\n\t            }\n\t        } else {\n\t            data.eachItemGraphicEl(function (el) {\n\t                elSetState(el, state);\n\t            });\n\t        }\n\t    }\n\t    // Enable Chart.extend.\n\t    clazzUtil.enableClassExtend(Chart);\n\t    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(Chart, { registerWhenExtend: true });\n\t    return Chart;\n\t});\n\tdefine('zrender/zrender', ['require', './core/guid', './core/env', './Handler', './Storage', './animation/Animation', './dom/HandlerProxy', './Painter'], function (require) {\n\t    var guid = require('./core/guid');\n\t    var env = require('./core/env');\n\t    var Handler = require('./Handler');\n\t    var Storage = require('./Storage');\n\t    var Animation = require('./animation/Animation');\n\t    var HandlerProxy = require('./dom/HandlerProxy');\n\t    var useVML = !env.canvasSupported;\n\t    var painterCtors = { canvas: require('./Painter') };\n\t    var instances = {};\n\t    // ZRender实例map索引\n\t    var zrender = {};\n\t    /**\n\t     * @type {string}\n\t     */\n\t    zrender.version = '3.1.3';\n\t    /**\n\t     * Initializing a zrender instance\n\t     * @param {HTMLElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.init = function (dom, opts) {\n\t        var zr = new ZRender(guid(), dom, opts);\n\t        instances[zr.id] = zr;\n\t        return zr;\n\t    };\n\t    /**\n\t     * Dispose zrender instance\n\t     * @param {module:zrender/ZRender} zr\n\t     */\n\t    zrender.dispose = function (zr) {\n\t        if (zr) {\n\t            zr.dispose();\n\t        } else {\n\t            for (var key in instances) {\n\t                instances[key].dispose();\n\t            }\n\t            instances = {};\n\t        }\n\t        return zrender;\n\t    };\n\t    /**\n\t     * Get zrender instance by id\n\t     * @param {string} id zrender instance id\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.getInstance = function (id) {\n\t        return instances[id];\n\t    };\n\t    zrender.registerPainter = function (name, Ctor) {\n\t        painterCtors[name] = Ctor;\n\t    };\n\t    function delInstance(id) {\n\t        delete instances[id];\n\t    }\n\t    /**\n\t     * @module zrender/ZRender\n\t     */\n\t    /**\n\t     * @constructor\n\t     * @alias module:zrender/ZRender\n\t     * @param {string} id\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     */\n\t    var ZRender = function (id, dom, opts) {\n\t        opts = opts || {};\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         */\n\t        this.dom = dom;\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id = id;\n\t        var self = this;\n\t        var storage = new Storage();\n\t        var rendererType = opts.renderer;\n\t        if (useVML) {\n\t            if (!painterCtors.vml) {\n\t                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n\t            }\n\t            rendererType = 'vml';\n\t        } else if (!rendererType || !painterCtors[rendererType]) {\n\t            rendererType = 'canvas';\n\t        }\n\t        var painter = new painterCtors[rendererType](dom, storage, opts);\n\t        this.storage = storage;\n\t        this.painter = painter;\n\t        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n\t        this.handler = new Handler(storage, painter, handerProxy);\n\t        /**\n\t         * @type {module:zrender/animation/Animation}\n\t         */\n\t        this.animation = new Animation({\n\t            stage: {\n\t                update: function () {\n\t                    if (self._needsRefresh) {\n\t                        self.refreshImmediately();\n\t                    }\n\t                    if (self._needsRefreshHover) {\n\t                        self.refreshHoverImmediately();\n\t                    }\n\t                }\n\t            }\n\t        });\n\t        this.animation.start();\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._needsRefresh;\n\t        // 修改 storage.delFromMap, 每次删除元素之前删除动画\n\t        // FIXME 有点ugly\n\t        var oldDelFromMap = storage.delFromMap;\n\t        var oldAddToMap = storage.addToMap;\n\t        storage.delFromMap = function (elId) {\n\t            var el = storage.get(elId);\n\t            oldDelFromMap.call(storage, elId);\n\t            el && el.removeSelfFromZr(self);\n\t        };\n\t        storage.addToMap = function (el) {\n\t            oldAddToMap.call(storage, el);\n\t            el.addSelfToZr(self);\n\t        };\n\t    };\n\t    ZRender.prototype = {\n\t        constructor: ZRender,\n\t        getId: function () {\n\t            return this.id;\n\t        },\n\t        add: function (el) {\n\t            this.storage.addRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t        remove: function (el) {\n\t            this.storage.delRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t        configLayer: function (zLevel, config) {\n\t            this.painter.configLayer(zLevel, config);\n\t            this._needsRefresh = true;\n\t        },\n\t        refreshImmediately: function () {\n\t            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n\t            // Or it will cause zrender refreshes again and again.\n\t            this._needsRefresh = false;\n\t            this.painter.refresh();\n\t            /**\n\t             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n\t             */\n\t            this._needsRefresh = false;\n\t        },\n\t        refresh: function () {\n\t            this._needsRefresh = true;\n\t        },\n\t        addHover: function (el, style) {\n\t            if (this.painter.addHover) {\n\t                this.painter.addHover(el, style);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t        removeHover: function (el) {\n\t            if (this.painter.removeHover) {\n\t                this.painter.removeHover(el);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t        clearHover: function () {\n\t            if (this.painter.clearHover) {\n\t                this.painter.clearHover();\n\t                this.refreshHover();\n\t            }\n\t        },\n\t        refreshHover: function () {\n\t            this._needsRefreshHover = true;\n\t        },\n\t        refreshHoverImmediately: function () {\n\t            this._needsRefreshHover = false;\n\t            this.painter.refreshHover && this.painter.refreshHover();\n\t        },\n\t        resize: function () {\n\t            this.painter.resize();\n\t            this.handler.resize();\n\t        },\n\t        clearAnimation: function () {\n\t            this.animation.clear();\n\t        },\n\t        getWidth: function () {\n\t            return this.painter.getWidth();\n\t        },\n\t        getHeight: function () {\n\t            return this.painter.getHeight();\n\t        },\n\t        pathToImage: function (e, width, height) {\n\t            var id = guid();\n\t            return this.painter.pathToImage(id, e, width, height);\n\t        },\n\t        setCursorStyle: function (cursorStyle) {\n\t            this.handler.setCursorStyle(cursorStyle);\n\t        },\n\t        on: function (eventName, eventHandler, context) {\n\t            this.handler.on(eventName, eventHandler, context);\n\t        },\n\t        off: function (eventName, eventHandler) {\n\t            this.handler.off(eventName, eventHandler);\n\t        },\n\t        trigger: function (eventName, event) {\n\t            this.handler.trigger(eventName, event);\n\t        },\n\t        clear: function () {\n\t            this.storage.delRoot();\n\t            this.painter.clear();\n\t        },\n\t        dispose: function () {\n\t            this.animation.stop();\n\t            this.clear();\n\t            this.storage.dispose();\n\t            this.painter.dispose();\n\t            this.handler.dispose();\n\t            this.animation = this.storage = this.painter = this.handler = null;\n\t            delInstance(this.id);\n\t        }\n\t    };\n\t    return zrender;\n\t});\n\tdefine('zrender/mixin/Eventful', ['require'], function (require) {\n\t    var arrySlice = Array.prototype.slice;\n\t    /**\n\t     * 事件分发器\n\t     * @alias module:zrender/mixin/Eventful\n\t     * @constructor\n\t     */\n\t    var Eventful = function () {\n\t        this._$handlers = {};\n\t    };\n\t    Eventful.prototype = {\n\t        constructor: Eventful,\n\t        one: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t            _h[event].push({\n\t                h: handler,\n\t                one: true,\n\t                ctx: context || this\n\t            });\n\t            return this;\n\t        },\n\t        on: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t            _h[event].push({\n\t                h: handler,\n\t                one: false,\n\t                ctx: context || this\n\t            });\n\t            return this;\n\t        },\n\t        isSilent: function (event) {\n\t            var _h = this._$handlers;\n\t            return _h[event] && _h[event].length;\n\t        },\n\t        off: function (event, handler) {\n\t            var _h = this._$handlers;\n\t            if (!event) {\n\t                this._$handlers = {};\n\t                return this;\n\t            }\n\t            if (handler) {\n\t                if (_h[event]) {\n\t                    var newList = [];\n\t                    for (var i = 0, l = _h[event].length; i < l; i++) {\n\t                        if (_h[event][i]['h'] != handler) {\n\t                            newList.push(_h[event][i]);\n\t                        }\n\t                    }\n\t                    _h[event] = newList;\n\t                }\n\t                if (_h[event] && _h[event].length === 0) {\n\t                    delete _h[event];\n\t                }\n\t            } else {\n\t                delete _h[event];\n\t            }\n\t            return this;\n\t        },\n\t        trigger: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t                if (argLen > 3) {\n\t                    args = arrySlice.call(args, 1);\n\t                }\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                    case 1:\n\t                        _h[i]['h'].call(_h[i]['ctx']);\n\t                        break;\n\t                    case 2:\n\t                        _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\t                        break;\n\t                    case 3:\n\t                        _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\t                        break;\n\t                    default:\n\t                        // have more than 2 given arguments\n\t                        _h[i]['h'].apply(_h[i]['ctx'], args);\n\t                        break;\n\t                    }\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    } else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t        triggerWithContext: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t                if (argLen > 4) {\n\t                    args = arrySlice.call(args, 1, args.length - 1);\n\t                }\n\t                var ctx = args[args.length - 1];\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                    case 1:\n\t                        _h[i]['h'].call(ctx);\n\t                        break;\n\t                    case 2:\n\t                        _h[i]['h'].call(ctx, args[1]);\n\t                        break;\n\t                    case 3:\n\t                        _h[i]['h'].call(ctx, args[1], args[2]);\n\t                        break;\n\t                    default:\n\t                        // have more than 2 given arguments\n\t                        _h[i]['h'].apply(ctx, args);\n\t                        break;\n\t                    }\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    } else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t            return this;\n\t        }\n\t    };\n\t    // 对象可以通过 onxxxx 绑定事件\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onclick\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseout\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousemove\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousewheel\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousedown\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseup\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragstart\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragend\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragenter\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragleave\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrop\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    return Eventful;\n\t});\n\tdefine('zrender/tool/color', ['require'], function (require) {\n\t    var kCSSColorTable = {\n\t            'transparent': [\n\t                0,\n\t                0,\n\t                0,\n\t                0\n\t            ],\n\t            'aliceblue': [\n\t                240,\n\t                248,\n\t                255,\n\t                1\n\t            ],\n\t            'antiquewhite': [\n\t                250,\n\t                235,\n\t                215,\n\t                1\n\t            ],\n\t            'aqua': [\n\t                0,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'aquamarine': [\n\t                127,\n\t                255,\n\t                212,\n\t                1\n\t            ],\n\t            'azure': [\n\t                240,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'beige': [\n\t                245,\n\t                245,\n\t                220,\n\t                1\n\t            ],\n\t            'bisque': [\n\t                255,\n\t                228,\n\t                196,\n\t                1\n\t            ],\n\t            'black': [\n\t                0,\n\t                0,\n\t                0,\n\t                1\n\t            ],\n\t            'blanchedalmond': [\n\t                255,\n\t                235,\n\t                205,\n\t                1\n\t            ],\n\t            'blue': [\n\t                0,\n\t                0,\n\t                255,\n\t                1\n\t            ],\n\t            'blueviolet': [\n\t                138,\n\t                43,\n\t                226,\n\t                1\n\t            ],\n\t            'brown': [\n\t                165,\n\t                42,\n\t                42,\n\t                1\n\t            ],\n\t            'burlywood': [\n\t                222,\n\t                184,\n\t                135,\n\t                1\n\t            ],\n\t            'cadetblue': [\n\t                95,\n\t                158,\n\t                160,\n\t                1\n\t            ],\n\t            'chartreuse': [\n\t                127,\n\t                255,\n\t                0,\n\t                1\n\t            ],\n\t            'chocolate': [\n\t                210,\n\t                105,\n\t                30,\n\t                1\n\t            ],\n\t            'coral': [\n\t                255,\n\t                127,\n\t                80,\n\t                1\n\t            ],\n\t            'cornflowerblue': [\n\t                100,\n\t                149,\n\t                237,\n\t                1\n\t            ],\n\t            'cornsilk': [\n\t                255,\n\t                248,\n\t                220,\n\t                1\n\t            ],\n\t            'crimson': [\n\t                220,\n\t                20,\n\t                60,\n\t                1\n\t            ],\n\t            'cyan': [\n\t                0,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'darkblue': [\n\t                0,\n\t                0,\n\t                139,\n\t                1\n\t            ],\n\t            'darkcyan': [\n\t                0,\n\t                139,\n\t                139,\n\t                1\n\t            ],\n\t            'darkgoldenrod': [\n\t                184,\n\t                134,\n\t                11,\n\t                1\n\t            ],\n\t            'darkgray': [\n\t                169,\n\t                169,\n\t                169,\n\t                1\n\t            ],\n\t            'darkgreen': [\n\t                0,\n\t                100,\n\t                0,\n\t                1\n\t            ],\n\t            'darkgrey': [\n\t                169,\n\t                169,\n\t                169,\n\t                1\n\t            ],\n\t            'darkkhaki': [\n\t                189,\n\t                183,\n\t                107,\n\t                1\n\t            ],\n\t            'darkmagenta': [\n\t                139,\n\t                0,\n\t                139,\n\t                1\n\t            ],\n\t            'darkolivegreen': [\n\t                85,\n\t                107,\n\t                47,\n\t                1\n\t            ],\n\t            'darkorange': [\n\t                255,\n\t                140,\n\t                0,\n\t                1\n\t            ],\n\t            'darkorchid': [\n\t                153,\n\t                50,\n\t                204,\n\t                1\n\t            ],\n\t            'darkred': [\n\t                139,\n\t                0,\n\t                0,\n\t                1\n\t            ],\n\t            'darksalmon': [\n\t                233,\n\t                150,\n\t                122,\n\t                1\n\t            ],\n\t            'darkseagreen': [\n\t                143,\n\t                188,\n\t                143,\n\t                1\n\t            ],\n\t            'darkslateblue': [\n\t                72,\n\t                61,\n\t                139,\n\t                1\n\t            ],\n\t            'darkslategray': [\n\t                47,\n\t                79,\n\t                79,\n\t                1\n\t            ],\n\t            'darkslategrey': [\n\t                47,\n\t                79,\n\t                79,\n\t                1\n\t            ],\n\t            'darkturquoise': [\n\t                0,\n\t                206,\n\t                209,\n\t                1\n\t            ],\n\t            'darkviolet': [\n\t                148,\n\t                0,\n\t                211,\n\t                1\n\t            ],\n\t            'deeppink': [\n\t                255,\n\t                20,\n\t                147,\n\t                1\n\t            ],\n\t            'deepskyblue': [\n\t                0,\n\t                191,\n\t                255,\n\t                1\n\t            ],\n\t            'dimgray': [\n\t                105,\n\t                105,\n\t                105,\n\t                1\n\t            ],\n\t            'dimgrey': [\n\t                105,\n\t                105,\n\t                105,\n\t                1\n\t            ],\n\t            'dodgerblue': [\n\t                30,\n\t                144,\n\t                255,\n\t                1\n\t            ],\n\t            'firebrick': [\n\t                178,\n\t                34,\n\t                34,\n\t                1\n\t            ],\n\t            'floralwhite': [\n\t                255,\n\t                250,\n\t                240,\n\t                1\n\t            ],\n\t            'forestgreen': [\n\t                34,\n\t                139,\n\t                34,\n\t                1\n\t            ],\n\t            'fuchsia': [\n\t                255,\n\t                0,\n\t                255,\n\t                1\n\t            ],\n\t            'gainsboro': [\n\t                220,\n\t                220,\n\t                220,\n\t                1\n\t            ],\n\t            'ghostwhite': [\n\t                248,\n\t                248,\n\t                255,\n\t                1\n\t            ],\n\t            'gold': [\n\t                255,\n\t                215,\n\t                0,\n\t                1\n\t            ],\n\t            'goldenrod': [\n\t                218,\n\t                165,\n\t                32,\n\t                1\n\t            ],\n\t            'gray': [\n\t                128,\n\t                128,\n\t                128,\n\t                1\n\t            ],\n\t            'green': [\n\t                0,\n\t                128,\n\t                0,\n\t                1\n\t            ],\n\t            'greenyellow': [\n\t                173,\n\t                255,\n\t                47,\n\t                1\n\t            ],\n\t            'grey': [\n\t                128,\n\t                128,\n\t                128,\n\t                1\n\t            ],\n\t            'honeydew': [\n\t                240,\n\t                255,\n\t                240,\n\t                1\n\t            ],\n\t            'hotpink': [\n\t                255,\n\t                105,\n\t                180,\n\t                1\n\t            ],\n\t            'indianred': [\n\t                205,\n\t                92,\n\t                92,\n\t                1\n\t            ],\n\t            'indigo': [\n\t                75,\n\t                0,\n\t                130,\n\t                1\n\t            ],\n\t            'ivory': [\n\t                255,\n\t                255,\n\t                240,\n\t                1\n\t            ],\n\t            'khaki': [\n\t                240,\n\t                230,\n\t                140,\n\t                1\n\t            ],\n\t            'lavender': [\n\t                230,\n\t                230,\n\t                250,\n\t                1\n\t            ],\n\t            'lavenderblush': [\n\t                255,\n\t                240,\n\t                245,\n\t                1\n\t            ],\n\t            'lawngreen': [\n\t                124,\n\t                252,\n\t                0,\n\t                1\n\t            ],\n\t            'lemonchiffon': [\n\t                255,\n\t                250,\n\t                205,\n\t                1\n\t            ],\n\t            'lightblue': [\n\t                173,\n\t                216,\n\t                230,\n\t                1\n\t            ],\n\t            'lightcoral': [\n\t                240,\n\t                128,\n\t                128,\n\t                1\n\t            ],\n\t            'lightcyan': [\n\t                224,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'lightgoldenrodyellow': [\n\t                250,\n\t                250,\n\t                210,\n\t                1\n\t            ],\n\t            'lightgray': [\n\t                211,\n\t                211,\n\t                211,\n\t                1\n\t            ],\n\t            'lightgreen': [\n\t                144,\n\t                238,\n\t                144,\n\t                1\n\t            ],\n\t            'lightgrey': [\n\t                211,\n\t                211,\n\t                211,\n\t                1\n\t            ],\n\t            'lightpink': [\n\t                255,\n\t                182,\n\t                193,\n\t                1\n\t            ],\n\t            'lightsalmon': [\n\t                255,\n\t                160,\n\t                122,\n\t                1\n\t            ],\n\t            'lightseagreen': [\n\t                32,\n\t                178,\n\t                170,\n\t                1\n\t            ],\n\t            'lightskyblue': [\n\t                135,\n\t                206,\n\t                250,\n\t                1\n\t            ],\n\t            'lightslategray': [\n\t                119,\n\t                136,\n\t                153,\n\t                1\n\t            ],\n\t            'lightslategrey': [\n\t                119,\n\t                136,\n\t                153,\n\t                1\n\t            ],\n\t            'lightsteelblue': [\n\t                176,\n\t                196,\n\t                222,\n\t                1\n\t            ],\n\t            'lightyellow': [\n\t                255,\n\t                255,\n\t                224,\n\t                1\n\t            ],\n\t            'lime': [\n\t                0,\n\t                255,\n\t                0,\n\t                1\n\t            ],\n\t            'limegreen': [\n\t                50,\n\t                205,\n\t                50,\n\t                1\n\t            ],\n\t            'linen': [\n\t                250,\n\t                240,\n\t                230,\n\t                1\n\t            ],\n\t            'magenta': [\n\t                255,\n\t                0,\n\t                255,\n\t                1\n\t            ],\n\t            'maroon': [\n\t                128,\n\t                0,\n\t                0,\n\t                1\n\t            ],\n\t            'mediumaquamarine': [\n\t                102,\n\t                205,\n\t                170,\n\t                1\n\t            ],\n\t            'mediumblue': [\n\t                0,\n\t                0,\n\t                205,\n\t                1\n\t            ],\n\t            'mediumorchid': [\n\t                186,\n\t                85,\n\t                211,\n\t                1\n\t            ],\n\t            'mediumpurple': [\n\t                147,\n\t                112,\n\t                219,\n\t                1\n\t            ],\n\t            'mediumseagreen': [\n\t                60,\n\t                179,\n\t                113,\n\t                1\n\t            ],\n\t            'mediumslateblue': [\n\t                123,\n\t                104,\n\t                238,\n\t                1\n\t            ],\n\t            'mediumspringgreen': [\n\t                0,\n\t                250,\n\t                154,\n\t                1\n\t            ],\n\t            'mediumturquoise': [\n\t                72,\n\t                209,\n\t                204,\n\t                1\n\t            ],\n\t            'mediumvioletred': [\n\t                199,\n\t                21,\n\t                133,\n\t                1\n\t            ],\n\t            'midnightblue': [\n\t                25,\n\t                25,\n\t                112,\n\t                1\n\t            ],\n\t            'mintcream': [\n\t                245,\n\t                255,\n\t                250,\n\t                1\n\t            ],\n\t            'mistyrose': [\n\t                255,\n\t                228,\n\t                225,\n\t                1\n\t            ],\n\t            'moccasin': [\n\t                255,\n\t                228,\n\t                181,\n\t                1\n\t            ],\n\t            'navajowhite': [\n\t                255,\n\t                222,\n\t                173,\n\t                1\n\t            ],\n\t            'navy': [\n\t                0,\n\t                0,\n\t                128,\n\t                1\n\t            ],\n\t            'oldlace': [\n\t                253,\n\t                245,\n\t                230,\n\t                1\n\t            ],\n\t            'olive': [\n\t                128,\n\t                128,\n\t                0,\n\t                1\n\t            ],\n\t            'olivedrab': [\n\t                107,\n\t                142,\n\t                35,\n\t                1\n\t            ],\n\t            'orange': [\n\t                255,\n\t                165,\n\t                0,\n\t                1\n\t            ],\n\t            'orangered': [\n\t                255,\n\t                69,\n\t                0,\n\t                1\n\t            ],\n\t            'orchid': [\n\t                218,\n\t                112,\n\t                214,\n\t                1\n\t            ],\n\t            'palegoldenrod': [\n\t                238,\n\t                232,\n\t                170,\n\t                1\n\t            ],\n\t            'palegreen': [\n\t                152,\n\t                251,\n\t                152,\n\t                1\n\t            ],\n\t            'paleturquoise': [\n\t                175,\n\t                238,\n\t                238,\n\t                1\n\t            ],\n\t            'palevioletred': [\n\t                219,\n\t                112,\n\t                147,\n\t                1\n\t            ],\n\t            'papayawhip': [\n\t                255,\n\t                239,\n\t                213,\n\t                1\n\t            ],\n\t            'peachpuff': [\n\t                255,\n\t                218,\n\t                185,\n\t                1\n\t            ],\n\t            'peru': [\n\t                205,\n\t                133,\n\t                63,\n\t                1\n\t            ],\n\t            'pink': [\n\t                255,\n\t                192,\n\t                203,\n\t                1\n\t            ],\n\t            'plum': [\n\t                221,\n\t                160,\n\t                221,\n\t                1\n\t            ],\n\t            'powderblue': [\n\t                176,\n\t                224,\n\t                230,\n\t                1\n\t            ],\n\t            'purple': [\n\t                128,\n\t                0,\n\t                128,\n\t                1\n\t            ],\n\t            'red': [\n\t                255,\n\t                0,\n\t                0,\n\t                1\n\t            ],\n\t            'rosybrown': [\n\t                188,\n\t                143,\n\t                143,\n\t                1\n\t            ],\n\t            'royalblue': [\n\t                65,\n\t                105,\n\t                225,\n\t                1\n\t            ],\n\t            'saddlebrown': [\n\t                139,\n\t                69,\n\t                19,\n\t                1\n\t            ],\n\t            'salmon': [\n\t                250,\n\t                128,\n\t                114,\n\t                1\n\t            ],\n\t            'sandybrown': [\n\t                244,\n\t                164,\n\t                96,\n\t                1\n\t            ],\n\t            'seagreen': [\n\t                46,\n\t                139,\n\t                87,\n\t                1\n\t            ],\n\t            'seashell': [\n\t                255,\n\t                245,\n\t                238,\n\t                1\n\t            ],\n\t            'sienna': [\n\t                160,\n\t                82,\n\t                45,\n\t                1\n\t            ],\n\t            'silver': [\n\t                192,\n\t                192,\n\t                192,\n\t                1\n\t            ],\n\t            'skyblue': [\n\t                135,\n\t                206,\n\t                235,\n\t                1\n\t            ],\n\t            'slateblue': [\n\t                106,\n\t                90,\n\t                205,\n\t                1\n\t            ],\n\t            'slategray': [\n\t                112,\n\t                128,\n\t                144,\n\t                1\n\t            ],\n\t            'slategrey': [\n\t                112,\n\t                128,\n\t                144,\n\t                1\n\t            ],\n\t            'snow': [\n\t                255,\n\t                250,\n\t                250,\n\t                1\n\t            ],\n\t            'springgreen': [\n\t                0,\n\t                255,\n\t                127,\n\t                1\n\t            ],\n\t            'steelblue': [\n\t                70,\n\t                130,\n\t                180,\n\t                1\n\t            ],\n\t            'tan': [\n\t                210,\n\t                180,\n\t                140,\n\t                1\n\t            ],\n\t            'teal': [\n\t                0,\n\t                128,\n\t                128,\n\t                1\n\t            ],\n\t            'thistle': [\n\t                216,\n\t                191,\n\t                216,\n\t                1\n\t            ],\n\t            'tomato': [\n\t                255,\n\t                99,\n\t                71,\n\t                1\n\t            ],\n\t            'turquoise': [\n\t                64,\n\t                224,\n\t                208,\n\t                1\n\t            ],\n\t            'violet': [\n\t                238,\n\t                130,\n\t                238,\n\t                1\n\t            ],\n\t            'wheat': [\n\t                245,\n\t                222,\n\t                179,\n\t                1\n\t            ],\n\t            'white': [\n\t                255,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'whitesmoke': [\n\t                245,\n\t                245,\n\t                245,\n\t                1\n\t            ],\n\t            'yellow': [\n\t                255,\n\t                255,\n\t                0,\n\t                1\n\t            ],\n\t            'yellowgreen': [\n\t                154,\n\t                205,\n\t                50,\n\t                1\n\t            ]\n\t        };\n\t    function clampCssByte(i) {\n\t        // Clamp to integer 0 .. 255.\n\t        i = Math.round(i);\n\t        // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 255 ? 255 : i;\n\t    }\n\t    function clampCssAngle(i) {\n\t        // Clamp to integer 0 .. 360.\n\t        i = Math.round(i);\n\t        // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 360 ? 360 : i;\n\t    }\n\t    function clampCssFloat(f) {\n\t        // Clamp to float 0.0 .. 1.0.\n\t        return f < 0 ? 0 : f > 1 ? 1 : f;\n\t    }\n\t    function parseCssInt(str) {\n\t        // int or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssByte(parseFloat(str) / 100 * 255);\n\t        }\n\t        return clampCssByte(parseInt(str, 10));\n\t    }\n\t    function parseCssFloat(str) {\n\t        // float or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssFloat(parseFloat(str) / 100);\n\t        }\n\t        return clampCssFloat(parseFloat(str));\n\t    }\n\t    function cssHueToRgb(m1, m2, h) {\n\t        if (h < 0) {\n\t            h += 1;\n\t        } else if (h > 1) {\n\t            h -= 1;\n\t        }\n\t        if (h * 6 < 1) {\n\t            return m1 + (m2 - m1) * h * 6;\n\t        }\n\t        if (h * 2 < 1) {\n\t            return m2;\n\t        }\n\t        if (h * 3 < 2) {\n\t            return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n\t        }\n\t        return m1;\n\t    }\n\t    function lerp(a, b, p) {\n\t        return a + (b - a) * p;\n\t    }\n\t    /**\n\t     * @param {string} colorStr\n\t     * @return {Array.<number>}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function parse(colorStr) {\n\t        if (!colorStr) {\n\t            return;\n\t        }\n\t        // colorStr may be not string\n\t        colorStr = colorStr + '';\n\t        // Remove all whitespace, not compliant, but should just be more accepting.\n\t        var str = colorStr.replace(/ /g, '').toLowerCase();\n\t        // Color keywords (and transparent) lookup.\n\t        if (str in kCSSColorTable) {\n\t            return kCSSColorTable[str].slice();    // dup.\n\t        }\n\t        // #abc and #abc123 syntax.\n\t        if (str.charAt(0) === '#') {\n\t            if (str.length === 4) {\n\t                var iv = parseInt(str.substr(1), 16);\n\t                // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 4095)) {\n\t                    return;    // Covers NaN.\n\t                }\n\t                return [\n\t                    (iv & 3840) >> 4 | (iv & 3840) >> 8,\n\t                    iv & 240 | (iv & 240) >> 4,\n\t                    iv & 15 | (iv & 15) << 4,\n\t                    1\n\t                ];\n\t            } else if (str.length === 7) {\n\t                var iv = parseInt(str.substr(1), 16);\n\t                // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 16777215)) {\n\t                    return;    // Covers NaN.\n\t                }\n\t                return [\n\t                    (iv & 16711680) >> 16,\n\t                    (iv & 65280) >> 8,\n\t                    iv & 255,\n\t                    1\n\t                ];\n\t            }\n\t            return;\n\t        }\n\t        var op = str.indexOf('('), ep = str.indexOf(')');\n\t        if (op !== -1 && ep + 1 === str.length) {\n\t            var fname = str.substr(0, op);\n\t            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n\t            var alpha = 1;\n\t            // To allow case fallthrough.\n\t            switch (fname) {\n\t            case 'rgba':\n\t                if (params.length !== 4) {\n\t                    return;\n\t                }\n\t                alpha = parseCssFloat(params.pop());\n\t            // jshint ignore:line\n\t            // Fall through.\n\t            case 'rgb':\n\t                if (params.length !== 3) {\n\t                    return;\n\t                }\n\t                return [\n\t                    parseCssInt(params[0]),\n\t                    parseCssInt(params[1]),\n\t                    parseCssInt(params[2]),\n\t                    alpha\n\t                ];\n\t            case 'hsla':\n\t                if (params.length !== 4) {\n\t                    return;\n\t                }\n\t                params[3] = parseCssFloat(params[3]);\n\t                return hsla2rgba(params);\n\t            case 'hsl':\n\t                if (params.length !== 3) {\n\t                    return;\n\t                }\n\t                return hsla2rgba(params);\n\t            default:\n\t                return;\n\t            }\n\t        }\n\t        return;\n\t    }\n\t    /**\n\t     * @param {Array.<number>} hsla\n\t     * @return {Array.<number>} rgba\n\t     */\n\t    function hsla2rgba(hsla) {\n\t        var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;\n\t        // 0 .. 1\n\t        // NOTE(deanm): According to the CSS spec s/l should only be\n\t        // percentages, but we don't bother and let float or percentage.\n\t        var s = parseCssFloat(hsla[1]);\n\t        var l = parseCssFloat(hsla[2]);\n\t        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\t        var m1 = l * 2 - m2;\n\t        var rgba = [\n\t                clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n\t                clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n\t                clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n\t            ];\n\t        if (hsla.length === 4) {\n\t            rgba[3] = hsla[3];\n\t        }\n\t        return rgba;\n\t    }\n\t    /**\n\t     * @param {Array.<number>} rgba\n\t     * @return {Array.<number>} hsla\n\t     */\n\t    function rgba2hsla(rgba) {\n\t        if (!rgba) {\n\t            return;\n\t        }\n\t        // RGB from 0 to 255\n\t        var R = rgba[0] / 255;\n\t        var G = rgba[1] / 255;\n\t        var B = rgba[2] / 255;\n\t        var vMin = Math.min(R, G, B);\n\t        // Min. value of RGB\n\t        var vMax = Math.max(R, G, B);\n\t        // Max. value of RGB\n\t        var delta = vMax - vMin;\n\t        // Delta RGB value\n\t        var L = (vMax + vMin) / 2;\n\t        var H;\n\t        var S;\n\t        // HSL results from 0 to 1\n\t        if (delta === 0) {\n\t            H = 0;\n\t            S = 0;\n\t        } else {\n\t            if (L < 0.5) {\n\t                S = delta / (vMax + vMin);\n\t            } else {\n\t                S = delta / (2 - vMax - vMin);\n\t            }\n\t            var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n\t            var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n\t            var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n\t            if (R === vMax) {\n\t                H = deltaB - deltaG;\n\t            } else if (G === vMax) {\n\t                H = 1 / 3 + deltaR - deltaB;\n\t            } else if (B === vMax) {\n\t                H = 2 / 3 + deltaG - deltaR;\n\t            }\n\t            if (H < 0) {\n\t                H += 1;\n\t            }\n\t            if (H > 1) {\n\t                H -= 1;\n\t            }\n\t        }\n\t        var hsla = [\n\t                H * 360,\n\t                S,\n\t                L\n\t            ];\n\t        if (rgba[3] != null) {\n\t            hsla.push(rgba[3]);\n\t        }\n\t        return hsla;\n\t    }\n\t    /**\n\t     * @param {string} color\n\t     * @param {number} level\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function lift(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            for (var i = 0; i < 3; i++) {\n\t                if (level < 0) {\n\t                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n\t                } else {\n\t                    colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n\t                }\n\t            }\n\t            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n\t        }\n\t    }\n\t    /**\n\t     * @param {string} color\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function toHex(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n\t        }\n\t    }\n\t    /**\n\t     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<Array.<number>>} colors List of rgba color array\n\t     * @param {Array.<number>} [out] Mapped gba color array\n\t     * @return {Array.<number>}\n\t     */\n\t    function fastMapToColor(normalizedValue, colors, out) {\n\t        if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n\t            return;\n\t        }\n\t        out = out || [\n\t            0,\n\t            0,\n\t            0,\n\t            0\n\t        ];\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = colors[leftIndex];\n\t        var rightColor = colors[rightIndex];\n\t        var dv = value - leftIndex;\n\t        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n\t        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n\t        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n\t        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n\t        return out;\n\t    }\n\t    /**\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {boolean=} fullOutput Default false.\n\t     * @return {(string|Object)} Result color. If fullOutput,\n\t     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function mapToColor(normalizedValue, colors, fullOutput) {\n\t        if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n\t            return;\n\t        }\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = parse(colors[leftIndex]);\n\t        var rightColor = parse(colors[rightIndex]);\n\t        var dv = value - leftIndex;\n\t        var color = stringify([\n\t                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n\t                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n\t                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n\t                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n\t            ], 'rgba');\n\t        return fullOutput ? {\n\t            color: color,\n\t            leftIndex: leftIndex,\n\t            rightIndex: rightIndex,\n\t            value: value\n\t        } : color;\n\t    }\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} h 0 ~ 360, ignore when null.\n\t     * @param {number=} s 0 ~ 1, ignore when null.\n\t     * @param {number=} l 0 ~ 1, ignore when null.\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyHSL(color, h, s, l) {\n\t        color = parse(color);\n\t        if (color) {\n\t            color = rgba2hsla(color);\n\t            h != null && (color[0] = clampCssAngle(h));\n\t            s != null && (color[1] = parseCssFloat(s));\n\t            l != null && (color[2] = parseCssFloat(l));\n\t            return stringify(hsla2rgba(color), 'rgba');\n\t        }\n\t    }\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} alpha 0 ~ 1\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyAlpha(color, alpha) {\n\t        color = parse(color);\n\t        if (color && alpha != null) {\n\t            color[3] = clampCssFloat(alpha);\n\t            return stringify(color, 'rgba');\n\t        }\n\t    }\n\t    /**\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {string} type 'rgba', 'hsva', ...\n\t     * @return {string} Result color.\n\t     */\n\t    function stringify(arrColor, type) {\n\t        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\t        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n\t            colorStr += ',' + arrColor[3];\n\t        }\n\t        return type + '(' + colorStr + ')';\n\t    }\n\t    return {\n\t        parse: parse,\n\t        lift: lift,\n\t        toHex: toHex,\n\t        fastMapToColor: fastMapToColor,\n\t        mapToColor: mapToColor,\n\t        modifyHSL: modifyHSL,\n\t        modifyAlpha: modifyAlpha,\n\t        stringify: stringify\n\t    };\n\t});\n\tdefine('zrender/core/timsort', [], function () {\n\t    var DEFAULT_MIN_MERGE = 32;\n\t    var DEFAULT_MIN_GALLOPING = 7;\n\t    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\t    function minRunLength(n) {\n\t        var r = 0;\n\t        while (n >= DEFAULT_MIN_MERGE) {\n\t            r |= n & 1;\n\t            n >>= 1;\n\t        }\n\t        return n + r;\n\t    }\n\t    function makeAscendingRun(array, lo, hi, compare) {\n\t        var runHi = lo + 1;\n\t        if (runHi === hi) {\n\t            return 1;\n\t        }\n\t        if (compare(array[runHi++], array[lo]) < 0) {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n\t                runHi++;\n\t            }\n\t            reverseRun(array, lo, runHi);\n\t        } else {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n\t                runHi++;\n\t            }\n\t        }\n\t        return runHi - lo;\n\t    }\n\t    function reverseRun(array, lo, hi) {\n\t        hi--;\n\t        while (lo < hi) {\n\t            var t = array[lo];\n\t            array[lo++] = array[hi];\n\t            array[hi--] = t;\n\t        }\n\t    }\n\t    function binaryInsertionSort(array, lo, hi, start, compare) {\n\t        if (start === lo) {\n\t            start++;\n\t        }\n\t        for (; start < hi; start++) {\n\t            var pivot = array[start];\n\t            var left = lo;\n\t            var right = start;\n\t            var mid;\n\t            while (left < right) {\n\t                mid = left + right >>> 1;\n\t                if (compare(pivot, array[mid]) < 0) {\n\t                    right = mid;\n\t                } else {\n\t                    left = mid + 1;\n\t                }\n\t            }\n\t            var n = start - left;\n\t            switch (n) {\n\t            case 3:\n\t                array[left + 3] = array[left + 2];\n\t            case 2:\n\t                array[left + 2] = array[left + 1];\n\t            case 1:\n\t                array[left + 1] = array[left];\n\t                break;\n\t            default:\n\t                while (n > 0) {\n\t                    array[left + n] = array[left + n - 1];\n\t                    n--;\n\t                }\n\t            }\n\t            array[left] = pivot;\n\t        }\n\t    }\n\t    function gallopLeft(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t        if (compare(value, array[start + hint]) > 0) {\n\t            maxOffset = length - hint;\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        } else {\n\t            maxOffset = hint + 1;\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t        lastOffset++;\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t            if (compare(value, array[start + m]) > 0) {\n\t                lastOffset = m + 1;\n\t            } else {\n\t                offset = m;\n\t            }\n\t        }\n\t        return offset;\n\t    }\n\t    function gallopRight(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t        if (compare(value, array[start + hint]) < 0) {\n\t            maxOffset = hint + 1;\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        } else {\n\t            maxOffset = length - hint;\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t        lastOffset++;\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t            if (compare(value, array[start + m]) < 0) {\n\t                offset = m;\n\t            } else {\n\t                lastOffset = m + 1;\n\t            }\n\t        }\n\t        return offset;\n\t    }\n\t    function TimSort(array, compare) {\n\t        var minGallop = DEFAULT_MIN_GALLOPING;\n\t        var length = 0;\n\t        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n\t        var stackLength = 0;\n\t        var runStart;\n\t        var runLength;\n\t        var stackSize = 0;\n\t        length = array.length;\n\t        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n\t            tmpStorageLength = length >>> 1;\n\t        }\n\t        var tmp = [];\n\t        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\t        runStart = [];\n\t        runLength = [];\n\t        function pushRun(_runStart, _runLength) {\n\t            runStart[stackSize] = _runStart;\n\t            runLength[stackSize] = _runLength;\n\t            stackSize += 1;\n\t        }\n\t        function mergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n\t                    if (runLength[n - 1] < runLength[n + 1]) {\n\t                        n--;\n\t                    }\n\t                } else if (runLength[n] > runLength[n + 1]) {\n\t                    break;\n\t                }\n\t                mergeAt(n);\n\t            }\n\t        }\n\t        function forceMergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n\t                    n--;\n\t                }\n\t                mergeAt(n);\n\t            }\n\t        }\n\t        function mergeAt(i) {\n\t            var start1 = runStart[i];\n\t            var length1 = runLength[i];\n\t            var start2 = runStart[i + 1];\n\t            var length2 = runLength[i + 1];\n\t            runLength[i] = length1 + length2;\n\t            if (i === stackSize - 3) {\n\t                runStart[i + 1] = runStart[i + 2];\n\t                runLength[i + 1] = runLength[i + 2];\n\t            }\n\t            stackSize--;\n\t            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n\t            start1 += k;\n\t            length1 -= k;\n\t            if (length1 === 0) {\n\t                return;\n\t            }\n\t            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\t            if (length2 === 0) {\n\t                return;\n\t            }\n\t            if (length1 <= length2) {\n\t                mergeLow(start1, length1, start2, length2);\n\t            } else {\n\t                mergeHigh(start1, length1, start2, length2);\n\t            }\n\t        }\n\t        function mergeLow(start1, length1, start2, length2) {\n\t            var i = 0;\n\t            for (i = 0; i < length1; i++) {\n\t                tmp[i] = array[start1 + i];\n\t            }\n\t            var cursor1 = 0;\n\t            var cursor2 = start2;\n\t            var dest = start1;\n\t            array[dest++] = array[cursor2++];\n\t            if (--length2 === 0) {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t                return;\n\t            }\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t                return;\n\t            }\n\t            var _minGallop = minGallop;\n\t            var count1, count2, exit;\n\t            while (1) {\n\t                count1 = 0;\n\t                count2 = 0;\n\t                exit = false;\n\t                do {\n\t                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n\t                        array[dest++] = array[cursor2++];\n\t                        count2++;\n\t                        count1 = 0;\n\t                        if (--length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    } else {\n\t                        array[dest++] = tmp[cursor1++];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t                if (exit) {\n\t                    break;\n\t                }\n\t                do {\n\t                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\t                    if (count1 !== 0) {\n\t                        for (i = 0; i < count1; i++) {\n\t                            array[dest + i] = tmp[cursor1 + i];\n\t                        }\n\t                        dest += count1;\n\t                        cursor1 += count1;\n\t                        length1 -= count1;\n\t                        if (length1 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest++] = array[cursor2++];\n\t                    if (--length2 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\t                    if (count2 !== 0) {\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[dest + i] = array[cursor2 + i];\n\t                        }\n\t                        dest += count2;\n\t                        cursor2 += count2;\n\t                        length2 -= count2;\n\t                        if (length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest++] = tmp[cursor1++];\n\t                    if (--length1 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t                if (exit) {\n\t                    break;\n\t                }\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t                _minGallop += 2;\n\t            }\n\t            minGallop = _minGallop;\n\t            minGallop < 1 && (minGallop = 1);\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t            } else if (length1 === 0) {\n\t                throw new Error();    // throw new Error('mergeLow preconditions were not respected');\n\t            } else {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t            }\n\t        }\n\t        function mergeHigh(start1, length1, start2, length2) {\n\t            var i = 0;\n\t            for (i = 0; i < length2; i++) {\n\t                tmp[i] = array[start2 + i];\n\t            }\n\t            var cursor1 = start1 + length1 - 1;\n\t            var cursor2 = length2 - 1;\n\t            var dest = start2 + length2 - 1;\n\t            var customCursor = 0;\n\t            var customDest = 0;\n\t            array[dest--] = array[cursor1--];\n\t            if (--length1 === 0) {\n\t                customCursor = dest - (length2 - 1);\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t                return;\n\t            }\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t                array[dest] = tmp[cursor2];\n\t                return;\n\t            }\n\t            var _minGallop = minGallop;\n\t            while (true) {\n\t                var count1 = 0;\n\t                var count2 = 0;\n\t                var exit = false;\n\t                do {\n\t                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n\t                        array[dest--] = array[cursor1--];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    } else {\n\t                        array[dest--] = tmp[cursor2--];\n\t                        count2++;\n\t                        count1 = 0;\n\t                        if (--length2 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t                if (exit) {\n\t                    break;\n\t                }\n\t                do {\n\t                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\t                    if (count1 !== 0) {\n\t                        dest -= count1;\n\t                        cursor1 -= count1;\n\t                        length1 -= count1;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor1 + 1;\n\t                        for (i = count1 - 1; i >= 0; i--) {\n\t                            array[customDest + i] = array[customCursor + i];\n\t                        }\n\t                        if (length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest--] = tmp[cursor2--];\n\t                    if (--length2 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\t                    if (count2 !== 0) {\n\t                        dest -= count2;\n\t                        cursor2 -= count2;\n\t                        length2 -= count2;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor2 + 1;\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[customDest + i] = tmp[customCursor + i];\n\t                        }\n\t                        if (length2 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest--] = array[cursor1--];\n\t                    if (--length1 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t                if (exit) {\n\t                    break;\n\t                }\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t                _minGallop += 2;\n\t            }\n\t            minGallop = _minGallop;\n\t            if (minGallop < 1) {\n\t                minGallop = 1;\n\t            }\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t                array[dest] = tmp[cursor2];\n\t            } else if (length2 === 0) {\n\t                throw new Error();    // throw new Error('mergeHigh preconditions were not respected');\n\t            } else {\n\t                customCursor = dest - (length2 - 1);\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t            }\n\t        }\n\t        this.mergeRuns = mergeRuns;\n\t        this.forceMergeRuns = forceMergeRuns;\n\t        this.pushRun = pushRun;\n\t    }\n\t    function sort(array, compare, lo, hi) {\n\t        if (!lo) {\n\t            lo = 0;\n\t        }\n\t        if (!hi) {\n\t            hi = array.length;\n\t        }\n\t        var remaining = hi - lo;\n\t        if (remaining < 2) {\n\t            return;\n\t        }\n\t        var runLength = 0;\n\t        if (remaining < DEFAULT_MIN_MERGE) {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n\t            return;\n\t        }\n\t        var ts = new TimSort(array, compare);\n\t        var minRun = minRunLength(remaining);\n\t        do {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            if (runLength < minRun) {\n\t                var force = remaining;\n\t                if (force > minRun) {\n\t                    force = minRun;\n\t                }\n\t                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n\t                runLength = force;\n\t            }\n\t            ts.pushRun(lo, runLength);\n\t            ts.mergeRuns();\n\t            remaining -= runLength;\n\t            lo += runLength;\n\t        } while (remaining !== 0);\n\t        ts.forceMergeRuns();\n\t    }\n\t    return sort;\n\t});\n\tdefine('echarts/visual/seriesColor', ['require', 'zrender/graphic/Gradient'], function (require) {\n\t    var Gradient = require('zrender/graphic/Gradient');\n\t    return function (ecModel) {\n\t        function encodeColor(seriesModel) {\n\t            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n\t            var data = seriesModel.getData();\n\t            var color = seriesModel.get(colorAccessPath) || seriesModel.getColorFromPalette(seriesModel.get('name'));\n\t            // Default color\n\t            // FIXME Set color function or use the platte color\n\t            data.setVisual('color', color);\n\t            // Only visible series has each data be visual encoded\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                if (typeof color === 'function' && !(color instanceof Gradient)) {\n\t                    data.each(function (idx) {\n\t                        data.setItemVisual(idx, 'color', color(seriesModel.getDataParams(idx)));\n\t                    });\n\t                }\n\t                // itemStyle in each data item\n\t                data.each(function (idx) {\n\t                    var itemModel = data.getItemModel(idx);\n\t                    var color = itemModel.get(colorAccessPath, true);\n\t                    if (color != null) {\n\t                        data.setItemVisual(idx, 'color', color);\n\t                    }\n\t                });\n\t            }\n\t        }\n\t        ecModel.eachRawSeries(encodeColor);\n\t    };\n\t});\n\tdefine('echarts/preprocessor/backwardCompat', ['require', 'zrender/core/util', './helper/compatStyle'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var compatStyle = require('./helper/compatStyle');\n\t    function get(opt, path) {\n\t        path = path.split(',');\n\t        var obj = opt;\n\t        for (var i = 0; i < path.length; i++) {\n\t            obj = obj && obj[path[i]];\n\t            if (obj == null) {\n\t                break;\n\t            }\n\t        }\n\t        return obj;\n\t    }\n\t    function set(opt, path, val, overwrite) {\n\t        path = path.split(',');\n\t        var obj = opt;\n\t        var key;\n\t        for (var i = 0; i < path.length - 1; i++) {\n\t            key = path[i];\n\t            if (obj[key] == null) {\n\t                obj[key] = {};\n\t            }\n\t            obj = obj[key];\n\t        }\n\t        if (overwrite || obj[path[i]] == null) {\n\t            obj[path[i]] = val;\n\t        }\n\t    }\n\t    function compatLayoutProperties(option) {\n\t        each(LAYOUT_PROPERTIES, function (prop) {\n\t            if (prop[0] in option && !(prop[1] in option)) {\n\t                option[prop[1]] = option[prop[0]];\n\t            }\n\t        });\n\t    }\n\t    var LAYOUT_PROPERTIES = [\n\t            [\n\t                'x',\n\t                'left'\n\t            ],\n\t            [\n\t                'y',\n\t                'top'\n\t            ],\n\t            [\n\t                'x2',\n\t                'right'\n\t            ],\n\t            [\n\t                'y2',\n\t                'bottom'\n\t            ]\n\t        ];\n\t    var COMPATITABLE_COMPONENTS = [\n\t            'grid',\n\t            'geo',\n\t            'parallel',\n\t            'legend',\n\t            'toolbox',\n\t            'title',\n\t            'visualMap',\n\t            'dataZoom',\n\t            'timeline'\n\t        ];\n\t    var COMPATITABLE_SERIES = [\n\t            'bar',\n\t            'boxplot',\n\t            'candlestick',\n\t            'chord',\n\t            'effectScatter',\n\t            'funnel',\n\t            'gauge',\n\t            'lines',\n\t            'graph',\n\t            'heatmap',\n\t            'line',\n\t            'map',\n\t            'parallel',\n\t            'pie',\n\t            'radar',\n\t            'sankey',\n\t            'scatter',\n\t            'treemap'\n\t        ];\n\t    var each = zrUtil.each;\n\t    return function (option) {\n\t        each(option.series, function (seriesOpt) {\n\t            if (!zrUtil.isObject(seriesOpt)) {\n\t                return;\n\t            }\n\t            var seriesType = seriesOpt.type;\n\t            compatStyle(seriesOpt);\n\t            if (seriesType === 'pie' || seriesType === 'gauge') {\n\t                if (seriesOpt.clockWise != null) {\n\t                    seriesOpt.clockwise = seriesOpt.clockWise;\n\t                }\n\t            }\n\t            if (seriesType === 'gauge') {\n\t                var pointerColor = get(seriesOpt, 'pointer.color');\n\t                pointerColor != null && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n\t            }\n\t            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n\t                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n\t                    compatLayoutProperties(seriesOpt);\n\t                    break;\n\t                }\n\t            }\n\t        });\n\t        // dataRange has changed to visualMap\n\t        if (option.dataRange) {\n\t            option.visualMap = option.dataRange;\n\t        }\n\t        each(COMPATITABLE_COMPONENTS, function (componentName) {\n\t            var options = option[componentName];\n\t            if (options) {\n\t                if (!zrUtil.isArray(options)) {\n\t                    options = [options];\n\t                }\n\t                each(options, function (option) {\n\t                    compatLayoutProperties(option);\n\t                });\n\t            }\n\t        });\n\t    };\n\t});\n\tdefine('echarts/loading/default', ['require', '../util/graphic', 'zrender/core/util'], function (require) {\n\t    var graphic = require('../util/graphic');\n\t    var zrUtil = require('zrender/core/util');\n\t    var PI = Math.PI;\n\t    /**\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     * @param {Object} [opts]\n\t     * @param {string} [opts.text]\n\t     * @param {string} [opts.color]\n\t     * @param {string} [opts.textColor]\n\t     * @return {module:zrender/Element}\n\t     */\n\t    return function (api, opts) {\n\t        opts = opts || {};\n\t        zrUtil.defaults(opts, {\n\t            text: 'loading',\n\t            color: '#c23531',\n\t            textColor: '#000',\n\t            maskColor: 'rgba(255, 255, 255, 0.8)',\n\t            zlevel: 0\n\t        });\n\t        var mask = new graphic.Rect({\n\t                style: { fill: opts.maskColor },\n\t                zlevel: opts.zlevel,\n\t                z: 10000\n\t            });\n\t        var arc = new graphic.Arc({\n\t                shape: {\n\t                    startAngle: -PI / 2,\n\t                    endAngle: -PI / 2 + 0.1,\n\t                    r: 10\n\t                },\n\t                style: {\n\t                    stroke: opts.color,\n\t                    lineCap: 'round',\n\t                    lineWidth: 5\n\t                },\n\t                zlevel: opts.zlevel,\n\t                z: 10001\n\t            });\n\t        var labelRect = new graphic.Rect({\n\t                style: {\n\t                    fill: 'none',\n\t                    text: opts.text,\n\t                    textPosition: 'right',\n\t                    textDistance: 10,\n\t                    textFill: opts.textColor\n\t                },\n\t                zlevel: opts.zlevel,\n\t                z: 10001\n\t            });\n\t        arc.animateShape(true).when(1000, { endAngle: PI * 3 / 2 }).start('circularInOut');\n\t        arc.animateShape(true).when(1000, { startAngle: PI * 3 / 2 }).delay(300).start('circularInOut');\n\t        var group = new graphic.Group();\n\t        group.add(arc);\n\t        group.add(labelRect);\n\t        group.add(mask);\n\t        // Inject resize\n\t        group.resize = function () {\n\t            var cx = api.getWidth() / 2;\n\t            var cy = api.getHeight() / 2;\n\t            arc.setShape({\n\t                cx: cx,\n\t                cy: cy\n\t            });\n\t            var r = arc.shape.r;\n\t            labelRect.setShape({\n\t                x: cx - r,\n\t                y: cy - r,\n\t                width: r * 2,\n\t                height: r * 2\n\t            });\n\t            mask.setShape({\n\t                x: 0,\n\t                y: 0,\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            });\n\t        };\n\t        group.resize();\n\t        return group;\n\t    };\n\t});\n\tdefine('zrender/core/matrix', [], function () {\n\t    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n\t    /**\n\t     * 3x2矩阵操作类\n\t     * @exports zrender/tool/matrix\n\t     */\n\t    var matrix = {\n\t            create: function () {\n\t                var out = new ArrayCtor(6);\n\t                matrix.identity(out);\n\t                return out;\n\t            },\n\t            identity: function (out) {\n\t                out[0] = 1;\n\t                out[1] = 0;\n\t                out[2] = 0;\n\t                out[3] = 1;\n\t                out[4] = 0;\n\t                out[5] = 0;\n\t                return out;\n\t            },\n\t            copy: function (out, m) {\n\t                out[0] = m[0];\n\t                out[1] = m[1];\n\t                out[2] = m[2];\n\t                out[3] = m[3];\n\t                out[4] = m[4];\n\t                out[5] = m[5];\n\t                return out;\n\t            },\n\t            mul: function (out, m1, m2) {\n\t                // Consider matrix.mul(m, m2, m);\n\t                // where out is the same as m2.\n\t                // So use temp variable to escape error.\n\t                var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n\t                var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n\t                var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n\t                var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n\t                var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n\t                var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n\t                out[0] = out0;\n\t                out[1] = out1;\n\t                out[2] = out2;\n\t                out[3] = out3;\n\t                out[4] = out4;\n\t                out[5] = out5;\n\t                return out;\n\t            },\n\t            translate: function (out, a, v) {\n\t                out[0] = a[0];\n\t                out[1] = a[1];\n\t                out[2] = a[2];\n\t                out[3] = a[3];\n\t                out[4] = a[4] + v[0];\n\t                out[5] = a[5] + v[1];\n\t                return out;\n\t            },\n\t            rotate: function (out, a, rad) {\n\t                var aa = a[0];\n\t                var ac = a[2];\n\t                var atx = a[4];\n\t                var ab = a[1];\n\t                var ad = a[3];\n\t                var aty = a[5];\n\t                var st = Math.sin(rad);\n\t                var ct = Math.cos(rad);\n\t                out[0] = aa * ct + ab * st;\n\t                out[1] = -aa * st + ab * ct;\n\t                out[2] = ac * ct + ad * st;\n\t                out[3] = -ac * st + ct * ad;\n\t                out[4] = ct * atx + st * aty;\n\t                out[5] = ct * aty - st * atx;\n\t                return out;\n\t            },\n\t            scale: function (out, a, v) {\n\t                var vx = v[0];\n\t                var vy = v[1];\n\t                out[0] = a[0] * vx;\n\t                out[1] = a[1] * vy;\n\t                out[2] = a[2] * vx;\n\t                out[3] = a[3] * vy;\n\t                out[4] = a[4] * vx;\n\t                out[5] = a[5] * vy;\n\t                return out;\n\t            },\n\t            invert: function (out, a) {\n\t                var aa = a[0];\n\t                var ac = a[2];\n\t                var atx = a[4];\n\t                var ab = a[1];\n\t                var ad = a[3];\n\t                var aty = a[5];\n\t                var det = aa * ad - ab * ac;\n\t                if (!det) {\n\t                    return null;\n\t                }\n\t                det = 1 / det;\n\t                out[0] = ad * det;\n\t                out[1] = -ab * det;\n\t                out[2] = -ac * det;\n\t                out[3] = aa * det;\n\t                out[4] = (ac * aty - ad * atx) * det;\n\t                out[5] = (ab * atx - aa * aty) * det;\n\t                return out;\n\t            }\n\t        };\n\t    return matrix;\n\t});\n\tdefine('echarts/model/Model', ['require', 'zrender/core/util', '../util/clazz', './mixin/lineStyle', './mixin/areaStyle', './mixin/textStyle', './mixin/itemStyle'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var clazzUtil = require('../util/clazz');\n\t    /**\n\t     * @alias module:echarts/model/Model\n\t     * @constructor\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} [parentModel]\n\t     * @param {module:echarts/model/Global} [ecModel]\n\t     */\n\t    function Model(option, parentModel, ecModel) {\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         * @readOnly\n\t         */\n\t        this.parentModel = parentModel;\n\t        /**\n\t         * @type {module:echarts/model/Global}\n\t         * @readOnly\n\t         */\n\t        this.ecModel = ecModel;\n\t        /**\n\t         * @type {Object}\n\t         * @protected\n\t         */\n\t        this.option = option;    // Simple optimization\n\t                                 // if (this.init) {\n\t                                 //     if (arguments.length <= 4) {\n\t                                 //         this.init(option, parentModel, ecModel, extraOpt);\n\t                                 //     }\n\t                                 //     else {\n\t                                 //         this.init.apply(this, arguments);\n\t                                 //     }\n\t                                 // }\n\t    }\n\t    Model.prototype = {\n\t        constructor: Model,\n\t        init: null,\n\t        mergeOption: function (option) {\n\t            zrUtil.merge(this.option, option, true);\n\t        },\n\t        get: function (path, ignoreParent) {\n\t            if (!path) {\n\t                return this.option;\n\t            }\n\t            if (typeof path === 'string') {\n\t                path = path.split('.');\n\t            }\n\t            var obj = this.option;\n\t            var parentModel = this.parentModel;\n\t            for (var i = 0; i < path.length; i++) {\n\t                // Ignore empty\n\t                if (!path[i]) {\n\t                    continue;\n\t                }\n\t                // obj could be number/string/... (like 0)\n\t                obj = obj && typeof obj === 'object' ? obj[path[i]] : null;\n\t                if (obj == null) {\n\t                    break;\n\t                }\n\t            }\n\t            if (obj == null && parentModel && !ignoreParent) {\n\t                obj = parentModel.get(path);\n\t            }\n\t            return obj;\n\t        },\n\t        getShallow: function (key, ignoreParent) {\n\t            var option = this.option;\n\t            var val = option == null ? option : option[key];\n\t            var parentModel = this.parentModel;\n\t            if (val == null && parentModel && !ignoreParent) {\n\t                val = parentModel.getShallow(key);\n\t            }\n\t            return val;\n\t        },\n\t        getModel: function (path, parentModel) {\n\t            var obj = this.get(path, true);\n\t            var thisParentModel = this.parentModel;\n\t            var model = new Model(obj, parentModel || thisParentModel && thisParentModel.getModel(path), this.ecModel);\n\t            return model;\n\t        },\n\t        isEmpty: function () {\n\t            return this.option == null;\n\t        },\n\t        restoreData: function () {\n\t        },\n\t        clone: function () {\n\t            var Ctor = this.constructor;\n\t            return new Ctor(zrUtil.clone(this.option));\n\t        },\n\t        setReadOnly: function (properties) {\n\t            clazzUtil.setReadOnly(this, properties);\n\t        }\n\t    };\n\t    // Enable Model.extend.\n\t    clazzUtil.enableClassExtend(Model);\n\t    var mixin = zrUtil.mixin;\n\t    mixin(Model, require('./mixin/lineStyle'));\n\t    mixin(Model, require('./mixin/areaStyle'));\n\t    mixin(Model, require('./mixin/textStyle'));\n\t    mixin(Model, require('./mixin/itemStyle'));\n\t    return Model;\n\t});\n\tdefine('echarts/data/List', ['require', '../model/Model', './DataDiffer', 'zrender/core/util', '../util/model'], function (require) {\n\t    var UNDEFINED = 'undefined';\n\t    var globalObj = typeof window === 'undefined' ? global : window;\n\t    var Float64Array = typeof globalObj.Float64Array === UNDEFINED ? Array : globalObj.Float64Array;\n\t    var Int32Array = typeof globalObj.Int32Array === UNDEFINED ? Array : globalObj.Int32Array;\n\t    var dataCtors = {\n\t            'float': Float64Array,\n\t            'int': Int32Array,\n\t            'ordinal': Array,\n\t            'number': Array,\n\t            'time': Array\n\t        };\n\t    var Model = require('../model/Model');\n\t    var DataDiffer = require('./DataDiffer');\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../util/model');\n\t    var isObject = zrUtil.isObject;\n\t    var TRANSFERABLE_PROPERTIES = [\n\t            'stackedOn',\n\t            'hasItemOption',\n\t            '_nameList',\n\t            '_idList',\n\t            '_rawData'\n\t        ];\n\t    var transferProperties = function (a, b) {\n\t        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n\t            if (b.hasOwnProperty(propName)) {\n\t                a[propName] = b[propName];\n\t            }\n\t        });\n\t        a.__wrappedMethods = b.__wrappedMethods;\n\t    };\n\t    /**\n\t     * @constructor\n\t     * @alias module:echarts/data/List\n\t     *\n\t     * @param {Array.<string>} dimensions\n\t     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n\t     * @param {module:echarts/model/Model} hostModel\n\t     */\n\t    var List = function (dimensions, hostModel) {\n\t        dimensions = dimensions || [\n\t            'x',\n\t            'y'\n\t        ];\n\t        var dimensionInfos = {};\n\t        var dimensionNames = [];\n\t        for (var i = 0; i < dimensions.length; i++) {\n\t            var dimensionName;\n\t            var dimensionInfo = {};\n\t            if (typeof dimensions[i] === 'string') {\n\t                dimensionName = dimensions[i];\n\t                dimensionInfo = {\n\t                    name: dimensionName,\n\t                    stackable: false,\n\t                    type: 'number'\n\t                };\n\t            } else {\n\t                dimensionInfo = dimensions[i];\n\t                dimensionName = dimensionInfo.name;\n\t                dimensionInfo.type = dimensionInfo.type || 'number';\n\t            }\n\t            dimensionNames.push(dimensionName);\n\t            dimensionInfos[dimensionName] = dimensionInfo;\n\t        }\n\t        /**\n\t         * @readOnly\n\t         * @type {Array.<string>}\n\t         */\n\t        this.dimensions = dimensionNames;\n\t        /**\n\t         * Infomation of each data dimension, like data type.\n\t         * @type {Object}\n\t         */\n\t        this._dimensionInfos = dimensionInfos;\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         */\n\t        this.hostModel = hostModel;\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         */\n\t        this.dataType;\n\t        /**\n\t         * Indices stores the indices of data subset after filtered.\n\t         * This data subset will be used in chart.\n\t         * @type {Array.<number>}\n\t         * @readOnly\n\t         */\n\t        this.indices = [];\n\t        /**\n\t         * Data storage\n\t         * @type {Object.<key, TypedArray|Array>}\n\t         * @private\n\t         */\n\t        this._storage = {};\n\t        /**\n\t         * @type {Array.<string>}\n\t         */\n\t        this._nameList = [];\n\t        /**\n\t         * @type {Array.<string>}\n\t         */\n\t        this._idList = [];\n\t        /**\n\t         * Models of data option is stored sparse for optimizing memory cost\n\t         * @type {Array.<module:echarts/model/Model>}\n\t         * @private\n\t         */\n\t        this._optionModels = [];\n\t        /**\n\t         * @param {module:echarts/data/List}\n\t         */\n\t        this.stackedOn = null;\n\t        /**\n\t         * Global visual properties after visual coding\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._visual = {};\n\t        /**\n\t         * Globel layout properties.\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._layout = {};\n\t        /**\n\t         * Item visual properties after visual coding\n\t         * @type {Array.<Object>}\n\t         * @private\n\t         */\n\t        this._itemVisuals = [];\n\t        /**\n\t         * Item layout properties after layout\n\t         * @type {Array.<Object>}\n\t         * @private\n\t         */\n\t        this._itemLayouts = [];\n\t        /**\n\t         * Graphic elemnents\n\t         * @type {Array.<module:zrender/Element>}\n\t         * @private\n\t         */\n\t        this._graphicEls = [];\n\t        /**\n\t         * @type {Array.<Array|Object>}\n\t         * @private\n\t         */\n\t        this._rawData;\n\t        /**\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._extent;\n\t    };\n\t    var listProto = List.prototype;\n\t    listProto.type = 'list';\n\t    /**\n\t     * If each data item has it's own option\n\t     * @type {boolean}\n\t     */\n\t    listProto.hasItemOption = true;\n\t    /**\n\t     * Get dimension name\n\t     * @param {string|number} dim\n\t     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n\t     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n\t     * @return {string} Concrete dim name.\n\t     */\n\t    listProto.getDimension = function (dim) {\n\t        if (!isNaN(dim)) {\n\t            dim = this.dimensions[dim] || dim;\n\t        }\n\t        return dim;\n\t    };\n\t    /**\n\t     * Get type and stackable info of particular dimension\n\t     * @param {string|number} dim\n\t     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n\t     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n\t     */\n\t    listProto.getDimensionInfo = function (dim) {\n\t        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n\t    };\n\t    /**\n\t     * Initialize from data\n\t     * @param {Array.<Object|number|Array>} data\n\t     * @param {Array.<string>} [nameList]\n\t     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n\t     */\n\t    listProto.initData = function (data, nameList, dimValueGetter) {\n\t        data = data || [];\n\t        if (true) {\n\t            if (!zrUtil.isArray(data)) {\n\t                throw new Error('Invalid data.');\n\t            }\n\t        }\n\t        this._rawData = data;\n\t        // Clear\n\t        var storage = this._storage = {};\n\t        var indices = this.indices = [];\n\t        var dimensions = this.dimensions;\n\t        var size = data.length;\n\t        var dimensionInfoMap = this._dimensionInfos;\n\t        var idList = [];\n\t        var nameRepeatCount = {};\n\t        nameList = nameList || [];\n\t        // Init storage\n\t        for (var i = 0; i < dimensions.length; i++) {\n\t            var dimInfo = dimensionInfoMap[dimensions[i]];\n\t            var DataCtor = dataCtors[dimInfo.type];\n\t            storage[dimensions[i]] = new DataCtor(size);\n\t        }\n\t        var self = this;\n\t        if (!dimValueGetter) {\n\t            self.hasItemOption = false;\n\t        }\n\t        // Default dim value getter\n\t        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n\t            var value = modelUtil.getDataItemValue(dataItem);\n\t            // If any dataItem is like { value: 10 }\n\t            if (modelUtil.isDataItemOption(dataItem)) {\n\t                self.hasItemOption = true;\n\t            }\n\t            return modelUtil.converDataValue(value instanceof Array ? value[dimIndex] : value, dimensionInfoMap[dimName]);\n\t        };\n\t        for (var idx = 0; idx < data.length; idx++) {\n\t            var dataItem = data[idx];\n\t            // Each data item is value\n\t            // [1, 2]\n\t            // 2\n\t            // Bar chart, line chart which uses category axis\n\t            // only gives the 'y' value. 'x' value is the indices of cateogry\n\t            // Use a tempValue to normalize the value to be a (x, y) value\n\t            // Store the data by dimensions\n\t            for (var k = 0; k < dimensions.length; k++) {\n\t                var dim = dimensions[k];\n\t                var dimStorage = storage[dim];\n\t                // PENDING NULL is empty or zero\n\t                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n\t            }\n\t            indices.push(idx);\n\t        }\n\t        // Use the name in option and create id\n\t        for (var i = 0; i < data.length; i++) {\n\t            if (!nameList[i]) {\n\t                if (data[i] && data[i].name != null) {\n\t                    nameList[i] = data[i].name;\n\t                }\n\t            }\n\t            var name = nameList[i] || '';\n\t            // Try using the id in option\n\t            var id = data[i] && data[i].id;\n\t            if (!id && name) {\n\t                // Use name as id and add counter to avoid same name\n\t                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n\t                id = name;\n\t                if (nameRepeatCount[name] > 0) {\n\t                    id += '__ec__' + nameRepeatCount[name];\n\t                }\n\t                nameRepeatCount[name]++;\n\t            }\n\t            id && (idList[i] = id);\n\t        }\n\t        this._nameList = nameList;\n\t        this._idList = idList;\n\t    };\n\t    /**\n\t     * @return {number}\n\t     */\n\t    listProto.count = function () {\n\t        return this.indices.length;\n\t    };\n\t    /**\n\t     * Get value. Return NaN if idx is out of range.\n\t     * @param {string} dim Dim must be concrete name.\n\t     * @param {number} idx\n\t     * @param {boolean} stack\n\t     * @return {number}\n\t     */\n\t    listProto.get = function (dim, idx, stack) {\n\t        var storage = this._storage;\n\t        var dataIndex = this.indices[idx];\n\t        // If value not exists\n\t        if (dataIndex == null) {\n\t            return NaN;\n\t        }\n\t        var value = storage[dim] && storage[dim][dataIndex];\n\t        // FIXME ordinal data type is not stackable\n\t        if (stack) {\n\t            var dimensionInfo = this._dimensionInfos[dim];\n\t            if (dimensionInfo && dimensionInfo.stackable) {\n\t                var stackedOn = this.stackedOn;\n\t                while (stackedOn) {\n\t                    // Get no stacked data of stacked on\n\t                    var stackedValue = stackedOn.get(dim, idx);\n\t                    // Considering positive stack, negative stack and empty data\n\t                    if (value >= 0 && stackedValue > 0 || value <= 0 && stackedValue < 0) {\n\t                        value += stackedValue;\n\t                    }\n\t                    stackedOn = stackedOn.stackedOn;\n\t                }\n\t            }\n\t        }\n\t        return value;\n\t    };\n\t    /**\n\t     * Get value for multi dimensions.\n\t     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n\t     * @param {number} idx\n\t     * @param {boolean} stack\n\t     * @return {number}\n\t     */\n\t    listProto.getValues = function (dimensions, idx, stack) {\n\t        var values = [];\n\t        if (!zrUtil.isArray(dimensions)) {\n\t            stack = idx;\n\t            idx = dimensions;\n\t            dimensions = this.dimensions;\n\t        }\n\t        for (var i = 0, len = dimensions.length; i < len; i++) {\n\t            values.push(this.get(dimensions[i], idx, stack));\n\t        }\n\t        return values;\n\t    };\n\t    /**\n\t     * If value is NaN. Inlcuding '-'\n\t     * @param {string} dim\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.hasValue = function (idx) {\n\t        var dimensions = this.dimensions;\n\t        var dimensionInfos = this._dimensionInfos;\n\t        for (var i = 0, len = dimensions.length; i < len; i++) {\n\t            if (dimensionInfos[dimensions[i]].type !== 'ordinal' && isNaN(this.get(dimensions[i], idx))) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    };\n\t    /**\n\t     * Get extent of data in one dimension\n\t     * @param {string} dim\n\t     * @param {boolean} stack\n\t     */\n\t    listProto.getDataExtent = function (dim, stack) {\n\t        dim = this.getDimension(dim);\n\t        var dimData = this._storage[dim];\n\t        var dimInfo = this.getDimensionInfo(dim);\n\t        stack = dimInfo && dimInfo.stackable && stack;\n\t        var dimExtent = (this._extent || (this._extent = {}))[dim + !!stack];\n\t        var value;\n\t        if (dimExtent) {\n\t            return dimExtent;\n\t        }\n\t        // var dimInfo = this._dimensionInfos[dim];\n\t        if (dimData) {\n\t            var min = Infinity;\n\t            var max = -Infinity;\n\t            // var isOrdinal = dimInfo.type === 'ordinal';\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                value = this.get(dim, i, stack);\n\t                // FIXME\n\t                // if (isOrdinal && typeof value === 'string') {\n\t                //     value = zrUtil.indexOf(dimData, value);\n\t                // }\n\t                value < min && (min = value);\n\t                value > max && (max = value);\n\t            }\n\t            return this._extent[dim + !!stack] = [\n\t                min,\n\t                max\n\t            ];\n\t        } else {\n\t            return [\n\t                Infinity,\n\t                -Infinity\n\t            ];\n\t        }\n\t    };\n\t    /**\n\t     * Get sum of data in one dimension\n\t     * @param {string} dim\n\t     * @param {boolean} stack\n\t     */\n\t    listProto.getSum = function (dim, stack) {\n\t        var dimData = this._storage[dim];\n\t        var sum = 0;\n\t        if (dimData) {\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                var value = this.get(dim, i, stack);\n\t                if (!isNaN(value)) {\n\t                    sum += value;\n\t                }\n\t            }\n\t        }\n\t        return sum;\n\t    };\n\t    /**\n\t     * Retreive the index with given value\n\t     * @param {number} idx\n\t     * @param {number} value\n\t     * @return {number}\n\t     */\n\t    // FIXME Precision of float value\n\t    listProto.indexOf = function (dim, value) {\n\t        var storage = this._storage;\n\t        var dimData = storage[dim];\n\t        var indices = this.indices;\n\t        if (dimData) {\n\t            for (var i = 0, len = indices.length; i < len; i++) {\n\t                var rawIndex = indices[i];\n\t                if (dimData[rawIndex] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t    /**\n\t     * Retreive the index with given name\n\t     * @param {number} idx\n\t     * @param {number} name\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfName = function (name) {\n\t        var indices = this.indices;\n\t        var nameList = this._nameList;\n\t        for (var i = 0, len = indices.length; i < len; i++) {\n\t            var rawIndex = indices[i];\n\t            if (nameList[rawIndex] === name) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t    /**\n\t     * Retreive the index with given raw data index\n\t     * @param {number} idx\n\t     * @param {number} name\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfRawIndex = function (rawIndex) {\n\t        // Indices are ascending\n\t        var indices = this.indices;\n\t        var left = 0;\n\t        var right = indices.length - 1;\n\t        while (left <= right) {\n\t            var mid = (left + right) / 2 | 0;\n\t            if (indices[mid] < rawIndex) {\n\t                left = mid + 1;\n\t            } else if (indices[mid] > rawIndex) {\n\t                right = mid - 1;\n\t            } else {\n\t                return mid;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t    /**\n\t     * Retreive the index of nearest value\n\t     * @param {string} dim\n\t     * @param {number} value\n\t     * @param {boolean} stack If given value is after stacked\n\t     * @param {number} [maxDistance=Infinity]\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {\n\t        var storage = this._storage;\n\t        var dimData = storage[dim];\n\t        if (maxDistance == null) {\n\t            maxDistance = Infinity;\n\t        }\n\t        var nearestIdx = -1;\n\t        if (dimData) {\n\t            var minDist = Number.MAX_VALUE;\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                var diff = value - this.get(dim, i, stack);\n\t                var dist = Math.abs(diff);\n\t                if (diff <= maxDistance && (dist < minDist || dist === minDist && diff > 0)) {\n\t                    minDist = dist;\n\t                    nearestIdx = i;\n\t                }\n\t            }\n\t        }\n\t        return nearestIdx;\n\t    };\n\t    /**\n\t     * Get raw data index\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.getRawIndex = function (idx) {\n\t        var rawIdx = this.indices[idx];\n\t        return rawIdx == null ? -1 : rawIdx;\n\t    };\n\t    /**\n\t     * Get raw data item\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.getRawDataItem = function (idx) {\n\t        return this._rawData[this.getRawIndex(idx)];\n\t    };\n\t    /**\n\t     * @param {number} idx\n\t     * @param {boolean} [notDefaultIdx=false]\n\t     * @return {string}\n\t     */\n\t    listProto.getName = function (idx) {\n\t        return this._nameList[this.indices[idx]] || '';\n\t    };\n\t    /**\n\t     * @param {number} idx\n\t     * @param {boolean} [notDefaultIdx=false]\n\t     * @return {string}\n\t     */\n\t    listProto.getId = function (idx) {\n\t        return this._idList[this.indices[idx]] || this.getRawIndex(idx) + '';\n\t    };\n\t    function normalizeDimensions(dimensions) {\n\t        if (!zrUtil.isArray(dimensions)) {\n\t            dimensions = [dimensions];\n\t        }\n\t        return dimensions;\n\t    }\n\t    /**\n\t     * Data iteration\n\t     * @param {string|Array.<string>}\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     *\n\t     * @example\n\t     *  list.each('x', function (x, idx) {});\n\t     *  list.each(['x', 'y'], function (x, y, idx) {});\n\t     *  list.each(function (idx) {})\n\t     */\n\t    listProto.each = function (dims, cb, stack, context) {\n\t        if (typeof dims === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dims;\n\t            dims = [];\n\t        }\n\t        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\t        var value = [];\n\t        var dimSize = dims.length;\n\t        var indices = this.indices;\n\t        context = context || this;\n\t        for (var i = 0; i < indices.length; i++) {\n\t            // Simple optimization\n\t            switch (dimSize) {\n\t            case 0:\n\t                cb.call(context, i);\n\t                break;\n\t            case 1:\n\t                cb.call(context, this.get(dims[0], i, stack), i);\n\t                break;\n\t            case 2:\n\t                cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n\t                break;\n\t            default:\n\t                for (var k = 0; k < dimSize; k++) {\n\t                    value[k] = this.get(dims[k], i, stack);\n\t                }\n\t                // Index\n\t                value[k] = i;\n\t                cb.apply(context, value);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t     * Data filter\n\t     * @param {string|Array.<string>}\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     */\n\t    listProto.filterSelf = function (dimensions, cb, stack, context) {\n\t        if (typeof dimensions === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dimensions;\n\t            dimensions = [];\n\t        }\n\t        dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n\t        var newIndices = [];\n\t        var value = [];\n\t        var dimSize = dimensions.length;\n\t        var indices = this.indices;\n\t        context = context || this;\n\t        for (var i = 0; i < indices.length; i++) {\n\t            var keep;\n\t            // Simple optimization\n\t            if (dimSize === 1) {\n\t                keep = cb.call(context, this.get(dimensions[0], i, stack), i);\n\t            } else {\n\t                for (var k = 0; k < dimSize; k++) {\n\t                    value[k] = this.get(dimensions[k], i, stack);\n\t                }\n\t                value[k] = i;\n\t                keep = cb.apply(context, value);\n\t            }\n\t            if (keep) {\n\t                newIndices.push(indices[i]);\n\t            }\n\t        }\n\t        this.indices = newIndices;\n\t        // Reset data extent\n\t        this._extent = {};\n\t        return this;\n\t    };\n\t    /**\n\t     * Data mapping to a plain array\n\t     * @param {string|Array.<string>} [dimensions]\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     * @return {Array}\n\t     */\n\t    listProto.mapArray = function (dimensions, cb, stack, context) {\n\t        if (typeof dimensions === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dimensions;\n\t            dimensions = [];\n\t        }\n\t        var result = [];\n\t        this.each(dimensions, function () {\n\t            result.push(cb && cb.apply(this, arguments));\n\t        }, stack, context);\n\t        return result;\n\t    };\n\t    function cloneListForMapAndSample(original, excludeDimensions) {\n\t        var allDimensions = original.dimensions;\n\t        var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel);\n\t        // FIXME If needs stackedOn, value may already been stacked\n\t        transferProperties(list, original);\n\t        var storage = list._storage = {};\n\t        var originalStorage = original._storage;\n\t        // Init storage\n\t        for (var i = 0; i < allDimensions.length; i++) {\n\t            var dim = allDimensions[i];\n\t            var dimStore = originalStorage[dim];\n\t            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n\t                storage[dim] = new dimStore.constructor(originalStorage[dim].length);\n\t            } else {\n\t                // Direct reference for other dimensions\n\t                storage[dim] = originalStorage[dim];\n\t            }\n\t        }\n\t        return list;\n\t    }\n\t    /**\n\t     * Data mapping to a new List with given dimensions\n\t     * @param {string|Array.<string>} dimensions\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     * @return {Array}\n\t     */\n\t    listProto.map = function (dimensions, cb, stack, context) {\n\t        dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n\t        var list = cloneListForMapAndSample(this, dimensions);\n\t        // Following properties are all immutable.\n\t        // So we can reference to the same value\n\t        var indices = list.indices = this.indices;\n\t        var storage = list._storage;\n\t        var tmpRetValue = [];\n\t        this.each(dimensions, function () {\n\t            var idx = arguments[arguments.length - 1];\n\t            var retValue = cb && cb.apply(this, arguments);\n\t            if (retValue != null) {\n\t                // a number\n\t                if (typeof retValue === 'number') {\n\t                    tmpRetValue[0] = retValue;\n\t                    retValue = tmpRetValue;\n\t                }\n\t                for (var i = 0; i < retValue.length; i++) {\n\t                    var dim = dimensions[i];\n\t                    var dimStore = storage[dim];\n\t                    var rawIdx = indices[idx];\n\t                    if (dimStore) {\n\t                        dimStore[rawIdx] = retValue[i];\n\t                    }\n\t                }\n\t            }\n\t        }, stack, context);\n\t        return list;\n\t    };\n\t    /**\n\t     * Large data down sampling on given dimension\n\t     * @param {string} dimension\n\t     * @param {number} rate\n\t     * @param {Function} sampleValue\n\t     * @param {Function} sampleIndex Sample index for name and id\n\t     */\n\t    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n\t        var list = cloneListForMapAndSample(this, [dimension]);\n\t        var storage = this._storage;\n\t        var targetStorage = list._storage;\n\t        var originalIndices = this.indices;\n\t        var indices = list.indices = [];\n\t        var frameValues = [];\n\t        var frameIndices = [];\n\t        var frameSize = Math.floor(1 / rate);\n\t        var dimStore = targetStorage[dimension];\n\t        var len = this.count();\n\t        // Copy data from original data\n\t        for (var i = 0; i < storage[dimension].length; i++) {\n\t            targetStorage[dimension][i] = storage[dimension][i];\n\t        }\n\t        for (var i = 0; i < len; i += frameSize) {\n\t            // Last frame\n\t            if (frameSize > len - i) {\n\t                frameSize = len - i;\n\t                frameValues.length = frameSize;\n\t            }\n\t            for (var k = 0; k < frameSize; k++) {\n\t                var idx = originalIndices[i + k];\n\t                frameValues[k] = dimStore[idx];\n\t                frameIndices[k] = idx;\n\t            }\n\t            var value = sampleValue(frameValues);\n\t            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n\t            // Only write value on the filtered data\n\t            dimStore[idx] = value;\n\t            indices.push(idx);\n\t        }\n\t        return list;\n\t    };\n\t    /**\n\t     * Get model of one data item.\n\t     *\n\t     * @param {number} idx\n\t     */\n\t    // FIXME Model proxy ?\n\t    listProto.getItemModel = function (idx) {\n\t        var hostModel = this.hostModel;\n\t        idx = this.indices[idx];\n\t        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n\t    };\n\t    /**\n\t     * Create a data differ\n\t     * @param {module:echarts/data/List} otherList\n\t     * @return {module:echarts/data/DataDiffer}\n\t     */\n\t    listProto.diff = function (otherList) {\n\t        var idList = this._idList;\n\t        var otherIdList = otherList && otherList._idList;\n\t        return new DataDiffer(otherList ? otherList.indices : [], this.indices, function (idx) {\n\t            return otherIdList[idx] || idx + '';\n\t        }, function (idx) {\n\t            return idList[idx] || idx + '';\n\t        });\n\t    };\n\t    /**\n\t     * Get visual property.\n\t     * @param {string} key\n\t     */\n\t    listProto.getVisual = function (key) {\n\t        var visual = this._visual;\n\t        return visual && visual[key];\n\t    };\n\t    /**\n\t     * Set visual property\n\t     * @param {string|Object} key\n\t     * @param {*} [value]\n\t     *\n\t     * @example\n\t     *  setVisual('color', color);\n\t     *  setVisual({\n\t     *      'color': color\n\t     *  });\n\t     */\n\t    listProto.setVisual = function (key, val) {\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    this.setVisual(name, key[name]);\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        this._visual = this._visual || {};\n\t        this._visual[key] = val;\n\t    };\n\t    /**\n\t     * Set layout property.\n\t     * @param {string} key\n\t     * @param {*} [val]\n\t     */\n\t    listProto.setLayout = function (key, val) {\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    this.setLayout(name, key[name]);\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        this._layout[key] = val;\n\t    };\n\t    /**\n\t     * Get layout property.\n\t     * @param  {string} key.\n\t     * @return {*}\n\t     */\n\t    listProto.getLayout = function (key) {\n\t        return this._layout[key];\n\t    };\n\t    /**\n\t     * Get layout of single data item\n\t     * @param {number} idx\n\t     */\n\t    listProto.getItemLayout = function (idx) {\n\t        return this._itemLayouts[idx];\n\t    };\n\t    /**\n\t     * Set layout of single data item\n\t     * @param {number} idx\n\t     * @param {Object} layout\n\t     * @param {boolean=} [merge=false]\n\t     */\n\t    listProto.setItemLayout = function (idx, layout, merge) {\n\t        this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n\t    };\n\t    /**\n\t     * Clear all layout of single data item\n\t     */\n\t    listProto.clearItemLayouts = function () {\n\t        this._itemLayouts.length = 0;\n\t    };\n\t    /**\n\t     * Get visual property of single data item\n\t     * @param {number} idx\n\t     * @param {string} key\n\t     * @param {boolean} ignoreParent\n\t     */\n\t    listProto.getItemVisual = function (idx, key, ignoreParent) {\n\t        var itemVisual = this._itemVisuals[idx];\n\t        var val = itemVisual && itemVisual[key];\n\t        if (val == null && !ignoreParent) {\n\t            // Use global visual property\n\t            return this.getVisual(key);\n\t        }\n\t        return val;\n\t    };\n\t    /**\n\t     * Set visual property of single data item\n\t     *\n\t     * @param {number} idx\n\t     * @param {string|Object} key\n\t     * @param {*} [value]\n\t     *\n\t     * @example\n\t     *  setItemVisual(0, 'color', color);\n\t     *  setItemVisual(0, {\n\t     *      'color': color\n\t     *  });\n\t     */\n\t    listProto.setItemVisual = function (idx, key, value) {\n\t        var itemVisual = this._itemVisuals[idx] || {};\n\t        this._itemVisuals[idx] = itemVisual;\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    itemVisual[name] = key[name];\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        itemVisual[key] = value;\n\t    };\n\t    /**\n\t     * Clear itemVisuals and list visual.\n\t     */\n\t    listProto.clearAllVisual = function () {\n\t        this._visual = {};\n\t        this._itemVisuals = [];\n\t    };\n\t    var setItemDataAndSeriesIndex = function (child) {\n\t        child.seriesIndex = this.seriesIndex;\n\t        child.dataIndex = this.dataIndex;\n\t        child.dataType = this.dataType;\n\t    };\n\t    /**\n\t     * Set graphic element relative to data. It can be set as null\n\t     * @param {number} idx\n\t     * @param {module:zrender/Element} [el]\n\t     */\n\t    listProto.setItemGraphicEl = function (idx, el) {\n\t        var hostModel = this.hostModel;\n\t        if (el) {\n\t            // Add data index and series index for indexing the data by element\n\t            // Useful in tooltip\n\t            el.dataIndex = idx;\n\t            el.dataType = this.dataType;\n\t            el.seriesIndex = hostModel && hostModel.seriesIndex;\n\t            if (el.type === 'group') {\n\t                el.traverse(setItemDataAndSeriesIndex, el);\n\t            }\n\t        }\n\t        this._graphicEls[idx] = el;\n\t    };\n\t    /**\n\t     * @param {number} idx\n\t     * @return {module:zrender/Element}\n\t     */\n\t    listProto.getItemGraphicEl = function (idx) {\n\t        return this._graphicEls[idx];\n\t    };\n\t    /**\n\t     * @param {Function} cb\n\t     * @param {*} context\n\t     */\n\t    listProto.eachItemGraphicEl = function (cb, context) {\n\t        zrUtil.each(this._graphicEls, function (el, idx) {\n\t            if (el) {\n\t                cb && cb.call(context, el, idx);\n\t            }\n\t        });\n\t    };\n\t    /**\n\t     * Shallow clone a new list except visual and layout properties, and graph elements.\n\t     * New list only change the indices.\n\t     */\n\t    listProto.cloneShallow = function () {\n\t        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n\t        var list = new List(dimensionInfoList, this.hostModel);\n\t        // FIXME\n\t        list._storage = this._storage;\n\t        transferProperties(list, this);\n\t        // Clone will not change the data extent and indices\n\t        list.indices = this.indices.slice();\n\t        if (this._extent) {\n\t            list._extent = zrUtil.extend({}, this._extent);\n\t        }\n\t        return list;\n\t    };\n\t    /**\n\t     * Wrap some method to add more feature\n\t     * @param {string} methodName\n\t     * @param {Function} injectFunction\n\t     */\n\t    listProto.wrapMethod = function (methodName, injectFunction) {\n\t        var originalMethod = this[methodName];\n\t        if (typeof originalMethod !== 'function') {\n\t            return;\n\t        }\n\t        this.__wrappedMethods = this.__wrappedMethods || [];\n\t        this.__wrappedMethods.push(methodName);\n\t        this[methodName] = function () {\n\t            var res = originalMethod.apply(this, arguments);\n\t            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n\t        };\n\t    };\n\t    // Methods that create a new list based on this list should be listed here.\n\t    // Notice that those method should `RETURN` the new list.\n\t    listProto.TRANSFERABLE_METHODS = [\n\t        'cloneShallow',\n\t        'downSample',\n\t        'map'\n\t    ];\n\t    // Methods that change indices of this list should be listed here.\n\t    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\t    return List;\n\t});\n\tdefine('zrender/core/vector', [], function () {\n\t    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n\t    /**\n\t     * @typedef {Float32Array|Array.<number>} Vector2\n\t     */\n\t    /**\n\t     * 二维向量类\n\t     * @exports zrender/tool/vector\n\t     */\n\t    var vector = {\n\t            create: function (x, y) {\n\t                var out = new ArrayCtor(2);\n\t                if (x == null) {\n\t                    x = 0;\n\t                }\n\t                if (y == null) {\n\t                    y = 0;\n\t                }\n\t                out[0] = x;\n\t                out[1] = y;\n\t                return out;\n\t            },\n\t            copy: function (out, v) {\n\t                out[0] = v[0];\n\t                out[1] = v[1];\n\t                return out;\n\t            },\n\t            clone: function (v) {\n\t                var out = new ArrayCtor(2);\n\t                out[0] = v[0];\n\t                out[1] = v[1];\n\t                return out;\n\t            },\n\t            set: function (out, a, b) {\n\t                out[0] = a;\n\t                out[1] = b;\n\t                return out;\n\t            },\n\t            add: function (out, v1, v2) {\n\t                out[0] = v1[0] + v2[0];\n\t                out[1] = v1[1] + v2[1];\n\t                return out;\n\t            },\n\t            scaleAndAdd: function (out, v1, v2, a) {\n\t                out[0] = v1[0] + v2[0] * a;\n\t                out[1] = v1[1] + v2[1] * a;\n\t                return out;\n\t            },\n\t            sub: function (out, v1, v2) {\n\t                out[0] = v1[0] - v2[0];\n\t                out[1] = v1[1] - v2[1];\n\t                return out;\n\t            },\n\t            len: function (v) {\n\t                return Math.sqrt(this.lenSquare(v));\n\t            },\n\t            lenSquare: function (v) {\n\t                return v[0] * v[0] + v[1] * v[1];\n\t            },\n\t            mul: function (out, v1, v2) {\n\t                out[0] = v1[0] * v2[0];\n\t                out[1] = v1[1] * v2[1];\n\t                return out;\n\t            },\n\t            div: function (out, v1, v2) {\n\t                out[0] = v1[0] / v2[0];\n\t                out[1] = v1[1] / v2[1];\n\t                return out;\n\t            },\n\t            dot: function (v1, v2) {\n\t                return v1[0] * v2[0] + v1[1] * v2[1];\n\t            },\n\t            scale: function (out, v, s) {\n\t                out[0] = v[0] * s;\n\t                out[1] = v[1] * s;\n\t                return out;\n\t            },\n\t            normalize: function (out, v) {\n\t                var d = vector.len(v);\n\t                if (d === 0) {\n\t                    out[0] = 0;\n\t                    out[1] = 0;\n\t                } else {\n\t                    out[0] = v[0] / d;\n\t                    out[1] = v[1] / d;\n\t                }\n\t                return out;\n\t            },\n\t            distance: function (v1, v2) {\n\t                return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n\t            },\n\t            distanceSquare: function (v1, v2) {\n\t                return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n\t            },\n\t            negate: function (out, v) {\n\t                out[0] = -v[0];\n\t                out[1] = -v[1];\n\t                return out;\n\t            },\n\t            lerp: function (out, v1, v2, t) {\n\t                out[0] = v1[0] + t * (v2[0] - v1[0]);\n\t                out[1] = v1[1] + t * (v2[1] - v1[1]);\n\t                return out;\n\t            },\n\t            applyTransform: function (out, v, m) {\n\t                var x = v[0];\n\t                var y = v[1];\n\t                out[0] = m[0] * x + m[2] * y + m[4];\n\t                out[1] = m[1] * x + m[3] * y + m[5];\n\t                return out;\n\t            },\n\t            min: function (out, v1, v2) {\n\t                out[0] = Math.min(v1[0], v2[0]);\n\t                out[1] = Math.min(v1[1], v2[1]);\n\t                return out;\n\t            },\n\t            max: function (out, v1, v2) {\n\t                out[0] = Math.max(v1[0], v2[0]);\n\t                out[1] = Math.max(v1[1], v2[1]);\n\t                return out;\n\t            }\n\t        };\n\t    vector.length = vector.len;\n\t    vector.lengthSquare = vector.lenSquare;\n\t    vector.dist = vector.distance;\n\t    vector.distSquare = vector.distanceSquare;\n\t    return vector;\n\t});\n\tdefine('echarts/scale/Scale', ['require', '../util/clazz'], function (require) {\n\t    var clazzUtil = require('../util/clazz');\n\t    function Scale() {\n\t        /**\n\t         * Extent\n\t         * @type {Array.<number>}\n\t         * @protected\n\t         */\n\t        this._extent = [\n\t            Infinity,\n\t            -Infinity\n\t        ];\n\t        /**\n\t         * Step is calculated in adjustExtent\n\t         * @type {Array.<number>}\n\t         * @protected\n\t         */\n\t        this._interval = 0;\n\t        this.init && this.init.apply(this, arguments);\n\t    }\n\t    var scaleProto = Scale.prototype;\n\t    /**\n\t     * Parse input val to valid inner number.\n\t     * @param {*} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.parse = function (val) {\n\t        // Notice: This would be a trap here, If the implementation\n\t        // of this method depends on extent, and this method is used\n\t        // before extent set (like in dataZoom), it would be wrong.\n\t        // Nevertheless, parse does not depend on extent generally.\n\t        return val;\n\t    };\n\t    scaleProto.contain = function (val) {\n\t        var extent = this._extent;\n\t        return val >= extent[0] && val <= extent[1];\n\t    };\n\t    /**\n\t     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n\t     * @param {number} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.normalize = function (val) {\n\t        var extent = this._extent;\n\t        if (extent[1] === extent[0]) {\n\t            return 0.5;\n\t        }\n\t        return (val - extent[0]) / (extent[1] - extent[0]);\n\t    };\n\t    /**\n\t     * Scale normalized value\n\t     * @param {number} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.scale = function (val) {\n\t        var extent = this._extent;\n\t        return val * (extent[1] - extent[0]) + extent[0];\n\t    };\n\t    /**\n\t     * Set extent from data\n\t     * @param {Array.<number>} other\n\t     */\n\t    scaleProto.unionExtent = function (other) {\n\t        var extent = this._extent;\n\t        other[0] < extent[0] && (extent[0] = other[0]);\n\t        other[1] > extent[1] && (extent[1] = other[1]);    // not setExtent because in log axis it may transformed to power\n\t                                                           // this.setExtent(extent[0], extent[1]);\n\t    };\n\t    /**\n\t     * Get extent\n\t     * @return {Array.<number>}\n\t     */\n\t    scaleProto.getExtent = function () {\n\t        return this._extent.slice();\n\t    };\n\t    /**\n\t     * Set extent\n\t     * @param {number} start\n\t     * @param {number} end\n\t     */\n\t    scaleProto.setExtent = function (start, end) {\n\t        var thisExtent = this._extent;\n\t        if (!isNaN(start)) {\n\t            thisExtent[0] = start;\n\t        }\n\t        if (!isNaN(end)) {\n\t            thisExtent[1] = end;\n\t        }\n\t    };\n\t    /**\n\t     * @return {Array.<string>}\n\t     */\n\t    scaleProto.getTicksLabels = function () {\n\t        var labels = [];\n\t        var ticks = this.getTicks();\n\t        for (var i = 0; i < ticks.length; i++) {\n\t            labels.push(this.getLabel(ticks[i]));\n\t        }\n\t        return labels;\n\t    };\n\t    clazzUtil.enableClassExtend(Scale);\n\t    clazzUtil.enableClassManagement(Scale, { registerWhenExtend: true });\n\t    return Scale;\n\t});\n\tdefine('echarts/coord/axisHelper', ['require', '../scale/Ordinal', '../scale/Interval', '../scale/Time', '../scale/Log', '../scale/Scale', '../util/number', 'zrender/core/util', 'zrender/contain/text'], function (require) {\n\t    var OrdinalScale = require('../scale/Ordinal');\n\t    var IntervalScale = require('../scale/Interval');\n\t    require('../scale/Time');\n\t    require('../scale/Log');\n\t    var Scale = require('../scale/Scale');\n\t    var numberUtil = require('../util/number');\n\t    var zrUtil = require('zrender/core/util');\n\t    var textContain = require('zrender/contain/text');\n\t    var axisHelper = {};\n\t    /**\n\t     * Get axis scale extent before niced.\n\t     */\n\t    axisHelper.getScaleExtent = function (axis, model) {\n\t        var scale = axis.scale;\n\t        var originalExtent = scale.getExtent();\n\t        var span = originalExtent[1] - originalExtent[0];\n\t        if (scale.type === 'ordinal') {\n\t            // If series has no data, scale extent may be wrong\n\t            if (!isFinite(span)) {\n\t                return [\n\t                    0,\n\t                    0\n\t                ];\n\t            } else {\n\t                return originalExtent;\n\t            }\n\t        }\n\t        var min = model.getMin ? model.getMin() : model.get('min');\n\t        var max = model.getMax ? model.getMax() : model.get('max');\n\t        var crossZero = model.getNeedCrossZero ? model.getNeedCrossZero() : !model.get('scale');\n\t        var boundaryGap = model.get('boundaryGap');\n\t        if (!zrUtil.isArray(boundaryGap)) {\n\t            boundaryGap = [\n\t                boundaryGap || 0,\n\t                boundaryGap || 0\n\t            ];\n\t        }\n\t        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n\t        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n\t        var fixMin = true;\n\t        var fixMax = true;\n\t        // Add boundary gap\n\t        if (min == null) {\n\t            min = originalExtent[0] - boundaryGap[0] * span;\n\t            fixMin = false;\n\t        }\n\t        if (max == null) {\n\t            max = originalExtent[1] + boundaryGap[1] * span;\n\t            fixMax = false;\n\t        }\n\t        if (min === 'dataMin') {\n\t            min = originalExtent[0];\n\t        }\n\t        if (max === 'dataMax') {\n\t            max = originalExtent[1];\n\t        }\n\t        // Evaluate if axis needs cross zero\n\t        if (crossZero) {\n\t            // Axis is over zero and min is not set\n\t            if (min > 0 && max > 0 && !fixMin) {\n\t                min = 0;\n\t            }\n\t            // Axis is under zero and max is not set\n\t            if (min < 0 && max < 0 && !fixMax) {\n\t                max = 0;\n\t            }\n\t        }\n\t        return [\n\t            min,\n\t            max\n\t        ];\n\t    };\n\t    axisHelper.niceScaleExtent = function (axis, model) {\n\t        var scale = axis.scale;\n\t        var extent = axisHelper.getScaleExtent(axis, model);\n\t        var fixMin = (model.getMin ? model.getMin() : model.get('min')) != null;\n\t        var fixMax = (model.getMax ? model.getMax() : model.get('max')) != null;\n\t        var splitNumber = model.get('splitNumber');\n\t        if (scale.type === 'log') {\n\t            scale.base = model.get('logBase');\n\t        }\n\t        scale.setExtent(extent[0], extent[1]);\n\t        scale.niceExtent(splitNumber, fixMin, fixMax);\n\t        // Use minInterval to constraint the calculated interval.\n\t        // If calculated interval is less than minInterval. increase the interval quantity until\n\t        // it is larger than minInterval.\n\t        // For example:\n\t        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n\t        //  an integer axis.\n\t        var minInterval = model.get('minInterval');\n\t        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n\t            var interval = scale.getInterval();\n\t            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n\t            // while (interval < minInterval) {\n\t            //     var quantity = numberUtil.quantity(interval);\n\t            //     interval = quantity * 10;\n\t            //     scaleQuantity *= 10;\n\t            // }\n\t            extent = scale.getExtent();\n\t            scale.setExtent(intervalScale * extent[0], extent[1] * intervalScale);\n\t            scale.niceExtent(splitNumber);\n\t        }\n\t        // If some one specified the min, max. And the default calculated interval\n\t        // is not good enough. He can specify the interval. It is often appeared\n\t        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n\t        // to be 60.\n\t        // FIXME\n\t        var interval = model.get('interval');\n\t        if (interval != null) {\n\t            scale.setInterval && scale.setInterval(interval);\n\t        }\n\t    };\n\t    /**\n\t     * @param {module:echarts/model/Model} model\n\t     * @param {string} [axisType] Default retrieve from model.type\n\t     * @return {module:echarts/scale/*}\n\t     */\n\t    axisHelper.createScaleByModel = function (model, axisType) {\n\t        axisType = axisType || model.get('type');\n\t        if (axisType) {\n\t            switch (axisType) {\n\t            // Buildin scale\n\t            case 'category':\n\t                return new OrdinalScale(model.getCategories(), [\n\t                    Infinity,\n\t                    -Infinity\n\t                ]);\n\t            case 'value':\n\t                return new IntervalScale();\n\t            // Extended scale, like time and log\n\t            default:\n\t                return (Scale.getClass(axisType) || IntervalScale).create(model);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t     * Check if the axis corss 0\n\t     */\n\t    axisHelper.ifAxisCrossZero = function (axis) {\n\t        var dataExtent = axis.scale.getExtent();\n\t        var min = dataExtent[0];\n\t        var max = dataExtent[1];\n\t        return !(min > 0 && max > 0 || min < 0 && max < 0);\n\t    };\n\t    /**\n\t     * @param {Array.<number>} tickCoords In axis self coordinate.\n\t     * @param {Array.<string>} labels\n\t     * @param {string} font\n\t     * @param {boolean} isAxisHorizontal\n\t     * @return {number}\n\t     */\n\t    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n\t        // FIXME\n\t        // 不同角的axis和label，不只是horizontal和vertical.\n\t        var textSpaceTakenRect;\n\t        var autoLabelInterval = 0;\n\t        var accumulatedLabelInterval = 0;\n\t        var step = 1;\n\t        if (labels.length > 40) {\n\t            // Simple optimization for large amount of labels\n\t            step = Math.floor(labels.length / 40);\n\t        }\n\t        for (var i = 0; i < tickCoords.length; i += step) {\n\t            var tickCoord = tickCoords[i];\n\t            var rect = textContain.getBoundingRect(labels[i], font, 'center', 'top');\n\t            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n\t            // FIXME Magic number 1.5\n\t            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n\t            if (!textSpaceTakenRect) {\n\t                textSpaceTakenRect = rect.clone();\n\t            }    // There is no space for current label;\n\t            else if (textSpaceTakenRect.intersect(rect)) {\n\t                accumulatedLabelInterval++;\n\t                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n\t            } else {\n\t                textSpaceTakenRect.union(rect);\n\t                // Reset\n\t                accumulatedLabelInterval = 0;\n\t            }\n\t        }\n\t        if (autoLabelInterval === 0 && step > 1) {\n\t            return step;\n\t        }\n\t        return (autoLabelInterval + 1) * step - 1;\n\t    };\n\t    /**\n\t     * @param {Object} axis\n\t     * @param {Function} labelFormatter\n\t     * @return {Array.<string>}\n\t     */\n\t    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n\t        var scale = axis.scale;\n\t        var labels = scale.getTicksLabels();\n\t        var ticks = scale.getTicks();\n\t        if (typeof labelFormatter === 'string') {\n\t            labelFormatter = function (tpl) {\n\t                return function (val) {\n\t                    return tpl.replace('{value}', val);\n\t                };\n\t            }(labelFormatter);\n\t            return zrUtil.map(labels, labelFormatter);\n\t        } else if (typeof labelFormatter === 'function') {\n\t            return zrUtil.map(ticks, function (tick, idx) {\n\t                return labelFormatter(axis.type === 'category' ? scale.getLabel(tick) : tick, idx);\n\t            }, this);\n\t        } else {\n\t            return labels;\n\t        }\n\t    };\n\t    return axisHelper;\n\t});\n\tdefine('echarts/coord/cartesian/Cartesian2D', ['require', 'zrender/core/util', './Cartesian'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var Cartesian = require('./Cartesian');\n\t    function Cartesian2D(name) {\n\t        Cartesian.call(this, name);\n\t    }\n\t    Cartesian2D.prototype = {\n\t        constructor: Cartesian2D,\n\t        type: 'cartesian2d',\n\t        dimensions: [\n\t            'x',\n\t            'y'\n\t        ],\n\t        getBaseAxis: function () {\n\t            return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n\t        },\n\t        containPoint: function (point) {\n\t            var axisX = this.getAxis('x');\n\t            var axisY = this.getAxis('y');\n\t            return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n\t        },\n\t        containData: function (data) {\n\t            return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n\t        },\n\t        dataToPoints: function (data, stack) {\n\t            return data.mapArray([\n\t                'x',\n\t                'y'\n\t            ], function (x, y) {\n\t                return this.dataToPoint([\n\t                    x,\n\t                    y\n\t                ]);\n\t            }, stack, this);\n\t        },\n\t        dataToPoint: function (data, clamp) {\n\t            var xAxis = this.getAxis('x');\n\t            var yAxis = this.getAxis('y');\n\t            return [\n\t                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n\t                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n\t            ];\n\t        },\n\t        pointToData: function (point, clamp) {\n\t            var xAxis = this.getAxis('x');\n\t            var yAxis = this.getAxis('y');\n\t            return [\n\t                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n\t                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n\t            ];\n\t        },\n\t        getOtherAxis: function (axis) {\n\t            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n\t        }\n\t    };\n\t    zrUtil.inherits(Cartesian2D, Cartesian);\n\t    return Cartesian2D;\n\t});\n\tdefine('echarts/coord/cartesian/Axis2D', ['require', 'zrender/core/util', '../Axis', './axisLabelInterval'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var Axis = require('../Axis');\n\t    var axisLabelInterval = require('./axisLabelInterval');\n\t    /**\n\t     * Extend axis 2d\n\t     * @constructor module:echarts/coord/cartesian/Axis2D\n\t     * @extends {module:echarts/coord/cartesian/Axis}\n\t     * @param {string} dim\n\t     * @param {*} scale\n\t     * @param {Array.<number>} coordExtent\n\t     * @param {string} axisType\n\t     * @param {string} position\n\t     */\n\t    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n\t        Axis.call(this, dim, scale, coordExtent);\n\t        /**\n\t         * Axis type\n\t         *  - 'category'\n\t         *  - 'value'\n\t         *  - 'time'\n\t         *  - 'log'\n\t         * @type {string}\n\t         */\n\t        this.type = axisType || 'value';\n\t        /**\n\t         * Axis position\n\t         *  - 'top'\n\t         *  - 'bottom'\n\t         *  - 'left'\n\t         *  - 'right'\n\t         */\n\t        this.position = position || 'bottom';\n\t    };\n\t    Axis2D.prototype = {\n\t        constructor: Axis2D,\n\t        index: 0,\n\t        onZero: false,\n\t        model: null,\n\t        isHorizontal: function () {\n\t            var position = this.position;\n\t            return position === 'top' || position === 'bottom';\n\t        },\n\t        getGlobalExtent: function () {\n\t            var ret = this.getExtent();\n\t            ret[0] = this.toGlobalCoord(ret[0]);\n\t            ret[1] = this.toGlobalCoord(ret[1]);\n\t            return ret;\n\t        },\n\t        getLabelInterval: function () {\n\t            var labelInterval = this._labelInterval;\n\t            if (!labelInterval) {\n\t                labelInterval = this._labelInterval = axisLabelInterval(this);\n\t            }\n\t            return labelInterval;\n\t        },\n\t        isLabelIgnored: function (idx) {\n\t            if (this.type === 'category') {\n\t                var labelInterval = this.getLabelInterval();\n\t                return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);\n\t            }\n\t        },\n\t        toLocalCoord: null,\n\t        toGlobalCoord: null\n\t    };\n\t    zrUtil.inherits(Axis2D, Axis);\n\t    return Axis2D;\n\t});\n\tdefine('echarts/coord/cartesian/GridModel', ['require', './AxisModel', '../../model/Component'], function (require) {\n\t    'use strict';\n\t    require('./AxisModel');\n\t    var ComponentModel = require('../../model/Component');\n\t    return ComponentModel.extend({\n\t        type: 'grid',\n\t        dependencies: [\n\t            'xAxis',\n\t            'yAxis'\n\t        ],\n\t        layoutMode: 'box',\n\t        coordinateSystem: null,\n\t        defaultOption: {\n\t            show: false,\n\t            zlevel: 0,\n\t            z: 0,\n\t            left: '10%',\n\t            top: 60,\n\t            right: '10%',\n\t            bottom: 60,\n\t            containLabel: false,\n\t            backgroundColor: 'rgba(0,0,0,0)',\n\t            borderWidth: 1,\n\t            borderColor: '#ccc'\n\t        }\n\t    });\n\t});\n\tdefine('zrender/tool/path', ['require', '../graphic/Path', '../core/PathProxy', './transformPath', '../core/matrix'], function (require) {\n\t    var Path = require('../graphic/Path');\n\t    var PathProxy = require('../core/PathProxy');\n\t    var transformPath = require('./transformPath');\n\t    var matrix = require('../core/matrix');\n\t    // command chars\n\t    var cc = [\n\t            'm',\n\t            'M',\n\t            'l',\n\t            'L',\n\t            'v',\n\t            'V',\n\t            'h',\n\t            'H',\n\t            'z',\n\t            'Z',\n\t            'c',\n\t            'C',\n\t            'q',\n\t            'Q',\n\t            't',\n\t            'T',\n\t            's',\n\t            'S',\n\t            'a',\n\t            'A'\n\t        ];\n\t    var mathSqrt = Math.sqrt;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t    var PI = Math.PI;\n\t    var vMag = function (v) {\n\t        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n\t    };\n\t    var vRatio = function (u, v) {\n\t        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n\t    };\n\t    var vAngle = function (u, v) {\n\t        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n\t    };\n\t    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n\t        var psi = psiDeg * (PI / 180);\n\t        var xp = mathCos(psi) * (x1 - x2) / 2 + mathSin(psi) * (y1 - y2) / 2;\n\t        var yp = -1 * mathSin(psi) * (x1 - x2) / 2 + mathCos(psi) * (y1 - y2) / 2;\n\t        var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n\t        if (lambda > 1) {\n\t            rx *= mathSqrt(lambda);\n\t            ry *= mathSqrt(lambda);\n\t        }\n\t        var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n\t        var cxp = f * rx * yp / ry;\n\t        var cyp = f * -ry * xp / rx;\n\t        var cx = (x1 + x2) / 2 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n\t        var cy = (y1 + y2) / 2 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n\t        var theta = vAngle([\n\t                1,\n\t                0\n\t            ], [\n\t                (xp - cxp) / rx,\n\t                (yp - cyp) / ry\n\t            ]);\n\t        var u = [\n\t                (xp - cxp) / rx,\n\t                (yp - cyp) / ry\n\t            ];\n\t        var v = [\n\t                (-1 * xp - cxp) / rx,\n\t                (-1 * yp - cyp) / ry\n\t            ];\n\t        var dTheta = vAngle(u, v);\n\t        if (vRatio(u, v) <= -1) {\n\t            dTheta = PI;\n\t        }\n\t        if (vRatio(u, v) >= 1) {\n\t            dTheta = 0;\n\t        }\n\t        if (fs === 0 && dTheta > 0) {\n\t            dTheta = dTheta - 2 * PI;\n\t        }\n\t        if (fs === 1 && dTheta < 0) {\n\t            dTheta = dTheta + 2 * PI;\n\t        }\n\t        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n\t    }\n\t    function createPathProxyFromString(data) {\n\t        if (!data) {\n\t            return [];\n\t        }\n\t        // command string\n\t        var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');\n\t        var n;\n\t        // create pipes so that we can split the data\n\t        for (n = 0; n < cc.length; n++) {\n\t            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n\t        }\n\t        // create array\n\t        var arr = cs.split('|');\n\t        // init context point\n\t        var cpx = 0;\n\t        var cpy = 0;\n\t        var path = new PathProxy();\n\t        var CMD = PathProxy.CMD;\n\t        var prevCmd;\n\t        for (n = 1; n < arr.length; n++) {\n\t            var str = arr[n];\n\t            var c = str.charAt(0);\n\t            var off = 0;\n\t            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n\t            var cmd;\n\t            if (p.length > 0 && p[0] === '') {\n\t                p.shift();\n\t            }\n\t            for (var i = 0; i < p.length; i++) {\n\t                p[i] = parseFloat(p[i]);\n\t            }\n\t            while (off < p.length && !isNaN(p[off])) {\n\t                if (isNaN(p[0])) {\n\t                    break;\n\t                }\n\t                var ctlPtx;\n\t                var ctlPty;\n\t                var rx;\n\t                var ry;\n\t                var psi;\n\t                var fa;\n\t                var fs;\n\t                var x1 = cpx;\n\t                var y1 = cpy;\n\t                // convert l, H, h, V, and v to L\n\t                switch (c) {\n\t                case 'l':\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'L':\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'm':\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.M;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    c = 'l';\n\t                    break;\n\t                case 'M':\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.M;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    c = 'L';\n\t                    break;\n\t                case 'h':\n\t                    cpx += p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'H':\n\t                    cpx = p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'v':\n\t                    cpy += p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'V':\n\t                    cpy = p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'C':\n\t                    cmd = CMD.C;\n\t                    path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n\t                    cpx = p[off - 2];\n\t                    cpy = p[off - 1];\n\t                    break;\n\t                case 'c':\n\t                    cmd = CMD.C;\n\t                    path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n\t                    cpx += p[off - 2];\n\t                    cpy += p[off - 1];\n\t                    break;\n\t                case 'S':\n\t                    ctlPtx = cpx;\n\t                    ctlPty = cpy;\n\t                    var len = path.len();\n\t                    var pathData = path.data;\n\t                    if (prevCmd === CMD.C) {\n\t                        ctlPtx += cpx - pathData[len - 4];\n\t                        ctlPty += cpy - pathData[len - 3];\n\t                    }\n\t                    cmd = CMD.C;\n\t                    x1 = p[off++];\n\t                    y1 = p[off++];\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                    break;\n\t                case 's':\n\t                    ctlPtx = cpx;\n\t                    ctlPty = cpy;\n\t                    var len = path.len();\n\t                    var pathData = path.data;\n\t                    if (prevCmd === CMD.C) {\n\t                        ctlPtx += cpx - pathData[len - 4];\n\t                        ctlPty += cpy - pathData[len - 3];\n\t                    }\n\t                    cmd = CMD.C;\n\t                    x1 = cpx + p[off++];\n\t                    y1 = cpy + p[off++];\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                    break;\n\t                case 'Q':\n\t                    x1 = p[off++];\n\t                    y1 = p[off++];\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.Q;\n\t                    path.addData(cmd, x1, y1, cpx, cpy);\n\t                    break;\n\t                case 'q':\n\t                    x1 = p[off++] + cpx;\n\t                    y1 = p[off++] + cpy;\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.Q;\n\t                    path.addData(cmd, x1, y1, cpx, cpy);\n\t                    break;\n\t                case 'T':\n\t                    ctlPtx = cpx;\n\t                    ctlPty = cpy;\n\t                    var len = path.len();\n\t                    var pathData = path.data;\n\t                    if (prevCmd === CMD.Q) {\n\t                        ctlPtx += cpx - pathData[len - 4];\n\t                        ctlPty += cpy - pathData[len - 3];\n\t                    }\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.Q;\n\t                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                    break;\n\t                case 't':\n\t                    ctlPtx = cpx;\n\t                    ctlPty = cpy;\n\t                    var len = path.len();\n\t                    var pathData = path.data;\n\t                    if (prevCmd === CMD.Q) {\n\t                        ctlPtx += cpx - pathData[len - 4];\n\t                        ctlPty += cpy - pathData[len - 3];\n\t                    }\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.Q;\n\t                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                    break;\n\t                case 'A':\n\t                    rx = p[off++];\n\t                    ry = p[off++];\n\t                    psi = p[off++];\n\t                    fa = p[off++];\n\t                    fs = p[off++];\n\t                    x1 = cpx, y1 = cpy;\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.A;\n\t                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n\t                    break;\n\t                case 'a':\n\t                    rx = p[off++];\n\t                    ry = p[off++];\n\t                    psi = p[off++];\n\t                    fa = p[off++];\n\t                    fs = p[off++];\n\t                    x1 = cpx, y1 = cpy;\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.A;\n\t                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n\t                    break;\n\t                }\n\t            }\n\t            if (c === 'z' || c === 'Z') {\n\t                cmd = CMD.Z;\n\t                path.addData(cmd);\n\t            }\n\t            prevCmd = cmd;\n\t        }\n\t        path.toStatic();\n\t        return path;\n\t    }\n\t    // TODO Optimize double memory cost problem\n\t    function createPathOptions(str, opts) {\n\t        var pathProxy = createPathProxyFromString(str);\n\t        var transform;\n\t        opts = opts || {};\n\t        opts.buildPath = function (path) {\n\t            path.setData(pathProxy.data);\n\t            transform && transformPath(path, transform);\n\t            // Svg and vml renderer don't have context\n\t            var ctx = path.getContext();\n\t            if (ctx) {\n\t                path.rebuildPath(ctx);\n\t            }\n\t        };\n\t        opts.applyTransform = function (m) {\n\t            if (!transform) {\n\t                transform = matrix.create();\n\t            }\n\t            matrix.mul(transform, m, transform);\n\t            this.dirty(true);\n\t        };\n\t        return opts;\n\t    }\n\t    return {\n\t        createFromString: function (str, opts) {\n\t            return new Path(createPathOptions(str, opts));\n\t        },\n\t        extendFromString: function (str, opts) {\n\t            return Path.extend(createPathOptions(str, opts));\n\t        },\n\t        mergePath: function (pathEls, opts) {\n\t            var pathList = [];\n\t            var len = pathEls.length;\n\t            for (var i = 0; i < len; i++) {\n\t                var pathEl = pathEls[i];\n\t                if (pathEl.__dirty) {\n\t                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n\t                }\n\t                pathList.push(pathEl.path);\n\t            }\n\t            var pathBundle = new Path(opts);\n\t            pathBundle.buildPath = function (path) {\n\t                path.appendPath(pathList);\n\t                // Svg and vml renderer don't have context\n\t                var ctx = path.getContext();\n\t                if (ctx) {\n\t                    path.rebuildPath(ctx);\n\t                }\n\t            };\n\t            return pathBundle;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/graphic/Path', ['require', './Displayable', '../core/util', '../core/PathProxy', '../contain/path', './Pattern'], function (require) {\n\t    var Displayable = require('./Displayable');\n\t    var zrUtil = require('../core/util');\n\t    var PathProxy = require('../core/PathProxy');\n\t    var pathContain = require('../contain/path');\n\t    var Pattern = require('./Pattern');\n\t    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\t    var abs = Math.abs;\n\t    /**\n\t     * @alias module:zrender/graphic/Path\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function Path(opts) {\n\t        Displayable.call(this, opts);\n\t        /**\n\t         * @type {module:zrender/core/PathProxy}\n\t         * @readOnly\n\t         */\n\t        this.path = new PathProxy();\n\t    }\n\t    Path.prototype = {\n\t        constructor: Path,\n\t        type: 'path',\n\t        __dirtyPath: true,\n\t        strokeContainThreshold: 5,\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var path = this.path;\n\t            var hasStroke = style.hasStroke();\n\t            var hasFill = style.hasFill();\n\t            var fill = style.fill;\n\t            var stroke = style.stroke;\n\t            var hasFillGradient = hasFill && !!fill.colorStops;\n\t            var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n\t            var hasFillPattern = hasFill && !!fill.image;\n\t            var hasStrokePattern = hasStroke && !!stroke.image;\n\t            style.bind(ctx, this, prevEl);\n\t            this.setTransform(ctx);\n\t            if (this.__dirty) {\n\t                var rect = this.getBoundingRect();\n\t                // Update gradient because bounding rect may changed\n\t                if (hasFillGradient) {\n\t                    this._fillGradient = style.getGradient(ctx, fill, rect);\n\t                }\n\t                if (hasStrokeGradient) {\n\t                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n\t                }\n\t            }\n\t            // Use the gradient or pattern\n\t            if (hasFillGradient) {\n\t                // PENDING If may have affect the state\n\t                ctx.fillStyle = this._fillGradient;\n\t            } else if (hasFillPattern) {\n\t                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n\t            }\n\t            if (hasStrokeGradient) {\n\t                ctx.strokeStyle = this._strokeGradient;\n\t            } else if (hasStrokePattern) {\n\t                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n\t            }\n\t            var lineDash = style.lineDash;\n\t            var lineDashOffset = style.lineDashOffset;\n\t            var ctxLineDash = !!ctx.setLineDash;\n\t            // Update path sx, sy\n\t            var scale = this.getGlobalScale();\n\t            path.setScale(scale[0], scale[1]);\n\t            // Proxy context\n\t            // Rebuild path in following 2 cases\n\t            // 1. Path is dirty\n\t            // 2. Path needs javascript implemented lineDash stroking.\n\t            //    In this case, lineDash information will not be saved in PathProxy\n\t            if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n\t                path = this.path.beginPath(ctx);\n\t                // Setting line dash before build path\n\t                if (lineDash && !ctxLineDash) {\n\t                    path.setLineDash(lineDash);\n\t                    path.setLineDashOffset(lineDashOffset);\n\t                }\n\t                this.buildPath(path, this.shape, false);\n\t                // Clear path dirty flag\n\t                this.__dirtyPath = false;\n\t            } else {\n\t                // Replay path building\n\t                ctx.beginPath();\n\t                this.path.rebuildPath(ctx);\n\t            }\n\t            hasFill && path.fill(ctx);\n\t            if (lineDash && ctxLineDash) {\n\t                ctx.setLineDash(lineDash);\n\t                ctx.lineDashOffset = lineDashOffset;\n\t            }\n\t            hasStroke && path.stroke(ctx);\n\t            if (lineDash && ctxLineDash) {\n\t                // PENDING\n\t                // Remove lineDash\n\t                ctx.setLineDash([]);\n\t            }\n\t            this.restoreTransform(ctx);\n\t            // Draw rect text\n\t            if (style.text || style.text === 0) {\n\t                // var rect = this.getBoundingRect();\n\t                this.drawRectText(ctx, this.getBoundingRect());\n\t            }\n\t        },\n\t        buildPath: function (ctx, shapeCfg, inBundle) {\n\t        },\n\t        getBoundingRect: function () {\n\t            var rect = this._rect;\n\t            var style = this.style;\n\t            var needsUpdateRect = !rect;\n\t            if (needsUpdateRect) {\n\t                var path = this.path;\n\t                if (this.__dirtyPath) {\n\t                    path.beginPath();\n\t                    this.buildPath(path, this.shape, false);\n\t                }\n\t                rect = path.getBoundingRect();\n\t            }\n\t            this._rect = rect;\n\t            if (style.hasStroke()) {\n\t                // Needs update rect with stroke lineWidth when\n\t                // 1. Element changes scale or lineWidth\n\t                // 2. Shape is changed\n\t                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\t                if (this.__dirty || needsUpdateRect) {\n\t                    rectWithStroke.copy(rect);\n\t                    // FIXME Must after updateTransform\n\t                    var w = style.lineWidth;\n\t                    // PENDING, Min line width is needed when line is horizontal or vertical\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t                    // Only add extra hover lineWidth when there are no fill\n\t                    if (!style.hasFill()) {\n\t                        w = Math.max(w, this.strokeContainThreshold || 4);\n\t                    }\n\t                    // Consider line width\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        rectWithStroke.width += w / lineScale;\n\t                        rectWithStroke.height += w / lineScale;\n\t                        rectWithStroke.x -= w / lineScale / 2;\n\t                        rectWithStroke.y -= w / lineScale / 2;\n\t                    }\n\t                }\n\t                // Return rect with stroke\n\t                return rectWithStroke;\n\t            }\n\t            return rect;\n\t        },\n\t        contain: function (x, y) {\n\t            var localPos = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            var style = this.style;\n\t            x = localPos[0];\n\t            y = localPos[1];\n\t            if (rect.contain(x, y)) {\n\t                var pathData = this.path.data;\n\t                if (style.hasStroke()) {\n\t                    var lineWidth = style.lineWidth;\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        // Only add extra hover lineWidth when there are no fill\n\t                        if (!style.hasFill()) {\n\t                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n\t                        }\n\t                        if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t                if (style.hasFill()) {\n\t                    return pathContain.contain(pathData, x, y);\n\t                }\n\t            }\n\t            return false;\n\t        },\n\t        dirty: function (dirtyPath) {\n\t            if (dirtyPath == null) {\n\t                dirtyPath = true;\n\t            }\n\t            // Only mark dirty, not mark clean\n\t            if (dirtyPath) {\n\t                this.__dirtyPath = dirtyPath;\n\t                this._rect = null;\n\t            }\n\t            this.__dirty = true;\n\t            this.__zr && this.__zr.refresh();\n\t            // Used as a clipping path\n\t            if (this.__clipTarget) {\n\t                this.__clipTarget.dirty();\n\t            }\n\t        },\n\t        animateShape: function (loop) {\n\t            return this.animate('shape', loop);\n\t        },\n\t        attrKV: function (key, value) {\n\t            // FIXME\n\t            if (key === 'shape') {\n\t                this.setShape(value);\n\t                this.__dirtyPath = true;\n\t                this._rect = null;\n\t            } else {\n\t                Displayable.prototype.attrKV.call(this, key, value);\n\t            }\n\t        },\n\t        setShape: function (key, value) {\n\t            var shape = this.shape;\n\t            // Path from string may not have shape\n\t            if (shape) {\n\t                if (zrUtil.isObject(key)) {\n\t                    for (var name in key) {\n\t                        shape[name] = key[name];\n\t                    }\n\t                } else {\n\t                    shape[key] = value;\n\t                }\n\t                this.dirty(true);\n\t            }\n\t            return this;\n\t        },\n\t        getLineScale: function () {\n\t            var m = this.transform;\n\t            // Get the line scale.\n\t            // Determinant of `m` means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n\t        }\n\t    };\n\t    /**\n\t     * 扩展一个 Path element, 比如星形，圆等。\n\t     * Extend a path element\n\t     * @param {Object} props\n\t     * @param {string} props.type Path type\n\t     * @param {Function} props.init Initialize\n\t     * @param {Function} props.buildPath Overwrite buildPath method\n\t     * @param {Object} [props.style] Extended default style config\n\t     * @param {Object} [props.shape] Extended default shape config\n\t     */\n\t    Path.extend = function (defaults) {\n\t        var Sub = function (opts) {\n\t            Path.call(this, opts);\n\t            if (defaults.style) {\n\t                // Extend default style\n\t                this.style.extendFrom(defaults.style, false);\n\t            }\n\t            // Extend default shape\n\t            var defaultShape = defaults.shape;\n\t            if (defaultShape) {\n\t                this.shape = this.shape || {};\n\t                var thisShape = this.shape;\n\t                for (var name in defaultShape) {\n\t                    if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n\t                        thisShape[name] = defaultShape[name];\n\t                    }\n\t                }\n\t            }\n\t            defaults.init && defaults.init.call(this, opts);\n\t        };\n\t        zrUtil.inherits(Sub, Path);\n\t        // FIXME 不能 extend position, rotation 等引用对象\n\t        for (var name in defaults) {\n\t            // Extending prototype values and methods\n\t            if (name !== 'style' && name !== 'shape') {\n\t                Sub.prototype[name] = defaults[name];\n\t            }\n\t        }\n\t        return Sub;\n\t    };\n\t    zrUtil.inherits(Path, Displayable);\n\t    return Path;\n\t});\n\tdefine('zrender/graphic/Gradient', ['require'], function (require) {\n\t    /**\n\t     * @param {Array.<Object>} colorStops\n\t     */\n\t    var Gradient = function (colorStops) {\n\t        this.colorStops = colorStops || [];\n\t    };\n\t    Gradient.prototype = {\n\t        constructor: Gradient,\n\t        addColorStop: function (offset, color) {\n\t            this.colorStops.push({\n\t                offset: offset,\n\t                color: color\n\t            });\n\t        }\n\t    };\n\t    return Gradient;\n\t});\n\tdefine('zrender/container/Group', ['require', '../core/util', '../Element', '../core/BoundingRect'], function (require) {\n\t    var zrUtil = require('../core/util');\n\t    var Element = require('../Element');\n\t    var BoundingRect = require('../core/BoundingRect');\n\t    /**\n\t     * @alias module:zrender/graphic/Group\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @extends module:zrender/mixin/Eventful\n\t     */\n\t    var Group = function (opts) {\n\t        opts = opts || {};\n\t        Element.call(this, opts);\n\t        for (var key in opts) {\n\t            this[key] = opts[key];\n\t        }\n\t        this._children = [];\n\t        this.__storage = null;\n\t        this.__dirty = true;\n\t    };\n\t    Group.prototype = {\n\t        constructor: Group,\n\t        isGroup: true,\n\t        type: 'group',\n\t        silent: false,\n\t        children: function () {\n\t            return this._children.slice();\n\t        },\n\t        childAt: function (idx) {\n\t            return this._children[idx];\n\t        },\n\t        childOfName: function (name) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                if (children[i].name === name) {\n\t                    return children[i];\n\t                }\n\t            }\n\t        },\n\t        childCount: function () {\n\t            return this._children.length;\n\t        },\n\t        add: function (child) {\n\t            if (child && child !== this && child.parent !== this) {\n\t                this._children.push(child);\n\t                this._doAdd(child);\n\t            }\n\t            return this;\n\t        },\n\t        addBefore: function (child, nextSibling) {\n\t            if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n\t                var children = this._children;\n\t                var idx = children.indexOf(nextSibling);\n\t                if (idx >= 0) {\n\t                    children.splice(idx, 0, child);\n\t                    this._doAdd(child);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t        _doAdd: function (child) {\n\t            if (child.parent) {\n\t                child.parent.remove(child);\n\t            }\n\t            child.parent = this;\n\t            var storage = this.__storage;\n\t            var zr = this.__zr;\n\t            if (storage && storage !== child.__storage) {\n\t                storage.addToMap(child);\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t            zr && zr.refresh();\n\t        },\n\t        remove: function (child) {\n\t            var zr = this.__zr;\n\t            var storage = this.__storage;\n\t            var children = this._children;\n\t            var idx = zrUtil.indexOf(children, child);\n\t            if (idx < 0) {\n\t                return this;\n\t            }\n\t            children.splice(idx, 1);\n\t            child.parent = null;\n\t            if (storage) {\n\t                storage.delFromMap(child.id);\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t            zr && zr.refresh();\n\t            return this;\n\t        },\n\t        removeAll: function () {\n\t            var children = this._children;\n\t            var storage = this.__storage;\n\t            var child;\n\t            var i;\n\t            for (i = 0; i < children.length; i++) {\n\t                child = children[i];\n\t                if (storage) {\n\t                    storage.delFromMap(child.id);\n\t                    if (child instanceof Group) {\n\t                        child.delChildrenFromStorage(storage);\n\t                    }\n\t                }\n\t                child.parent = null;\n\t            }\n\t            children.length = 0;\n\t            return this;\n\t        },\n\t        eachChild: function (cb, context) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                cb.call(context, child, i);\n\t            }\n\t            return this;\n\t        },\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                cb.call(context, child);\n\t                if (child.type === 'group') {\n\t                    child.traverse(cb, context);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t        addChildrenToStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.addToMap(child);\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t        },\n\t        delChildrenFromStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.delFromMap(child.id);\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t        },\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t            this.__zr && this.__zr.refresh();\n\t            return this;\n\t        },\n\t        getBoundingRect: function (includeChildren) {\n\t            // TODO Caching\n\t            // TODO Transform\n\t            var rect = null;\n\t            var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t            var children = includeChildren || this._children;\n\t            var tmpMat = [];\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                if (child.ignore || child.invisible) {\n\t                    continue;\n\t                }\n\t                var childRect = child.getBoundingRect();\n\t                var transform = child.getLocalTransform(tmpMat);\n\t                if (transform) {\n\t                    tmpRect.copy(childRect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = rect || tmpRect.clone();\n\t                    rect.union(tmpRect);\n\t                } else {\n\t                    rect = rect || childRect.clone();\n\t                    rect.union(childRect);\n\t                }\n\t            }\n\t            return rect || tmpRect;\n\t        }\n\t    };\n\t    zrUtil.inherits(Group, Element);\n\t    return Group;\n\t});\n\tdefine('zrender/graphic/Text', ['require', './Displayable', '../core/util', '../contain/text'], function (require) {\n\t    var Displayable = require('./Displayable');\n\t    var zrUtil = require('../core/util');\n\t    var textContain = require('../contain/text');\n\t    /**\n\t     * @alias zrender/graphic/Text\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    var Text = function (opts) {\n\t        Displayable.call(this, opts);\n\t    };\n\t    Text.prototype = {\n\t        constructor: Text,\n\t        type: 'text',\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var x = style.x || 0;\n\t            var y = style.y || 0;\n\t            // Convert to string\n\t            var text = style.text;\n\t            // Convert to string\n\t            text != null && (text += '');\n\t            // Always bind style\n\t            style.bind(ctx, this, prevEl);\n\t            if (text) {\n\t                this.setTransform(ctx);\n\t                var textBaseline;\n\t                var textAlign = style.textAlign;\n\t                var font = style.textFont || style.font;\n\t                if (style.textVerticalAlign) {\n\t                    var rect = textContain.getBoundingRect(text, font, style.textAlign, 'top');\n\t                    // Ignore textBaseline\n\t                    textBaseline = 'middle';\n\t                    switch (style.textVerticalAlign) {\n\t                    case 'middle':\n\t                        y -= rect.height / 2 - rect.lineHeight / 2;\n\t                        break;\n\t                    case 'bottom':\n\t                        y -= rect.height - rect.lineHeight / 2;\n\t                        break;\n\t                    default:\n\t                        y += rect.lineHeight / 2;\n\t                    }\n\t                } else {\n\t                    textBaseline = style.textBaseline;\n\t                }\n\t                // TODO Invalid font\n\t                ctx.font = font || '12px sans-serif';\n\t                ctx.textAlign = textAlign || 'left';\n\t                // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t                if (ctx.textAlign !== textAlign) {\n\t                    ctx.textAlign = 'left';\n\t                }\n\t                ctx.textBaseline = textBaseline || 'alphabetic';\n\t                // Use canvas default alphabetic baseline\n\t                if (ctx.textBaseline !== textBaseline) {\n\t                    ctx.textBaseline = 'alphabetic';\n\t                }\n\t                var lineHeight = textContain.measureText('国', ctx.font).width;\n\t                var textLines = text.split('\\n');\n\t                for (var i = 0; i < textLines.length; i++) {\n\t                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n\t                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n\t                    y += lineHeight;\n\t                }\n\t                this.restoreTransform(ctx);\n\t            }\n\t        },\n\t        getBoundingRect: function () {\n\t            if (!this._rect) {\n\t                var style = this.style;\n\t                var textVerticalAlign = style.textVerticalAlign;\n\t                var rect = textContain.getBoundingRect(style.text + '', style.textFont || style.font, style.textAlign, textVerticalAlign ? 'top' : style.textBaseline);\n\t                switch (textVerticalAlign) {\n\t                case 'middle':\n\t                    rect.y -= rect.height / 2;\n\t                    break;\n\t                case 'bottom':\n\t                    rect.y -= rect.height;\n\t                    break;\n\t                }\n\t                rect.x += style.x || 0;\n\t                rect.y += style.y || 0;\n\t                this._rect = rect;\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t    zrUtil.inherits(Text, Displayable);\n\t    return Text;\n\t});\n\tdefine('zrender/graphic/Image', ['require', './Displayable', '../core/BoundingRect', '../core/util', '../core/LRU'], function (require) {\n\t    var Displayable = require('./Displayable');\n\t    var BoundingRect = require('../core/BoundingRect');\n\t    var zrUtil = require('../core/util');\n\t    var LRU = require('../core/LRU');\n\t    var globalImageCache = new LRU(50);\n\t    /**\n\t     * @alias zrender/graphic/Image\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function ZImage(opts) {\n\t        Displayable.call(this, opts);\n\t    }\n\t    ZImage.prototype = {\n\t        constructor: ZImage,\n\t        type: 'image',\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var src = style.image;\n\t            var image;\n\t            // Must bind each time\n\t            style.bind(ctx, this, prevEl);\n\t            // style.image is a url string\n\t            if (typeof src === 'string') {\n\t                image = this._image;\n\t            }    // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n\t            else {\n\t                image = src;\n\t            }\n\t            // FIXME Case create many images with src\n\t            if (!image && src) {\n\t                // Try get from global image cache\n\t                var cachedImgObj = globalImageCache.get(src);\n\t                if (!cachedImgObj) {\n\t                    // Create a new image\n\t                    image = new Image();\n\t                    image.onload = function () {\n\t                        image.onload = null;\n\t                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n\t                            cachedImgObj.pending[i].dirty();\n\t                        }\n\t                    };\n\t                    cachedImgObj = {\n\t                        image: image,\n\t                        pending: [this]\n\t                    };\n\t                    image.src = src;\n\t                    globalImageCache.put(src, cachedImgObj);\n\t                    this._image = image;\n\t                    return;\n\t                } else {\n\t                    image = cachedImgObj.image;\n\t                    this._image = image;\n\t                    // Image is not complete finish, add to pending list\n\t                    if (!image.width || !image.height) {\n\t                        cachedImgObj.pending.push(this);\n\t                        return;\n\t                    }\n\t                }\n\t            }\n\t            if (image) {\n\t                // 图片已经加载完成\n\t                // if (image.nodeName.toUpperCase() == 'IMG') {\n\t                //     if (!image.complete) {\n\t                //         return;\n\t                //     }\n\t                // }\n\t                // Else is canvas\n\t                var width = style.width || image.width;\n\t                var height = style.height || image.height;\n\t                var x = style.x || 0;\n\t                var y = style.y || 0;\n\t                // 图片加载失败\n\t                if (!image.width || !image.height) {\n\t                    return;\n\t                }\n\t                // 设置transform\n\t                this.setTransform(ctx);\n\t                if (style.sWidth && style.sHeight) {\n\t                    var sx = style.sx || 0;\n\t                    var sy = style.sy || 0;\n\t                    ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n\t                } else if (style.sx && style.sy) {\n\t                    var sx = style.sx;\n\t                    var sy = style.sy;\n\t                    var sWidth = width - sx;\n\t                    var sHeight = height - sy;\n\t                    ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n\t                } else {\n\t                    ctx.drawImage(image, x, y, width, height);\n\t                }\n\t                // 如果没设置宽和高的话自动根据图片宽高设置\n\t                if (style.width == null) {\n\t                    style.width = width;\n\t                }\n\t                if (style.height == null) {\n\t                    style.height = height;\n\t                }\n\t                this.restoreTransform(ctx);\n\t                // Draw rect text\n\t                if (style.text != null) {\n\t                    this.drawRectText(ctx, this.getBoundingRect());\n\t                }\n\t            }\n\t        },\n\t        getBoundingRect: function () {\n\t            var style = this.style;\n\t            if (!this._rect) {\n\t                this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t    zrUtil.inherits(ZImage, Displayable);\n\t    return ZImage;\n\t});\n\tdefine('zrender/graphic/shape/Circle', ['require', '../Path'], function (require) {\n\t    'use strict';\n\t    return require('../Path').extend({\n\t        type: 'circle',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0\n\t        },\n\t        buildPath: function (ctx, shape, inBundle) {\n\t            // Better stroking in ShapeBundle\n\t            // Always do it may have performence issue ( fill may be 2x more cost)\n\t            if (inBundle) {\n\t                ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            }\n\t            // Better stroking in ShapeBundle\n\t            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Ring', ['require', '../Path'], function (require) {\n\t    return require('../Path').extend({\n\t        type: 'ring',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0,\n\t            r0: 0\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var PI2 = Math.PI * 2;\n\t            ctx.moveTo(x + shape.r, y);\n\t            ctx.arc(x, y, shape.r, 0, PI2, false);\n\t            ctx.moveTo(x + shape.r0, y);\n\t            ctx.arc(x, y, shape.r0, 0, PI2, true);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Sector', ['require', '../Path'], function (require) {\n\t    return require('../Path').extend({\n\t        type: 'sector',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r0: 0,\n\t            r: 0,\n\t            startAngle: 0,\n\t            endAngle: Math.PI * 2,\n\t            clockwise: true\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r0 = Math.max(shape.r0 || 0, 0);\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\t            ctx.lineTo(unitX * r + x, unitY * r + y);\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t            ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n\t            if (r0 !== 0) {\n\t                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n\t            }\n\t            ctx.closePath();\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Rect', ['require', '../helper/roundRect', '../Path'], function (require) {\n\t    var roundRectHelper = require('../helper/roundRect');\n\t    return require('../Path').extend({\n\t        type: 'rect',\n\t        shape: {\n\t            r: 0,\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            if (!shape.r) {\n\t                ctx.rect(x, y, width, height);\n\t            } else {\n\t                roundRectHelper.buildPath(ctx, shape);\n\t            }\n\t            ctx.closePath();\n\t            return;\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Polygon', ['require', '../helper/poly', '../Path'], function (require) {\n\t    var polyHelper = require('../helper/poly');\n\t    return require('../Path').extend({\n\t        type: 'polygon',\n\t        shape: {\n\t            points: null,\n\t            smooth: false,\n\t            smoothConstraint: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, true);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Polyline', ['require', '../helper/poly', '../Path'], function (require) {\n\t    var polyHelper = require('../helper/poly');\n\t    return require('../Path').extend({\n\t        type: 'polyline',\n\t        shape: {\n\t            points: null,\n\t            smooth: false,\n\t            smoothConstraint: null\n\t        },\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, false);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Line', ['require', '../Path'], function (require) {\n\t    return require('../Path').extend({\n\t        type: 'line',\n\t        shape: {\n\t            x1: 0,\n\t            y1: 0,\n\t            x2: 0,\n\t            y2: 0,\n\t            percent: 1\n\t        },\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var percent = shape.percent;\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t            ctx.moveTo(x1, y1);\n\t            if (percent < 1) {\n\t                x2 = x1 * (1 - percent) + x2 * percent;\n\t                y2 = y1 * (1 - percent) + y2 * percent;\n\t            }\n\t            ctx.lineTo(x2, y2);\n\t        },\n\t        pointAt: function (p) {\n\t            var shape = this.shape;\n\t            return [\n\t                shape.x1 * (1 - p) + shape.x2 * p,\n\t                shape.y1 * (1 - p) + shape.y2 * p\n\t            ];\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/BezierCurve', ['require', '../../core/curve', '../../core/vector', '../Path'], function (require) {\n\t    'use strict';\n\t    var curveTool = require('../../core/curve');\n\t    var vec2 = require('../../core/vector');\n\t    var quadraticSubdivide = curveTool.quadraticSubdivide;\n\t    var cubicSubdivide = curveTool.cubicSubdivide;\n\t    var quadraticAt = curveTool.quadraticAt;\n\t    var cubicAt = curveTool.cubicAt;\n\t    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n\t    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\t    var out = [];\n\t    function someVectorAt(shape, t, isTangent) {\n\t        var cpx2 = shape.cpx2;\n\t        var cpy2 = shape.cpy2;\n\t        if (cpx2 === null || cpy2 === null) {\n\t            return [\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n\t            ];\n\t        } else {\n\t            return [\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n\t            ];\n\t        }\n\t    }\n\t    return require('../Path').extend({\n\t        type: 'bezier-curve',\n\t        shape: {\n\t            x1: 0,\n\t            y1: 0,\n\t            x2: 0,\n\t            y2: 0,\n\t            cpx1: 0,\n\t            cpy1: 0,\n\t            percent: 1\n\t        },\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var cpx1 = shape.cpx1;\n\t            var cpy1 = shape.cpy1;\n\t            var cpx2 = shape.cpx2;\n\t            var cpy2 = shape.cpy2;\n\t            var percent = shape.percent;\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t            ctx.moveTo(x1, y1);\n\t            if (cpx2 == null || cpy2 == null) {\n\t                if (percent < 1) {\n\t                    quadraticSubdivide(x1, cpx1, x2, percent, out);\n\t                    cpx1 = out[1];\n\t                    x2 = out[2];\n\t                    quadraticSubdivide(y1, cpy1, y2, percent, out);\n\t                    cpy1 = out[1];\n\t                    y2 = out[2];\n\t                }\n\t                ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n\t            } else {\n\t                if (percent < 1) {\n\t                    cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n\t                    cpx1 = out[1];\n\t                    cpx2 = out[2];\n\t                    x2 = out[3];\n\t                    cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n\t                    cpy1 = out[1];\n\t                    cpy2 = out[2];\n\t                    y2 = out[3];\n\t                }\n\t                ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n\t            }\n\t        },\n\t        pointAt: function (t) {\n\t            return someVectorAt(this.shape, t, false);\n\t        },\n\t        tangentAt: function (t) {\n\t            var p = someVectorAt(this.shape, t, true);\n\t            return vec2.normalize(p, p);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Arc', ['require', '../Path'], function (require) {\n\t    return require('../Path').extend({\n\t        type: 'arc',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0,\n\t            startAngle: 0,\n\t            endAngle: Math.PI * 2,\n\t            clockwise: true\n\t        },\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t            ctx.moveTo(unitX * r + x, unitY * r + y);\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/RadialGradient', ['require', '../core/util', './Gradient'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('../core/util');\n\t    var Gradient = require('./Gradient');\n\t    /**\n\t     * x, y, r are all percent from 0 to 1\n\t     * @param {number} [x=0.5]\n\t     * @param {number} [y=0.5]\n\t     * @param {number} [r=0.5]\n\t     * @param {Array.<Object>} [colorStops]\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n\t        this.x = x == null ? 0.5 : x;\n\t        this.y = y == null ? 0.5 : y;\n\t        this.r = r == null ? 0.5 : r;\n\t        // Can be cloned\n\t        this.type = 'radial';\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t        Gradient.call(this, colorStops);\n\t    };\n\t    RadialGradient.prototype = { constructor: RadialGradient };\n\t    zrUtil.inherits(RadialGradient, Gradient);\n\t    return RadialGradient;\n\t});\n\tdefine('zrender/graphic/LinearGradient', ['require', '../core/util', './Gradient'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('../core/util');\n\t    var Gradient = require('./Gradient');\n\t    /**\n\t     * x, y, x2, y2 are all percent from 0 to 1\n\t     * @param {number} [x=0]\n\t     * @param {number} [y=0]\n\t     * @param {number} [x2=1]\n\t     * @param {number} [y2=0]\n\t     * @param {Array.<Object>} colorStops\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n\t        this.x = x == null ? 0 : x;\n\t        this.y = y == null ? 0 : y;\n\t        this.x2 = x2 == null ? 1 : x2;\n\t        this.y2 = y2 == null ? 0 : y2;\n\t        // Can be cloned\n\t        this.type = 'linear';\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t        Gradient.call(this, colorStops);\n\t    };\n\t    LinearGradient.prototype = { constructor: LinearGradient };\n\t    zrUtil.inherits(LinearGradient, Gradient);\n\t    return LinearGradient;\n\t});\n\tdefine('zrender/graphic/CompoundPath', ['require', './Path'], function (require) {\n\t    var Path = require('./Path');\n\t    return Path.extend({\n\t        type: 'compound',\n\t        shape: { paths: null },\n\t        _updatePathDirty: function () {\n\t            var dirtyPath = this.__dirtyPath;\n\t            var paths = this.shape.paths;\n\t            for (var i = 0; i < paths.length; i++) {\n\t                // Mark as dirty if any subpath is dirty\n\t                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n\t            }\n\t            this.__dirtyPath = dirtyPath;\n\t            this.__dirty = this.__dirty || dirtyPath;\n\t        },\n\t        beforeBrush: function () {\n\t            this._updatePathDirty();\n\t            var paths = this.shape.paths || [];\n\t            var scale = this.getGlobalScale();\n\t            // Update path scale\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].path.setScale(scale[0], scale[1]);\n\t            }\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var paths = shape.paths || [];\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].buildPath(ctx, paths[i].shape, true);\n\t            }\n\t        },\n\t        afterBrush: function () {\n\t            var paths = this.shape.paths;\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].__dirtyPath = false;\n\t            }\n\t        },\n\t        getBoundingRect: function () {\n\t            this._updatePathDirty();\n\t            return Path.prototype.getBoundingRect.call(this);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/core/BoundingRect', ['require', './vector', './matrix'], function (require) {\n\t    'use strict';\n\t    var vec2 = require('./vector');\n\t    var matrix = require('./matrix');\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var mathMin = Math.min;\n\t    var mathAbs = Math.abs;\n\t    var mathMax = Math.max;\n\t    /**\n\t     * @alias module:echarts/core/BoundingRect\n\t     */\n\t    function BoundingRect(x, y, width, height) {\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.x = x;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.y = y;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.width = width;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.height = height;\n\t    }\n\t    BoundingRect.prototype = {\n\t        constructor: BoundingRect,\n\t        union: function (other) {\n\t            var x = mathMin(other.x, this.x);\n\t            var y = mathMin(other.y, this.y);\n\t            this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n\t            this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n\t            this.x = x;\n\t            this.y = y;\n\t        },\n\t        applyTransform: function () {\n\t            var min = [];\n\t            var max = [];\n\t            return function (m) {\n\t                // In case usage like this\n\t                // el.getBoundingRect().applyTransform(el.transform)\n\t                // And element has no transform\n\t                if (!m) {\n\t                    return;\n\t                }\n\t                min[0] = this.x;\n\t                min[1] = this.y;\n\t                max[0] = this.x + this.width;\n\t                max[1] = this.y + this.height;\n\t                v2ApplyTransform(min, min, m);\n\t                v2ApplyTransform(max, max, m);\n\t                this.x = mathMin(min[0], max[0]);\n\t                this.y = mathMin(min[1], max[1]);\n\t                this.width = mathAbs(max[0] - min[0]);\n\t                this.height = mathAbs(max[1] - min[1]);\n\t            };\n\t        }(),\n\t        calculateTransform: function (b) {\n\t            var a = this;\n\t            var sx = b.width / a.width;\n\t            var sy = b.height / a.height;\n\t            var m = matrix.create();\n\t            // 矩阵右乘\n\t            matrix.translate(m, m, [\n\t                -a.x,\n\t                -a.y\n\t            ]);\n\t            matrix.scale(m, m, [\n\t                sx,\n\t                sy\n\t            ]);\n\t            matrix.translate(m, m, [\n\t                b.x,\n\t                b.y\n\t            ]);\n\t            return m;\n\t        },\n\t        intersect: function (b) {\n\t            var a = this;\n\t            var ax0 = a.x;\n\t            var ax1 = a.x + a.width;\n\t            var ay0 = a.y;\n\t            var ay1 = a.y + a.height;\n\t            var bx0 = b.x;\n\t            var bx1 = b.x + b.width;\n\t            var by0 = b.y;\n\t            var by1 = b.y + b.height;\n\t            return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\t        },\n\t        contain: function (x, y) {\n\t            var rect = this;\n\t            return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n\t        },\n\t        clone: function () {\n\t            return new BoundingRect(this.x, this.y, this.width, this.height);\n\t        },\n\t        copy: function (other) {\n\t            this.x = other.x;\n\t            this.y = other.y;\n\t            this.width = other.width;\n\t            this.height = other.height;\n\t        }\n\t    };\n\t    return BoundingRect;\n\t});\n\tdefine('zrender/contain/text', ['require', '../core/util', '../core/BoundingRect'], function (require) {\n\t    var textWidthCache = {};\n\t    var textWidthCacheCounter = 0;\n\t    var TEXT_CACHE_MAX = 5000;\n\t    var util = require('../core/util');\n\t    var BoundingRect = require('../core/BoundingRect');\n\t    var retrieve = util.retrieve;\n\t    function getTextWidth(text, textFont) {\n\t        var key = text + ':' + textFont;\n\t        if (textWidthCache[key]) {\n\t            return textWidthCache[key];\n\t        }\n\t        var textLines = (text + '').split('\\n');\n\t        var width = 0;\n\t        for (var i = 0, l = textLines.length; i < l; i++) {\n\t            // measureText 可以被覆盖以兼容不支持 Canvas 的环境\n\t            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n\t        }\n\t        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n\t            textWidthCacheCounter = 0;\n\t            textWidthCache = {};\n\t        }\n\t        textWidthCacheCounter++;\n\t        textWidthCache[key] = width;\n\t        return width;\n\t    }\n\t    function getTextRect(text, textFont, textAlign, textBaseline) {\n\t        var textLineLen = ((text || '') + '').split('\\n').length;\n\t        var width = getTextWidth(text, textFont);\n\t        // FIXME 高度计算比较粗暴\n\t        var lineHeight = getTextWidth('国', textFont);\n\t        var height = textLineLen * lineHeight;\n\t        var rect = new BoundingRect(0, 0, width, height);\n\t        // Text has a special line height property\n\t        rect.lineHeight = lineHeight;\n\t        switch (textBaseline) {\n\t        case 'bottom':\n\t        case 'alphabetic':\n\t            rect.y -= lineHeight;\n\t            break;\n\t        case 'middle':\n\t            rect.y -= lineHeight / 2;\n\t            break;    // case 'hanging':\n\t                      // case 'top':\n\t        }\n\t        // FIXME Right to left language\n\t        switch (textAlign) {\n\t        case 'end':\n\t        case 'right':\n\t            rect.x -= rect.width;\n\t            break;\n\t        case 'center':\n\t            rect.x -= rect.width / 2;\n\t            break;    // case 'start':\n\t                      // case 'left':\n\t        }\n\t        return rect;\n\t    }\n\t    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\t        var x = rect.x;\n\t        var y = rect.y;\n\t        var height = rect.height;\n\t        var width = rect.width;\n\t        var textHeight = textRect.height;\n\t        var halfHeight = height / 2 - textHeight / 2;\n\t        var textAlign = 'left';\n\t        switch (textPosition) {\n\t        case 'left':\n\t            x -= distance;\n\t            y += halfHeight;\n\t            textAlign = 'right';\n\t            break;\n\t        case 'right':\n\t            x += distance + width;\n\t            y += halfHeight;\n\t            textAlign = 'left';\n\t            break;\n\t        case 'top':\n\t            x += width / 2;\n\t            y -= distance + textHeight;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'bottom':\n\t            x += width / 2;\n\t            y += height + distance;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'inside':\n\t            x += width / 2;\n\t            y += halfHeight;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'insideLeft':\n\t            x += distance;\n\t            y += halfHeight;\n\t            textAlign = 'left';\n\t            break;\n\t        case 'insideRight':\n\t            x += width - distance;\n\t            y += halfHeight;\n\t            textAlign = 'right';\n\t            break;\n\t        case 'insideTop':\n\t            x += width / 2;\n\t            y += distance;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'insideBottom':\n\t            x += width / 2;\n\t            y += height - textHeight - distance;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'insideTopLeft':\n\t            x += distance;\n\t            y += distance;\n\t            textAlign = 'left';\n\t            break;\n\t        case 'insideTopRight':\n\t            x += width - distance;\n\t            y += distance;\n\t            textAlign = 'right';\n\t            break;\n\t        case 'insideBottomLeft':\n\t            x += distance;\n\t            y += height - textHeight - distance;\n\t            break;\n\t        case 'insideBottomRight':\n\t            x += width - distance;\n\t            y += height - textHeight - distance;\n\t            textAlign = 'right';\n\t            break;\n\t        }\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            textAlign: textAlign,\n\t            textBaseline: 'top'\n\t        };\n\t    }\n\t    /**\n\t     * Show ellipsis if overflow.\n\t     *\n\t     * @param  {string} text\n\t     * @param  {string} containerWidth\n\t     * @param  {string} textFont\n\t     * @param  {number} [ellipsis='...']\n\t     * @param  {Object} [options]\n\t     * @param  {number} [options.maxIterations=3]\n\t     * @param  {number} [options.minChar=0] If truncate result are less\n\t     *                  then minChar, ellipsis will not show, which is\n\t     *                  better for user hint in some cases.\n\t     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n\t     * @return {string}\n\t     */\n\t    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n\t        if (!containerWidth) {\n\t            return '';\n\t        }\n\t        options = options || {};\n\t        ellipsis = retrieve(ellipsis, '...');\n\t        var maxIterations = retrieve(options.maxIterations, 2);\n\t        var minChar = retrieve(options.minChar, 0);\n\t        // FIXME\n\t        // Other languages?\n\t        var cnCharWidth = getTextWidth('国', textFont);\n\t        // FIXME\n\t        // Consider proportional font?\n\t        var ascCharWidth = getTextWidth('a', textFont);\n\t        var placeholder = retrieve(options.placeholder, '');\n\t        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n\t        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\t        var contentWidth = containerWidth = Math.max(0, containerWidth - 1);\n\t        // Reserve some gap.\n\t        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n\t            contentWidth -= ascCharWidth;\n\t        }\n\t        var ellipsisWidth = getTextWidth(ellipsis);\n\t        if (ellipsisWidth > contentWidth) {\n\t            ellipsis = '';\n\t            ellipsisWidth = 0;\n\t        }\n\t        contentWidth = containerWidth - ellipsisWidth;\n\t        var textLines = (text + '').split('\\n');\n\t        for (var i = 0, len = textLines.length; i < len; i++) {\n\t            var textLine = textLines[i];\n\t            var lineWidth = getTextWidth(textLine, textFont);\n\t            if (lineWidth <= containerWidth) {\n\t                continue;\n\t            }\n\t            for (var j = 0;; j++) {\n\t                if (lineWidth <= contentWidth || j >= maxIterations) {\n\t                    textLine += ellipsis;\n\t                    break;\n\t                }\n\t                var subLength = j === 0 ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n\t                textLine = textLine.substr(0, subLength);\n\t                lineWidth = getTextWidth(textLine, textFont);\n\t            }\n\t            if (textLine === '') {\n\t                textLine = placeholder;\n\t            }\n\t            textLines[i] = textLine;\n\t        }\n\t        return textLines.join('\\n');\n\t    }\n\t    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n\t        var width = 0;\n\t        var i = 0;\n\t        for (var len = text.length; i < len && width < contentWidth; i++) {\n\t            var charCode = text.charCodeAt(i);\n\t            width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n\t        }\n\t        return i;\n\t    }\n\t    var textContain = {\n\t            getWidth: getTextWidth,\n\t            getBoundingRect: getTextRect,\n\t            adjustTextPositionOnRect: adjustTextPositionOnRect,\n\t            truncateText: truncateText,\n\t            measureText: function (text, textFont) {\n\t                var ctx = util.getContext();\n\t                ctx.font = textFont || '12px sans-serif';\n\t                return ctx.measureText(text);\n\t            }\n\t        };\n\t    return textContain;\n\t});\n\tdefine('echarts/util/model', ['require', './format', './number', '../model/Model', 'zrender/core/util'], function (require) {\n\t    var formatUtil = require('./format');\n\t    var nubmerUtil = require('./number');\n\t    var Model = require('../model/Model');\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = {};\n\t    /**\n\t     * If value is not array, then translate it to array.\n\t     * @param  {*} value\n\t     * @return {Array} [value] or value\n\t     */\n\t    modelUtil.normalizeToArray = function (value) {\n\t        return value instanceof Array ? value : value == null ? [] : [value];\n\t    };\n\t    /**\n\t     * Sync default option between normal and emphasis like `position` and `show`\n\t     * In case some one will write code like\n\t     *     label: {\n\t     *         normal: {\n\t     *             show: false,\n\t     *             position: 'outside',\n\t     *             textStyle: {\n\t     *                 fontSize: 18\n\t     *             }\n\t     *         },\n\t     *         emphasis: {\n\t     *             show: true\n\t     *         }\n\t     *     }\n\t     * @param {Object} opt\n\t     * @param {Array.<string>} subOpts\n\t     */\n\t    modelUtil.defaultEmphasis = function (opt, subOpts) {\n\t        if (opt) {\n\t            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n\t            var normalOpt = opt.normal = opt.normal || {};\n\t            // Default emphasis option from normal\n\t            zrUtil.each(subOpts, function (subOptName) {\n\t                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n\t                if (val != null) {\n\t                    emphasisOpt[subOptName] = val;\n\t                }\n\t            });\n\t        }\n\t    };\n\t    modelUtil.LABEL_OPTIONS = [\n\t        'position',\n\t        'show',\n\t        'textStyle',\n\t        'distance',\n\t        'formatter'\n\t    ];\n\t    /**\n\t     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n\t     * This helper method retieves value from data.\n\t     * @param {string|number|Date|Array|Object} dataItem\n\t     * @return {number|string|Date|Array.<number|string|Date>}\n\t     */\n\t    modelUtil.getDataItemValue = function (dataItem) {\n\t        // Performance sensitive.\n\t        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n\t    };\n\t    /**\n\t     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n\t     * This helper method determine if dataItem has extra option besides value\n\t     * @param {string|number|Date|Array|Object} dataItem\n\t     */\n\t    modelUtil.isDataItemOption = function (dataItem) {\n\t        return zrUtil.isObject(dataItem) && !(dataItem instanceof Array);    // // markLine data can be array\n\t                                                                             // && !(dataItem[0] && zrUtil.isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n\t    };\n\t    /**\n\t     * This helper method convert value in data.\n\t     * @param {string|number|Date} value\n\t     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n\t     */\n\t    modelUtil.converDataValue = function (value, dimInfo) {\n\t        // Performance sensitive.\n\t        var dimType = dimInfo && dimInfo.type;\n\t        if (dimType === 'ordinal') {\n\t            return value;\n\t        }\n\t        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {\n\t            value = +nubmerUtil.parseDate(value);\n\t        }\n\t        // dimType defaults 'number'.\n\t        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n\t        // parse to NaN.\n\t        return value == null || value === '' ? NaN : +value;    // If string (like '-'), using '+' parse to NaN\n\t    };\n\t    /**\n\t     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n\t     * @param {module:echarts/data/List} data\n\t     * @param {Object} opt\n\t     * @param {string} [opt.seriesIndex]\n\t     * @param {Object} [opt.name]\n\t     * @param {Object} [opt.mainType]\n\t     * @param {Object} [opt.subType]\n\t     */\n\t    modelUtil.createDataFormatModel = function (data, opt) {\n\t        var model = new Model();\n\t        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n\t        model.seriesIndex = opt.seriesIndex;\n\t        model.name = opt.name || '';\n\t        model.mainType = opt.mainType;\n\t        model.subType = opt.subType;\n\t        model.getData = function () {\n\t            return data;\n\t        };\n\t        return model;\n\t    };\n\t    // PENDING A little ugly\n\t    modelUtil.dataFormatMixin = {\n\t        getDataParams: function (dataIndex, dataType) {\n\t            var data = this.getData(dataType);\n\t            var seriesIndex = this.seriesIndex;\n\t            var seriesName = this.name;\n\t            var rawValue = this.getRawValue(dataIndex, dataType);\n\t            var rawDataIndex = data.getRawIndex(dataIndex);\n\t            var name = data.getName(dataIndex, true);\n\t            var itemOpt = data.getRawDataItem(dataIndex);\n\t            return {\n\t                componentType: this.mainType,\n\t                componentSubType: this.subType,\n\t                seriesType: this.mainType === 'series' ? this.subType : null,\n\t                seriesIndex: seriesIndex,\n\t                seriesName: seriesName,\n\t                name: name,\n\t                dataIndex: rawDataIndex,\n\t                data: itemOpt,\n\t                dataType: dataType,\n\t                value: rawValue,\n\t                color: data.getItemVisual(dataIndex, 'color'),\n\t                $vars: [\n\t                    'seriesName',\n\t                    'name',\n\t                    'value'\n\t                ]\n\t            };\n\t        },\n\t        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n\t            status = status || 'normal';\n\t            var data = this.getData(dataType);\n\t            var itemModel = data.getItemModel(dataIndex);\n\t            var params = this.getDataParams(dataIndex, dataType);\n\t            if (dimIndex != null && params.value instanceof Array) {\n\t                params.value = params.value[dimIndex];\n\t            }\n\t            var formatter = itemModel.get([\n\t                    'label',\n\t                    status,\n\t                    'formatter'\n\t                ]);\n\t            if (typeof formatter === 'function') {\n\t                params.status = status;\n\t                return formatter(params);\n\t            } else if (typeof formatter === 'string') {\n\t                return formatUtil.formatTpl(formatter, params);\n\t            }\n\t        },\n\t        getRawValue: function (idx, dataType) {\n\t            var data = this.getData(dataType);\n\t            var dataItem = data.getRawDataItem(idx);\n\t            if (dataItem != null) {\n\t                return zrUtil.isObject(dataItem) && !(dataItem instanceof Array) ? dataItem.value : dataItem;\n\t            }\n\t        },\n\t        formatTooltip: zrUtil.noop\n\t    };\n\t    /**\n\t     * Mapping to exists for merge.\n\t     *\n\t     * @public\n\t     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n\t     * @param {Object|Array.<Object>} newCptOptions\n\t     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n\t     *                          which order is the same as exists.\n\t     */\n\t    modelUtil.mappingToExists = function (exists, newCptOptions) {\n\t        // Mapping by the order by original option (but not order of\n\t        // new option) in merge mode. Because we should ensure\n\t        // some specified index (like xAxisIndex) is consistent with\n\t        // original option, which is easy to understand, espatially in\n\t        // media query. And in most case, merge option is used to\n\t        // update partial option but not be expected to change order.\n\t        newCptOptions = (newCptOptions || []).slice();\n\t        var result = zrUtil.map(exists || [], function (obj, index) {\n\t                return { exist: obj };\n\t            });\n\t        // Mapping by id or name if specified.\n\t        zrUtil.each(newCptOptions, function (cptOption, index) {\n\t            if (!zrUtil.isObject(cptOption)) {\n\t                return;\n\t            }\n\t            // id has highest priority.\n\t            for (var i = 0; i < result.length; i++) {\n\t                if (!result[i].option && cptOption.id != null && result[i].exist.id === cptOption.id + '') {\n\t                    result[i].option = cptOption;\n\t                    newCptOptions[index] = null;\n\t                    return;\n\t                }\n\t            }\n\t            for (var i = 0; i < result.length; i++) {\n\t                var exist = result[i].exist;\n\t                if (!result[i].option && (exist.id == null || cptOption.id == null) && cptOption.name != null && !modelUtil.isIdInner(cptOption) && !modelUtil.isIdInner(exist) && exist.name === cptOption.name + '') {\n\t                    result[i].option = cptOption;\n\t                    newCptOptions[index] = null;\n\t                    return;\n\t                }\n\t            }\n\t        });\n\t        // Otherwise mapping by index.\n\t        zrUtil.each(newCptOptions, function (cptOption, index) {\n\t            if (!zrUtil.isObject(cptOption)) {\n\t                return;\n\t            }\n\t            var i = 0;\n\t            for (; i < result.length; i++) {\n\t                var exist = result[i].exist;\n\t                if (!result[i].option && !modelUtil.isIdInner(exist) && cptOption.id == null) {\n\t                    result[i].option = cptOption;\n\t                    break;\n\t                }\n\t            }\n\t            if (i >= result.length) {\n\t                result.push({ option: cptOption });\n\t            }\n\t        });\n\t        return result;\n\t    };\n\t    /**\n\t     * @public\n\t     * @param {Object} cptOption\n\t     * @return {boolean}\n\t     */\n\t    modelUtil.isIdInner = function (cptOption) {\n\t        return zrUtil.isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\u0000_ec_\u0000') === 0;\n\t    };\n\t    /**\n\t     * A helper for removing duplicate items between batchA and batchB,\n\t     * and in themselves, and categorize by series.\n\t     *\n\t     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n\t     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n\t     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n\t     */\n\t    modelUtil.compressBatches = function (batchA, batchB) {\n\t        var mapA = {};\n\t        var mapB = {};\n\t        makeMap(batchA || [], mapA);\n\t        makeMap(batchB || [], mapB, mapA);\n\t        return [\n\t            mapToArray(mapA),\n\t            mapToArray(mapB)\n\t        ];\n\t        function makeMap(sourceBatch, map, otherMap) {\n\t            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n\t                var seriesId = sourceBatch[i].seriesId;\n\t                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n\t                var otherDataIndices = otherMap && otherMap[seriesId];\n\t                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n\t                    var dataIndex = dataIndices[j];\n\t                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n\t                        otherDataIndices[dataIndex] = null;\n\t                    } else {\n\t                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        function mapToArray(map, isData) {\n\t            var result = [];\n\t            for (var i in map) {\n\t                if (map.hasOwnProperty(i) && map[i] != null) {\n\t                    if (isData) {\n\t                        result.push(+i);\n\t                    } else {\n\t                        var dataIndices = mapToArray(map[i], true);\n\t                        dataIndices.length && result.push({\n\t                            seriesId: i,\n\t                            dataIndex: dataIndices\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    };\n\t    return modelUtil;\n\t});\n\tdefine('echarts/model/globalDefault', [], function () {\n\t    var platform = '';\n\t    // Navigator not exists in node\n\t    if (typeof navigator !== 'undefined') {\n\t        platform = navigator.platform || '';\n\t    }\n\t    return {\n\t        color: [\n\t            '#c23531',\n\t            '#2f4554',\n\t            '#61a0a8',\n\t            '#d48265',\n\t            '#91c7ae',\n\t            '#749f83',\n\t            '#ca8622',\n\t            '#bda29a',\n\t            '#6e7074',\n\t            '#546570',\n\t            '#c4ccd3'\n\t        ],\n\t        textStyle: {\n\t            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n\t            fontSize: 12,\n\t            fontStyle: 'normal',\n\t            fontWeight: 'normal'\n\t        },\n\t        blendMode: null,\n\t        animation: true,\n\t        animationDuration: 1000,\n\t        animationDurationUpdate: 300,\n\t        animationEasing: 'exponentialOut',\n\t        animationEasingUpdate: 'cubicOut',\n\t        animationThreshold: 2000,\n\t        progressiveThreshold: 3000,\n\t        progressive: 400,\n\t        hoverLayerThreshold: 3000\n\t    };\n\t});\n\tdefine('echarts/model/mixin/colorPalette', [], function () {\n\t    return {\n\t        clearColorPalette: function () {\n\t            this._colorIdx = 0;\n\t            this._colorNameMap = {};\n\t        },\n\t        getColorFromPalette: function (name, scope) {\n\t            scope = scope || this;\n\t            var colorIdx = scope._colorIdx || 0;\n\t            var colorNameMap = scope._colorNameMap || (scope._colorNameMap = {});\n\t            if (colorNameMap[name]) {\n\t                return colorNameMap[name];\n\t            }\n\t            var colorPalette = this.get('color', true) || [];\n\t            if (!colorPalette.length) {\n\t                return;\n\t            }\n\t            var color = colorPalette[colorIdx];\n\t            if (name) {\n\t                colorNameMap[name] = color;\n\t            }\n\t            scope._colorIdx = (colorIdx + 1) % colorPalette.length;\n\t            return color;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/core/PathProxy', ['require', './curve', './vector', './bbox', './BoundingRect', '../config'], function (require) {\n\t    'use strict';\n\t    var curve = require('./curve');\n\t    var vec2 = require('./vector');\n\t    var bbox = require('./bbox');\n\t    var BoundingRect = require('./BoundingRect');\n\t    var dpr = require('../config').devicePixelRatio;\n\t    var CMD = {\n\t            M: 1,\n\t            L: 2,\n\t            C: 3,\n\t            Q: 4,\n\t            A: 5,\n\t            Z: 6,\n\t            R: 7\n\t        };\n\t    var min = [];\n\t    var max = [];\n\t    var min2 = [];\n\t    var max2 = [];\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathCos = Math.cos;\n\t    var mathSin = Math.sin;\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAbs = Math.abs;\n\t    var hasTypedArray = typeof Float32Array != 'undefined';\n\t    /**\n\t     * @alias module:zrender/core/PathProxy\n\t     * @constructor\n\t     */\n\t    var PathProxy = function () {\n\t        /**\n\t         * Path data. Stored as flat array\n\t         * @type {Array.<Object>}\n\t         */\n\t        this.data = [];\n\t        this._len = 0;\n\t        this._ctx = null;\n\t        this._xi = 0;\n\t        this._yi = 0;\n\t        this._x0 = 0;\n\t        this._y0 = 0;\n\t        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n\t        this._ux = 0;\n\t        this._uy = 0;\n\t    };\n\t    /**\n\t     * 快速计算Path包围盒（并不是最小包围盒）\n\t     * @return {Object}\n\t     */\n\t    PathProxy.prototype = {\n\t        constructor: PathProxy,\n\t        _lineDash: null,\n\t        _dashOffset: 0,\n\t        _dashIdx: 0,\n\t        _dashSum: 0,\n\t        setScale: function (sx, sy) {\n\t            this._ux = mathAbs(1 / dpr / sx) || 0;\n\t            this._uy = mathAbs(1 / dpr / sy) || 0;\n\t        },\n\t        getContext: function () {\n\t            return this._ctx;\n\t        },\n\t        beginPath: function (ctx) {\n\t            this._ctx = ctx;\n\t            ctx && ctx.beginPath();\n\t            ctx && (this.dpr = ctx.dpr);\n\t            // Reset\n\t            this._len = 0;\n\t            if (this._lineDash) {\n\t                this._lineDash = null;\n\t                this._dashOffset = 0;\n\t            }\n\t            return this;\n\t        },\n\t        moveTo: function (x, y) {\n\t            this.addData(CMD.M, x, y);\n\t            this._ctx && this._ctx.moveTo(x, y);\n\t            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n\t            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n\t            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n\t            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n\t            this._x0 = x;\n\t            this._y0 = y;\n\t            this._xi = x;\n\t            this._yi = y;\n\t            return this;\n\t        },\n\t        lineTo: function (x, y) {\n\t            var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy || this._len < 5;\n\t            this.addData(CMD.L, x, y);\n\t            if (this._ctx && exceedUnit) {\n\t                this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n\t            }\n\t            if (exceedUnit) {\n\t                this._xi = x;\n\t                this._yi = y;\n\t            }\n\t            return this;\n\t        },\n\t        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n\t            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n\t            }\n\t            this._xi = x3;\n\t            this._yi = y3;\n\t            return this;\n\t        },\n\t        quadraticCurveTo: function (x1, y1, x2, y2) {\n\t            this.addData(CMD.Q, x1, y1, x2, y2);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n\t            }\n\t            this._xi = x2;\n\t            this._yi = y2;\n\t            return this;\n\t        },\n\t        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n\t            this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n\t            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\t            this._xi = mathCos(endAngle) * r + cx;\n\t            this._xi = mathSin(endAngle) * r + cx;\n\t            return this;\n\t        },\n\t        arcTo: function (x1, y1, x2, y2, radius) {\n\t            if (this._ctx) {\n\t                this._ctx.arcTo(x1, y1, x2, y2, radius);\n\t            }\n\t            return this;\n\t        },\n\t        rect: function (x, y, w, h) {\n\t            this._ctx && this._ctx.rect(x, y, w, h);\n\t            this.addData(CMD.R, x, y, w, h);\n\t            return this;\n\t        },\n\t        closePath: function () {\n\t            this.addData(CMD.Z);\n\t            var ctx = this._ctx;\n\t            var x0 = this._x0;\n\t            var y0 = this._y0;\n\t            if (ctx) {\n\t                this._needsDash() && this._dashedLineTo(x0, y0);\n\t                ctx.closePath();\n\t            }\n\t            this._xi = x0;\n\t            this._yi = y0;\n\t            return this;\n\t        },\n\t        fill: function (ctx) {\n\t            ctx && ctx.fill();\n\t            this.toStatic();\n\t        },\n\t        stroke: function (ctx) {\n\t            ctx && ctx.stroke();\n\t            this.toStatic();\n\t        },\n\t        setLineDash: function (lineDash) {\n\t            if (lineDash instanceof Array) {\n\t                this._lineDash = lineDash;\n\t                this._dashIdx = 0;\n\t                var lineDashSum = 0;\n\t                for (var i = 0; i < lineDash.length; i++) {\n\t                    lineDashSum += lineDash[i];\n\t                }\n\t                this._dashSum = lineDashSum;\n\t            }\n\t            return this;\n\t        },\n\t        setLineDashOffset: function (offset) {\n\t            this._dashOffset = offset;\n\t            return this;\n\t        },\n\t        len: function () {\n\t            return this._len;\n\t        },\n\t        setData: function (data) {\n\t            var len = data.length;\n\t            if (!(this.data && this.data.length == len) && hasTypedArray) {\n\t                this.data = new Float32Array(len);\n\t            }\n\t            for (var i = 0; i < len; i++) {\n\t                this.data[i] = data[i];\n\t            }\n\t            this._len = len;\n\t        },\n\t        appendPath: function (path) {\n\t            if (!(path instanceof Array)) {\n\t                path = [path];\n\t            }\n\t            var len = path.length;\n\t            var appendSize = 0;\n\t            var offset = this._len;\n\t            for (var i = 0; i < len; i++) {\n\t                appendSize += path[i].len();\n\t            }\n\t            if (hasTypedArray && this.data instanceof Float32Array) {\n\t                this.data = new Float32Array(offset + appendSize);\n\t            }\n\t            for (var i = 0; i < len; i++) {\n\t                var appendPathData = path[i].data;\n\t                for (var k = 0; k < appendPathData.length; k++) {\n\t                    this.data[offset++] = appendPathData[k];\n\t                }\n\t            }\n\t            this._len = offset;\n\t        },\n\t        addData: function (cmd) {\n\t            var data = this.data;\n\t            if (this._len + arguments.length > data.length) {\n\t                // 因为之前的数组已经转换成静态的 Float32Array\n\t                // 所以不够用时需要扩展一个新的动态数组\n\t                this._expandData();\n\t                data = this.data;\n\t            }\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                data[this._len++] = arguments[i];\n\t            }\n\t            this._prevCmd = cmd;\n\t        },\n\t        _expandData: function () {\n\t            // Only if data is Float32Array\n\t            if (!(this.data instanceof Array)) {\n\t                var newData = [];\n\t                for (var i = 0; i < this._len; i++) {\n\t                    newData[i] = this.data[i];\n\t                }\n\t                this.data = newData;\n\t            }\n\t        },\n\t        _needsDash: function () {\n\t            return this._lineDash;\n\t        },\n\t        _dashedLineTo: function (x1, y1) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var dx = x1 - x0;\n\t            var dy = y1 - y0;\n\t            var dist = mathSqrt(dx * dx + dy * dy);\n\t            var x = x0;\n\t            var y = y0;\n\t            var dash;\n\t            var nDash = lineDash.length;\n\t            var idx;\n\t            dx /= dist;\n\t            dy /= dist;\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            x -= offset * dx;\n\t            y -= offset * dy;\n\t            while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n\t                idx = this._dashIdx;\n\t                dash = lineDash[idx];\n\t                x += dx * dash;\n\t                y += dy * dash;\n\t                this._dashIdx = (idx + 1) % nDash;\n\t                // Skip positive offset\n\t                if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n\t                    continue;\n\t                }\n\t                ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n\t            }\n\t            // Offset for next lineTo\n\t            dx = x - x1;\n\t            dy = y - y1;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var t;\n\t            var dx;\n\t            var dy;\n\t            var cubicAt = curve.cubicAt;\n\t            var bezierLen = 0;\n\t            var idx = this._dashIdx;\n\t            var nDash = lineDash.length;\n\t            var x;\n\t            var y;\n\t            var tmpLen = 0;\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            // Bezier approx length\n\t            for (t = 0; t < 1; t += 0.1) {\n\t                dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n\t                dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n\t                bezierLen += mathSqrt(dx * dx + dy * dy);\n\t            }\n\t            // Find idx after add offset\n\t            for (; idx < nDash; idx++) {\n\t                tmpLen += lineDash[idx];\n\t                if (tmpLen > offset) {\n\t                    break;\n\t                }\n\t            }\n\t            t = (tmpLen - offset) / bezierLen;\n\t            while (t <= 1) {\n\t                x = cubicAt(x0, x1, x2, x3, t);\n\t                y = cubicAt(y0, y1, y2, y3, t);\n\t                // Use line to approximate dashed bezier\n\t                // Bad result if dash is long\n\t                idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n\t                t += lineDash[idx] / bezierLen;\n\t                idx = (idx + 1) % nDash;\n\t            }\n\t            // Finish the last segment and calculate the new offset\n\t            idx % 2 !== 0 && ctx.lineTo(x3, y3);\n\t            dx = x3 - x;\n\t            dy = y3 - y;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n\t            // Convert quadratic to cubic using degree elevation\n\t            var x3 = x2;\n\t            var y3 = y2;\n\t            x2 = (x2 + 2 * x1) / 3;\n\t            y2 = (y2 + 2 * y1) / 3;\n\t            x1 = (this._xi + 2 * x1) / 3;\n\t            y1 = (this._yi + 2 * y1) / 3;\n\t            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n\t        },\n\t        toStatic: function () {\n\t            var data = this.data;\n\t            if (data instanceof Array) {\n\t                data.length = this._len;\n\t                if (hasTypedArray) {\n\t                    this.data = new Float32Array(data);\n\t                }\n\t            }\n\t        },\n\t        getBoundingRect: function () {\n\t            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n\t            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\t            var data = this.data;\n\t            var xi = 0;\n\t            var yi = 0;\n\t            var x0 = 0;\n\t            var y0 = 0;\n\t            for (var i = 0; i < data.length;) {\n\t                var cmd = data[i++];\n\t                if (i == 1) {\n\t                    // 如果第一个命令是 L, C, Q\n\t                    // 则 previous point 同绘制命令的第一个 point\n\t                    //\n\t                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                    xi = data[i];\n\t                    yi = data[i + 1];\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t                switch (cmd) {\n\t                case CMD.M:\n\t                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t                    // 在 closePath 的时候使用\n\t                    x0 = data[i++];\n\t                    y0 = data[i++];\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    min2[0] = x0;\n\t                    min2[1] = y0;\n\t                    max2[0] = x0;\n\t                    max2[1] = y0;\n\t                    break;\n\t                case CMD.L:\n\t                    bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.C:\n\t                    bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.Q:\n\t                    bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.A:\n\t                    // TODO Arc 判断的开销比较大\n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var startAngle = data[i++];\n\t                    var endAngle = data[i++] + startAngle;\n\t                    // TODO Arc 旋转\n\t                    var psi = data[i++];\n\t                    var anticlockwise = 1 - data[i++];\n\t                    if (i == 1) {\n\t                        // 直接使用 arc 命令\n\t                        // 第一个命令起点还未定义\n\t                        x0 = mathCos(startAngle) * rx + cx;\n\t                        y0 = mathSin(startAngle) * ry + cy;\n\t                    }\n\t                    bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n\t                    xi = mathCos(endAngle) * rx + cx;\n\t                    yi = mathSin(endAngle) * ry + cy;\n\t                    break;\n\t                case CMD.R:\n\t                    x0 = xi = data[i++];\n\t                    y0 = yi = data[i++];\n\t                    var width = data[i++];\n\t                    var height = data[i++];\n\t                    // Use fromLine\n\t                    bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n\t                    break;\n\t                case CMD.Z:\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t                }\n\t                // Union\n\t                vec2.min(min, min, min2);\n\t                vec2.max(max, max, max2);\n\t            }\n\t            // No data\n\t            if (i === 0) {\n\t                min[0] = min[1] = max[0] = max[1] = 0;\n\t            }\n\t            return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t        },\n\t        rebuildPath: function (ctx) {\n\t            var d = this.data;\n\t            var x0, y0;\n\t            var xi, yi;\n\t            var x, y;\n\t            var ux = this._ux;\n\t            var uy = this._uy;\n\t            var len = this._len;\n\t            for (var i = 0; i < len;) {\n\t                var cmd = d[i++];\n\t                if (i == 1) {\n\t                    // 如果第一个命令是 L, C, Q\n\t                    // 则 previous point 同绘制命令的第一个 point\n\t                    //\n\t                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                    xi = d[i];\n\t                    yi = d[i + 1];\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t                switch (cmd) {\n\t                case CMD.M:\n\t                    x0 = xi = d[i++];\n\t                    y0 = yi = d[i++];\n\t                    ctx.moveTo(xi, yi);\n\t                    break;\n\t                case CMD.L:\n\t                    x = d[i++];\n\t                    y = d[i++];\n\t                    // Not draw too small seg between\n\t                    if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n\t                        ctx.lineTo(x, y);\n\t                        xi = x;\n\t                        yi = y;\n\t                    }\n\t                    break;\n\t                case CMD.C:\n\t                    ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n\t                    xi = d[i - 2];\n\t                    yi = d[i - 1];\n\t                    break;\n\t                case CMD.Q:\n\t                    ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n\t                    xi = d[i - 2];\n\t                    yi = d[i - 1];\n\t                    break;\n\t                case CMD.A:\n\t                    var cx = d[i++];\n\t                    var cy = d[i++];\n\t                    var rx = d[i++];\n\t                    var ry = d[i++];\n\t                    var theta = d[i++];\n\t                    var dTheta = d[i++];\n\t                    var psi = d[i++];\n\t                    var fs = d[i++];\n\t                    var r = rx > ry ? rx : ry;\n\t                    var scaleX = rx > ry ? 1 : rx / ry;\n\t                    var scaleY = rx > ry ? ry / rx : 1;\n\t                    var isEllipse = Math.abs(rx - ry) > 0.001;\n\t                    var endAngle = theta + dTheta;\n\t                    if (isEllipse) {\n\t                        ctx.translate(cx, cy);\n\t                        ctx.rotate(psi);\n\t                        ctx.scale(scaleX, scaleY);\n\t                        ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n\t                        ctx.scale(1 / scaleX, 1 / scaleY);\n\t                        ctx.rotate(-psi);\n\t                        ctx.translate(-cx, -cy);\n\t                    } else {\n\t                        ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n\t                    }\n\t                    if (i == 1) {\n\t                        // 直接使用 arc 命令\n\t                        // 第一个命令起点还未定义\n\t                        x0 = mathCos(theta) * rx + cx;\n\t                        y0 = mathSin(theta) * ry + cy;\n\t                    }\n\t                    xi = mathCos(endAngle) * rx + cx;\n\t                    yi = mathSin(endAngle) * ry + cy;\n\t                    break;\n\t                case CMD.R:\n\t                    x0 = xi = d[i];\n\t                    y0 = yi = d[i + 1];\n\t                    ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n\t                    break;\n\t                case CMD.Z:\n\t                    ctx.closePath();\n\t                    xi = x0;\n\t                    yi = y0;\n\t                }\n\t            }\n\t        }\n\t    };\n\t    PathProxy.CMD = CMD;\n\t    return PathProxy;\n\t});\n\tdefine('zrender/tool/transformPath', ['require', '../core/PathProxy', '../core/vector'], function (require) {\n\t    var CMD = require('../core/PathProxy').CMD;\n\t    var vec2 = require('../core/vector');\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var points = [\n\t            [],\n\t            [],\n\t            []\n\t        ];\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAtan2 = Math.atan2;\n\t    function transformPath(path, m) {\n\t        var data = path.data;\n\t        var cmd;\n\t        var nPoint;\n\t        var i;\n\t        var j;\n\t        var k;\n\t        var p;\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var R = CMD.R;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t        for (i = 0, j = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            j = i;\n\t            nPoint = 0;\n\t            switch (cmd) {\n\t            case M:\n\t                nPoint = 1;\n\t                break;\n\t            case L:\n\t                nPoint = 1;\n\t                break;\n\t            case C:\n\t                nPoint = 3;\n\t                break;\n\t            case Q:\n\t                nPoint = 2;\n\t                break;\n\t            case A:\n\t                var x = m[4];\n\t                var y = m[5];\n\t                var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n\t                var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n\t                var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n\t                // cx\n\t                data[i++] += x;\n\t                // cy\n\t                data[i++] += y;\n\t                // Scale rx and ry\n\t                // FIXME Assume psi is 0 here\n\t                data[i++] *= sx;\n\t                data[i++] *= sy;\n\t                // Start angle\n\t                data[i++] += angle;\n\t                // end angle\n\t                data[i++] += angle;\n\t                // FIXME psi\n\t                i += 2;\n\t                j = i;\n\t                break;\n\t            case R:\n\t                // x0, y0\n\t                p[0] = data[i++];\n\t                p[1] = data[i++];\n\t                v2ApplyTransform(p, p, m);\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t                // x1, y1\n\t                p[0] += data[i++];\n\t                p[1] += data[i++];\n\t                v2ApplyTransform(p, p, m);\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t            }\n\t            for (k = 0; k < nPoint; k++) {\n\t                var p = points[k];\n\t                p[0] = data[i++];\n\t                p[1] = data[i++];\n\t                v2ApplyTransform(p, p, m);\n\t                // Write back\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t            }\n\t        }\n\t    }\n\t    return transformPath;\n\t});\n\tdefine('echarts/util/clazz', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var clazz = {};\n\t    var TYPE_DELIMITER = '.';\n\t    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n\t    /**\n\t     * @public\n\t     */\n\t    var parseClassType = clazz.parseClassType = function (componentType) {\n\t            var ret = {\n\t                    main: '',\n\t                    sub: ''\n\t                };\n\t            if (componentType) {\n\t                componentType = componentType.split(TYPE_DELIMITER);\n\t                ret.main = componentType[0] || '';\n\t                ret.sub = componentType[1] || '';\n\t            }\n\t            return ret;\n\t        };\n\t    /**\n\t     * @public\n\t     */\n\t    clazz.enableClassExtend = function (RootClass) {\n\t        RootClass.$constructor = RootClass;\n\t        RootClass.extend = function (proto) {\n\t            var superClass = this;\n\t            var ExtendedClass = function () {\n\t                if (!proto.$constructor) {\n\t                    superClass.apply(this, arguments);\n\t                } else {\n\t                    proto.$constructor.apply(this, arguments);\n\t                }\n\t            };\n\t            zrUtil.extend(ExtendedClass.prototype, proto);\n\t            ExtendedClass.extend = this.extend;\n\t            ExtendedClass.superCall = superCall;\n\t            ExtendedClass.superApply = superApply;\n\t            zrUtil.inherits(ExtendedClass, this);\n\t            ExtendedClass.superClass = superClass;\n\t            return ExtendedClass;\n\t        };\n\t    };\n\t    // superCall should have class info, which can not be fetch from 'this'.\n\t    // Consider this case:\n\t    // class A has method f,\n\t    // class B inherits class A, overrides method f, f call superApply('f'),\n\t    // class C inherits class B, do not overrides method f,\n\t    // then when method of class C is called, dead loop occured.\n\t    function superCall(context, methodName) {\n\t        var args = zrUtil.slice(arguments, 2);\n\t        return this.superClass.prototype[methodName].apply(context, args);\n\t    }\n\t    function superApply(context, methodName, args) {\n\t        return this.superClass.prototype[methodName].apply(context, args);\n\t    }\n\t    /**\n\t     * @param {Object} entity\n\t     * @param {Object} options\n\t     * @param {boolean} [options.registerWhenExtend]\n\t     * @public\n\t     */\n\t    clazz.enableClassManagement = function (entity, options) {\n\t        options = options || {};\n\t        /**\n\t         * Component model classes\n\t         * key: componentType,\n\t         * value:\n\t         *     componentClass, when componentType is 'xxx'\n\t         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n\t         * @type {Object}\n\t         */\n\t        var storage = {};\n\t        entity.registerClass = function (Clazz, componentType) {\n\t            if (componentType) {\n\t                componentType = parseClassType(componentType);\n\t                if (!componentType.sub) {\n\t                    if (true) {\n\t                        if (storage[componentType.main]) {\n\t                            console.warn(componentType.main + ' exists.');\n\t                        }\n\t                    }\n\t                    storage[componentType.main] = Clazz;\n\t                } else if (componentType.sub !== IS_CONTAINER) {\n\t                    var container = makeContainer(componentType);\n\t                    container[componentType.sub] = Clazz;\n\t                }\n\t            }\n\t            return Clazz;\n\t        };\n\t        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\n\t            var Clazz = storage[componentTypeMain];\n\t            if (Clazz && Clazz[IS_CONTAINER]) {\n\t                Clazz = subType ? Clazz[subType] : null;\n\t            }\n\t            if (throwWhenNotFound && !Clazz) {\n\t                throw new Error('Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.');\n\t            }\n\t            return Clazz;\n\t        };\n\t        entity.getClassesByMainType = function (componentType) {\n\t            componentType = parseClassType(componentType);\n\t            var result = [];\n\t            var obj = storage[componentType.main];\n\t            if (obj && obj[IS_CONTAINER]) {\n\t                zrUtil.each(obj, function (o, type) {\n\t                    type !== IS_CONTAINER && result.push(o);\n\t                });\n\t            } else {\n\t                result.push(obj);\n\t            }\n\t            return result;\n\t        };\n\t        entity.hasClass = function (componentType) {\n\t            // Just consider componentType.main.\n\t            componentType = parseClassType(componentType);\n\t            return !!storage[componentType.main];\n\t        };\n\t        /**\n\t         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n\t         */\n\t        entity.getAllClassMainTypes = function () {\n\t            var types = [];\n\t            zrUtil.each(storage, function (obj, type) {\n\t                types.push(type);\n\t            });\n\t            return types;\n\t        };\n\t        /**\n\t         * If a main type is container and has sub types\n\t         * @param  {string}  mainType\n\t         * @return {boolean}\n\t         */\n\t        entity.hasSubTypes = function (componentType) {\n\t            componentType = parseClassType(componentType);\n\t            var obj = storage[componentType.main];\n\t            return obj && obj[IS_CONTAINER];\n\t        };\n\t        entity.parseClassType = parseClassType;\n\t        function makeContainer(componentType) {\n\t            var container = storage[componentType.main];\n\t            if (!container || !container[IS_CONTAINER]) {\n\t                container = storage[componentType.main] = {};\n\t                container[IS_CONTAINER] = true;\n\t            }\n\t            return container;\n\t        }\n\t        if (options.registerWhenExtend) {\n\t            var originalExtend = entity.extend;\n\t            if (originalExtend) {\n\t                entity.extend = function (proto) {\n\t                    var ExtendedClass = originalExtend.call(this, proto);\n\t                    return entity.registerClass(ExtendedClass, proto.type);\n\t                };\n\t            }\n\t        }\n\t        return entity;\n\t    };\n\t    /**\n\t     * @param {string|Array.<string>} properties\n\t     */\n\t    clazz.setReadOnly = function (obj, properties) {\n\t    };\n\t    return clazz;\n\t});\n\tdefine('zrender/graphic/Displayable', ['require', '../core/util', './Style', '../Element', './mixin/RectText'], function (require) {\n\t    var zrUtil = require('../core/util');\n\t    var Style = require('./Style');\n\t    var Element = require('../Element');\n\t    var RectText = require('./mixin/RectText');\n\t    // var Stateful = require('./mixin/Stateful');\n\t    /**\n\t     * @alias module:zrender/graphic/Displayable\n\t     * @extends module:zrender/Element\n\t     * @extends module:zrender/graphic/mixin/RectText\n\t     */\n\t    function Displayable(opts) {\n\t        opts = opts || {};\n\t        Element.call(this, opts);\n\t        // Extend properties\n\t        for (var name in opts) {\n\t            if (opts.hasOwnProperty(name) && name !== 'style') {\n\t                this[name] = opts[name];\n\t            }\n\t        }\n\t        /**\n\t         * @type {module:zrender/graphic/Style}\n\t         */\n\t        this.style = new Style(opts.style);\n\t        this._rect = null;\n\t        // Shapes for cascade clipping.\n\t        this.__clipPaths = [];    // FIXME Stateful must be mixined after style is setted\n\t                                  // Stateful.call(this, opts);\n\t    }\n\t    Displayable.prototype = {\n\t        constructor: Displayable,\n\t        type: 'displayable',\n\t        __dirty: true,\n\t        invisible: false,\n\t        z: 0,\n\t        z2: 0,\n\t        zlevel: 0,\n\t        draggable: false,\n\t        dragging: false,\n\t        silent: false,\n\t        culling: false,\n\t        cursor: 'pointer',\n\t        rectHover: false,\n\t        progressive: -1,\n\t        beforeBrush: function (ctx) {\n\t        },\n\t        afterBrush: function (ctx) {\n\t        },\n\t        brush: function (ctx, prevEl) {\n\t        },\n\t        getBoundingRect: function () {\n\t        },\n\t        contain: function (x, y) {\n\t            return this.rectContain(x, y);\n\t        },\n\t        traverse: function (cb, context) {\n\t            cb.call(context, this);\n\t        },\n\t        rectContain: function (x, y) {\n\t            var coord = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            return rect.contain(coord[0], coord[1]);\n\t        },\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t            this._rect = null;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t        animateStyle: function (loop) {\n\t            return this.animate('style', loop);\n\t        },\n\t        attrKV: function (key, value) {\n\t            if (key !== 'style') {\n\t                Element.prototype.attrKV.call(this, key, value);\n\t            } else {\n\t                this.style.set(value);\n\t            }\n\t        },\n\t        setStyle: function (key, value) {\n\t            this.style.set(key, value);\n\t            this.dirty(false);\n\t            return this;\n\t        },\n\t        useStyle: function (obj) {\n\t            this.style = new Style(obj);\n\t            this.dirty(false);\n\t            return this;\n\t        }\n\t    };\n\t    zrUtil.inherits(Displayable, Element);\n\t    zrUtil.mixin(Displayable, RectText);\n\t    // zrUtil.mixin(Displayable, Stateful);\n\t    return Displayable;\n\t});\n\tdefine('zrender/contain/path', ['require', '../core/PathProxy', './line', './cubic', './quadratic', './arc', './util', '../core/curve', './windingLine'], function (require) {\n\t    'use strict';\n\t    var CMD = require('../core/PathProxy').CMD;\n\t    var line = require('./line');\n\t    var cubic = require('./cubic');\n\t    var quadratic = require('./quadratic');\n\t    var arc = require('./arc');\n\t    var normalizeRadian = require('./util').normalizeRadian;\n\t    var curve = require('../core/curve');\n\t    var windingLine = require('./windingLine');\n\t    var containStroke = line.containStroke;\n\t    var PI2 = Math.PI * 2;\n\t    var EPSILON = 0.0001;\n\t    function isAroundEqual(a, b) {\n\t        return Math.abs(a - b) < EPSILON;\n\t    }\n\t    // 临时数组\n\t    var roots = [\n\t            -1,\n\t            -1,\n\t            -1\n\t        ];\n\t    var extrema = [\n\t            -1,\n\t            -1\n\t        ];\n\t    function swapExtrema() {\n\t        var tmp = extrema[0];\n\t        extrema[0] = extrema[1];\n\t        extrema[1] = tmp;\n\t    }\n\t    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n\t        // Quick reject\n\t        if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        } else {\n\t            var w = 0;\n\t            var nExtrema = -1;\n\t            var y0_, y1_;\n\t            for (var i = 0; i < nRoots; i++) {\n\t                var t = roots[i];\n\t                // Avoid winding error when intersection point is the connect point of two line of polygon\n\t                var unit = t === 0 || t === 1 ? 0.5 : 1;\n\t                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\t                if (x_ < x) {\n\t                    // Quick reject\n\t                    continue;\n\t                }\n\t                if (nExtrema < 0) {\n\t                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\t                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n\t                        swapExtrema();\n\t                    }\n\t                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\t                    if (nExtrema > 1) {\n\t                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n\t                    }\n\t                }\n\t                if (nExtrema == 2) {\n\t                    // 分成三段单调函数\n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    } else if (t < extrema[1]) {\n\t                        w += y1_ < y0_ ? unit : -unit;\n\t                    } else {\n\t                        w += y3 < y1_ ? unit : -unit;\n\t                    }\n\t                } else {\n\t                    // 分成两段单调函数\n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    } else {\n\t                        w += y3 < y0_ ? unit : -unit;\n\t                    }\n\t                }\n\t            }\n\t            return w;\n\t        }\n\t    }\n\t    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n\t        // Quick reject\n\t        if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        } else {\n\t            var t = curve.quadraticExtremum(y0, y1, y2);\n\t            if (t >= 0 && t <= 1) {\n\t                var w = 0;\n\t                var y_ = curve.quadraticAt(y0, y1, y2, t);\n\t                for (var i = 0; i < nRoots; i++) {\n\t                    // Remove one endpoint.\n\t                    var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n\t                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\t                    if (x_ < x) {\n\t                        // Quick reject\n\t                        continue;\n\t                    }\n\t                    if (roots[i] < t) {\n\t                        w += y_ < y0 ? unit : -unit;\n\t                    } else {\n\t                        w += y2 < y_ ? unit : -unit;\n\t                    }\n\t                }\n\t                return w;\n\t            } else {\n\t                // Remove one endpoint.\n\t                var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n\t                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\t                if (x_ < x) {\n\t                    // Quick reject\n\t                    return 0;\n\t                }\n\t                return y2 < y0 ? unit : -unit;\n\t            }\n\t        }\n\t    }\n\t    // TODO\n\t    // Arc 旋转\n\t    function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n\t        y -= cy;\n\t        if (y > r || y < -r) {\n\t            return 0;\n\t        }\n\t        var tmp = Math.sqrt(r * r - y * y);\n\t        roots[0] = -tmp;\n\t        roots[1] = tmp;\n\t        var diff = Math.abs(startAngle - endAngle);\n\t        if (diff < 0.0001) {\n\t            return 0;\n\t        }\n\t        if (diff % PI2 < 0.0001) {\n\t            // Is a circle\n\t            startAngle = 0;\n\t            endAngle = PI2;\n\t            var dir = anticlockwise ? 1 : -1;\n\t            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n\t                return dir;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t        if (anticlockwise) {\n\t            var tmp = startAngle;\n\t            startAngle = normalizeRadian(endAngle);\n\t            endAngle = normalizeRadian(tmp);\n\t        } else {\n\t            startAngle = normalizeRadian(startAngle);\n\t            endAngle = normalizeRadian(endAngle);\n\t        }\n\t        if (startAngle > endAngle) {\n\t            endAngle += PI2;\n\t        }\n\t        var w = 0;\n\t        for (var i = 0; i < 2; i++) {\n\t            var x_ = roots[i];\n\t            if (x_ + cx > x) {\n\t                var angle = Math.atan2(y, x_);\n\t                var dir = anticlockwise ? 1 : -1;\n\t                if (angle < 0) {\n\t                    angle = PI2 + angle;\n\t                }\n\t                if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n\t                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n\t                        dir = -dir;\n\t                    }\n\t                    w += dir;\n\t                }\n\t            }\n\t        }\n\t        return w;\n\t    }\n\t    function containPath(data, lineWidth, isStroke, x, y) {\n\t        var w = 0;\n\t        var xi = 0;\n\t        var yi = 0;\n\t        var x0 = 0;\n\t        var y0 = 0;\n\t        for (var i = 0; i < data.length;) {\n\t            var cmd = data[i++];\n\t            // Begin a new subpath\n\t            if (cmd === CMD.M && i > 1) {\n\t                // Close previous subpath\n\t                if (!isStroke) {\n\t                    w += windingLine(xi, yi, x0, y0, x, y);\n\t                }    // 如果被任何一个 subpath 包含\n\t                     // if (w !== 0) {\n\t                     //     return true;\n\t                     // }\n\t            }\n\t            if (i == 1) {\n\t                // 如果第一个命令是 L, C, Q\n\t                // 则 previous point 同绘制命令的第一个 point\n\t                //\n\t                // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                xi = data[i];\n\t                yi = data[i + 1];\n\t                x0 = xi;\n\t                y0 = yi;\n\t            }\n\t            switch (cmd) {\n\t            case CMD.M:\n\t                // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t                // 在 closePath 的时候使用\n\t                x0 = data[i++];\n\t                y0 = data[i++];\n\t                xi = x0;\n\t                yi = y0;\n\t                break;\n\t            case CMD.L:\n\t                if (isStroke) {\n\t                    if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n\t                    w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n\t                }\n\t                xi = data[i++];\n\t                yi = data[i++];\n\t                break;\n\t            case CMD.C:\n\t                if (isStroke) {\n\t                    if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n\t                }\n\t                xi = data[i++];\n\t                yi = data[i++];\n\t                break;\n\t            case CMD.Q:\n\t                if (isStroke) {\n\t                    if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n\t                }\n\t                xi = data[i++];\n\t                yi = data[i++];\n\t                break;\n\t            case CMD.A:\n\t                // TODO Arc 判断的开销比较大\n\t                var cx = data[i++];\n\t                var cy = data[i++];\n\t                var rx = data[i++];\n\t                var ry = data[i++];\n\t                var theta = data[i++];\n\t                var dTheta = data[i++];\n\t                // TODO Arc 旋转\n\t                var psi = data[i++];\n\t                var anticlockwise = 1 - data[i++];\n\t                var x1 = Math.cos(theta) * rx + cx;\n\t                var y1 = Math.sin(theta) * ry + cy;\n\t                // 不是直接使用 arc 命令\n\t                if (i > 1) {\n\t                    w += windingLine(xi, yi, x1, y1, x, y);\n\t                } else {\n\t                    // 第一个命令起点还未定义\n\t                    x0 = x1;\n\t                    y0 = y1;\n\t                }\n\t                // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\t                var _x = (x - cx) * ry / rx + cx;\n\t                if (isStroke) {\n\t                    if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n\t                }\n\t                xi = Math.cos(theta + dTheta) * rx + cx;\n\t                yi = Math.sin(theta + dTheta) * ry + cy;\n\t                break;\n\t            case CMD.R:\n\t                x0 = xi = data[i++];\n\t                y0 = yi = data[i++];\n\t                var width = data[i++];\n\t                var height = data[i++];\n\t                var x1 = x0 + width;\n\t                var y1 = y0 + height;\n\t                if (isStroke) {\n\t                    if (containStroke(x0, y0, x1, y0, lineWidth, x, y) || containStroke(x1, y0, x1, y1, lineWidth, x, y) || containStroke(x1, y1, x0, y1, lineWidth, x, y) || containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    // FIXME Clockwise ?\n\t                    w += windingLine(x1, y0, x1, y1, x, y);\n\t                    w += windingLine(x0, y1, x0, y0, x, y);\n\t                }\n\t                break;\n\t            case CMD.Z:\n\t                if (isStroke) {\n\t                    if (containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    // Close a subpath\n\t                    w += windingLine(xi, yi, x0, y0, x, y);    // 如果被任何一个 subpath 包含\n\t                                                               // FIXME subpaths may overlap\n\t                                                               // if (w !== 0) {\n\t                                                               //     return true;\n\t                                                               // }\n\t                }\n\t                xi = x0;\n\t                yi = y0;\n\t                break;\n\t            }\n\t        }\n\t        if (!isStroke && !isAroundEqual(yi, y0)) {\n\t            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n\t        }\n\t        return w !== 0;\n\t    }\n\t    return {\n\t        contain: function (pathData, x, y) {\n\t            return containPath(pathData, 0, false, x, y);\n\t        },\n\t        containStroke: function (pathData, lineWidth, x, y) {\n\t            return containPath(pathData, lineWidth, true, x, y);\n\t        }\n\t    };\n\t});\n\tdefine('echarts/model/mixin/lineStyle', ['require', './makeStyleMapper'], function (require) {\n\t    var getLineStyle = require('./makeStyleMapper')([\n\t            [\n\t                'lineWidth',\n\t                'width'\n\t            ],\n\t            [\n\t                'stroke',\n\t                'color'\n\t            ],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor']\n\t        ]);\n\t    return {\n\t        getLineStyle: function (excludes) {\n\t            var style = getLineStyle.call(this, excludes);\n\t            var lineDash = this.getLineDash();\n\t            lineDash && (style.lineDash = lineDash);\n\t            return style;\n\t        },\n\t        getLineDash: function () {\n\t            var lineType = this.get('type');\n\t            return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [\n\t                5,\n\t                5\n\t            ] : [\n\t                2,\n\t                2\n\t            ];\n\t        }\n\t    };\n\t});\n\tdefine('echarts/scale/Ordinal', ['require', 'zrender/core/util', './Scale'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var Scale = require('./Scale');\n\t    var scaleProto = Scale.prototype;\n\t    var OrdinalScale = Scale.extend({\n\t            type: 'ordinal',\n\t            init: function (data, extent) {\n\t                this._data = data;\n\t                this._extent = extent || [\n\t                    0,\n\t                    data.length - 1\n\t                ];\n\t            },\n\t            parse: function (val) {\n\t                return typeof val === 'string' ? zrUtil.indexOf(this._data, val) : Math.round(val);\n\t            },\n\t            contain: function (rank) {\n\t                rank = this.parse(rank);\n\t                return scaleProto.contain.call(this, rank) && this._data[rank] != null;\n\t            },\n\t            normalize: function (val) {\n\t                return scaleProto.normalize.call(this, this.parse(val));\n\t            },\n\t            scale: function (val) {\n\t                return Math.round(scaleProto.scale.call(this, val));\n\t            },\n\t            getTicks: function () {\n\t                var ticks = [];\n\t                var extent = this._extent;\n\t                var rank = extent[0];\n\t                while (rank <= extent[1]) {\n\t                    ticks.push(rank);\n\t                    rank++;\n\t                }\n\t                return ticks;\n\t            },\n\t            getLabel: function (n) {\n\t                return this._data[n];\n\t            },\n\t            count: function () {\n\t                return this._extent[1] - this._extent[0] + 1;\n\t            },\n\t            niceTicks: zrUtil.noop,\n\t            niceExtent: zrUtil.noop\n\t        });\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    OrdinalScale.create = function () {\n\t        return new OrdinalScale();\n\t    };\n\t    return OrdinalScale;\n\t});\n\tdefine('zrender/graphic/Pattern', ['require'], function (require) {\n\t    var Pattern = function (image, repeat) {\n\t        this.image = image;\n\t        this.repeat = repeat;\n\t        // Can be cloned\n\t        this.type = 'pattern';\n\t    };\n\t    Pattern.prototype.getCanvasPattern = function (ctx) {\n\t        return this._canvasPattern || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n\t    };\n\t    return Pattern;\n\t});\n\tdefine('echarts/model/mixin/areaStyle', ['require', './makeStyleMapper'], function (require) {\n\t    return {\n\t        getAreaStyle: require('./makeStyleMapper')([\n\t            [\n\t                'fill',\n\t                'color'\n\t            ],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['opacity'],\n\t            ['shadowColor']\n\t        ])\n\t    };\n\t});\n\tdefine('echarts/model/mixin/textStyle', ['require', 'zrender/contain/text'], function (require) {\n\t    var textContain = require('zrender/contain/text');\n\t    function getShallow(model, path) {\n\t        return model && model.getShallow(path);\n\t    }\n\t    return {\n\t        getTextColor: function () {\n\t            var ecModel = this.ecModel;\n\t            return this.getShallow('color') || ecModel && ecModel.get('textStyle.color');\n\t        },\n\t        getFont: function () {\n\t            var ecModel = this.ecModel;\n\t            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n\t            return [\n\t                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n\t                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n\t                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n\t                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n\t            ].join(' ');\n\t        },\n\t        getTextRect: function (text) {\n\t            var textStyle = this.get('textStyle') || {};\n\t            return textContain.getBoundingRect(text, this.getFont(), textStyle.align, textStyle.baseline);\n\t        },\n\t        truncateText: function (text, containerWidth, ellipsis, options) {\n\t            return textContain.truncateText(text, containerWidth, this.getFont(), ellipsis, options);\n\t        }\n\t    };\n\t});\n\tdefine('echarts/model/mixin/itemStyle', ['require', './makeStyleMapper'], function (require) {\n\t    var getItemStyle = require('./makeStyleMapper')([\n\t            [\n\t                'fill',\n\t                'color'\n\t            ],\n\t            [\n\t                'stroke',\n\t                'borderColor'\n\t            ],\n\t            [\n\t                'lineWidth',\n\t                'borderWidth'\n\t            ],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor']\n\t        ]);\n\t    return {\n\t        getItemStyle: function (excludes) {\n\t            var style = getItemStyle.call(this, excludes);\n\t            var lineDash = this.getBorderLineDash();\n\t            lineDash && (style.lineDash = lineDash);\n\t            return style;\n\t        },\n\t        getBorderLineDash: function () {\n\t            var lineType = this.get('borderType');\n\t            return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [\n\t                5,\n\t                5\n\t            ] : [\n\t                1,\n\t                1\n\t            ];\n\t        }\n\t    };\n\t});\n\tdefine('zrender/graphic/Style', ['require'], function (require) {\n\t    var STYLE_COMMON_PROPS = [\n\t            [\n\t                'shadowBlur',\n\t                0\n\t            ],\n\t            [\n\t                'shadowOffsetX',\n\t                0\n\t            ],\n\t            [\n\t                'shadowOffsetY',\n\t                0\n\t            ],\n\t            [\n\t                'shadowColor',\n\t                '#000'\n\t            ],\n\t            [\n\t                'lineCap',\n\t                'butt'\n\t            ],\n\t            [\n\t                'lineJoin',\n\t                'miter'\n\t            ],\n\t            [\n\t                'miterLimit',\n\t                10\n\t            ]\n\t        ];\n\t    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n\t    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\t    var Style = function (opts) {\n\t        this.extendFrom(opts);\n\t    };\n\t    function createLinearGradient(ctx, obj, rect) {\n\t        // var size =\n\t        var x = obj.x;\n\t        var x2 = obj.x2;\n\t        var y = obj.y;\n\t        var y2 = obj.y2;\n\t        if (!obj.global) {\n\t            x = x * rect.width + rect.x;\n\t            x2 = x2 * rect.width + rect.x;\n\t            y = y * rect.height + rect.y;\n\t            y2 = y2 * rect.height + rect.y;\n\t        }\n\t        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\t        return canvasGradient;\n\t    }\n\t    function createRadialGradient(ctx, obj, rect) {\n\t        var width = rect.width;\n\t        var height = rect.height;\n\t        var min = Math.min(width, height);\n\t        var x = obj.x;\n\t        var y = obj.y;\n\t        var r = obj.r;\n\t        if (!obj.global) {\n\t            x = x * width + rect.x;\n\t            y = y * height + rect.y;\n\t            r = r * min;\n\t        }\n\t        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\t        return canvasGradient;\n\t    }\n\t    Style.prototype = {\n\t        constructor: Style,\n\t        fill: '#000000',\n\t        stroke: null,\n\t        opacity: 1,\n\t        lineDash: null,\n\t        lineDashOffset: 0,\n\t        shadowBlur: 0,\n\t        shadowOffsetX: 0,\n\t        shadowOffsetY: 0,\n\t        lineWidth: 1,\n\t        strokeNoScale: false,\n\t        text: null,\n\t        textFill: '#000',\n\t        textStroke: null,\n\t        textPosition: 'inside',\n\t        textBaseline: null,\n\t        textAlign: null,\n\t        textVerticalAlign: null,\n\t        textDistance: 5,\n\t        textShadowBlur: 0,\n\t        textShadowOffsetX: 0,\n\t        textShadowOffsetY: 0,\n\t        textTransform: false,\n\t        textRotation: 0,\n\t        blend: null,\n\t        bind: function (ctx, el, prevEl) {\n\t            var style = this;\n\t            var prevStyle = prevEl && prevEl.style;\n\t            var firstDraw = !prevStyle;\n\t            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t                var prop = STYLE_COMMON_PROPS[i];\n\t                var styleName = prop[0];\n\t                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n\t                    // FIXME Invalid property value will cause style leak from previous element.\n\t                    ctx[styleName] = style[styleName] || prop[1];\n\t                }\n\t            }\n\t            if (firstDraw || style.fill !== prevStyle.fill) {\n\t                ctx.fillStyle = style.fill;\n\t            }\n\t            if (firstDraw || style.stroke !== prevStyle.stroke) {\n\t                ctx.strokeStyle = style.stroke;\n\t            }\n\t            if (firstDraw || style.opacity !== prevStyle.opacity) {\n\t                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n\t            }\n\t            if (firstDraw || style.blend !== prevStyle.blend) {\n\t                ctx.globalCompositeOperation = style.blend || 'source-over';\n\t            }\n\t            if (this.hasStroke()) {\n\t                var lineWidth = style.lineWidth;\n\t                ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n\t            }\n\t        },\n\t        hasFill: function () {\n\t            var fill = this.fill;\n\t            return fill != null && fill !== 'none';\n\t        },\n\t        hasStroke: function () {\n\t            var stroke = this.stroke;\n\t            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n\t        },\n\t        extendFrom: function (otherStyle, overwrite) {\n\t            if (otherStyle) {\n\t                var target = this;\n\t                for (var name in otherStyle) {\n\t                    if (otherStyle.hasOwnProperty(name) && (overwrite || !target.hasOwnProperty(name))) {\n\t                        target[name] = otherStyle[name];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        set: function (obj, value) {\n\t            if (typeof obj === 'string') {\n\t                this[obj] = value;\n\t            } else {\n\t                this.extendFrom(obj, true);\n\t            }\n\t        },\n\t        clone: function () {\n\t            var newStyle = new this.constructor();\n\t            newStyle.extendFrom(this, true);\n\t            return newStyle;\n\t        },\n\t        getGradient: function (ctx, obj, rect) {\n\t            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n\t            var canvasGradient = method(ctx, obj, rect);\n\t            var colorStops = obj.colorStops;\n\t            for (var i = 0; i < colorStops.length; i++) {\n\t                canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n\t            }\n\t            return canvasGradient;\n\t        }\n\t    };\n\t    var styleProto = Style.prototype;\n\t    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t        var prop = STYLE_COMMON_PROPS[i];\n\t        if (!(prop[0] in styleProto)) {\n\t            styleProto[prop[0]] = prop[1];\n\t        }\n\t    }\n\t    // Provide for others\n\t    Style.getGradient = styleProto.getGradient;\n\t    return Style;\n\t});\n\tdefine('zrender/graphic/mixin/RectText', ['require', '../../contain/text', '../../core/BoundingRect'], function (require) {\n\t    var textContain = require('../../contain/text');\n\t    var BoundingRect = require('../../core/BoundingRect');\n\t    var tmpRect = new BoundingRect();\n\t    var RectText = function () {\n\t    };\n\t    function parsePercent(value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    }\n\t    RectText.prototype = {\n\t        constructor: RectText,\n\t        drawRectText: function (ctx, rect, textRect) {\n\t            var style = this.style;\n\t            var text = style.text;\n\t            // Convert to string\n\t            text != null && (text += '');\n\t            if (!text) {\n\t                return;\n\t            }\n\t            // FIXME\n\t            ctx.save();\n\t            var x;\n\t            var y;\n\t            var textPosition = style.textPosition;\n\t            var distance = style.textDistance;\n\t            var align = style.textAlign;\n\t            var font = style.textFont || style.font;\n\t            var baseline = style.textBaseline;\n\t            var verticalAlign = style.textVerticalAlign;\n\t            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\t            // Transform rect to view space\n\t            var transform = this.transform;\n\t            if (!style.textTransform) {\n\t                if (transform) {\n\t                    tmpRect.copy(rect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = tmpRect;\n\t                }\n\t            } else {\n\t                this.setTransform(ctx);\n\t            }\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                // Percent\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t                align = align || 'left';\n\t                baseline = baseline || 'top';\n\t                if (verticalAlign) {\n\t                    switch (verticalAlign) {\n\t                    case 'middle':\n\t                        y -= textRect.height / 2 - textRect.lineHeight / 2;\n\t                        break;\n\t                    case 'bottom':\n\t                        y -= textRect.height - textRect.lineHeight / 2;\n\t                        break;\n\t                    default:\n\t                        y += textRect.lineHeight / 2;\n\t                    }\n\t                    // Force bseline to be middle\n\t                    baseline = 'middle';\n\t                }\n\t            } else {\n\t                var res = textContain.adjustTextPositionOnRect(textPosition, rect, textRect, distance);\n\t                x = res.x;\n\t                y = res.y;\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                baseline = baseline || res.textBaseline;\n\t            }\n\t            // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t            ctx.textAlign = align || 'left';\n\t            // Use canvas default alphabetic baseline\n\t            ctx.textBaseline = baseline || 'alphabetic';\n\t            var textFill = style.textFill;\n\t            var textStroke = style.textStroke;\n\t            textFill && (ctx.fillStyle = textFill);\n\t            textStroke && (ctx.strokeStyle = textStroke);\n\t            // TODO Invalid font\n\t            ctx.font = font || '12px sans-serif';\n\t            // Text shadow\n\t            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n\t            ctx.shadowBlur = style.textShadowBlur;\n\t            ctx.shadowColor = style.textShadowColor || 'transparent';\n\t            ctx.shadowOffsetX = style.textShadowOffsetX;\n\t            ctx.shadowOffsetY = style.textShadowOffsetY;\n\t            var textLines = text.split('\\n');\n\t            if (style.textRotation) {\n\t                transform && ctx.translate(transform[4], transform[5]);\n\t                ctx.rotate(style.textRotation);\n\t                transform && ctx.translate(-transform[4], -transform[5]);\n\t            }\n\t            for (var i = 0; i < textLines.length; i++) {\n\t                textFill && ctx.fillText(textLines[i], x, y);\n\t                textStroke && ctx.strokeText(textLines[i], x, y);\n\t                y += textRect.lineHeight;\n\t            }\n\t            ctx.restore();\n\t        }\n\t    };\n\t    return RectText;\n\t});\n\tdefine('zrender/Element', ['require', './core/guid', './mixin/Eventful', './mixin/Transformable', './mixin/Animatable', './core/util'], function (require) {\n\t    'use strict';\n\t    var guid = require('./core/guid');\n\t    var Eventful = require('./mixin/Eventful');\n\t    var Transformable = require('./mixin/Transformable');\n\t    var Animatable = require('./mixin/Animatable');\n\t    var zrUtil = require('./core/util');\n\t    /**\n\t     * @alias module:zrender/Element\n\t     * @constructor\n\t     * @extends {module:zrender/mixin/Animatable}\n\t     * @extends {module:zrender/mixin/Transformable}\n\t     * @extends {module:zrender/mixin/Eventful}\n\t     */\n\t    var Element = function (opts) {\n\t        Transformable.call(this, opts);\n\t        Eventful.call(this, opts);\n\t        Animatable.call(this, opts);\n\t        /**\n\t         * 画布元素ID\n\t         * @type {string}\n\t         */\n\t        this.id = opts.id || guid();\n\t    };\n\t    Element.prototype = {\n\t        type: 'element',\n\t        name: '',\n\t        __zr: null,\n\t        ignore: false,\n\t        clipPath: null,\n\t        drift: function (dx, dy) {\n\t            switch (this.draggable) {\n\t            case 'horizontal':\n\t                dy = 0;\n\t                break;\n\t            case 'vertical':\n\t                dx = 0;\n\t                break;\n\t            }\n\t            var m = this.transform;\n\t            if (!m) {\n\t                m = this.transform = [\n\t                    1,\n\t                    0,\n\t                    0,\n\t                    1,\n\t                    0,\n\t                    0\n\t                ];\n\t            }\n\t            m[4] += dx;\n\t            m[5] += dy;\n\t            this.decomposeTransform();\n\t            this.dirty(false);\n\t        },\n\t        beforeUpdate: function () {\n\t        },\n\t        afterUpdate: function () {\n\t        },\n\t        update: function () {\n\t            this.updateTransform();\n\t        },\n\t        traverse: function (cb, context) {\n\t        },\n\t        attrKV: function (key, value) {\n\t            if (key === 'position' || key === 'scale' || key === 'origin') {\n\t                // Copy the array\n\t                if (value) {\n\t                    var target = this[key];\n\t                    if (!target) {\n\t                        target = this[key] = [];\n\t                    }\n\t                    target[0] = value[0];\n\t                    target[1] = value[1];\n\t                }\n\t            } else {\n\t                this[key] = value;\n\t            }\n\t        },\n\t        hide: function () {\n\t            this.ignore = true;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t        show: function () {\n\t            this.ignore = false;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t        attr: function (key, value) {\n\t            if (typeof key === 'string') {\n\t                this.attrKV(key, value);\n\t            } else if (zrUtil.isObject(key)) {\n\t                for (var name in key) {\n\t                    if (key.hasOwnProperty(name)) {\n\t                        this.attrKV(name, key[name]);\n\t                    }\n\t                }\n\t            }\n\t            this.dirty(false);\n\t            return this;\n\t        },\n\t        setClipPath: function (clipPath) {\n\t            var zr = this.__zr;\n\t            if (zr) {\n\t                clipPath.addSelfToZr(zr);\n\t            }\n\t            // Remove previous clip path\n\t            if (this.clipPath && this.clipPath !== clipPath) {\n\t                this.removeClipPath();\n\t            }\n\t            this.clipPath = clipPath;\n\t            clipPath.__zr = zr;\n\t            clipPath.__clipTarget = this;\n\t            this.dirty(false);\n\t        },\n\t        removeClipPath: function () {\n\t            var clipPath = this.clipPath;\n\t            if (clipPath) {\n\t                if (clipPath.__zr) {\n\t                    clipPath.removeSelfFromZr(clipPath.__zr);\n\t                }\n\t                clipPath.__zr = null;\n\t                clipPath.__clipTarget = null;\n\t                this.clipPath = null;\n\t                this.dirty(false);\n\t            }\n\t        },\n\t        addSelfToZr: function (zr) {\n\t            this.__zr = zr;\n\t            // 添加动画\n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.addAnimator(animators[i]);\n\t                }\n\t            }\n\t            if (this.clipPath) {\n\t                this.clipPath.addSelfToZr(zr);\n\t            }\n\t        },\n\t        removeSelfFromZr: function (zr) {\n\t            this.__zr = null;\n\t            // 移除动画\n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.removeAnimator(animators[i]);\n\t                }\n\t            }\n\t            if (this.clipPath) {\n\t                this.clipPath.removeSelfFromZr(zr);\n\t            }\n\t        }\n\t    };\n\t    zrUtil.mixin(Element, Animatable);\n\t    zrUtil.mixin(Element, Transformable);\n\t    zrUtil.mixin(Element, Eventful);\n\t    return Element;\n\t});\n\tdefine('echarts/model/mixin/makeStyleMapper', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    return function (properties) {\n\t        // Normalize\n\t        for (var i = 0; i < properties.length; i++) {\n\t            if (!properties[i][1]) {\n\t                properties[i][1] = properties[i][0];\n\t            }\n\t        }\n\t        return function (excludes) {\n\t            var style = {};\n\t            for (var i = 0; i < properties.length; i++) {\n\t                var propName = properties[i][1];\n\t                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {\n\t                    continue;\n\t                }\n\t                var val = this.getShallow(propName);\n\t                if (val != null) {\n\t                    style[properties[i][0]] = val;\n\t                }\n\t            }\n\t            return style;\n\t        };\n\t    };\n\t});\n\tdefine('echarts/coord/cartesian/Cartesian', ['require', 'zrender/core/util'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    function dimAxisMapper(dim) {\n\t        return this._axes[dim];\n\t    }\n\t    /**\n\t     * @alias module:echarts/coord/Cartesian\n\t     * @constructor\n\t     */\n\t    var Cartesian = function (name) {\n\t        this._axes = {};\n\t        this._dimList = [];\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.name = name || '';\n\t    };\n\t    Cartesian.prototype = {\n\t        constructor: Cartesian,\n\t        type: 'cartesian',\n\t        getAxis: function (dim) {\n\t            return this._axes[dim];\n\t        },\n\t        getAxes: function () {\n\t            return zrUtil.map(this._dimList, dimAxisMapper, this);\n\t        },\n\t        getAxesByScale: function (scaleType) {\n\t            scaleType = scaleType.toLowerCase();\n\t            return zrUtil.filter(this.getAxes(), function (axis) {\n\t                return axis.scale.type === scaleType;\n\t            });\n\t        },\n\t        addAxis: function (axis) {\n\t            var dim = axis.dim;\n\t            this._axes[dim] = axis;\n\t            this._dimList.push(dim);\n\t        },\n\t        dataToCoord: function (val) {\n\t            return this._dataCoordConvert(val, 'dataToCoord');\n\t        },\n\t        coordToData: function (val) {\n\t            return this._dataCoordConvert(val, 'coordToData');\n\t        },\n\t        _dataCoordConvert: function (input, method) {\n\t            var dimList = this._dimList;\n\t            var output = input instanceof Array ? [] : {};\n\t            for (var i = 0; i < dimList.length; i++) {\n\t                var dim = dimList[i];\n\t                var axis = this._axes[dim];\n\t                output[dim] = axis[method](input[dim]);\n\t            }\n\t            return output;\n\t        }\n\t    };\n\t    return Cartesian;\n\t});\n\tdefine('zrender/core/guid', [], function () {\n\t    var idStart = 2311;\n\t    return function () {\n\t        return idStart++;\n\t    };\n\t});\n\tdefine('zrender/mixin/Transformable', ['require', '../core/matrix', '../core/vector'], function (require) {\n\t    'use strict';\n\t    var matrix = require('../core/matrix');\n\t    var vector = require('../core/vector');\n\t    var mIdentity = matrix.identity;\n\t    var EPSILON = 0.00005;\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t    /**\n\t     * @alias module:zrender/mixin/Transformable\n\t     * @constructor\n\t     */\n\t    var Transformable = function (opts) {\n\t        opts = opts || {};\n\t        // If there are no given position, rotation, scale\n\t        if (!opts.position) {\n\t            /**\n\t             * 平移\n\t             * @type {Array.<number>}\n\t             * @default [0, 0]\n\t             */\n\t            this.position = [\n\t                0,\n\t                0\n\t            ];\n\t        }\n\t        if (opts.rotation == null) {\n\t            /**\n\t             * 旋转\n\t             * @type {Array.<number>}\n\t             * @default 0\n\t             */\n\t            this.rotation = 0;\n\t        }\n\t        if (!opts.scale) {\n\t            /**\n\t             * 缩放\n\t             * @type {Array.<number>}\n\t             * @default [1, 1]\n\t             */\n\t            this.scale = [\n\t                1,\n\t                1\n\t            ];\n\t        }\n\t        /**\n\t         * 旋转和缩放的原点\n\t         * @type {Array.<number>}\n\t         * @default null\n\t         */\n\t        this.origin = this.origin || null;\n\t    };\n\t    var transformableProto = Transformable.prototype;\n\t    transformableProto.transform = null;\n\t    /**\n\t     * 判断是否需要有坐标变换\n\t     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n\t     */\n\t    transformableProto.needLocalTransform = function () {\n\t        return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n\t    };\n\t    transformableProto.updateTransform = function () {\n\t        var parent = this.parent;\n\t        var parentHasTransform = parent && parent.transform;\n\t        var needLocalTransform = this.needLocalTransform();\n\t        var m = this.transform;\n\t        if (!(needLocalTransform || parentHasTransform)) {\n\t            m && mIdentity(m);\n\t            return;\n\t        }\n\t        m = m || matrix.create();\n\t        if (needLocalTransform) {\n\t            this.getLocalTransform(m);\n\t        } else {\n\t            mIdentity(m);\n\t        }\n\t        // 应用父节点变换\n\t        if (parentHasTransform) {\n\t            if (needLocalTransform) {\n\t                matrix.mul(m, parent.transform, m);\n\t            } else {\n\t                matrix.copy(m, parent.transform);\n\t            }\n\t        }\n\t        // 保存这个变换矩阵\n\t        this.transform = m;\n\t        this.invTransform = this.invTransform || matrix.create();\n\t        matrix.invert(this.invTransform, m);\n\t    };\n\t    transformableProto.getLocalTransform = function (m) {\n\t        m = m || [];\n\t        mIdentity(m);\n\t        var origin = this.origin;\n\t        var scale = this.scale;\n\t        var rotation = this.rotation;\n\t        var position = this.position;\n\t        if (origin) {\n\t            // Translate to origin\n\t            m[4] -= origin[0];\n\t            m[5] -= origin[1];\n\t        }\n\t        matrix.scale(m, m, scale);\n\t        if (rotation) {\n\t            matrix.rotate(m, m, rotation);\n\t        }\n\t        if (origin) {\n\t            // Translate back from origin\n\t            m[4] += origin[0];\n\t            m[5] += origin[1];\n\t        }\n\t        m[4] += position[0];\n\t        m[5] += position[1];\n\t        return m;\n\t    };\n\t    /**\n\t     * 将自己的transform应用到context上\n\t     * @param {Context2D} ctx\n\t     */\n\t    transformableProto.setTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        if (m) {\n\t            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n\t        } else {\n\t            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t        }\n\t    };\n\t    transformableProto.restoreTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t    };\n\t    var tmpTransform = [];\n\t    /**\n\t     * 分解`transform`矩阵到`position`, `rotation`, `scale`\n\t     */\n\t    transformableProto.decomposeTransform = function () {\n\t        if (!this.transform) {\n\t            return;\n\t        }\n\t        var parent = this.parent;\n\t        var m = this.transform;\n\t        if (parent && parent.transform) {\n\t            // Get local transform and decompose them to position, scale, rotation\n\t            matrix.mul(tmpTransform, parent.invTransform, m);\n\t            m = tmpTransform;\n\t        }\n\t        var sx = m[0] * m[0] + m[1] * m[1];\n\t        var sy = m[2] * m[2] + m[3] * m[3];\n\t        var position = this.position;\n\t        var scale = this.scale;\n\t        if (isNotAroundZero(sx - 1)) {\n\t            sx = Math.sqrt(sx);\n\t        }\n\t        if (isNotAroundZero(sy - 1)) {\n\t            sy = Math.sqrt(sy);\n\t        }\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        position[0] = m[4];\n\t        position[1] = m[5];\n\t        scale[0] = sx;\n\t        scale[1] = sy;\n\t        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n\t    };\n\t    /**\n\t     * Get global scale\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.getGlobalScale = function () {\n\t        var m = this.transform;\n\t        if (!m) {\n\t            return [\n\t                1,\n\t                1\n\t            ];\n\t        }\n\t        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n\t        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        return [\n\t            sx,\n\t            sy\n\t        ];\n\t    };\n\t    /**\n\t     * 变换坐标位置到 shape 的局部坐标空间\n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToLocal = function (x, y) {\n\t        var v2 = [\n\t                x,\n\t                y\n\t            ];\n\t        var invTransform = this.invTransform;\n\t        if (invTransform) {\n\t            vector.applyTransform(v2, v2, invTransform);\n\t        }\n\t        return v2;\n\t    };\n\t    /**\n\t     * 变换局部坐标位置到全局坐标空间\n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToGlobal = function (x, y) {\n\t        var v2 = [\n\t                x,\n\t                y\n\t            ];\n\t        var transform = this.transform;\n\t        if (transform) {\n\t            vector.applyTransform(v2, v2, transform);\n\t        }\n\t        return v2;\n\t    };\n\t    return Transformable;\n\t});\n\tdefine('zrender/mixin/Animatable', ['require', '../animation/Animator', '../core/util', '../core/log'], function (require) {\n\t    'use strict';\n\t    var Animator = require('../animation/Animator');\n\t    var util = require('../core/util');\n\t    var isString = util.isString;\n\t    var isFunction = util.isFunction;\n\t    var isObject = util.isObject;\n\t    var log = require('../core/log');\n\t    /**\n\t     * @alias modue:zrender/mixin/Animatable\n\t     * @constructor\n\t     */\n\t    var Animatable = function () {\n\t        /**\n\t         * @type {Array.<module:zrender/animation/Animator>}\n\t         * @readOnly\n\t         */\n\t        this.animators = [];\n\t    };\n\t    Animatable.prototype = {\n\t        constructor: Animatable,\n\t        animate: function (path, loop) {\n\t            var target;\n\t            var animatingShape = false;\n\t            var el = this;\n\t            var zr = this.__zr;\n\t            if (path) {\n\t                var pathSplitted = path.split('.');\n\t                var prop = el;\n\t                // If animating shape\n\t                animatingShape = pathSplitted[0] === 'shape';\n\t                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n\t                    if (!prop) {\n\t                        continue;\n\t                    }\n\t                    prop = prop[pathSplitted[i]];\n\t                }\n\t                if (prop) {\n\t                    target = prop;\n\t                }\n\t            } else {\n\t                target = el;\n\t            }\n\t            if (!target) {\n\t                log('Property \"' + path + '\" is not existed in element ' + el.id);\n\t                return;\n\t            }\n\t            var animators = el.animators;\n\t            var animator = new Animator(target, loop);\n\t            animator.during(function (target) {\n\t                el.dirty(animatingShape);\n\t            }).done(function () {\n\t                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n\t                animators.splice(util.indexOf(animators, animator), 1);\n\t            });\n\t            animators.push(animator);\n\t            // If animate after added to the zrender\n\t            if (zr) {\n\t                zr.animation.addAnimator(animator);\n\t            }\n\t            return animator;\n\t        },\n\t        stopAnimation: function (forwardToLast) {\n\t            var animators = this.animators;\n\t            var len = animators.length;\n\t            for (var i = 0; i < len; i++) {\n\t                animators[i].stop(forwardToLast);\n\t            }\n\t            animators.length = 0;\n\t            return this;\n\t        },\n\t        animateTo: function (target, time, delay, easing, callback) {\n\t            // animateTo(target, time, easing, callback);\n\t            if (isString(delay)) {\n\t                callback = easing;\n\t                easing = delay;\n\t                delay = 0;\n\t            }    // animateTo(target, time, delay, callback);\n\t            else if (isFunction(easing)) {\n\t                callback = easing;\n\t                easing = 'linear';\n\t                delay = 0;\n\t            }    // animateTo(target, time, callback);\n\t            else if (isFunction(delay)) {\n\t                callback = delay;\n\t                delay = 0;\n\t            }    // animateTo(target, callback)\n\t            else if (isFunction(time)) {\n\t                callback = time;\n\t                time = 500;\n\t            }    // animateTo(target)\n\t            else if (!time) {\n\t                time = 500;\n\t            }\n\t            // Stop all previous animations\n\t            this.stopAnimation();\n\t            this._animateToShallow('', this, target, time, delay, easing, callback);\n\t            // Animators may be removed immediately after start\n\t            // if there is nothing to animate\n\t            var animators = this.animators.slice();\n\t            var count = animators.length;\n\t            function done() {\n\t                count--;\n\t                if (!count) {\n\t                    callback && callback();\n\t                }\n\t            }\n\t            // No animators. This should be checked before animators[i].start(),\n\t            // because 'done' may be executed immediately if no need to animate.\n\t            if (!count) {\n\t                callback && callback();\n\t            }\n\t            // Start after all animators created\n\t            // Incase any animator is done immediately when all animation properties are not changed\n\t            for (var i = 0; i < animators.length; i++) {\n\t                animators[i].done(done).start(easing);\n\t            }\n\t        },\n\t        _animateToShallow: function (path, source, target, time, delay) {\n\t            var objShallow = {};\n\t            var propertyCount = 0;\n\t            for (var name in target) {\n\t                if (source[name] != null) {\n\t                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n\t                        this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n\t                    } else {\n\t                        objShallow[name] = target[name];\n\t                        propertyCount++;\n\t                    }\n\t                } else if (target[name] != null) {\n\t                    // Attr directly if not has property\n\t                    // FIXME, if some property not needed for element ?\n\t                    if (!path) {\n\t                        this.attr(name, target[name]);\n\t                    } else {\n\t                        // Shape or style\n\t                        var props = {};\n\t                        props[path] = {};\n\t                        props[path][name] = target[name];\n\t                        this.attr(props);\n\t                    }\n\t                }\n\t            }\n\t            if (propertyCount > 0) {\n\t                this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n\t            }\n\t            return this;\n\t        }\n\t    };\n\t    return Animatable;\n\t});\n\tdefine('echarts/util/component', ['require', 'zrender/core/util', './clazz'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var clazz = require('./clazz');\n\t    var parseClassType = clazz.parseClassType;\n\t    var base = 0;\n\t    var componentUtil = {};\n\t    var DELIMITER = '_';\n\t    /**\n\t     * @public\n\t     * @param {string} type\n\t     * @return {string}\n\t     */\n\t    componentUtil.getUID = function (type) {\n\t        // Considering the case of crossing js context,\n\t        // use Math.random to make id as unique as possible.\n\t        return [\n\t            type || '',\n\t            base++,\n\t            Math.random()\n\t        ].join(DELIMITER);\n\t    };\n\t    /**\n\t     * @inner\n\t     */\n\t    componentUtil.enableSubTypeDefaulter = function (entity) {\n\t        var subTypeDefaulters = {};\n\t        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n\t            componentType = parseClassType(componentType);\n\t            subTypeDefaulters[componentType.main] = defaulter;\n\t        };\n\t        entity.determineSubType = function (componentType, option) {\n\t            var type = option.type;\n\t            if (!type) {\n\t                var componentTypeMain = parseClassType(componentType).main;\n\t                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n\t                    type = subTypeDefaulters[componentTypeMain](option);\n\t                }\n\t            }\n\t            return type;\n\t        };\n\t        return entity;\n\t    };\n\t    /**\n\t     * Topological travel on Activity Network (Activity On Vertices).\n\t     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n\t     *\n\t     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n\t     *\n\t     * If there is circle dependencey, Error will be thrown.\n\t     *\n\t     */\n\t    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\t        /**\n\t         * @public\n\t         * @param {Array.<string>} targetNameList Target Component type list.\n\t         *                                           Can be ['aa', 'bb', 'aa.xx']\n\t         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n\t         * @param {Function} callback Params: componentType, dependencies.\n\t         * @param {Object} context Scope of callback.\n\t         */\n\t        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n\t            if (!targetNameList.length) {\n\t                return;\n\t            }\n\t            var result = makeDepndencyGraph(fullNameList);\n\t            var graph = result.graph;\n\t            var stack = result.noEntryList;\n\t            var targetNameSet = {};\n\t            zrUtil.each(targetNameList, function (name) {\n\t                targetNameSet[name] = true;\n\t            });\n\t            while (stack.length) {\n\t                var currComponentType = stack.pop();\n\t                var currVertex = graph[currComponentType];\n\t                var isInTargetNameSet = !!targetNameSet[currComponentType];\n\t                if (isInTargetNameSet) {\n\t                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n\t                    delete targetNameSet[currComponentType];\n\t                }\n\t                zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);\n\t            }\n\t            zrUtil.each(targetNameSet, function () {\n\t                throw new Error('Circle dependency may exists');\n\t            });\n\t            function removeEdge(succComponentType) {\n\t                graph[succComponentType].entryCount--;\n\t                if (graph[succComponentType].entryCount === 0) {\n\t                    stack.push(succComponentType);\n\t                }\n\t            }\n\t            // Consider this case: legend depends on series, and we call\n\t            // chart.setOption({series: [...]}), where only series is in option.\n\t            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n\t            // not be called, but only sereis.mergeOption is called. Thus legend\n\t            // have no chance to update its local record about series (like which\n\t            // name of series is available in legend).\n\t            function removeEdgeAndAdd(succComponentType) {\n\t                targetNameSet[succComponentType] = true;\n\t                removeEdge(succComponentType);\n\t            }\n\t        };\n\t        /**\n\t         * DepndencyGraph: {Object}\n\t         * key: conponentType,\n\t         * value: {\n\t         *     successor: [conponentTypes...],\n\t         *     originalDeps: [conponentTypes...],\n\t         *     entryCount: {number}\n\t         * }\n\t         */\n\t        function makeDepndencyGraph(fullNameList) {\n\t            var graph = {};\n\t            var noEntryList = [];\n\t            zrUtil.each(fullNameList, function (name) {\n\t                var thisItem = createDependencyGraphItem(graph, name);\n\t                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\t                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n\t                thisItem.entryCount = availableDeps.length;\n\t                if (thisItem.entryCount === 0) {\n\t                    noEntryList.push(name);\n\t                }\n\t                zrUtil.each(availableDeps, function (dependentName) {\n\t                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n\t                        thisItem.predecessor.push(dependentName);\n\t                    }\n\t                    var thatItem = createDependencyGraphItem(graph, dependentName);\n\t                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n\t                        thatItem.successor.push(name);\n\t                    }\n\t                });\n\t            });\n\t            return {\n\t                graph: graph,\n\t                noEntryList: noEntryList\n\t            };\n\t        }\n\t        function createDependencyGraphItem(graph, name) {\n\t            if (!graph[name]) {\n\t                graph[name] = {\n\t                    predecessor: [],\n\t                    successor: []\n\t                };\n\t            }\n\t            return graph[name];\n\t        }\n\t        function getAvailableDependencies(originalDeps, fullNameList) {\n\t            var availableDeps = [];\n\t            zrUtil.each(originalDeps, function (dep) {\n\t                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n\t            });\n\t            return availableDeps;\n\t        }\n\t    };\n\t    return componentUtil;\n\t});\n\tdefine('echarts/model/mixin/boxLayout', ['require'], function (require) {\n\t    return {\n\t        getBoxLayoutParams: function () {\n\t            return {\n\t                left: this.get('left'),\n\t                top: this.get('top'),\n\t                right: this.get('right'),\n\t                bottom: this.get('bottom'),\n\t                width: this.get('width'),\n\t                height: this.get('height')\n\t            };\n\t        }\n\t    };\n\t});\n\tdefine('echarts/coord/Axis', ['require', '../util/number', 'zrender/core/util'], function (require) {\n\t    var numberUtil = require('../util/number');\n\t    var linearMap = numberUtil.linearMap;\n\t    var zrUtil = require('zrender/core/util');\n\t    function fixExtentWithBands(extent, nTick) {\n\t        var size = extent[1] - extent[0];\n\t        var len = nTick;\n\t        var margin = size / len / 2;\n\t        extent[0] += margin;\n\t        extent[1] -= margin;\n\t    }\n\t    var normalizedExtent = [\n\t            0,\n\t            1\n\t        ];\n\t    /**\n\t     * @name module:echarts/coord/CartesianAxis\n\t     * @constructor\n\t     */\n\t    var Axis = function (dim, scale, extent) {\n\t        /**\n\t         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n\t         * @type {string}\n\t         */\n\t        this.dim = dim;\n\t        /**\n\t         * Axis scale\n\t         * @type {module:echarts/coord/scale/*}\n\t         */\n\t        this.scale = scale;\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        this._extent = extent || [\n\t            0,\n\t            0\n\t        ];\n\t        /**\n\t         * @type {boolean}\n\t         */\n\t        this.inverse = false;\n\t        /**\n\t         * Usually true when axis has a ordinal scale\n\t         * @type {boolean}\n\t         */\n\t        this.onBand = false;\n\t    };\n\t    Axis.prototype = {\n\t        constructor: Axis,\n\t        contain: function (coord) {\n\t            var extent = this._extent;\n\t            var min = Math.min(extent[0], extent[1]);\n\t            var max = Math.max(extent[0], extent[1]);\n\t            return coord >= min && coord <= max;\n\t        },\n\t        containData: function (data) {\n\t            return this.contain(this.dataToCoord(data));\n\t        },\n\t        getExtent: function () {\n\t            var ret = this._extent.slice();\n\t            return ret;\n\t        },\n\t        getPixelPrecision: function (dataExtent) {\n\t            return numberUtil.getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);\n\t        },\n\t        setExtent: function (start, end) {\n\t            var extent = this._extent;\n\t            extent[0] = start;\n\t            extent[1] = end;\n\t        },\n\t        dataToCoord: function (data, clamp) {\n\t            var extent = this._extent;\n\t            var scale = this.scale;\n\t            data = scale.normalize(data);\n\t            if (this.onBand && scale.type === 'ordinal') {\n\t                extent = extent.slice();\n\t                fixExtentWithBands(extent, scale.count());\n\t            }\n\t            return linearMap(data, normalizedExtent, extent, clamp);\n\t        },\n\t        coordToData: function (coord, clamp) {\n\t            var extent = this._extent;\n\t            var scale = this.scale;\n\t            if (this.onBand && scale.type === 'ordinal') {\n\t                extent = extent.slice();\n\t                fixExtentWithBands(extent, scale.count());\n\t            }\n\t            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\t            return this.scale.scale(t);\n\t        },\n\t        getTicksCoords: function (alignWithLabel) {\n\t            if (this.onBand && !alignWithLabel) {\n\t                var bands = this.getBands();\n\t                var coords = [];\n\t                for (var i = 0; i < bands.length; i++) {\n\t                    coords.push(bands[i][0]);\n\t                }\n\t                if (bands[i - 1]) {\n\t                    coords.push(bands[i - 1][1]);\n\t                }\n\t                return coords;\n\t            } else {\n\t                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n\t            }\n\t        },\n\t        getLabelsCoords: function () {\n\t            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n\t        },\n\t        getBands: function () {\n\t            var extent = this.getExtent();\n\t            var bands = [];\n\t            var len = this.scale.count();\n\t            var start = extent[0];\n\t            var end = extent[1];\n\t            var span = end - start;\n\t            for (var i = 0; i < len; i++) {\n\t                bands.push([\n\t                    span * i / len + start,\n\t                    span * (i + 1) / len + start\n\t                ]);\n\t            }\n\t            return bands;\n\t        },\n\t        getBandWidth: function () {\n\t            var axisExtent = this._extent;\n\t            var dataExtent = this.scale.getExtent();\n\t            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n\t            // Fix #2728, avoid NaN when only one data.\n\t            len === 0 && (len = 1);\n\t            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\t            return Math.abs(size) / len;\n\t        }\n\t    };\n\t    return Axis;\n\t});\n\tdefine('echarts/coord/cartesian/axisLabelInterval', ['require', 'zrender/core/util', '../axisHelper'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var axisHelper = require('../axisHelper');\n\t    return function (axis) {\n\t        var axisModel = axis.model;\n\t        var labelModel = axisModel.getModel('axisLabel');\n\t        var labelInterval = labelModel.get('interval');\n\t        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n\t            return labelInterval === 'auto' ? 0 : labelInterval;\n\t        }\n\t        return axisHelper.getAxisLabelInterval(zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis), axisModel.getFormattedLabels(), labelModel.getModel('textStyle').getFont(), axis.isHorizontal());\n\t    };\n\t});\n\tdefine('zrender/core/log', ['require', '../config'], function (require) {\n\t    var config = require('../config');\n\t    /**\n\t         * @exports zrender/tool/log\n\t         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t         */\n\t    return function () {\n\t        if (config.debugMode === 0) {\n\t            return;\n\t        } else if (config.debugMode == 1) {\n\t            for (var k in arguments) {\n\t                throw new Error(arguments[k]);\n\t            }\n\t        } else if (config.debugMode > 1) {\n\t            for (var k in arguments) {\n\t                console.log(arguments[k]);\n\t            }\n\t        }\n\t    };    /* for debug\n\t        return function(mes) {\n\t            document.getElementById('wrong-message').innerHTML =\n\t                mes + ' ' + (new Date() - 0)\n\t                + '<br/>' \n\t                + document.getElementById('wrong-message').innerHTML;\n\t        };\n\t        */\n\t});\n\tdefine('zrender/animation/Animator', ['require', './Clip', '../tool/color', '../core/util'], function (require) {\n\t    var Clip = require('./Clip');\n\t    var color = require('../tool/color');\n\t    var util = require('../core/util');\n\t    var isArrayLike = util.isArrayLike;\n\t    var arraySlice = Array.prototype.slice;\n\t    function defaultGetter(target, key) {\n\t        return target[key];\n\t    }\n\t    function defaultSetter(target, key, value) {\n\t        target[key] = value;\n\t    }\n\t    /**\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} percent\n\t     * @return {number}\n\t     */\n\t    function interpolateNumber(p0, p1, percent) {\n\t        return (p1 - p0) * percent + p0;\n\t    }\n\t    /**\n\t     * @param  {string} p0\n\t     * @param  {string} p1\n\t     * @param  {number} percent\n\t     * @return {string}\n\t     */\n\t    function interpolateString(p0, p1, percent) {\n\t        return percent > 0.5 ? p1 : p0;\n\t    }\n\t    /**\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {number} percent\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function interpolateArray(p0, p1, percent, out, arrDim) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = interpolateNumber(p0[i], p1[i], percent);\n\t            }\n\t        } else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    // arr0 is source array, arr1 is target array.\n\t    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\t    function fillArr(arr0, arr1, arrDim) {\n\t        var arr0Len = arr0.length;\n\t        var arr1Len = arr1.length;\n\t        if (arr0Len !== arr1Len) {\n\t            // FIXME Not work for TypedArray\n\t            var isPreviousLarger = arr0Len > arr1Len;\n\t            if (isPreviousLarger) {\n\t                // Cut the previous\n\t                arr0.length = arr1Len;\n\t            } else {\n\t                // Fill the previous\n\t                for (var i = arr0Len; i < arr1Len; i++) {\n\t                    arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n\t                }\n\t            }\n\t        }\n\t        // Handling NaN value\n\t        var len2 = arr0[0] && arr0[0].length;\n\t        for (var i = 0; i < arr0.length; i++) {\n\t            if (arrDim === 1) {\n\t                if (isNaN(arr0[i])) {\n\t                    arr0[i] = arr1[i];\n\t                }\n\t            } else {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (isNaN(arr0[i][j])) {\n\t                        arr0[i][j] = arr1[i][j];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @param  {Array} arr0\n\t     * @param  {Array} arr1\n\t     * @param  {number} arrDim\n\t     * @return {boolean}\n\t     */\n\t    function isArraySame(arr0, arr1, arrDim) {\n\t        if (arr0 === arr1) {\n\t            return true;\n\t        }\n\t        var len = arr0.length;\n\t        if (len !== arr1.length) {\n\t            return false;\n\t        }\n\t        if (arrDim === 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                if (arr0[i] !== arr1[i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        } else {\n\t            var len2 = arr0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (arr0[i][j] !== arr1[i][j]) {\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    /**\n\t     * Catmull Rom interpolate array\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {Array} p2\n\t     * @param  {Array} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n\t            }\n\t        } else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * Catmull Rom interpolate number\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @return {number}\n\t     */\n\t    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t    }\n\t    function cloneValue(value) {\n\t        if (isArrayLike(value)) {\n\t            var len = value.length;\n\t            if (isArrayLike(value[0])) {\n\t                var ret = [];\n\t                for (var i = 0; i < len; i++) {\n\t                    ret.push(arraySlice.call(value[i]));\n\t                }\n\t                return ret;\n\t            }\n\t            return arraySlice.call(value);\n\t        }\n\t        return value;\n\t    }\n\t    function rgba2String(rgba) {\n\t        rgba[0] = Math.floor(rgba[0]);\n\t        rgba[1] = Math.floor(rgba[1]);\n\t        rgba[2] = Math.floor(rgba[2]);\n\t        return 'rgba(' + rgba.join(',') + ')';\n\t    }\n\t    function createTrackClip(animator, easing, oneTrackDone, keyframes, propName) {\n\t        var getter = animator._getter;\n\t        var setter = animator._setter;\n\t        var useSpline = easing === 'spline';\n\t        var trackLen = keyframes.length;\n\t        if (!trackLen) {\n\t            return;\n\t        }\n\t        // Guess data type\n\t        var firstVal = keyframes[0].value;\n\t        var isValueArray = isArrayLike(firstVal);\n\t        var isValueColor = false;\n\t        var isValueString = false;\n\t        // For vertices morphing\n\t        var arrDim = isValueArray && isArrayLike(firstVal[0]) ? 2 : 1;\n\t        var trackMaxTime;\n\t        // Sort keyframe as ascending\n\t        keyframes.sort(function (a, b) {\n\t            return a.time - b.time;\n\t        });\n\t        trackMaxTime = keyframes[trackLen - 1].time;\n\t        // Percents of each keyframe\n\t        var kfPercents = [];\n\t        // Value of each keyframe\n\t        var kfValues = [];\n\t        var prevValue = keyframes[0].value;\n\t        var isAllValueEqual = true;\n\t        for (var i = 0; i < trackLen; i++) {\n\t            kfPercents.push(keyframes[i].time / trackMaxTime);\n\t            // Assume value is a color when it is a string\n\t            var value = keyframes[i].value;\n\t            // Check if value is equal, deep check if value is array\n\t            if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n\t                isAllValueEqual = false;\n\t            }\n\t            prevValue = value;\n\t            // Try converting a string to a color array\n\t            if (typeof value == 'string') {\n\t                var colorArray = color.parse(value);\n\t                if (colorArray) {\n\t                    value = colorArray;\n\t                    isValueColor = true;\n\t                } else {\n\t                    isValueString = true;\n\t                }\n\t            }\n\t            kfValues.push(value);\n\t        }\n\t        if (isAllValueEqual) {\n\t            return;\n\t        }\n\t        var lastValue = kfValues[trackLen - 1];\n\t        // Polyfill array and NaN value\n\t        for (var i = 0; i < trackLen - 1; i++) {\n\t            if (isValueArray) {\n\t                fillArr(kfValues[i], lastValue, arrDim);\n\t            } else {\n\t                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n\t                    kfValues[i] = lastValue;\n\t                }\n\t            }\n\t        }\n\t        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\t        // Cache the key of last frame to speed up when\n\t        // animation playback is sequency\n\t        var lastFrame = 0;\n\t        var lastFramePercent = 0;\n\t        var start;\n\t        var w;\n\t        var p0;\n\t        var p1;\n\t        var p2;\n\t        var p3;\n\t        if (isValueColor) {\n\t            var rgba = [\n\t                    0,\n\t                    0,\n\t                    0,\n\t                    0\n\t                ];\n\t        }\n\t        var onframe = function (target, percent) {\n\t            // Find the range keyframes\n\t            // kf1-----kf2---------current--------kf3\n\t            // find kf2 and kf3 and do interpolation\n\t            var frame;\n\t            // In the easing function like elasticOut, percent may less than 0\n\t            if (percent < 0) {\n\t                frame = 0;\n\t            } else if (percent < lastFramePercent) {\n\t                // Start from next key\n\t                // PENDING start from lastFrame ?\n\t                start = Math.min(lastFrame + 1, trackLen - 1);\n\t                for (frame = start; frame >= 0; frame--) {\n\t                    if (kfPercents[frame] <= percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                // PENDING really need to do this ?\n\t                frame = Math.min(frame, trackLen - 2);\n\t            } else {\n\t                for (frame = lastFrame; frame < trackLen; frame++) {\n\t                    if (kfPercents[frame] > percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                frame = Math.min(frame - 1, trackLen - 2);\n\t            }\n\t            lastFrame = frame;\n\t            lastFramePercent = percent;\n\t            var range = kfPercents[frame + 1] - kfPercents[frame];\n\t            if (range === 0) {\n\t                return;\n\t            } else {\n\t                w = (percent - kfPercents[frame]) / range;\n\t            }\n\t            if (useSpline) {\n\t                p1 = kfValues[frame];\n\t                p0 = kfValues[frame === 0 ? frame : frame - 1];\n\t                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n\t                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\t                if (isValueArray) {\n\t                    catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n\t                } else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n\t                        value = rgba2String(rgba);\n\t                    } else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(p1, p2, w);\n\t                    } else {\n\t                        value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n\t                    }\n\t                    setter(target, propName, value);\n\t                }\n\t            } else {\n\t                if (isValueArray) {\n\t                    interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n\t                } else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n\t                        value = rgba2String(rgba);\n\t                    } else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n\t                    } else {\n\t                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    setter(target, propName, value);\n\t                }\n\t            }\n\t        };\n\t        var clip = new Clip({\n\t                target: animator._target,\n\t                life: trackMaxTime,\n\t                loop: animator._loop,\n\t                delay: animator._delay,\n\t                onframe: onframe,\n\t                ondestroy: oneTrackDone\n\t            });\n\t        if (easing && easing !== 'spline') {\n\t            clip.easing = easing;\n\t        }\n\t        return clip;\n\t    }\n\t    /**\n\t     * @alias module:zrender/animation/Animator\n\t     * @constructor\n\t     * @param {Object} target\n\t     * @param {boolean} loop\n\t     * @param {Function} getter\n\t     * @param {Function} setter\n\t     */\n\t    var Animator = function (target, loop, getter, setter) {\n\t        this._tracks = {};\n\t        this._target = target;\n\t        this._loop = loop || false;\n\t        this._getter = getter || defaultGetter;\n\t        this._setter = setter || defaultSetter;\n\t        this._clipCount = 0;\n\t        this._delay = 0;\n\t        this._doneList = [];\n\t        this._onframeList = [];\n\t        this._clipList = [];\n\t    };\n\t    Animator.prototype = {\n\t        when: function (time, props) {\n\t            var tracks = this._tracks;\n\t            for (var propName in props) {\n\t                if (!tracks[propName]) {\n\t                    tracks[propName] = [];\n\t                    // Invalid value\n\t                    var value = this._getter(this._target, propName);\n\t                    if (value == null) {\n\t                        // zrLog('Invalid property ' + propName);\n\t                        continue;\n\t                    }\n\t                    // If time is 0\n\t                    //  Then props is given initialize value\n\t                    // Else\n\t                    //  Initialize value from current prop value\n\t                    if (time !== 0) {\n\t                        tracks[propName].push({\n\t                            time: 0,\n\t                            value: cloneValue(value)\n\t                        });\n\t                    }\n\t                }\n\t                tracks[propName].push({\n\t                    time: time,\n\t                    value: props[propName]\n\t                });\n\t            }\n\t            return this;\n\t        },\n\t        during: function (callback) {\n\t            this._onframeList.push(callback);\n\t            return this;\n\t        },\n\t        _doneCallback: function () {\n\t            // Clear all tracks\n\t            this._tracks = {};\n\t            // Clear all clips\n\t            this._clipList.length = 0;\n\t            var doneList = this._doneList;\n\t            var len = doneList.length;\n\t            for (var i = 0; i < len; i++) {\n\t                doneList[i].call(this);\n\t            }\n\t        },\n\t        start: function (easing) {\n\t            var self = this;\n\t            var clipCount = 0;\n\t            var oneTrackDone = function () {\n\t                clipCount--;\n\t                if (!clipCount) {\n\t                    self._doneCallback();\n\t                }\n\t            };\n\t            var lastClip;\n\t            for (var propName in this._tracks) {\n\t                var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName);\n\t                if (clip) {\n\t                    this._clipList.push(clip);\n\t                    clipCount++;\n\t                    // If start after added to animation\n\t                    if (this.animation) {\n\t                        this.animation.addClip(clip);\n\t                    }\n\t                    lastClip = clip;\n\t                }\n\t            }\n\t            // Add during callback on the last clip\n\t            if (lastClip) {\n\t                var oldOnFrame = lastClip.onframe;\n\t                lastClip.onframe = function (target, percent) {\n\t                    oldOnFrame(target, percent);\n\t                    for (var i = 0; i < self._onframeList.length; i++) {\n\t                        self._onframeList[i](target, percent);\n\t                    }\n\t                };\n\t            }\n\t            if (!clipCount) {\n\t                this._doneCallback();\n\t            }\n\t            return this;\n\t        },\n\t        stop: function (forwardToLast) {\n\t            var clipList = this._clipList;\n\t            var animation = this.animation;\n\t            for (var i = 0; i < clipList.length; i++) {\n\t                var clip = clipList[i];\n\t                if (forwardToLast) {\n\t                    // Move to last frame before stop\n\t                    clip.onframe(this._target, 1);\n\t                }\n\t                animation && animation.removeClip(clip);\n\t            }\n\t            clipList.length = 0;\n\t        },\n\t        delay: function (time) {\n\t            this._delay = time;\n\t            return this;\n\t        },\n\t        done: function (cb) {\n\t            if (cb) {\n\t                this._doneList.push(cb);\n\t            }\n\t            return this;\n\t        },\n\t        getClips: function () {\n\t            return this._clipList;\n\t        }\n\t    };\n\t    return Animator;\n\t});\n\tdefine('echarts/coord/cartesian/AxisModel', ['require', '../../model/Component', 'zrender/core/util', '../axisModelCreator', '../axisModelCommonMixin'], function (require) {\n\t    'use strict';\n\t    var ComponentModel = require('../../model/Component');\n\t    var zrUtil = require('zrender/core/util');\n\t    var axisModelCreator = require('../axisModelCreator');\n\t    var AxisModel = ComponentModel.extend({\n\t            type: 'cartesian2dAxis',\n\t            axis: null,\n\t            init: function () {\n\t                AxisModel.superApply(this, 'init', arguments);\n\t                this._resetRange();\n\t            },\n\t            mergeOption: function () {\n\t                AxisModel.superApply(this, 'mergeOption', arguments);\n\t                this._resetRange();\n\t            },\n\t            restoreData: function () {\n\t                AxisModel.superApply(this, 'restoreData', arguments);\n\t                this._resetRange();\n\t            },\n\t            setRange: function (rangeStart, rangeEnd) {\n\t                this.option.rangeStart = rangeStart;\n\t                this.option.rangeEnd = rangeEnd;\n\t            },\n\t            getMin: function () {\n\t                var option = this.option;\n\t                return option.rangeStart != null ? option.rangeStart : option.min;\n\t            },\n\t            getMax: function () {\n\t                var option = this.option;\n\t                return option.rangeEnd != null ? option.rangeEnd : option.max;\n\t            },\n\t            getNeedCrossZero: function () {\n\t                var option = this.option;\n\t                return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;\n\t            },\n\t            findGridModel: function () {\n\t                return this.ecModel.queryComponents({\n\t                    mainType: 'grid',\n\t                    index: this.get('gridIndex'),\n\t                    id: this.get('gridId')\n\t                })[0];\n\t            },\n\t            _resetRange: function () {\n\t                // rangeStart and rangeEnd is readonly.\n\t                this.option.rangeStart = this.option.rangeEnd = null;\n\t            }\n\t        });\n\t    function getAxisType(axisDim, option) {\n\t        // Default axis with data is category axis\n\t        return option.type || (option.data ? 'category' : 'value');\n\t    }\n\t    zrUtil.merge(AxisModel.prototype, require('../axisModelCommonMixin'));\n\t    var extraOption = { offset: 0 };\n\t    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n\t    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\t    return AxisModel;\n\t});\n\tdefine('zrender/animation/Clip', ['require', './easing'], function (require) {\n\t    var easingFuncs = require('./easing');\n\t    function Clip(options) {\n\t        this._target = options.target;\n\t        // 生命周期\n\t        this._life = options.life || 1000;\n\t        // 延时\n\t        this._delay = options.delay || 0;\n\t        // 开始时间\n\t        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n\t        this._initialized = false;\n\t        // 是否循环\n\t        this.loop = options.loop == null ? false : options.loop;\n\t        this.gap = options.gap || 0;\n\t        this.easing = options.easing || 'Linear';\n\t        this.onframe = options.onframe;\n\t        this.ondestroy = options.ondestroy;\n\t        this.onrestart = options.onrestart;\n\t    }\n\t    Clip.prototype = {\n\t        constructor: Clip,\n\t        step: function (globalTime) {\n\t            // Set startTime on first step, or _startTime may has milleseconds different between clips\n\t            // PENDING\n\t            if (!this._initialized) {\n\t                this._startTime = globalTime + this._delay;\n\t                this._initialized = true;\n\t            }\n\t            var percent = (globalTime - this._startTime) / this._life;\n\t            // 还没开始\n\t            if (percent < 0) {\n\t                return;\n\t            }\n\t            percent = Math.min(percent, 1);\n\t            var easing = this.easing;\n\t            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t            var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n\t            this.fire('frame', schedule);\n\t            // 结束\n\t            if (percent == 1) {\n\t                if (this.loop) {\n\t                    this.restart(globalTime);\n\t                    // 重新开始周期\n\t                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n\t                    return 'restart';\n\t                }\n\t                // 动画完成将这个控制器标识为待删除\n\t                // 在Animation.update中进行批量删除\n\t                this._needsRemove = true;\n\t                return 'destroy';\n\t            }\n\t            return null;\n\t        },\n\t        restart: function (globalTime) {\n\t            var remainder = (globalTime - this._startTime) % this._life;\n\t            this._startTime = globalTime - remainder + this.gap;\n\t            this._needsRemove = false;\n\t        },\n\t        fire: function (eventType, arg) {\n\t            eventType = 'on' + eventType;\n\t            if (this[eventType]) {\n\t                this[eventType](this._target, arg);\n\t            }\n\t        }\n\t    };\n\t    return Clip;\n\t});\n\tdefine('echarts/coord/axisModelCreator', ['require', './axisDefault', 'zrender/core/util', '../model/Component', '../util/layout'], function (require) {\n\t    var axisDefault = require('./axisDefault');\n\t    var zrUtil = require('zrender/core/util');\n\t    var ComponentModel = require('../model/Component');\n\t    var layout = require('../util/layout');\n\t    // FIXME axisType is fixed ?\n\t    var AXIS_TYPES = [\n\t            'value',\n\t            'category',\n\t            'time',\n\t            'log'\n\t        ];\n\t    /**\n\t     * Generate sub axis model class\n\t     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n\t     * @param {module:echarts/model/Component} BaseAxisModelClass\n\t     * @param {Function} axisTypeDefaulter\n\t     * @param {Object} [extraDefaultOption]\n\t     */\n\t    return function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\t        zrUtil.each(AXIS_TYPES, function (axisType) {\n\t            BaseAxisModelClass.extend({\n\t                type: axisName + 'Axis.' + axisType,\n\t                mergeDefaultAndTheme: function (option, ecModel) {\n\t                    var layoutMode = this.layoutMode;\n\t                    var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};\n\t                    var themeModel = ecModel.getTheme();\n\t                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n\t                    zrUtil.merge(option, this.getDefaultOption());\n\t                    option.type = axisTypeDefaulter(axisName, option);\n\t                    if (layoutMode) {\n\t                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n\t                    }\n\t                },\n\t                defaultOption: zrUtil.mergeAll([\n\t                    {},\n\t                    axisDefault[axisType + 'Axis'],\n\t                    extraDefaultOption\n\t                ], true)\n\t            });\n\t        });\n\t        ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n\t    };\n\t});\n\tdefine('echarts/coord/axisModelCommonMixin', ['require', 'zrender/core/util', './axisHelper'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var axisHelper = require('./axisHelper');\n\t    function getName(obj) {\n\t        if (zrUtil.isObject(obj) && obj.value != null) {\n\t            return obj.value;\n\t        } else {\n\t            return obj;\n\t        }\n\t    }\n\t    /**\n\t     * Get categories\n\t     */\n\t    function getCategories() {\n\t        return this.get('type') === 'category' && zrUtil.map(this.get('data'), getName);\n\t    }\n\t    /**\n\t     * Format labels\n\t     * @return {Array.<string>}\n\t     */\n\t    function getFormattedLabels() {\n\t        return axisHelper.getFormattedLabels(this.axis, this.get('axisLabel.formatter'));\n\t    }\n\t    return {\n\t        getFormattedLabels: getFormattedLabels,\n\t        getCategories: getCategories\n\t    };\n\t});\n\tdefine('zrender/animation/easing', [], function () {\n\t    var easing = {\n\t            linear: function (k) {\n\t                return k;\n\t            },\n\t            quadraticIn: function (k) {\n\t                return k * k;\n\t            },\n\t            quadraticOut: function (k) {\n\t                return k * (2 - k);\n\t            },\n\t            quadraticInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * k * k;\n\t                }\n\t                return -0.5 * (--k * (k - 2) - 1);\n\t            },\n\t            cubicIn: function (k) {\n\t                return k * k * k;\n\t            },\n\t            cubicOut: function (k) {\n\t                return --k * k * k + 1;\n\t            },\n\t            cubicInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * k * k * k;\n\t                }\n\t                return 0.5 * ((k -= 2) * k * k + 2);\n\t            },\n\t            quarticIn: function (k) {\n\t                return k * k * k * k;\n\t            },\n\t            quarticOut: function (k) {\n\t                return 1 - --k * k * k * k;\n\t            },\n\t            quarticInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * k * k * k * k;\n\t                }\n\t                return -0.5 * ((k -= 2) * k * k * k - 2);\n\t            },\n\t            quinticIn: function (k) {\n\t                return k * k * k * k * k;\n\t            },\n\t            quinticOut: function (k) {\n\t                return --k * k * k * k * k + 1;\n\t            },\n\t            quinticInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * k * k * k * k * k;\n\t                }\n\t                return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t            },\n\t            sinusoidalIn: function (k) {\n\t                return 1 - Math.cos(k * Math.PI / 2);\n\t            },\n\t            sinusoidalOut: function (k) {\n\t                return Math.sin(k * Math.PI / 2);\n\t            },\n\t            sinusoidalInOut: function (k) {\n\t                return 0.5 * (1 - Math.cos(Math.PI * k));\n\t            },\n\t            exponentialIn: function (k) {\n\t                return k === 0 ? 0 : Math.pow(1024, k - 1);\n\t            },\n\t            exponentialOut: function (k) {\n\t                return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\t            },\n\t            exponentialInOut: function (k) {\n\t                if (k === 0) {\n\t                    return 0;\n\t                }\n\t                if (k === 1) {\n\t                    return 1;\n\t                }\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * Math.pow(1024, k - 1);\n\t                }\n\t                return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t            },\n\t            circularIn: function (k) {\n\t                return 1 - Math.sqrt(1 - k * k);\n\t            },\n\t            circularOut: function (k) {\n\t                return Math.sqrt(1 - --k * k);\n\t            },\n\t            circularInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t                }\n\t                return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t            },\n\t            elasticIn: function (k) {\n\t                var s;\n\t                var a = 0.1;\n\t                var p = 0.4;\n\t                if (k === 0) {\n\t                    return 0;\n\t                }\n\t                if (k === 1) {\n\t                    return 1;\n\t                }\n\t                if (!a || a < 1) {\n\t                    a = 1;\n\t                    s = p / 4;\n\t                } else {\n\t                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t                }\n\t                return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t            },\n\t            elasticOut: function (k) {\n\t                var s;\n\t                var a = 0.1;\n\t                var p = 0.4;\n\t                if (k === 0) {\n\t                    return 0;\n\t                }\n\t                if (k === 1) {\n\t                    return 1;\n\t                }\n\t                if (!a || a < 1) {\n\t                    a = 1;\n\t                    s = p / 4;\n\t                } else {\n\t                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t                }\n\t                return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n\t            },\n\t            elasticInOut: function (k) {\n\t                var s;\n\t                var a = 0.1;\n\t                var p = 0.4;\n\t                if (k === 0) {\n\t                    return 0;\n\t                }\n\t                if (k === 1) {\n\t                    return 1;\n\t                }\n\t                if (!a || a < 1) {\n\t                    a = 1;\n\t                    s = p / 4;\n\t                } else {\n\t                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t                }\n\t                if ((k *= 2) < 1) {\n\t                    return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t                }\n\t                return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t            },\n\t            backIn: function (k) {\n\t                var s = 1.70158;\n\t                return k * k * ((s + 1) * k - s);\n\t            },\n\t            backOut: function (k) {\n\t                var s = 1.70158;\n\t                return --k * k * ((s + 1) * k + s) + 1;\n\t            },\n\t            backInOut: function (k) {\n\t                var s = 1.70158 * 1.525;\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * (k * k * ((s + 1) * k - s));\n\t                }\n\t                return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t            },\n\t            bounceIn: function (k) {\n\t                return 1 - easing.bounceOut(1 - k);\n\t            },\n\t            bounceOut: function (k) {\n\t                if (k < 1 / 2.75) {\n\t                    return 7.5625 * k * k;\n\t                } else if (k < 2 / 2.75) {\n\t                    return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n\t                } else if (k < 2.5 / 2.75) {\n\t                    return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n\t                } else {\n\t                    return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n\t                }\n\t            },\n\t            bounceInOut: function (k) {\n\t                if (k < 0.5) {\n\t                    return easing.bounceIn(k * 2) * 0.5;\n\t                }\n\t                return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n\t            }\n\t        };\n\t    return easing;\n\t});\n\tdefine('echarts/coord/axisDefault', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var defaultOption = {\n\t            show: true,\n\t            zlevel: 0,\n\t            z: 0,\n\t            inverse: false,\n\t            name: '',\n\t            nameLocation: 'end',\n\t            nameRotate: null,\n\t            nameTruncate: {\n\t                maxWidth: null,\n\t                ellipsis: '...',\n\t                placeholder: '.'\n\t            },\n\t            nameTextStyle: {},\n\t            nameGap: 15,\n\t            silent: false,\n\t            triggerEvent: false,\n\t            tooltip: { show: false },\n\t            axisLine: {\n\t                show: true,\n\t                onZero: true,\n\t                lineStyle: {\n\t                    color: '#333',\n\t                    width: 1,\n\t                    type: 'solid'\n\t                }\n\t            },\n\t            axisTick: {\n\t                show: true,\n\t                inside: false,\n\t                length: 5,\n\t                lineStyle: { width: 1 }\n\t            },\n\t            axisLabel: {\n\t                show: true,\n\t                inside: false,\n\t                rotate: 0,\n\t                margin: 8,\n\t                textStyle: { fontSize: 12 }\n\t            },\n\t            splitLine: {\n\t                show: true,\n\t                lineStyle: {\n\t                    color: ['#ccc'],\n\t                    width: 1,\n\t                    type: 'solid'\n\t                }\n\t            },\n\t            splitArea: {\n\t                show: false,\n\t                areaStyle: {\n\t                    color: [\n\t                        'rgba(250,250,250,0.3)',\n\t                        'rgba(200,200,200,0.3)'\n\t                    ]\n\t                }\n\t            }\n\t        };\n\t    var categoryAxis = zrUtil.merge({\n\t            boundaryGap: true,\n\t            splitLine: { show: false },\n\t            axisTick: {\n\t                alignWithLabel: false,\n\t                interval: 'auto'\n\t            },\n\t            axisLabel: { interval: 'auto' }\n\t        }, defaultOption);\n\t    var valueAxis = zrUtil.merge({\n\t            boundaryGap: [\n\t                0,\n\t                0\n\t            ],\n\t            splitNumber: 5\n\t        }, defaultOption);\n\t    // FIXME\n\t    var timeAxis = zrUtil.defaults({\n\t            scale: true,\n\t            min: 'dataMin',\n\t            max: 'dataMax'\n\t        }, valueAxis);\n\t    var logAxis = zrUtil.defaults({ logBase: 10 }, valueAxis);\n\t    logAxis.scale = true;\n\t    return {\n\t        categoryAxis: categoryAxis,\n\t        valueAxis: valueAxis,\n\t        timeAxis: timeAxis,\n\t        logAxis: logAxis\n\t    };\n\t});\n\tdefine('zrender/config', [], function () {\n\t    var dpr = 1;\n\t    // If in browser environment\n\t    if (typeof window !== 'undefined') {\n\t        dpr = Math.max(window.devicePixelRatio || 1, 1);\n\t    }\n\t    /**\n\t     * config默认配置项\n\t     * @exports zrender/config\n\t     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t     */\n\t    var config = {\n\t            debugMode: 0,\n\t            devicePixelRatio: dpr\n\t        };\n\t    return config;\n\t});\n\tdefine('echarts/chart/helper/createListFromArray', ['require', '../../data/List', '../../data/helper/completeDimensions', 'zrender/core/util', '../../util/model', '../../CoordinateSystem'], function (require) {\n\t    'use strict';\n\t    var List = require('../../data/List');\n\t    var completeDimensions = require('../../data/helper/completeDimensions');\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../../util/model');\n\t    var CoordinateSystem = require('../../CoordinateSystem');\n\t    var getDataItemValue = modelUtil.getDataItemValue;\n\t    var converDataValue = modelUtil.converDataValue;\n\t    function firstDataNotNull(data) {\n\t        var i = 0;\n\t        while (i < data.length && data[i] == null) {\n\t            i++;\n\t        }\n\t        return data[i];\n\t    }\n\t    function ifNeedCompleteOrdinalData(data) {\n\t        var sampleItem = firstDataNotNull(data);\n\t        return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));\n\t    }\n\t    /**\n\t     * Helper function to create a list from option data\n\t     */\n\t    function createListFromArray(data, seriesModel, ecModel) {\n\t        // If data is undefined\n\t        data = data || [];\n\t        if (true) {\n\t            if (!zrUtil.isArray(data)) {\n\t                throw new Error('Invalid data.');\n\t            }\n\t        }\n\t        var coordSysName = seriesModel.get('coordinateSystem');\n\t        var creator = creators[coordSysName];\n\t        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n\t        // FIXME\n\t        var axesInfo = creator && creator(data, seriesModel, ecModel);\n\t        var dimensions = axesInfo && axesInfo.dimensions;\n\t        if (!dimensions) {\n\t            // Get dimensions from registered coordinate system\n\t            dimensions = registeredCoordSys && registeredCoordSys.dimensions || [\n\t                'x',\n\t                'y'\n\t            ];\n\t            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));\n\t        }\n\t        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\t        var list = new List(dimensions, seriesModel);\n\t        var nameList = createNameList(axesInfo, data);\n\t        var categories = {};\n\t        var dimValueGetter = categoryIndex >= 0 && ifNeedCompleteOrdinalData(data) ? function (itemOpt, dimName, dataIndex, dimIndex) {\n\t                // If any dataItem is like { value: 10 }\n\t                if (modelUtil.isDataItemOption(itemOpt)) {\n\t                    list.hasItemOption = true;\n\t                }\n\t                // Use dataIndex as ordinal value in categoryAxis\n\t                return dimIndex === categoryIndex ? dataIndex : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n\t            } : function (itemOpt, dimName, dataIndex, dimIndex) {\n\t                var value = getDataItemValue(itemOpt);\n\t                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n\t                // If any dataItem is like { value: 10 }\n\t                if (modelUtil.isDataItemOption(itemOpt)) {\n\t                    list.hasItemOption = true;\n\t                }\n\t                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n\t                if (categoryAxesModels && categoryAxesModels[dimName]) {\n\t                    // If given value is a category string\n\t                    if (typeof val === 'string') {\n\t                        // Lazy get categories\n\t                        categories[dimName] = categories[dimName] || categoryAxesModels[dimName].getCategories();\n\t                        val = zrUtil.indexOf(categories[dimName], val);\n\t                        if (val < 0 && !isNaN(val)) {\n\t                            // In case some one write '1', '2' istead of 1, 2\n\t                            val = +val;\n\t                        }\n\t                    }\n\t                }\n\t                return val;\n\t            };\n\t        list.hasItemOption = false;\n\t        list.initData(data, nameList, dimValueGetter);\n\t        return list;\n\t    }\n\t    function isStackable(axisType) {\n\t        return axisType !== 'category' && axisType !== 'time';\n\t    }\n\t    function getDimTypeByAxis(axisType) {\n\t        return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';\n\t    }\n\t    /**\n\t     * Creaters for each coord system.\n\t     */\n\t    var creators = {\n\t            cartesian2d: function (data, seriesModel, ecModel) {\n\t                var axesModels = zrUtil.map([\n\t                        'xAxis',\n\t                        'yAxis'\n\t                    ], function (name) {\n\t                        return ecModel.queryComponents({\n\t                            mainType: name,\n\t                            index: seriesModel.get(name + 'Index'),\n\t                            id: seriesModel.get(name + 'Id')\n\t                        })[0];\n\t                    });\n\t                var xAxisModel = axesModels[0];\n\t                var yAxisModel = axesModels[1];\n\t                if (true) {\n\t                    if (!xAxisModel) {\n\t                        throw new Error('xAxis \"' + zrUtil.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('xAxisId'), 0) + '\" not found');\n\t                    }\n\t                    if (!yAxisModel) {\n\t                        throw new Error('yAxis \"' + zrUtil.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('yAxisId'), 0) + '\" not found');\n\t                    }\n\t                }\n\t                var xAxisType = xAxisModel.get('type');\n\t                var yAxisType = yAxisModel.get('type');\n\t                var dimensions = [\n\t                        {\n\t                            name: 'x',\n\t                            type: getDimTypeByAxis(xAxisType),\n\t                            stackable: isStackable(xAxisType)\n\t                        },\n\t                        {\n\t                            name: 'y',\n\t                            type: getDimTypeByAxis(yAxisType),\n\t                            stackable: isStackable(yAxisType)\n\t                        }\n\t                    ];\n\t                var isXAxisCateogry = xAxisType === 'category';\n\t                var isYAxisCategory = yAxisType === 'category';\n\t                completeDimensions(dimensions, data, [\n\t                    'x',\n\t                    'y',\n\t                    'z'\n\t                ]);\n\t                var categoryAxesModels = {};\n\t                if (isXAxisCateogry) {\n\t                    categoryAxesModels.x = xAxisModel;\n\t                }\n\t                if (isYAxisCategory) {\n\t                    categoryAxesModels.y = yAxisModel;\n\t                }\n\t                return {\n\t                    dimensions: dimensions,\n\t                    categoryIndex: isXAxisCateogry ? 0 : isYAxisCategory ? 1 : -1,\n\t                    categoryAxesModels: categoryAxesModels\n\t                };\n\t            },\n\t            polar: function (data, seriesModel, ecModel) {\n\t                var polarModel = ecModel.queryComponents({\n\t                        mainType: 'polar',\n\t                        index: seriesModel.get('polarIndex'),\n\t                        id: seriesModel.get('polarId')\n\t                    })[0];\n\t                var angleAxisModel = polarModel.findAxisModel('angleAxis');\n\t                var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\t                if (true) {\n\t                    if (!angleAxisModel) {\n\t                        throw new Error('angleAxis option not found');\n\t                    }\n\t                    if (!radiusAxisModel) {\n\t                        throw new Error('radiusAxis option not found');\n\t                    }\n\t                }\n\t                var radiusAxisType = radiusAxisModel.get('type');\n\t                var angleAxisType = angleAxisModel.get('type');\n\t                var dimensions = [\n\t                        {\n\t                            name: 'radius',\n\t                            type: getDimTypeByAxis(radiusAxisType),\n\t                            stackable: isStackable(radiusAxisType)\n\t                        },\n\t                        {\n\t                            name: 'angle',\n\t                            type: getDimTypeByAxis(angleAxisType),\n\t                            stackable: isStackable(angleAxisType)\n\t                        }\n\t                    ];\n\t                var isAngleAxisCateogry = angleAxisType === 'category';\n\t                var isRadiusAxisCateogry = radiusAxisType === 'category';\n\t                completeDimensions(dimensions, data, [\n\t                    'radius',\n\t                    'angle',\n\t                    'value'\n\t                ]);\n\t                var categoryAxesModels = {};\n\t                if (isRadiusAxisCateogry) {\n\t                    categoryAxesModels.radius = radiusAxisModel;\n\t                }\n\t                if (isAngleAxisCateogry) {\n\t                    categoryAxesModels.angle = angleAxisModel;\n\t                }\n\t                return {\n\t                    dimensions: dimensions,\n\t                    categoryIndex: isAngleAxisCateogry ? 1 : isRadiusAxisCateogry ? 0 : -1,\n\t                    categoryAxesModels: categoryAxesModels\n\t                };\n\t            },\n\t            geo: function (data, seriesModel, ecModel) {\n\t                // TODO Region\n\t                // 多个散点图系列在同一个地区的时候\n\t                return {\n\t                    dimensions: completeDimensions([\n\t                        { name: 'lng' },\n\t                        { name: 'lat' }\n\t                    ], data, [\n\t                        'lng',\n\t                        'lat',\n\t                        'value'\n\t                    ])\n\t                };\n\t            }\n\t        };\n\t    function createNameList(result, data) {\n\t        var nameList = [];\n\t        var categoryDim = result && result.dimensions[result.categoryIndex];\n\t        var categoryAxisModel;\n\t        if (categoryDim) {\n\t            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n\t        }\n\t        if (categoryAxisModel) {\n\t            // FIXME Two category axis\n\t            var categories = categoryAxisModel.getCategories();\n\t            if (categories) {\n\t                var dataLen = data.length;\n\t                // Ordered data is given explicitly like\n\t                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n\t                // or given scatter data,\n\t                // pick the category\n\t                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n\t                    nameList = [];\n\t                    for (var i = 0; i < dataLen; i++) {\n\t                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n\t                    }\n\t                } else {\n\t                    nameList = categories.slice(0);\n\t                }\n\t            }\n\t        }\n\t        return nameList;\n\t    }\n\t    return createListFromArray;\n\t});\n\tdefine('zrender/core/curve', ['require', './vector'], function (require) {\n\t    'use strict';\n\t    var vec2 = require('./vector');\n\t    var v2Create = vec2.create;\n\t    var v2DistSquare = vec2.distSquare;\n\t    var mathPow = Math.pow;\n\t    var mathSqrt = Math.sqrt;\n\t    var EPSILON = 1e-8;\n\t    var EPSILON_NUMERIC = 0.0001;\n\t    var THREE_SQRT = mathSqrt(3);\n\t    var ONE_THIRD = 1 / 3;\n\t    // 临时变量\n\t    var _v0 = v2Create();\n\t    var _v1 = v2Create();\n\t    var _v2 = v2Create();\n\t    // var _v3 = vec2.create();\n\t    function isAroundZero(val) {\n\t        return val > -EPSILON && val < EPSILON;\n\t    }\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t    /**\n\t     * 计算三次贝塞尔值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n\t    }\n\t    /**\n\t     * 计算三次贝塞尔导数值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n\t    }\n\t    /**\n\t     * 计算三次贝塞尔方程根，使用盛金公式\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} val\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} 有效根数目\n\t     */\n\t    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n\t        // Evaluate roots of cubic functions\n\t        var a = p3 + 3 * (p1 - p2) - p0;\n\t        var b = 3 * (p2 - p1 * 2 + p0);\n\t        var c = 3 * (p1 - p0);\n\t        var d = p0 - val;\n\t        var A = b * b - 3 * a * c;\n\t        var B = b * c - 9 * a * d;\n\t        var C = c * c - 3 * b * d;\n\t        var n = 0;\n\t        if (isAroundZero(A) && isAroundZero(B)) {\n\t            if (isAroundZero(b)) {\n\t                roots[0] = 0;\n\t            } else {\n\t                var t1 = -c / b;\n\t                //t1, t2, t3, b is not zero\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        } else {\n\t            var disc = B * B - 4 * A * C;\n\t            if (isAroundZero(disc)) {\n\t                var K = B / A;\n\t                var t1 = -b / a + K;\n\t                // t1, a is not zero\n\t                var t2 = -K / 2;\n\t                // t2, t3\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            } else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n\t                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\t                if (Y1 < 0) {\n\t                    Y1 = -mathPow(-Y1, ONE_THIRD);\n\t                } else {\n\t                    Y1 = mathPow(Y1, ONE_THIRD);\n\t                }\n\t                if (Y2 < 0) {\n\t                    Y2 = -mathPow(-Y2, ONE_THIRD);\n\t                } else {\n\t                    Y2 = mathPow(Y2, ONE_THIRD);\n\t                }\n\t                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            } else {\n\t                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n\t                var theta = Math.acos(T) / 3;\n\t                var ASqrt = mathSqrt(A);\n\t                var tmp = Math.cos(theta);\n\t                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n\t                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t                if (t3 >= 0 && t3 <= 1) {\n\t                    roots[n++] = t3;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t    /**\n\t     * 计算三次贝塞尔方程极限值的位置\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {Array.<number>} extrema\n\t     * @return {number} 有效数目\n\t     */\n\t    function cubicExtrema(p0, p1, p2, p3, extrema) {\n\t        var b = 6 * p2 - 12 * p1 + 6 * p0;\n\t        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n\t        var c = 3 * p1 - 3 * p0;\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t            }\n\t        } else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                extrema[0] = -b / (2 * a);\n\t            } else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    extrema[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t    /**\n\t     * 细分三次贝塞尔曲线\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p23 = (p3 - p2) * t + p2;\n\t        var p012 = (p12 - p01) * t + p01;\n\t        var p123 = (p23 - p12) * t + p12;\n\t        var p0123 = (p123 - p012) * t + p012;\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t        out[3] = p0123;\n\t        // Seg1\n\t        out[4] = p0123;\n\t        out[5] = p123;\n\t        out[6] = p23;\n\t        out[7] = p3;\n\t    }\n\t    /**\n\t     * 投射点到三次贝塞尔曲线上，返回投射距离。\n\t     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} [out] 投射点\n\t     * @return {number}\n\t     */\n\t    function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t        var prev;\n\t        var next;\n\t        var d1;\n\t        var d2;\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t        // 先粗略估计一下可能的最小距离的 t 值\n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n\t            d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            prev = t - interval;\n\t            next = t + interval;\n\t            // t - interval\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\t            d1 = v2DistSquare(_v1, _v0);\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            } else {\n\t                // t + interval\n\t                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n\t                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n\t                d2 = v2DistSquare(_v2, _v0);\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                } else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = cubicAt(x0, x1, x2, x3, t);\n\t            out[1] = cubicAt(y0, y1, y2, y3, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t    /**\n\t     * 计算二次方贝塞尔值\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticAt(p0, p1, p2, t) {\n\t        var onet = 1 - t;\n\t        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n\t    }\n\t    /**\n\t     * 计算二次方贝塞尔导数值\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticDerivativeAt(p0, p1, p2, t) {\n\t        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n\t    }\n\t    /**\n\t     * 计算二次方贝塞尔方程根\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} 有效根数目\n\t     */\n\t    function quadraticRootAt(p0, p1, p2, val, roots) {\n\t        var a = p0 - 2 * p1 + p2;\n\t        var b = 2 * (p1 - p0);\n\t        var c = p0 - val;\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        } else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                var t1 = -b / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            } else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t    /**\n\t     * 计算二次贝塞尔方程极限值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @return {number}\n\t     */\n\t    function quadraticExtremum(p0, p1, p2) {\n\t        var divider = p0 + p2 - 2 * p1;\n\t        if (divider === 0) {\n\t            // p1 is center of p0 and p2\n\t            return 0.5;\n\t        } else {\n\t            return (p0 - p1) / divider;\n\t        }\n\t    }\n\t    /**\n\t     * 细分二次贝塞尔曲线\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function quadraticSubdivide(p0, p1, p2, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p012 = (p12 - p01) * t + p01;\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t        // Seg1\n\t        out[3] = p012;\n\t        out[4] = p12;\n\t        out[5] = p2;\n\t    }\n\t    /**\n\t     * 投射点到二次贝塞尔曲线上，返回投射距离。\n\t     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} out 投射点\n\t     * @return {number}\n\t     */\n\t    function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t        // 先粗略估计一下可能的最小距离的 t 值\n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = quadraticAt(x0, x1, x2, _t);\n\t            _v1[1] = quadraticAt(y0, y1, y2, _t);\n\t            var d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            var prev = t - interval;\n\t            var next = t + interval;\n\t            // t - interval\n\t            _v1[0] = quadraticAt(x0, x1, x2, prev);\n\t            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\t            var d1 = v2DistSquare(_v1, _v0);\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            } else {\n\t                // t + interval\n\t                _v2[0] = quadraticAt(x0, x1, x2, next);\n\t                _v2[1] = quadraticAt(y0, y1, y2, next);\n\t                var d2 = v2DistSquare(_v2, _v0);\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                } else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = quadraticAt(x0, x1, x2, t);\n\t            out[1] = quadraticAt(y0, y1, y2, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t    return {\n\t        cubicAt: cubicAt,\n\t        cubicDerivativeAt: cubicDerivativeAt,\n\t        cubicRootAt: cubicRootAt,\n\t        cubicExtrema: cubicExtrema,\n\t        cubicSubdivide: cubicSubdivide,\n\t        cubicProjectPoint: cubicProjectPoint,\n\t        quadraticAt: quadraticAt,\n\t        quadraticDerivativeAt: quadraticDerivativeAt,\n\t        quadraticRootAt: quadraticRootAt,\n\t        quadraticExtremum: quadraticExtremum,\n\t        quadraticSubdivide: quadraticSubdivide,\n\t        quadraticProjectPoint: quadraticProjectPoint\n\t    };\n\t});\n\tdefine('zrender/core/bbox', ['require', './vector', './curve'], function (require) {\n\t    var vec2 = require('./vector');\n\t    var curve = require('./curve');\n\t    var bbox = {};\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t    var start = vec2.create();\n\t    var end = vec2.create();\n\t    var extremity = vec2.create();\n\t    var PI2 = Math.PI * 2;\n\t    /**\n\t     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n\t     * @module zrender/core/bbox\n\t     * @param {Array<Object>} points 顶点数组\n\t     * @param {number} min\n\t     * @param {number} max\n\t     */\n\t    bbox.fromPoints = function (points, min, max) {\n\t        if (points.length === 0) {\n\t            return;\n\t        }\n\t        var p = points[0];\n\t        var left = p[0];\n\t        var right = p[0];\n\t        var top = p[1];\n\t        var bottom = p[1];\n\t        var i;\n\t        for (i = 1; i < points.length; i++) {\n\t            p = points[i];\n\t            left = mathMin(left, p[0]);\n\t            right = mathMax(right, p[0]);\n\t            top = mathMin(top, p[1]);\n\t            bottom = mathMax(bottom, p[1]);\n\t        }\n\t        min[0] = left;\n\t        min[1] = top;\n\t        max[0] = right;\n\t        max[1] = bottom;\n\t    };\n\t    /**\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n\t        min[0] = mathMin(x0, x1);\n\t        min[1] = mathMin(y0, y1);\n\t        max[0] = mathMax(x0, x1);\n\t        max[1] = mathMax(y0, y1);\n\t    };\n\t    var xDim = [];\n\t    var yDim = [];\n\t    /**\n\t     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromCubic = function (x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n\t        var cubicExtrema = curve.cubicExtrema;\n\t        var cubicAt = curve.cubicAt;\n\t        var i;\n\t        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\t        min[0] = Infinity;\n\t        min[1] = Infinity;\n\t        max[0] = -Infinity;\n\t        max[1] = -Infinity;\n\t        for (i = 0; i < n; i++) {\n\t            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n\t            min[0] = mathMin(x, min[0]);\n\t            max[0] = mathMax(x, max[0]);\n\t        }\n\t        n = cubicExtrema(y0, y1, y2, y3, yDim);\n\t        for (i = 0; i < n; i++) {\n\t            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n\t            min[1] = mathMin(y, min[1]);\n\t            max[1] = mathMax(y, max[1]);\n\t        }\n\t        min[0] = mathMin(x0, min[0]);\n\t        max[0] = mathMax(x0, max[0]);\n\t        min[0] = mathMin(x3, min[0]);\n\t        max[0] = mathMax(x3, max[0]);\n\t        min[1] = mathMin(y0, min[1]);\n\t        max[1] = mathMax(y0, max[1]);\n\t        min[1] = mathMin(y3, min[1]);\n\t        max[1] = mathMax(y3, max[1]);\n\t    };\n\t    /**\n\t     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromQuadratic = function (x0, y0, x1, y1, x2, y2, min, max) {\n\t        var quadraticExtremum = curve.quadraticExtremum;\n\t        var quadraticAt = curve.quadraticAt;\n\t        // Find extremities, where derivative in x dim or y dim is zero\n\t        var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n\t        var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n\t        var x = quadraticAt(x0, x1, x2, tx);\n\t        var y = quadraticAt(y0, y1, y2, ty);\n\t        min[0] = mathMin(x0, x2, x);\n\t        min[1] = mathMin(y0, y2, y);\n\t        max[0] = mathMax(x0, x2, x);\n\t        max[1] = mathMax(y0, y2, y);\n\t    };\n\t    /**\n\t     * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n\t     * @method\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {number} rx\n\t     * @param {number} ry\n\t     * @param {number} startAngle\n\t     * @param {number} endAngle\n\t     * @param {number} anticlockwise\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromArc = function (x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n\t        var vec2Min = vec2.min;\n\t        var vec2Max = vec2.max;\n\t        var diff = Math.abs(startAngle - endAngle);\n\t        if (diff % PI2 < 0.0001 && diff > 0.0001) {\n\t            // Is a circle\n\t            min[0] = x - rx;\n\t            min[1] = y - ry;\n\t            max[0] = x + rx;\n\t            max[1] = y + ry;\n\t            return;\n\t        }\n\t        start[0] = mathCos(startAngle) * rx + x;\n\t        start[1] = mathSin(startAngle) * ry + y;\n\t        end[0] = mathCos(endAngle) * rx + x;\n\t        end[1] = mathSin(endAngle) * ry + y;\n\t        vec2Min(min, start, end);\n\t        vec2Max(max, start, end);\n\t        // Thresh to [0, Math.PI * 2]\n\t        startAngle = startAngle % PI2;\n\t        if (startAngle < 0) {\n\t            startAngle = startAngle + PI2;\n\t        }\n\t        endAngle = endAngle % PI2;\n\t        if (endAngle < 0) {\n\t            endAngle = endAngle + PI2;\n\t        }\n\t        if (startAngle > endAngle && !anticlockwise) {\n\t            endAngle += PI2;\n\t        } else if (startAngle < endAngle && anticlockwise) {\n\t            startAngle += PI2;\n\t        }\n\t        if (anticlockwise) {\n\t            var tmp = endAngle;\n\t            endAngle = startAngle;\n\t            startAngle = tmp;\n\t        }\n\t        // var number = 0;\n\t        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\t        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n\t            if (angle > startAngle) {\n\t                extremity[0] = mathCos(angle) * rx + x;\n\t                extremity[1] = mathSin(angle) * ry + y;\n\t                vec2Min(min, extremity, min);\n\t                vec2Max(max, extremity, max);\n\t            }\n\t        }\n\t    };\n\t    return bbox;\n\t});\n\tdefine('echarts/data/DataDiffer', ['require'], function (require) {\n\t    'use strict';\n\t    function defaultKeyGetter(item) {\n\t        return item;\n\t    }\n\t    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n\t        this._old = oldArr;\n\t        this._new = newArr;\n\t        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n\t        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n\t    }\n\t    DataDiffer.prototype = {\n\t        constructor: DataDiffer,\n\t        add: function (func) {\n\t            this._add = func;\n\t            return this;\n\t        },\n\t        update: function (func) {\n\t            this._update = func;\n\t            return this;\n\t        },\n\t        remove: function (func) {\n\t            this._remove = func;\n\t            return this;\n\t        },\n\t        execute: function () {\n\t            var oldArr = this._old;\n\t            var newArr = this._new;\n\t            var oldKeyGetter = this._oldKeyGetter;\n\t            var newKeyGetter = this._newKeyGetter;\n\t            var oldDataIndexMap = {};\n\t            var newDataIndexMap = {};\n\t            var oldDataKeyArr = [];\n\t            var newDataKeyArr = [];\n\t            var i;\n\t            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n\t            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\t            // Travel by inverted order to make sure order consistency\n\t            // when duplicate keys exists (consider newDataIndex.pop() below).\n\t            // For performance consideration, these code below do not look neat.\n\t            for (i = 0; i < oldArr.length; i++) {\n\t                var key = oldDataKeyArr[i];\n\t                var idx = newDataIndexMap[key];\n\t                // idx can never be empty array here. see 'set null' logic below.\n\t                if (idx != null) {\n\t                    // Consider there is duplicate key (for example, use dataItem.name as key).\n\t                    // We should make sure every item in newArr and oldArr can be visited.\n\t                    var len = idx.length;\n\t                    if (len) {\n\t                        len === 1 && (newDataIndexMap[key] = null);\n\t                        idx = idx.unshift();\n\t                    } else {\n\t                        newDataIndexMap[key] = null;\n\t                    }\n\t                    this._update && this._update(idx, i);\n\t                } else {\n\t                    this._remove && this._remove(i);\n\t                }\n\t            }\n\t            for (var i = 0; i < newDataKeyArr.length; i++) {\n\t                var key = newDataKeyArr[i];\n\t                if (newDataIndexMap.hasOwnProperty(key)) {\n\t                    var idx = newDataIndexMap[key];\n\t                    if (idx == null) {\n\t                        continue;\n\t                    }\n\t                    // idx can never be empty array here. see 'set null' logic above.\n\t                    if (!idx.length) {\n\t                        this._add && this._add(idx);\n\t                    } else {\n\t                        for (var j = 0, len = idx.length; j < len; j++) {\n\t                            this._add && this._add(idx[j]);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t    function initIndexMap(arr, map, keyArr, keyGetter) {\n\t        for (var i = 0; i < arr.length; i++) {\n\t            var key = keyGetter(arr[i], i);\n\t            var existence = map[key];\n\t            if (existence == null) {\n\t                keyArr.push(key);\n\t                map[key] = i;\n\t            } else {\n\t                if (!existence.length) {\n\t                    map[key] = existence = [existence];\n\t                }\n\t                existence.push(i);\n\t            }\n\t        }\n\t    }\n\t    return DataDiffer;\n\t});\n\tdefine('echarts/data/helper/completeDimensions', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    /**\n\t     * Complete the dimensions array guessed from the data structure.\n\t     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n\t     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n\t     * @param  {Array.<string>} defaultNames    Default names to fill not necessary dimensions, like ['value']\n\t     * @param  {string} extraPrefix             Prefix of name when filling the left dimensions.\n\t     * @return {Array.<string>}\n\t     */\n\t    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n\t        if (!data) {\n\t            return dimensions;\n\t        }\n\t        var value0 = retrieveValue(data[0]);\n\t        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n\t        defaultNames = defaultNames || [];\n\t        extraPrefix = extraPrefix || 'extra';\n\t        for (var i = 0; i < dimSize; i++) {\n\t            if (!dimensions[i]) {\n\t                var name = defaultNames[i] || extraPrefix + (i - defaultNames.length);\n\t                dimensions[i] = guessOrdinal(data, i) ? {\n\t                    type: 'ordinal',\n\t                    name: name\n\t                } : name;\n\t            }\n\t        }\n\t        return dimensions;\n\t    }\n\t    // The rule should not be complex, otherwise user might not\n\t    // be able to known where the data is wrong.\n\t    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n\t            for (var i = 0, len = data.length; i < len; i++) {\n\t                var value = retrieveValue(data[i]);\n\t                if (!zrUtil.isArray(value)) {\n\t                    return false;\n\t                }\n\t                var value = value[dimIndex];\n\t                if (value != null && isFinite(value)) {\n\t                    return false;\n\t                } else if (zrUtil.isString(value) && value !== '-') {\n\t                    return true;\n\t                }\n\t            }\n\t            return false;\n\t        };\n\t    function retrieveValue(o) {\n\t        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value : o;\n\t    }\n\t    return completeDimensions;\n\t});\n\tdefine('zrender/contain/cubic', ['require', '../core/curve'], function (require) {\n\t    var curve = require('../core/curve');\n\t    return {\n\t        containStroke: function (x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n\t                return false;\n\t            }\n\t            var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/line', [], function () {\n\t    return {\n\t        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            var _a = 0;\n\t            var _b = x0;\n\t            // Quick reject\n\t            if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n\t                return false;\n\t            }\n\t            if (x0 !== x1) {\n\t                _a = (y0 - y1) / (x0 - x1);\n\t                _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n\t            } else {\n\t                return Math.abs(x - x0) <= _l / 2;\n\t            }\n\t            var tmp = _a * x - y + _b;\n\t            var _s = tmp * tmp / (_a * _a + 1);\n\t            return _s <= _l / 2 * _l / 2;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/quadratic', ['require', '../core/curve'], function (require) {\n\t    var curve = require('../core/curve');\n\t    return {\n\t        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n\t                return false;\n\t            }\n\t            var d = curve.quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/arc', ['require', './util'], function (require) {\n\t    var normalizeRadian = require('./util').normalizeRadian;\n\t    var PI2 = Math.PI * 2;\n\t    return {\n\t        containStroke: function (cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            x -= cx;\n\t            y -= cy;\n\t            var d = Math.sqrt(x * x + y * y);\n\t            if (d - _l > r || d + _l < r) {\n\t                return false;\n\t            }\n\t            if (Math.abs(startAngle - endAngle) % PI2 < 0.0001) {\n\t                // Is a circle\n\t                return true;\n\t            }\n\t            if (anticlockwise) {\n\t                var tmp = startAngle;\n\t                startAngle = normalizeRadian(endAngle);\n\t                endAngle = normalizeRadian(tmp);\n\t            } else {\n\t                startAngle = normalizeRadian(startAngle);\n\t                endAngle = normalizeRadian(endAngle);\n\t            }\n\t            if (startAngle > endAngle) {\n\t                endAngle += PI2;\n\t            }\n\t            var angle = Math.atan2(y, x);\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/util', ['require'], function (require) {\n\t    var PI2 = Math.PI * 2;\n\t    return {\n\t        normalizeRadian: function (angle) {\n\t            angle %= PI2;\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return angle;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/windingLine', [], function () {\n\t    return function windingLine(x0, y0, x1, y1, x, y) {\n\t        if (y > y0 && y > y1 || y < y0 && y < y1) {\n\t            return 0;\n\t        }\n\t        // Ignore horizontal line\n\t        if (y1 === y0) {\n\t            return 0;\n\t        }\n\t        var dir = y1 < y0 ? 1 : -1;\n\t        var t = (y - y0) / (y1 - y0);\n\t        // Avoid winding error when intersection point is the connect point of two line of polygon\n\t        if (t === 1 || t === 0) {\n\t            dir = y1 < y0 ? 0.5 : -0.5;\n\t        }\n\t        var x_ = t * (x1 - x0) + x0;\n\t        return x_ > x ? dir : 0;\n\t    };\n\t});\n\tdefine('echarts/chart/bar/barItemStyle', ['require', '../../model/mixin/makeStyleMapper'], function (require) {\n\t    var getBarItemStyle = require('../../model/mixin/makeStyleMapper')([\n\t            [\n\t                'fill',\n\t                'color'\n\t            ],\n\t            [\n\t                'stroke',\n\t                'borderColor'\n\t            ],\n\t            [\n\t                'lineWidth',\n\t                'borderWidth'\n\t            ],\n\t            [\n\t                'stroke',\n\t                'barBorderColor'\n\t            ],\n\t            [\n\t                'lineWidth',\n\t                'barBorderWidth'\n\t            ],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor']\n\t        ]);\n\t    return {\n\t        getBarItemStyle: function (excludes) {\n\t            var style = getBarItemStyle.call(this, excludes);\n\t            if (this.getBorderLineDash) {\n\t                var lineDash = this.getBorderLineDash();\n\t                lineDash && (style.lineDash = lineDash);\n\t            }\n\t            return style;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/core/LRU', ['require'], function (require) {\n\t    /**\n\t     * Simple double linked list. Compared with array, it has O(1) remove operation.\n\t     * @constructor\n\t     */\n\t    var LinkedList = function () {\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.head = null;\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.tail = null;\n\t        this._len = 0;\n\t    };\n\t    var linkedListProto = LinkedList.prototype;\n\t    /**\n\t     * Insert a new value at the tail\n\t     * @param  {} val\n\t     * @return {module:zrender/core/LRU~Entry}\n\t     */\n\t    linkedListProto.insert = function (val) {\n\t        var entry = new Entry(val);\n\t        this.insertEntry(entry);\n\t        return entry;\n\t    };\n\t    /**\n\t     * Insert an entry at the tail\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.insertEntry = function (entry) {\n\t        if (!this.head) {\n\t            this.head = this.tail = entry;\n\t        } else {\n\t            this.tail.next = entry;\n\t            entry.prev = this.tail;\n\t            this.tail = entry;\n\t        }\n\t        this._len++;\n\t    };\n\t    /**\n\t     * Remove entry.\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.remove = function (entry) {\n\t        var prev = entry.prev;\n\t        var next = entry.next;\n\t        if (prev) {\n\t            prev.next = next;\n\t        } else {\n\t            // Is head\n\t            this.head = next;\n\t        }\n\t        if (next) {\n\t            next.prev = prev;\n\t        } else {\n\t            // Is tail\n\t            this.tail = prev;\n\t        }\n\t        entry.next = entry.prev = null;\n\t        this._len--;\n\t    };\n\t    /**\n\t     * @return {number}\n\t     */\n\t    linkedListProto.len = function () {\n\t        return this._len;\n\t    };\n\t    /**\n\t     * @constructor\n\t     * @param {} val\n\t     */\n\t    var Entry = function (val) {\n\t        /**\n\t         * @type {}\n\t         */\n\t        this.value = val;\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.next;\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.prev;\n\t    };\n\t    /**\n\t     * LRU Cache\n\t     * @constructor\n\t     * @alias module:zrender/core/LRU\n\t     */\n\t    var LRU = function (maxSize) {\n\t        this._list = new LinkedList();\n\t        this._map = {};\n\t        this._maxSize = maxSize || 10;\n\t    };\n\t    var LRUProto = LRU.prototype;\n\t    /**\n\t     * @param  {string} key\n\t     * @param  {} value\n\t     */\n\t    LRUProto.put = function (key, value) {\n\t        var list = this._list;\n\t        var map = this._map;\n\t        if (map[key] == null) {\n\t            var len = list.len();\n\t            if (len >= this._maxSize && len > 0) {\n\t                // Remove the least recently used\n\t                var leastUsedEntry = list.head;\n\t                list.remove(leastUsedEntry);\n\t                delete map[leastUsedEntry.key];\n\t            }\n\t            var entry = list.insert(value);\n\t            entry.key = key;\n\t            map[key] = entry;\n\t        }\n\t    };\n\t    /**\n\t     * @param  {string} key\n\t     * @return {}\n\t     */\n\t    LRUProto.get = function (key) {\n\t        var entry = this._map[key];\n\t        var list = this._list;\n\t        if (entry != null) {\n\t            // Put the latest used entry in the tail\n\t            if (entry !== list.tail) {\n\t                list.remove(entry);\n\t                list.insertEntry(entry);\n\t            }\n\t            return entry.value;\n\t        }\n\t    };\n\t    /**\n\t     * Clear the cache\n\t     */\n\t    LRUProto.clear = function () {\n\t        this._list.clear();\n\t        this._map = {};\n\t    };\n\t    return LRU;\n\t});\n\tdefine('zrender/graphic/helper/poly', ['require', './smoothSpline', './smoothBezier'], function (require) {\n\t    var smoothSpline = require('./smoothSpline');\n\t    var smoothBezier = require('./smoothBezier');\n\t    return {\n\t        buildPath: function (ctx, shape, closePath) {\n\t            var points = shape.points;\n\t            var smooth = shape.smooth;\n\t            if (points && points.length >= 2) {\n\t                if (smooth && smooth !== 'spline') {\n\t                    var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    var len = points.length;\n\t                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n\t                        var cp1 = controlPoints[i * 2];\n\t                        var cp2 = controlPoints[i * 2 + 1];\n\t                        var p = points[(i + 1) % len];\n\t                        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n\t                    }\n\t                } else {\n\t                    if (smooth === 'spline') {\n\t                        points = smoothSpline(points, closePath);\n\t                    }\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    for (var i = 1, l = points.length; i < l; i++) {\n\t                        ctx.lineTo(points[i][0], points[i][1]);\n\t                    }\n\t                }\n\t                closePath && ctx.closePath();\n\t            }\n\t        }\n\t    };\n\t});\n\tdefine('zrender/graphic/helper/smoothSpline', ['require', '../../core/vector'], function (require) {\n\t    var vec2 = require('../../core/vector');\n\t    /**\n\t     * @inner\n\t     */\n\t    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t    }\n\t    /**\n\t     * @alias module:zrender/shape/util/smoothSpline\n\t     * @param {Array} points 线段顶点数组\n\t     * @param {boolean} isLoop\n\t     * @return {Array}\n\t     */\n\t    return function (points, isLoop) {\n\t        var len = points.length;\n\t        var ret = [];\n\t        var distance = 0;\n\t        for (var i = 1; i < len; i++) {\n\t            distance += vec2.distance(points[i - 1], points[i]);\n\t        }\n\t        var segs = distance / 2;\n\t        segs = segs < len ? len : segs;\n\t        for (var i = 0; i < segs; i++) {\n\t            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n\t            var idx = Math.floor(pos);\n\t            var w = pos - idx;\n\t            var p0;\n\t            var p1 = points[idx % len];\n\t            var p2;\n\t            var p3;\n\t            if (!isLoop) {\n\t                p0 = points[idx === 0 ? idx : idx - 1];\n\t                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n\t                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n\t            } else {\n\t                p0 = points[(idx - 1 + len) % len];\n\t                p2 = points[(idx + 1) % len];\n\t                p3 = points[(idx + 2) % len];\n\t            }\n\t            var w2 = w * w;\n\t            var w3 = w * w2;\n\t            ret.push([\n\t                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n\t                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n\t            ]);\n\t        }\n\t        return ret;\n\t    };\n\t});\n\tdefine('zrender/graphic/helper/smoothBezier', ['require', '../../core/vector'], function (require) {\n\t    var vec2 = require('../../core/vector');\n\t    var v2Min = vec2.min;\n\t    var v2Max = vec2.max;\n\t    var v2Scale = vec2.scale;\n\t    var v2Distance = vec2.distance;\n\t    var v2Add = vec2.add;\n\t    /**\n\t     * 贝塞尔平滑曲线\n\t     * @alias module:zrender/shape/util/smoothBezier\n\t     * @param {Array} points 线段顶点数组\n\t     * @param {number} smooth 平滑等级, 0-1\n\t     * @param {boolean} isLoop\n\t     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n\t     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n\t     *                           整个折线的包围盒做一个并集用来约束控制点。\n\t     * @param {Array} 计算出来的控制点数组\n\t     */\n\t    return function (points, smooth, isLoop, constraint) {\n\t        var cps = [];\n\t        var v = [];\n\t        var v1 = [];\n\t        var v2 = [];\n\t        var prevPoint;\n\t        var nextPoint;\n\t        var min, max;\n\t        if (constraint) {\n\t            min = [\n\t                Infinity,\n\t                Infinity\n\t            ];\n\t            max = [\n\t                -Infinity,\n\t                -Infinity\n\t            ];\n\t            for (var i = 0, len = points.length; i < len; i++) {\n\t                v2Min(min, min, points[i]);\n\t                v2Max(max, max, points[i]);\n\t            }\n\t            // 与指定的包围盒做并集\n\t            v2Min(min, min, constraint[0]);\n\t            v2Max(max, max, constraint[1]);\n\t        }\n\t        for (var i = 0, len = points.length; i < len; i++) {\n\t            var point = points[i];\n\t            if (isLoop) {\n\t                prevPoint = points[i ? i - 1 : len - 1];\n\t                nextPoint = points[(i + 1) % len];\n\t            } else {\n\t                if (i === 0 || i === len - 1) {\n\t                    cps.push(vec2.clone(points[i]));\n\t                    continue;\n\t                } else {\n\t                    prevPoint = points[i - 1];\n\t                    nextPoint = points[i + 1];\n\t                }\n\t            }\n\t            vec2.sub(v, nextPoint, prevPoint);\n\t            // use degree to scale the handle length\n\t            v2Scale(v, v, smooth);\n\t            var d0 = v2Distance(point, prevPoint);\n\t            var d1 = v2Distance(point, nextPoint);\n\t            var sum = d0 + d1;\n\t            if (sum !== 0) {\n\t                d0 /= sum;\n\t                d1 /= sum;\n\t            }\n\t            v2Scale(v1, v, -d0);\n\t            v2Scale(v2, v, d1);\n\t            var cp0 = v2Add([], point, v1);\n\t            var cp1 = v2Add([], point, v2);\n\t            if (constraint) {\n\t                v2Max(cp0, cp0, min);\n\t                v2Min(cp0, cp0, max);\n\t                v2Max(cp1, cp1, min);\n\t                v2Min(cp1, cp1, max);\n\t            }\n\t            cps.push(cp0);\n\t            cps.push(cp1);\n\t        }\n\t        if (isLoop) {\n\t            cps.push(cps.shift());\n\t        }\n\t        return cps;\n\t    };\n\t});\n\tdefine('zrender/graphic/helper/roundRect', ['require'], function (require) {\n\t    return {\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            var r = shape.r;\n\t            var r1;\n\t            var r2;\n\t            var r3;\n\t            var r4;\n\t            // Convert width and height to positive for better borderRadius\n\t            if (width < 0) {\n\t                x = x + width;\n\t                width = -width;\n\t            }\n\t            if (height < 0) {\n\t                y = y + height;\n\t                height = -height;\n\t            }\n\t            if (typeof r === 'number') {\n\t                r1 = r2 = r3 = r4 = r;\n\t            } else if (r instanceof Array) {\n\t                if (r.length === 1) {\n\t                    r1 = r2 = r3 = r4 = r[0];\n\t                } else if (r.length === 2) {\n\t                    r1 = r3 = r[0];\n\t                    r2 = r4 = r[1];\n\t                } else if (r.length === 3) {\n\t                    r1 = r[0];\n\t                    r2 = r4 = r[1];\n\t                    r3 = r[2];\n\t                } else {\n\t                    r1 = r[0];\n\t                    r2 = r[1];\n\t                    r3 = r[2];\n\t                    r4 = r[3];\n\t                }\n\t            } else {\n\t                r1 = r2 = r3 = r4 = 0;\n\t            }\n\t            var total;\n\t            if (r1 + r2 > width) {\n\t                total = r1 + r2;\n\t                r1 *= width / total;\n\t                r2 *= width / total;\n\t            }\n\t            if (r3 + r4 > width) {\n\t                total = r3 + r4;\n\t                r3 *= width / total;\n\t                r4 *= width / total;\n\t            }\n\t            if (r2 + r3 > height) {\n\t                total = r2 + r3;\n\t                r2 *= height / total;\n\t                r3 *= height / total;\n\t            }\n\t            if (r1 + r4 > height) {\n\t                total = r1 + r4;\n\t                r1 *= height / total;\n\t                r4 *= height / total;\n\t            }\n\t            ctx.moveTo(x + r1, y);\n\t            ctx.lineTo(x + width - r2, y);\n\t            r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);\n\t            ctx.lineTo(x + width, y + height - r3);\n\t            r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);\n\t            ctx.lineTo(x + r4, y + height);\n\t            r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);\n\t            ctx.lineTo(x, y + r1);\n\t            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n\t        }\n\t    };\n\t});\n\tdefine('zrender/Storage', ['require', './core/util', './core/env', './container/Group', './core/timsort'], function (require) {\n\t    'use strict';\n\t    var util = require('./core/util');\n\t    var env = require('./core/env');\n\t    var Group = require('./container/Group');\n\t    // Use timsort because in most case elements are partially sorted\n\t    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n\t    var timsort = require('./core/timsort');\n\t    function shapeCompareFunc(a, b) {\n\t        if (a.zlevel === b.zlevel) {\n\t            if (a.z === b.z) {\n\t                // if (a.z2 === b.z2) {\n\t                //     // FIXME Slow has renderidx compare\n\t                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n\t                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n\t                //     return a.__renderidx - b.__renderidx;\n\t                // }\n\t                return a.z2 - b.z2;\n\t            }\n\t            return a.z - b.z;\n\t        }\n\t        return a.zlevel - b.zlevel;\n\t    }\n\t    /**\n\t     * 内容仓库 (M)\n\t     * @alias module:zrender/Storage\n\t     * @constructor\n\t     */\n\t    var Storage = function () {\n\t        // 所有常规形状，id索引的map\n\t        this._elements = {};\n\t        this._roots = [];\n\t        this._displayList = [];\n\t        this._displayListLen = 0;\n\t    };\n\t    Storage.prototype = {\n\t        constructor: Storage,\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._roots.length; i++) {\n\t                this._roots[i].traverse(cb, context);\n\t            }\n\t        },\n\t        getDisplayList: function (update, includeIgnore) {\n\t            includeIgnore = includeIgnore || false;\n\t            if (update) {\n\t                this.updateDisplayList(includeIgnore);\n\t            }\n\t            return this._displayList;\n\t        },\n\t        updateDisplayList: function (includeIgnore) {\n\t            this._displayListLen = 0;\n\t            var roots = this._roots;\n\t            var displayList = this._displayList;\n\t            for (var i = 0, len = roots.length; i < len; i++) {\n\t                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n\t            }\n\t            displayList.length = this._displayListLen;\n\t            // for (var i = 0, len = displayList.length; i < len; i++) {\n\t            //     displayList[i].__renderidx = i;\n\t            // }\n\t            // displayList.sort(shapeCompareFunc);\n\t            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n\t        },\n\t        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\t            if (el.ignore && !includeIgnore) {\n\t                return;\n\t            }\n\t            el.beforeUpdate();\n\t            if (el.__dirty) {\n\t                el.update();\n\t            }\n\t            el.afterUpdate();\n\t            var clipPath = el.clipPath;\n\t            if (clipPath) {\n\t                // clipPath 的变换是基于 group 的变换\n\t                clipPath.parent = el;\n\t                clipPath.updateTransform();\n\t                // FIXME 效率影响\n\t                if (clipPaths) {\n\t                    clipPaths = clipPaths.slice();\n\t                    clipPaths.push(clipPath);\n\t                } else {\n\t                    clipPaths = [clipPath];\n\t                }\n\t            }\n\t            if (el.isGroup) {\n\t                var children = el._children;\n\t                for (var i = 0; i < children.length; i++) {\n\t                    var child = children[i];\n\t                    // Force to mark as dirty if group is dirty\n\t                    // FIXME __dirtyPath ?\n\t                    if (el.__dirty) {\n\t                        child.__dirty = true;\n\t                    }\n\t                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n\t                }\n\t                // Mark group clean here\n\t                el.__dirty = false;\n\t            } else {\n\t                el.__clipPaths = clipPaths;\n\t                this._displayList[this._displayListLen++] = el;\n\t            }\n\t        },\n\t        addRoot: function (el) {\n\t            // Element has been added\n\t            if (this._elements[el.id]) {\n\t                return;\n\t            }\n\t            if (el instanceof Group) {\n\t                el.addChildrenToStorage(this);\n\t            }\n\t            this.addToMap(el);\n\t            this._roots.push(el);\n\t        },\n\t        delRoot: function (elId) {\n\t            if (elId == null) {\n\t                // 不指定elId清空\n\t                for (var i = 0; i < this._roots.length; i++) {\n\t                    var root = this._roots[i];\n\t                    if (root instanceof Group) {\n\t                        root.delChildrenFromStorage(this);\n\t                    }\n\t                }\n\t                this._elements = {};\n\t                this._roots = [];\n\t                this._displayList = [];\n\t                this._displayListLen = 0;\n\t                return;\n\t            }\n\t            if (elId instanceof Array) {\n\t                for (var i = 0, l = elId.length; i < l; i++) {\n\t                    this.delRoot(elId[i]);\n\t                }\n\t                return;\n\t            }\n\t            var el;\n\t            if (typeof elId == 'string') {\n\t                el = this._elements[elId];\n\t            } else {\n\t                el = elId;\n\t            }\n\t            var idx = util.indexOf(this._roots, el);\n\t            if (idx >= 0) {\n\t                this.delFromMap(el.id);\n\t                this._roots.splice(idx, 1);\n\t                if (el instanceof Group) {\n\t                    el.delChildrenFromStorage(this);\n\t                }\n\t            }\n\t        },\n\t        addToMap: function (el) {\n\t            if (el instanceof Group) {\n\t                el.__storage = this;\n\t            }\n\t            el.dirty(false);\n\t            this._elements[el.id] = el;\n\t            return this;\n\t        },\n\t        get: function (elId) {\n\t            return this._elements[elId];\n\t        },\n\t        delFromMap: function (elId) {\n\t            var elements = this._elements;\n\t            var el = elements[elId];\n\t            if (el) {\n\t                delete elements[elId];\n\t                if (el instanceof Group) {\n\t                    el.__storage = null;\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t        dispose: function () {\n\t            this._elements = this._renderList = this._roots = null;\n\t        },\n\t        displayableSortFunc: shapeCompareFunc\n\t    };\n\t    return Storage;\n\t});\n\tdefine('zrender/Handler', ['require', './core/util', './mixin/Draggable', './mixin/Eventful'], function (require) {\n\t    'use strict';\n\t    var util = require('./core/util');\n\t    var Draggable = require('./mixin/Draggable');\n\t    var Eventful = require('./mixin/Eventful');\n\t    function makeEventPacket(eveType, target, event) {\n\t        return {\n\t            type: eveType,\n\t            event: event,\n\t            target: target,\n\t            cancelBubble: false,\n\t            offsetX: event.zrX,\n\t            offsetY: event.zrY,\n\t            gestureEvent: event.gestureEvent,\n\t            pinchX: event.pinchX,\n\t            pinchY: event.pinchY,\n\t            pinchScale: event.pinchScale,\n\t            wheelDelta: event.zrDelta\n\t        };\n\t    }\n\t    function EmptyProxy() {\n\t    }\n\t    EmptyProxy.prototype.dispose = function () {\n\t    };\n\t    var handlerNames = [\n\t            'click',\n\t            'dblclick',\n\t            'mousewheel',\n\t            'mouseout',\n\t            'mouseup',\n\t            'mousedown',\n\t            'mousemove'\n\t        ];\n\t    /**\n\t     * @alias module:zrender/Handler\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Eventful\n\t     * @param {HTMLElement} root Main HTML element for painting.\n\t     * @param {module:zrender/Storage} storage Storage instance.\n\t     * @param {module:zrender/Painter} painter Painter instance.\n\t     */\n\t    var Handler = function (storage, painter, proxy) {\n\t        Eventful.call(this);\n\t        this.storage = storage;\n\t        this.painter = painter;\n\t        proxy = proxy || new EmptyProxy();\n\t        /**\n\t         * Proxy of event. can be Dom, WebGLSurface, etc.\n\t         */\n\t        this.proxy = proxy;\n\t        // Attach handler\n\t        proxy.handler = this;\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._hovered;\n\t        /**\n\t         * @private\n\t         * @type {Date}\n\t         */\n\t        this._lastTouchMoment;\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastX;\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastY;\n\t        Draggable.call(this);\n\t        util.each(handlerNames, function (name) {\n\t            proxy.on && proxy.on(name, this[name], this);\n\t        }, this);\n\t    };\n\t    Handler.prototype = {\n\t        constructor: Handler,\n\t        mousemove: function (event) {\n\t            var x = event.zrX;\n\t            var y = event.zrY;\n\t            var hovered = this.findHover(x, y, null);\n\t            var lastHovered = this._hovered;\n\t            var proxy = this.proxy;\n\t            this._hovered = hovered;\n\t            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\t            // Mouse out on previous hovered element\n\t            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n\t                this.dispatchToElement(lastHovered, 'mouseout', event);\n\t            }\n\t            // Mouse moving on one element\n\t            this.dispatchToElement(hovered, 'mousemove', event);\n\t            // Mouse over on a new element\n\t            if (hovered && hovered !== lastHovered) {\n\t                this.dispatchToElement(hovered, 'mouseover', event);\n\t            }\n\t        },\n\t        mouseout: function (event) {\n\t            this.dispatchToElement(this._hovered, 'mouseout', event);\n\t            this.trigger('globalout', { event: event });\n\t        },\n\t        resize: function (event) {\n\t            this._hovered = null;\n\t        },\n\t        dispatch: function (eventName, eventArgs) {\n\t            var handler = this[eventName];\n\t            handler && handler.call(this, eventArgs);\n\t        },\n\t        dispose: function () {\n\t            this.proxy.dispose();\n\t            this.storage = this.proxy = this.painter = null;\n\t        },\n\t        setCursorStyle: function (cursorStyle) {\n\t            var proxy = this.proxy;\n\t            proxy.setCursor && proxy.setCursor(cursorStyle);\n\t        },\n\t        dispatchToElement: function (targetEl, eventName, event) {\n\t            var eventHandler = 'on' + eventName;\n\t            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\t            var el = targetEl;\n\t            while (el) {\n\t                el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\t                el.trigger(eventName, eventPacket);\n\t                el = el.parent;\n\t                if (eventPacket.cancelBubble) {\n\t                    break;\n\t                }\n\t            }\n\t            if (!eventPacket.cancelBubble) {\n\t                // 冒泡到顶级 zrender 对象\n\t                this.trigger(eventName, eventPacket);\n\t                // 分发事件到用户自定义层\n\t                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\t                this.painter && this.painter.eachOtherLayer(function (layer) {\n\t                    if (typeof layer[eventHandler] == 'function') {\n\t                        layer[eventHandler].call(layer, eventPacket);\n\t                    }\n\t                    if (layer.trigger) {\n\t                        layer.trigger(eventName, eventPacket);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t        findHover: function (x, y, exclude) {\n\t            var list = this.storage.getDisplayList();\n\t            for (var i = list.length - 1; i >= 0; i--) {\n\t                if (!list[i].silent && list[i] !== exclude && !list[i].ignore && isHover(list[i], x, y)) {\n\t                    return list[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t    // Common handlers\n\t    util.each([\n\t        'click',\n\t        'mousedown',\n\t        'mouseup',\n\t        'mousewheel',\n\t        'dblclick'\n\t    ], function (name) {\n\t        Handler.prototype[name] = function (event) {\n\t            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n\t            var hovered = this.findHover(event.zrX, event.zrY, null);\n\t            if (name === 'mousedown') {\n\t                this._downel = hovered;\n\t                // In case click triggered before mouseup\n\t                this._upel = hovered;\n\t            } else if (name === 'mosueup') {\n\t                this._upel = hovered;\n\t            } else if (name === 'click') {\n\t                if (this._downel !== this._upel) {\n\t                    return;\n\t                }\n\t            }\n\t            this.dispatchToElement(hovered, name, event);\n\t        };\n\t    });\n\t    function isHover(displayable, x, y) {\n\t        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n\t            var el = displayable;\n\t            while (el) {\n\t                // If ancestor is silent or clipped by ancestor\n\t                if (el.silent || el.clipPath && !el.clipPath.contain(x, y)) {\n\t                    return false;\n\t                }\n\t                el = el.parent;\n\t            }\n\t            return true;\n\t        }\n\t        return false;\n\t    }\n\t    util.mixin(Handler, Eventful);\n\t    util.mixin(Handler, Draggable);\n\t    return Handler;\n\t});\n\tdefine('zrender/animation/Animation', ['require', '../core/util', '../core/event', './requestAnimationFrame', './Animator'], function (require) {\n\t    'use strict';\n\t    var util = require('../core/util');\n\t    var Dispatcher = require('../core/event').Dispatcher;\n\t    var requestAnimationFrame = require('./requestAnimationFrame');\n\t    var Animator = require('./Animator');\n\t    /**\n\t     * @typedef {Object} IZRenderStage\n\t     * @property {Function} update\n\t     */\n\t    /**\n\t     * @alias module:zrender/animation/Animation\n\t     * @constructor\n\t     * @param {Object} [options]\n\t     * @param {Function} [options.onframe]\n\t     * @param {IZRenderStage} [options.stage]\n\t     * @example\n\t     *     var animation = new Animation();\n\t     *     var obj = {\n\t     *         x: 100,\n\t     *         y: 100\n\t     *     };\n\t     *     animation.animate(node.position)\n\t     *         .when(1000, {\n\t     *             x: 500,\n\t     *             y: 500\n\t     *         })\n\t     *         .when(2000, {\n\t     *             x: 100,\n\t     *             y: 100\n\t     *         })\n\t     *         .start('spline');\n\t     */\n\t    var Animation = function (options) {\n\t        options = options || {};\n\t        this.stage = options.stage || {};\n\t        this.onframe = options.onframe || function () {\n\t        };\n\t        // private properties\n\t        this._clips = [];\n\t        this._running = false;\n\t        this._time;\n\t        this._pausedTime;\n\t        this._pauseStart;\n\t        this._paused = false;\n\t        Dispatcher.call(this);\n\t    };\n\t    Animation.prototype = {\n\t        constructor: Animation,\n\t        addClip: function (clip) {\n\t            this._clips.push(clip);\n\t        },\n\t        addAnimator: function (animator) {\n\t            animator.animation = this;\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.addClip(clips[i]);\n\t            }\n\t        },\n\t        removeClip: function (clip) {\n\t            var idx = util.indexOf(this._clips, clip);\n\t            if (idx >= 0) {\n\t                this._clips.splice(idx, 1);\n\t            }\n\t        },\n\t        removeAnimator: function (animator) {\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.removeClip(clips[i]);\n\t            }\n\t            animator.animation = null;\n\t        },\n\t        _update: function () {\n\t            var time = new Date().getTime() - this._pausedTime;\n\t            var delta = time - this._time;\n\t            var clips = this._clips;\n\t            var len = clips.length;\n\t            var deferredEvents = [];\n\t            var deferredClips = [];\n\t            for (var i = 0; i < len; i++) {\n\t                var clip = clips[i];\n\t                var e = clip.step(time);\n\t                // Throw out the events need to be called after\n\t                // stage.update, like destroy\n\t                if (e) {\n\t                    deferredEvents.push(e);\n\t                    deferredClips.push(clip);\n\t                }\n\t            }\n\t            // Remove the finished clip\n\t            for (var i = 0; i < len;) {\n\t                if (clips[i]._needsRemove) {\n\t                    clips[i] = clips[len - 1];\n\t                    clips.pop();\n\t                    len--;\n\t                } else {\n\t                    i++;\n\t                }\n\t            }\n\t            len = deferredEvents.length;\n\t            for (var i = 0; i < len; i++) {\n\t                deferredClips[i].fire(deferredEvents[i]);\n\t            }\n\t            this._time = time;\n\t            this.onframe(delta);\n\t            this.trigger('frame', delta);\n\t            if (this.stage.update) {\n\t                this.stage.update();\n\t            }\n\t        },\n\t        _startLoop: function () {\n\t            var self = this;\n\t            this._running = true;\n\t            function step() {\n\t                if (self._running) {\n\t                    requestAnimationFrame(step);\n\t                    !self._paused && self._update();\n\t                }\n\t            }\n\t            requestAnimationFrame(step);\n\t        },\n\t        start: function () {\n\t            this._time = new Date().getTime();\n\t            this._pausedTime = 0;\n\t            this._startLoop();\n\t        },\n\t        stop: function () {\n\t            this._running = false;\n\t        },\n\t        pause: function () {\n\t            if (!this._paused) {\n\t                this._pauseStart = new Date().getTime();\n\t                this._paused = true;\n\t            }\n\t        },\n\t        resume: function () {\n\t            if (this._paused) {\n\t                this._pausedTime += new Date().getTime() - this._pauseStart;\n\t                this._paused = false;\n\t            }\n\t        },\n\t        clear: function () {\n\t            this._clips = [];\n\t        },\n\t        animate: function (target, options) {\n\t            options = options || {};\n\t            var animator = new Animator(target, options.loop, options.getter, options.setter);\n\t            return animator;\n\t        }\n\t    };\n\t    util.mixin(Animation, Dispatcher);\n\t    return Animation;\n\t});\n\tdefine('zrender/dom/HandlerProxy', ['require', '../core/event', '../core/util', '../mixin/Eventful', '../core/env', '../core/GestureMgr'], function (require) {\n\t    var eventTool = require('../core/event');\n\t    var zrUtil = require('../core/util');\n\t    var Eventful = require('../mixin/Eventful');\n\t    var env = require('../core/env');\n\t    var GestureMgr = require('../core/GestureMgr');\n\t    var addEventListener = eventTool.addEventListener;\n\t    var removeEventListener = eventTool.removeEventListener;\n\t    var normalizeEvent = eventTool.normalizeEvent;\n\t    var TOUCH_CLICK_DELAY = 300;\n\t    var mouseHandlerNames = [\n\t            'click',\n\t            'dblclick',\n\t            'mousewheel',\n\t            'mouseout',\n\t            'mouseup',\n\t            'mousedown',\n\t            'mousemove'\n\t        ];\n\t    var touchHandlerNames = [\n\t            'touchstart',\n\t            'touchend',\n\t            'touchmove'\n\t        ];\n\t    function eventNameFix(name) {\n\t        return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n\t    }\n\t    function processGesture(proxy, event, stage) {\n\t        var gestureMgr = proxy._gestureMgr;\n\t        stage === 'start' && gestureMgr.clear();\n\t        var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null), proxy.dom);\n\t        stage === 'end' && gestureMgr.clear();\n\t        if (gestureInfo) {\n\t            // eventTool.stop(event);\n\t            var type = gestureInfo.type;\n\t            event.gestureEvent = type;\n\t            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n\t        }\n\t    }\n\t    /**\n\t     * Prevent mouse event from being dispatched after Touch Events action\n\t     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n\t     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n\t     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n\t     * Result: Blocking Mouse Events for 700ms.\n\t     */\n\t    function setTouchTimer(instance) {\n\t        instance._touching = true;\n\t        clearTimeout(instance._touchTimer);\n\t        instance._touchTimer = setTimeout(function () {\n\t            instance._touching = false;\n\t        }, 700);\n\t    }\n\t    function useTouchEvent() {\n\t        return env.touchEventsSupported;\n\t    }\n\t    var domHandlers = {\n\t            mousemove: function (event) {\n\t                event = normalizeEvent(this.dom, event);\n\t                this.trigger('mousemove', event);\n\t            },\n\t            mouseout: function (event) {\n\t                event = normalizeEvent(this.dom, event);\n\t                var element = event.toElement || event.relatedTarget;\n\t                if (element != this.dom) {\n\t                    while (element && element.nodeType != 9) {\n\t                        // 忽略包含在root中的dom引起的mouseOut\n\t                        if (element === this.dom) {\n\t                            return;\n\t                        }\n\t                        element = element.parentNode;\n\t                    }\n\t                }\n\t                this.trigger('mouseout', event);\n\t            },\n\t            touchstart: function (event) {\n\t                // Default mouse behaviour should not be disabled here.\n\t                // For example, page may needs to be slided.\n\t                event = normalizeEvent(this.dom, event);\n\t                this._lastTouchMoment = new Date();\n\t                processGesture(this, event, 'start');\n\t                // 平板补充一次findHover\n\t                // this._mobileFindFixed(event);\n\t                // Trigger mousemove and mousedown\n\t                domHandlers.mousemove.call(this, event);\n\t                domHandlers.mousedown.call(this, event);\n\t                setTouchTimer(this);\n\t            },\n\t            touchmove: function (event) {\n\t                event = normalizeEvent(this.dom, event);\n\t                processGesture(this, event, 'change');\n\t                // Mouse move should always be triggered no matter whether\n\t                // there is gestrue event, because mouse move and pinch may\n\t                // be used at the same time.\n\t                domHandlers.mousemove.call(this, event);\n\t                setTouchTimer(this);\n\t            },\n\t            touchend: function (event) {\n\t                event = normalizeEvent(this.dom, event);\n\t                processGesture(this, event, 'end');\n\t                domHandlers.mouseup.call(this, event);\n\t                // click event should always be triggered no matter whether\n\t                // there is gestrue event. System click can not be prevented.\n\t                if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n\t                    domHandlers.click.call(this, event);\n\t                }\n\t                setTouchTimer(this);\n\t            }\n\t        };\n\t    // Common handlers\n\t    zrUtil.each([\n\t        'click',\n\t        'mousedown',\n\t        'mouseup',\n\t        'mousewheel',\n\t        'dblclick'\n\t    ], function (name) {\n\t        domHandlers[name] = function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t            this.trigger(name, event);\n\t        };\n\t    });\n\t    /**\n\t     * 为控制类实例初始化dom 事件处理函数\n\t     *\n\t     * @inner\n\t     * @param {module:zrender/Handler} instance 控制类实例\n\t     */\n\t    function initDomHandler(instance) {\n\t        for (var i = 0; i < touchHandlerNames.length; i++) {\n\t            var name = touchHandlerNames[i];\n\t            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t        }\n\t        for (var i = 0; i < mouseHandlerNames.length; i++) {\n\t            var name = mouseHandlerNames[i];\n\t            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n\t        }\n\t        function makeMouseHandler(fn, instance) {\n\t            return function () {\n\t                if (instance._touching) {\n\t                    return;\n\t                }\n\t                return fn.apply(instance, arguments);\n\t            };\n\t        }\n\t    }\n\t    function HandlerDomProxy(dom) {\n\t        Eventful.call(this);\n\t        this.dom = dom;\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._touching = false;\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._touchTimer;\n\t        /**\n\t         * @private\n\t         * @type {module:zrender/core/GestureMgr}\n\t         */\n\t        this._gestureMgr = new GestureMgr();\n\t        this._handlers = {};\n\t        initDomHandler(this);\n\t        if (useTouchEvent()) {\n\t            mountHandlers(touchHandlerNames, this);    // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n\t                                                       // addEventListener(root, 'mouseout', this._mouseoutHandler);\n\t        }\n\t        // Considering some devices that both enable touch and mouse event (like MS Surface\n\t        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n\t        // mouse event can not be handle in those devices.\n\t        mountHandlers(mouseHandlerNames, this);\n\t        function mountHandlers(handlerNames, instance) {\n\t            zrUtil.each(handlerNames, function (name) {\n\t                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n\t            }, instance);\n\t        }\n\t    }\n\t    var handlerDomProxyProto = HandlerDomProxy.prototype;\n\t    handlerDomProxyProto.dispose = function () {\n\t        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\t        for (var i = 0; i < handlerNames.length; i++) {\n\t            var name = handlerNames[i];\n\t            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n\t        }\n\t    };\n\t    handlerDomProxyProto.setCursor = function (cursorStyle) {\n\t        this.dom.style.cursor = cursorStyle || 'default';\n\t    };\n\t    zrUtil.mixin(HandlerDomProxy, Eventful);\n\t    return HandlerDomProxy;\n\t});\n\tdefine('zrender/Painter', ['require', './config', './core/util', './core/log', './core/BoundingRect', './core/timsort', './Layer', './animation/requestAnimationFrame', './graphic/Image'], function (require) {\n\t    'use strict';\n\t    var config = require('./config');\n\t    var util = require('./core/util');\n\t    var log = require('./core/log');\n\t    var BoundingRect = require('./core/BoundingRect');\n\t    var timsort = require('./core/timsort');\n\t    var Layer = require('./Layer');\n\t    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n\t    // PENDIGN\n\t    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n\t    //\n\t    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n\t    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t    function isLayerValid(layer) {\n\t        if (!layer) {\n\t            return false;\n\t        }\n\t        if (layer.isBuildin) {\n\t            return true;\n\t        }\n\t        if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n\t            return false;\n\t        }\n\t        return true;\n\t    }\n\t    function preProcessLayer(layer) {\n\t        layer.__unusedCount++;\n\t    }\n\t    function postProcessLayer(layer) {\n\t        if (layer.__unusedCount == 1) {\n\t            layer.clear();\n\t        }\n\t    }\n\t    var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t    var viewRect = new BoundingRect(0, 0, 0, 0);\n\t    function isDisplayableCulled(el, width, height) {\n\t        tmpRect.copy(el.getBoundingRect());\n\t        if (el.transform) {\n\t            tmpRect.applyTransform(el.transform);\n\t        }\n\t        viewRect.width = width;\n\t        viewRect.height = height;\n\t        return !tmpRect.intersect(viewRect);\n\t    }\n\t    function isClipPathChanged(clipPaths, prevClipPaths) {\n\t        if (clipPaths == prevClipPaths) {\n\t            // Can both be null or undefined\n\t            return false;\n\t        }\n\t        if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n\t            return true;\n\t        }\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            if (clipPaths[i] !== prevClipPaths[i]) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t    function doClip(clipPaths, ctx) {\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            var clipPath = clipPaths[i];\n\t            var path = clipPath.path;\n\t            clipPath.setTransform(ctx);\n\t            path.beginPath(ctx);\n\t            clipPath.buildPath(path, clipPath.shape);\n\t            ctx.clip();\n\t            // Transform back\n\t            clipPath.restoreTransform(ctx);\n\t        }\n\t    }\n\t    function createRoot(width, height) {\n\t        var domRoot = document.createElement('div');\n\t        var domRootStyle = domRoot.style;\n\t        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t        domRootStyle.position = 'relative';\n\t        domRootStyle.overflow = 'hidden';\n\t        domRootStyle.width = width + 'px';\n\t        domRootStyle.height = height + 'px';\n\t        return domRoot;\n\t    }\n\t    /**\n\t     * @alias module:zrender/Painter\n\t     * @constructor\n\t     * @param {HTMLElement} root 绘图容器\n\t     * @param {module:zrender/Storage} storage\n\t     * @param {Ojbect} opts\n\t     */\n\t    var Painter = function (root, storage, opts) {\n\t        // In node environment using node-canvas\n\t        var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === 'CANVAS';\n\t        opts = opts || {};\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._singleCanvas = singleCanvas;\n\t        /**\n\t         * 绘图容器\n\t         * @type {HTMLElement}\n\t         */\n\t        this.root = root;\n\t        var rootStyle = root.style;\n\t        if (rootStyle) {\n\t            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n\t            rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n\t            root.innerHTML = '';\n\t        }\n\t        /**\n\t         * @type {module:zrender/Storage}\n\t         */\n\t        this.storage = storage;\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        var zlevelList = this._zlevelList = [];\n\t        /**\n\t         * @type {Object.<string, module:zrender/Layer>}\n\t         * @private\n\t         */\n\t        var layers = this._layers = {};\n\t        /**\n\t         * @type {Object.<string, Object>}\n\t         * @type {private}\n\t         */\n\t        this._layerConfig = {};\n\t        if (!singleCanvas) {\n\t            this._width = this._getWidth();\n\t            this._height = this._getHeight();\n\t            var domRoot = this._domRoot = createRoot(this._width, this._height);\n\t            root.appendChild(domRoot);\n\t        } else {\n\t            // Use canvas width and height directly\n\t            var width = root.width;\n\t            var height = root.height;\n\t            this._width = width;\n\t            this._height = height;\n\t            // Create layer if only one given canvas\n\t            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\t            var mainLayer = new Layer(root, this, 1);\n\t            mainLayer.initContext();\n\t            // FIXME Use canvas width and height\n\t            // mainLayer.resize(width, height);\n\t            layers[0] = mainLayer;\n\t            zlevelList.push(0);\n\t        }\n\t        this.pathToImage = this._createPathToImage();\n\t        // Layers for progressive rendering\n\t        this._progressiveLayers = [];\n\t        /**\n\t         * @type {module:zrender/Layer}\n\t         * @private\n\t         */\n\t        this._hoverlayer;\n\t        this._hoverElements = [];\n\t    };\n\t    Painter.prototype = {\n\t        constructor: Painter,\n\t        isSingleCanvas: function () {\n\t            return this._singleCanvas;\n\t        },\n\t        getViewportRoot: function () {\n\t            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n\t        },\n\t        refresh: function (paintAll) {\n\t            var list = this.storage.getDisplayList(true);\n\t            var zlevelList = this._zlevelList;\n\t            this._paintList(list, paintAll);\n\t            // Paint custum layers\n\t            for (var i = 0; i < zlevelList.length; i++) {\n\t                var z = zlevelList[i];\n\t                var layer = this._layers[z];\n\t                if (!layer.isBuildin && layer.refresh) {\n\t                    layer.refresh();\n\t                }\n\t            }\n\t            this.refreshHover();\n\t            if (this._progressiveLayers.length) {\n\t                this._startProgessive();\n\t            }\n\t            return this;\n\t        },\n\t        addHover: function (el, hoverStyle) {\n\t            if (el.__hoverMir) {\n\t                return;\n\t            }\n\t            var elMirror = new el.constructor({\n\t                    style: el.style,\n\t                    shape: el.shape\n\t                });\n\t            elMirror.__from = el;\n\t            el.__hoverMir = elMirror;\n\t            elMirror.setStyle(hoverStyle);\n\t            this._hoverElements.push(elMirror);\n\t        },\n\t        removeHover: function (el) {\n\t            var elMirror = el.__hoverMir;\n\t            var hoverElements = this._hoverElements;\n\t            var idx = util.indexOf(hoverElements, elMirror);\n\t            if (idx >= 0) {\n\t                hoverElements.splice(idx, 1);\n\t            }\n\t            el.__hoverMir = null;\n\t        },\n\t        clearHover: function (el) {\n\t            var hoverElements = this._hoverElements;\n\t            for (var i = 0; i < hoverElements.length; i++) {\n\t                var from = hoverElements[i].__from;\n\t                if (from) {\n\t                    from.__hoverMir = null;\n\t                }\n\t            }\n\t            hoverElements.length = 0;\n\t        },\n\t        refreshHover: function () {\n\t            var hoverElements = this._hoverElements;\n\t            var len = hoverElements.length;\n\t            var hoverLayer = this._hoverlayer;\n\t            hoverLayer && hoverLayer.clear();\n\t            if (!len) {\n\t                return;\n\t            }\n\t            timsort(hoverElements, this.storage.displayableSortFunc);\n\t            // Use a extream large zlevel\n\t            // FIXME?\n\t            if (!hoverLayer) {\n\t                hoverLayer = this._hoverlayer = this.getLayer(100000);\n\t            }\n\t            var scope = {};\n\t            hoverLayer.ctx.save();\n\t            for (var i = 0; i < len;) {\n\t                var el = hoverElements[i];\n\t                var originalEl = el.__from;\n\t                // Original el is removed\n\t                // PENDING\n\t                if (!(originalEl && originalEl.__zr)) {\n\t                    hoverElements.splice(i, 1);\n\t                    originalEl.__hoverMir = null;\n\t                    len--;\n\t                    continue;\n\t                }\n\t                i++;\n\t                // Use transform\n\t                // FIXME style and shape ?\n\t                if (!originalEl.invisible) {\n\t                    el.transform = originalEl.transform;\n\t                    el.invTransform = originalEl.invTransform;\n\t                    el.__clipPaths = originalEl.__clipPaths;\n\t                    // el.\n\t                    this._doPaintEl(el, hoverLayer, true, scope);\n\t                }\n\t            }\n\t            hoverLayer.ctx.restore();\n\t        },\n\t        _startProgessive: function () {\n\t            var self = this;\n\t            if (!self._furtherProgressive) {\n\t                return;\n\t            }\n\t            // Use a token to stop progress steps triggered by\n\t            // previous zr.refresh calling.\n\t            var token = self._progressiveToken = +new Date();\n\t            self._progress++;\n\t            requestAnimationFrame(step);\n\t            function step() {\n\t                // In case refreshed or disposed\n\t                if (token === self._progressiveToken && self.storage) {\n\t                    self._doPaintList(self.storage.getDisplayList());\n\t                    if (self._furtherProgressive) {\n\t                        self._progress++;\n\t                        requestAnimationFrame(step);\n\t                    } else {\n\t                        self._progressiveToken = -1;\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        _clearProgressive: function () {\n\t            this._progressiveToken = -1;\n\t            this._progress = 0;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                layer.__dirty && layer.clear();\n\t            });\n\t        },\n\t        _paintList: function (list, paintAll) {\n\t            if (paintAll == null) {\n\t                paintAll = false;\n\t            }\n\t            this._updateLayerStatus(list);\n\t            this._clearProgressive();\n\t            this.eachBuildinLayer(preProcessLayer);\n\t            this._doPaintList(list, paintAll);\n\t            this.eachBuildinLayer(postProcessLayer);\n\t        },\n\t        _doPaintList: function (list, paintAll) {\n\t            var currentLayer;\n\t            var currentZLevel;\n\t            var ctx;\n\t            // var invTransform = [];\n\t            var scope;\n\t            var progressiveLayerIdx = 0;\n\t            var currentProgressiveLayer;\n\t            var width = this._width;\n\t            var height = this._height;\n\t            var layerProgress;\n\t            var frame = this._progress;\n\t            function flushProgressiveLayer(layer) {\n\t                var dpr = ctx.dpr || 1;\n\t                ctx.save();\n\t                ctx.globalAlpha = 1;\n\t                ctx.shadowBlur = 0;\n\t                // Avoid layer don't clear in next progressive frame\n\t                currentLayer.__dirty = true;\n\t                ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n\t                ctx.restore();\n\t            }\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\t                var elFrame = el.__frame;\n\t                // Flush at current context\n\t                // PENDING\n\t                if (elFrame < 0 && currentProgressiveLayer) {\n\t                    flushProgressiveLayer(currentProgressiveLayer);\n\t                    currentProgressiveLayer = null;\n\t                }\n\t                // Change draw layer\n\t                if (currentZLevel !== elZLevel) {\n\t                    if (ctx) {\n\t                        ctx.restore();\n\t                    }\n\t                    // Reset scope\n\t                    scope = {};\n\t                    // Only 0 zlevel if only has one canvas\n\t                    currentZLevel = elZLevel;\n\t                    currentLayer = this.getLayer(currentZLevel);\n\t                    if (!currentLayer.isBuildin) {\n\t                        log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n\t                    }\n\t                    ctx = currentLayer.ctx;\n\t                    ctx.save();\n\t                    // Reset the count\n\t                    currentLayer.__unusedCount = 0;\n\t                    if (currentLayer.__dirty || paintAll) {\n\t                        currentLayer.clear();\n\t                    }\n\t                }\n\t                if (!(currentLayer.__dirty || paintAll)) {\n\t                    continue;\n\t                }\n\t                if (elFrame >= 0) {\n\t                    // Progressive layer changed\n\t                    if (!currentProgressiveLayer) {\n\t                        currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n\t                        currentProgressiveLayer.ctx.save();\n\t                        currentProgressiveLayer.renderScope = {};\n\t                        if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n\t                            // flushProgressiveLayer(currentProgressiveLayer);\n\t                            // Quick jump all progressive elements\n\t                            // All progressive element are not dirty, jump over and flush directly\n\t                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n\t                            // currentProgressiveLayer = null;\n\t                            continue;\n\t                        }\n\t                        layerProgress = currentProgressiveLayer.__progress;\n\t                        if (!currentProgressiveLayer.__dirty) {\n\t                            // Keep rendering\n\t                            frame = layerProgress;\n\t                        }\n\t                        currentProgressiveLayer.__progress = frame + 1;\n\t                    }\n\t                    if (elFrame === frame) {\n\t                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n\t                    }\n\t                } else {\n\t                    this._doPaintEl(el, currentLayer, paintAll, scope);\n\t                }\n\t                el.__dirty = false;\n\t            }\n\t            if (currentProgressiveLayer) {\n\t                flushProgressiveLayer(currentProgressiveLayer);\n\t            }\n\t            // Restore the lastLayer ctx\n\t            ctx && ctx.restore();\n\t            // If still has clipping state\n\t            // if (scope.prevElClipPaths) {\n\t            //     ctx.restore();\n\t            // }\n\t            this._furtherProgressive = false;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                if (layer.__maxProgress >= layer.__progress) {\n\t                    this._furtherProgressive = true;\n\t                }\n\t            }, this);\n\t        },\n\t        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n\t            var ctx = currentLayer.ctx;\n\t            var m = el.transform;\n\t            if ((currentLayer.__dirty || forcePaint) && !el.invisible && el.style.opacity !== 0 && !(m && !m[0] && !m[3]) && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n\t                var clipPaths = el.__clipPaths;\n\t                // Optimize when clipping on group with several elements\n\t                if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n\t                    // If has previous clipping state, restore from it\n\t                    if (scope.prevElClipPaths) {\n\t                        scope.prevClipLayer.ctx.restore();\n\t                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\t                        // Reset prevEl since context has been restored\n\t                        scope.prevEl = null;\n\t                    }\n\t                    // New clipping state\n\t                    if (clipPaths) {\n\t                        ctx.save();\n\t                        doClip(clipPaths, ctx);\n\t                        scope.prevClipLayer = currentLayer;\n\t                        scope.prevElClipPaths = clipPaths;\n\t                    }\n\t                }\n\t                el.beforeBrush && el.beforeBrush(ctx);\n\t                el.brush(ctx, scope.prevEl || null);\n\t                scope.prevEl = el;\n\t                el.afterBrush && el.afterBrush(ctx);\n\t            }\n\t        },\n\t        getLayer: function (zlevel) {\n\t            if (this._singleCanvas) {\n\t                return this._layers[0];\n\t            }\n\t            var layer = this._layers[zlevel];\n\t            if (!layer) {\n\t                // Create a new layer\n\t                layer = new Layer('zr_' + zlevel, this, this.dpr);\n\t                layer.isBuildin = true;\n\t                if (this._layerConfig[zlevel]) {\n\t                    util.merge(layer, this._layerConfig[zlevel], true);\n\t                }\n\t                this.insertLayer(zlevel, layer);\n\t                // Context is created after dom inserted to document\n\t                // Or excanvas will get 0px clientWidth and clientHeight\n\t                layer.initContext();\n\t            }\n\t            return layer;\n\t        },\n\t        insertLayer: function (zlevel, layer) {\n\t            var layersMap = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var len = zlevelList.length;\n\t            var prevLayer = null;\n\t            var i = -1;\n\t            var domRoot = this._domRoot;\n\t            if (layersMap[zlevel]) {\n\t                log('ZLevel ' + zlevel + ' has been used already');\n\t                return;\n\t            }\n\t            // Check if is a valid layer\n\t            if (!isLayerValid(layer)) {\n\t                log('Layer of zlevel ' + zlevel + ' is not valid');\n\t                return;\n\t            }\n\t            if (len > 0 && zlevel > zlevelList[0]) {\n\t                for (i = 0; i < len - 1; i++) {\n\t                    if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n\t                        break;\n\t                    }\n\t                }\n\t                prevLayer = layersMap[zlevelList[i]];\n\t            }\n\t            zlevelList.splice(i + 1, 0, zlevel);\n\t            if (prevLayer) {\n\t                var prevDom = prevLayer.dom;\n\t                if (prevDom.nextSibling) {\n\t                    domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n\t                } else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            } else {\n\t                if (domRoot.firstChild) {\n\t                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n\t                } else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            }\n\t            layersMap[zlevel] = layer;\n\t        },\n\t        eachLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                cb.call(context, this._layers[z], z);\n\t            }\n\t        },\n\t        eachBuildinLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t        eachOtherLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (!layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t        getLayers: function () {\n\t            return this._layers;\n\t        },\n\t        _updateLayerStatus: function (list) {\n\t            var layers = this._layers;\n\t            var progressiveLayers = this._progressiveLayers;\n\t            var elCountsLastFrame = {};\n\t            var progressiveElCountsLastFrame = {};\n\t            this.eachBuildinLayer(function (layer, z) {\n\t                elCountsLastFrame[z] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                progressiveElCountsLastFrame[idx] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t            var progressiveLayerCount = 0;\n\t            var currentProgressiveLayer;\n\t            var lastProgressiveKey;\n\t            var frameCount = 0;\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n\t                var layer = layers[zlevel];\n\t                var elProgress = el.progressive;\n\t                if (layer) {\n\t                    layer.elCount++;\n\t                    layer.__dirty = layer.__dirty || el.__dirty;\n\t                }\n\t                /////// Update progressive\n\t                if (elProgress >= 0) {\n\t                    // Fix wrong progressive sequence problem.\n\t                    if (lastProgressiveKey !== elProgress) {\n\t                        lastProgressiveKey = elProgress;\n\t                        frameCount++;\n\t                    }\n\t                    var elFrame = el.__frame = frameCount - 1;\n\t                    if (!currentProgressiveLayer) {\n\t                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n\t                        currentProgressiveLayer = progressiveLayers[idx];\n\t                        if (!currentProgressiveLayer) {\n\t                            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n\t                            currentProgressiveLayer.initContext();\n\t                        }\n\t                        currentProgressiveLayer.__maxProgress = 0;\n\t                    }\n\t                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n\t                    currentProgressiveLayer.elCount++;\n\t                    currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n\t                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n\t                        // Should keep rendering this  layer because progressive rendering is not finished yet\n\t                        layer.__dirty = true;\n\t                    }\n\t                } else {\n\t                    el.__frame = -1;\n\t                    if (currentProgressiveLayer) {\n\t                        currentProgressiveLayer.__nextIdxNotProg = i;\n\t                        progressiveLayerCount++;\n\t                        currentProgressiveLayer = null;\n\t                    }\n\t                }\n\t            }\n\t            if (currentProgressiveLayer) {\n\t                progressiveLayerCount++;\n\t                currentProgressiveLayer.__nextIdxNotProg = i;\n\t            }\n\t            // 层中的元素数量有发生变化\n\t            this.eachBuildinLayer(function (layer, z) {\n\t                if (elCountsLastFrame[z] !== layer.elCount) {\n\t                    layer.__dirty = true;\n\t                }\n\t            });\n\t            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n\t                    el.__dirty = true;\n\t                }\n\t                if (layer.__dirty) {\n\t                    layer.__progress = 0;\n\t                }\n\t            });\n\t        },\n\t        clear: function () {\n\t            this.eachBuildinLayer(this._clearLayer);\n\t            return this;\n\t        },\n\t        _clearLayer: function (layer) {\n\t            layer.clear();\n\t        },\n\t        configLayer: function (zlevel, config) {\n\t            if (config) {\n\t                var layerConfig = this._layerConfig;\n\t                if (!layerConfig[zlevel]) {\n\t                    layerConfig[zlevel] = config;\n\t                } else {\n\t                    util.merge(layerConfig[zlevel], config, true);\n\t                }\n\t                var layer = this._layers[zlevel];\n\t                if (layer) {\n\t                    util.merge(layer, layerConfig[zlevel], true);\n\t                }\n\t            }\n\t        },\n\t        delLayer: function (zlevel) {\n\t            var layers = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var layer = layers[zlevel];\n\t            if (!layer) {\n\t                return;\n\t            }\n\t            layer.dom.parentNode.removeChild(layer.dom);\n\t            delete layers[zlevel];\n\t            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n\t        },\n\t        resize: function (width, height) {\n\t            var domRoot = this._domRoot;\n\t            // FIXME Why ?\n\t            domRoot.style.display = 'none';\n\t            width = width || this._getWidth();\n\t            height = height || this._getHeight();\n\t            domRoot.style.display = '';\n\t            // 优化没有实际改变的resize\n\t            if (this._width != width || height != this._height) {\n\t                domRoot.style.width = width + 'px';\n\t                domRoot.style.height = height + 'px';\n\t                for (var id in this._layers) {\n\t                    this._layers[id].resize(width, height);\n\t                }\n\t                this.refresh(true);\n\t            }\n\t            this._width = width;\n\t            this._height = height;\n\t            return this;\n\t        },\n\t        clearLayer: function (zlevel) {\n\t            var layer = this._layers[zlevel];\n\t            if (layer) {\n\t                layer.clear();\n\t            }\n\t        },\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t            this.root = this.storage = this._domRoot = this._layers = null;\n\t        },\n\t        getRenderedCanvas: function (opts) {\n\t            opts = opts || {};\n\t            if (this._singleCanvas) {\n\t                return this._layers[0].dom;\n\t            }\n\t            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n\t            imageLayer.initContext();\n\t            imageLayer.clearColor = opts.backgroundColor;\n\t            imageLayer.clear();\n\t            var displayList = this.storage.getDisplayList(true);\n\t            var scope = {};\n\t            for (var i = 0; i < displayList.length; i++) {\n\t                var el = displayList[i];\n\t                this._doPaintEl(el, imageLayer, true, scope);\n\t            }\n\t            return imageLayer.dom;\n\t        },\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t        _getWidth: function () {\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t            // FIXME Better way to get the width and height when element has not been append to the document\n\t            return (root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width)) - (parseInt10(stl.paddingLeft) || 0) - (parseInt10(stl.paddingRight) || 0) | 0;\n\t        },\n\t        _getHeight: function () {\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t            return (root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height)) - (parseInt10(stl.paddingTop) || 0) - (parseInt10(stl.paddingBottom) || 0) | 0;\n\t        },\n\t        _pathToImage: function (id, path, width, height, dpr) {\n\t            var canvas = document.createElement('canvas');\n\t            var ctx = canvas.getContext('2d');\n\t            canvas.width = width * dpr;\n\t            canvas.height = height * dpr;\n\t            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\t            var pathTransform = {\n\t                    position: path.position,\n\t                    rotation: path.rotation,\n\t                    scale: path.scale\n\t                };\n\t            path.position = [\n\t                0,\n\t                0,\n\t                0\n\t            ];\n\t            path.rotation = 0;\n\t            path.scale = [\n\t                1,\n\t                1\n\t            ];\n\t            if (path) {\n\t                path.brush(ctx);\n\t            }\n\t            var ImageShape = require('./graphic/Image');\n\t            var imgShape = new ImageShape({\n\t                    id: id,\n\t                    style: {\n\t                        x: 0,\n\t                        y: 0,\n\t                        image: canvas\n\t                    }\n\t                });\n\t            if (pathTransform.position != null) {\n\t                imgShape.position = path.position = pathTransform.position;\n\t            }\n\t            if (pathTransform.rotation != null) {\n\t                imgShape.rotation = path.rotation = pathTransform.rotation;\n\t            }\n\t            if (pathTransform.scale != null) {\n\t                imgShape.scale = path.scale = pathTransform.scale;\n\t            }\n\t            return imgShape;\n\t        },\n\t        _createPathToImage: function () {\n\t            var me = this;\n\t            return function (id, e, width, height) {\n\t                return me._pathToImage(id, e, width, height, me.dpr);\n\t            };\n\t        }\n\t    };\n\t    return Painter;\n\t});\n\tdefine('zrender/mixin/Draggable', ['require'], function (require) {\n\t    function Draggable() {\n\t        this.on('mousedown', this._dragStart, this);\n\t        this.on('mousemove', this._drag, this);\n\t        this.on('mouseup', this._dragEnd, this);\n\t        this.on('globalout', this._dragEnd, this);    // this._dropTarget = null;\n\t                                                      // this._draggingTarget = null;\n\t                                                      // this._x = 0;\n\t                                                      // this._y = 0;\n\t    }\n\t    Draggable.prototype = {\n\t        constructor: Draggable,\n\t        _dragStart: function (e) {\n\t            var draggingTarget = e.target;\n\t            if (draggingTarget && draggingTarget.draggable) {\n\t                this._draggingTarget = draggingTarget;\n\t                draggingTarget.dragging = true;\n\t                this._x = e.offsetX;\n\t                this._y = e.offsetY;\n\t                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n\t            }\n\t        },\n\t        _drag: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t            if (draggingTarget) {\n\t                var x = e.offsetX;\n\t                var y = e.offsetY;\n\t                var dx = x - this._x;\n\t                var dy = y - this._y;\n\t                this._x = x;\n\t                this._y = y;\n\t                draggingTarget.drift(dx, dy, e);\n\t                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\t                var dropTarget = this.findHover(x, y, draggingTarget);\n\t                var lastDropTarget = this._dropTarget;\n\t                this._dropTarget = dropTarget;\n\t                if (draggingTarget !== dropTarget) {\n\t                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n\t                    }\n\t                    if (dropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        _dragEnd: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t            if (draggingTarget) {\n\t                draggingTarget.dragging = false;\n\t            }\n\t            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\t            if (this._dropTarget) {\n\t                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n\t            }\n\t            this._draggingTarget = null;\n\t            this._dropTarget = null;\n\t        }\n\t    };\n\t    return Draggable;\n\t});\n\tdefine('zrender/core/event', ['require', '../mixin/Eventful'], function (require) {\n\t    'use strict';\n\t    var Eventful = require('../mixin/Eventful');\n\t    var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\n\t    function getBoundingClientRect(el) {\n\t        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n\t        return el.getBoundingClientRect ? el.getBoundingClientRect() : {\n\t            left: 0,\n\t            top: 0\n\t        };\n\t    }\n\t    function clientToLocal(el, e, out) {\n\t        // clientX/clientY is according to view port.\n\t        var box = getBoundingClientRect(el);\n\t        out = out || {};\n\t        out.zrX = e.clientX - box.left;\n\t        out.zrY = e.clientY - box.top;\n\t        return out;\n\t    }\n\t    /**\n\t     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标\n\t     */\n\t    function normalizeEvent(el, e) {\n\t        e = e || window.event;\n\t        if (e.zrX != null) {\n\t            return e;\n\t        }\n\t        var eventType = e.type;\n\t        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\t        if (!isTouch) {\n\t            clientToLocal(el, e, e);\n\t            e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n\t        } else {\n\t            var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n\t            touch && clientToLocal(el, touch, e);\n\t        }\n\t        return e;\n\t    }\n\t    function addEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.addEventListener(name, handler);\n\t        } else {\n\t            el.attachEvent('on' + name, handler);\n\t        }\n\t    }\n\t    function removeEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.removeEventListener(name, handler);\n\t        } else {\n\t            el.detachEvent('on' + name, handler);\n\t        }\n\t    }\n\t    /**\n\t     * 停止冒泡和阻止默认行为\n\t     * @memberOf module:zrender/core/event\n\t     * @method\n\t     * @param {Event} e : event对象\n\t     */\n\t    var stop = isDomLevel2 ? function (e) {\n\t            e.preventDefault();\n\t            e.stopPropagation();\n\t            e.cancelBubble = true;\n\t        } : function (e) {\n\t            e.returnValue = false;\n\t            e.cancelBubble = true;\n\t        };\n\t    return {\n\t        clientToLocal: clientToLocal,\n\t        normalizeEvent: normalizeEvent,\n\t        addEventListener: addEventListener,\n\t        removeEventListener: removeEventListener,\n\t        stop: stop,\n\t        Dispatcher: Eventful\n\t    };\n\t});\n\tdefine('zrender/animation/requestAnimationFrame', ['require'], function (require) {\n\t    return typeof window !== 'undefined' && (window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n\t        setTimeout(func, 16);\n\t    };\n\t});\n\tdefine('zrender/core/GestureMgr', ['require', './event'], function (require) {\n\t    'use strict';\n\t    var eventUtil = require('./event');\n\t    var GestureMgr = function () {\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._track = [];\n\t    };\n\t    GestureMgr.prototype = {\n\t        constructor: GestureMgr,\n\t        recognize: function (event, target, root) {\n\t            this._doTrack(event, target, root);\n\t            return this._recognize(event);\n\t        },\n\t        clear: function () {\n\t            this._track.length = 0;\n\t            return this;\n\t        },\n\t        _doTrack: function (event, target, root) {\n\t            var touches = event.touches;\n\t            if (!touches) {\n\t                return;\n\t            }\n\t            var trackItem = {\n\t                    points: [],\n\t                    touches: [],\n\t                    target: target,\n\t                    event: event\n\t                };\n\t            for (var i = 0, len = touches.length; i < len; i++) {\n\t                var touch = touches[i];\n\t                var pos = eventUtil.clientToLocal(root, touch);\n\t                trackItem.points.push([\n\t                    pos.zrX,\n\t                    pos.zrY\n\t                ]);\n\t                trackItem.touches.push(touch);\n\t            }\n\t            this._track.push(trackItem);\n\t        },\n\t        _recognize: function (event) {\n\t            for (var eventName in recognizers) {\n\t                if (recognizers.hasOwnProperty(eventName)) {\n\t                    var gestureInfo = recognizers[eventName](this._track, event);\n\t                    if (gestureInfo) {\n\t                        return gestureInfo;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t    function dist(pointPair) {\n\t        var dx = pointPair[1][0] - pointPair[0][0];\n\t        var dy = pointPair[1][1] - pointPair[0][1];\n\t        return Math.sqrt(dx * dx + dy * dy);\n\t    }\n\t    function center(pointPair) {\n\t        return [\n\t            (pointPair[0][0] + pointPair[1][0]) / 2,\n\t            (pointPair[0][1] + pointPair[1][1]) / 2\n\t        ];\n\t    }\n\t    var recognizers = {\n\t            pinch: function (track, event) {\n\t                var trackLen = track.length;\n\t                if (!trackLen) {\n\t                    return;\n\t                }\n\t                var pinchEnd = (track[trackLen - 1] || {}).points;\n\t                var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\t                if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n\t                    var pinchScale = dist(pinchEnd) / dist(pinchPre);\n\t                    !isFinite(pinchScale) && (pinchScale = 1);\n\t                    event.pinchScale = pinchScale;\n\t                    var pinchCenter = center(pinchEnd);\n\t                    event.pinchX = pinchCenter[0];\n\t                    event.pinchY = pinchCenter[1];\n\t                    return {\n\t                        type: 'pinch',\n\t                        target: track[0].target,\n\t                        event: event\n\t                    };\n\t                }\n\t            }    // Only pinch currently.\n\t        };\n\t    return GestureMgr;\n\t});\n\tdefine('zrender/Layer', ['require', './core/util', './config', './graphic/Style', './graphic/Pattern'], function (require) {\n\t    var util = require('./core/util');\n\t    var config = require('./config');\n\t    var Style = require('./graphic/Style');\n\t    var Pattern = require('./graphic/Pattern');\n\t    function returnFalse() {\n\t        return false;\n\t    }\n\t    /**\n\t     * 创建dom\n\t     *\n\t     * @inner\n\t     * @param {string} id dom id 待用\n\t     * @param {string} type dom type，such as canvas, div etc.\n\t     * @param {Painter} painter painter instance\n\t     * @param {number} number\n\t     */\n\t    function createDom(id, type, painter, dpr) {\n\t        var newDom = document.createElement(type);\n\t        var width = painter.getWidth();\n\t        var height = painter.getHeight();\n\t        var newDomStyle = newDom.style;\n\t        // 没append呢，请原谅我这样写，清晰~\n\t        newDomStyle.position = 'absolute';\n\t        newDomStyle.left = 0;\n\t        newDomStyle.top = 0;\n\t        newDomStyle.width = width + 'px';\n\t        newDomStyle.height = height + 'px';\n\t        newDom.width = width * dpr;\n\t        newDom.height = height * dpr;\n\t        // id不作为索引用，避免可能造成的重名，定义为私有属性\n\t        newDom.setAttribute('data-zr-dom-id', id);\n\t        return newDom;\n\t    }\n\t    /**\n\t     * @alias module:zrender/Layer\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @param {string} id\n\t     * @param {module:zrender/Painter} painter\n\t     * @param {number} [dpr]\n\t     */\n\t    var Layer = function (id, painter, dpr) {\n\t        var dom;\n\t        dpr = dpr || config.devicePixelRatio;\n\t        if (typeof id === 'string') {\n\t            dom = createDom(id, 'canvas', painter, dpr);\n\t        }    // Not using isDom because in node it will return false\n\t        else if (util.isObject(id)) {\n\t            dom = id;\n\t            id = dom.id;\n\t        }\n\t        this.id = id;\n\t        this.dom = dom;\n\t        var domStyle = dom.style;\n\t        if (domStyle) {\n\t            // Not in node\n\t            dom.onselectstart = returnFalse;\n\t            // 避免页面选中的尴尬\n\t            domStyle['-webkit-user-select'] = 'none';\n\t            domStyle['user-select'] = 'none';\n\t            domStyle['-webkit-touch-callout'] = 'none';\n\t            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n\t        }\n\t        this.domBack = null;\n\t        this.ctxBack = null;\n\t        this.painter = painter;\n\t        this.config = null;\n\t        // Configs\n\t        /**\n\t         * 每次清空画布的颜色\n\t         * @type {string}\n\t         * @default 0\n\t         */\n\t        this.clearColor = 0;\n\t        /**\n\t         * 是否开启动态模糊\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        this.motionBlur = false;\n\t        /**\n\t         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t         * @type {number}\n\t         * @default 0.7\n\t         */\n\t        this.lastFrameAlpha = 0.7;\n\t        /**\n\t         * Layer dpr\n\t         * @type {number}\n\t         */\n\t        this.dpr = dpr;\n\t    };\n\t    Layer.prototype = {\n\t        constructor: Layer,\n\t        elCount: 0,\n\t        __dirty: true,\n\t        initContext: function () {\n\t            this.ctx = this.dom.getContext('2d');\n\t            this.ctx.dpr = this.dpr;\n\t        },\n\t        createBackBuffer: function () {\n\t            var dpr = this.dpr;\n\t            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n\t            this.ctxBack = this.domBack.getContext('2d');\n\t            if (dpr != 1) {\n\t                this.ctxBack.scale(dpr, dpr);\n\t            }\n\t        },\n\t        resize: function (width, height) {\n\t            var dpr = this.dpr;\n\t            var dom = this.dom;\n\t            var domStyle = dom.style;\n\t            var domBack = this.domBack;\n\t            domStyle.width = width + 'px';\n\t            domStyle.height = height + 'px';\n\t            dom.width = width * dpr;\n\t            dom.height = height * dpr;\n\t            if (domBack) {\n\t                domBack.width = width * dpr;\n\t                domBack.height = height * dpr;\n\t                if (dpr != 1) {\n\t                    this.ctxBack.scale(dpr, dpr);\n\t                }\n\t            }\n\t        },\n\t        clear: function (clearAll) {\n\t            var dom = this.dom;\n\t            var ctx = this.ctx;\n\t            var width = dom.width;\n\t            var height = dom.height;\n\t            var clearColor = this.clearColor;\n\t            var haveMotionBLur = this.motionBlur && !clearAll;\n\t            var lastFrameAlpha = this.lastFrameAlpha;\n\t            var dpr = this.dpr;\n\t            if (haveMotionBLur) {\n\t                if (!this.domBack) {\n\t                    this.createBackBuffer();\n\t                }\n\t                this.ctxBack.globalCompositeOperation = 'copy';\n\t                this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n\t            }\n\t            ctx.clearRect(0, 0, width, height);\n\t            if (clearColor) {\n\t                var clearColorGradientOrPattern;\n\t                // Gradient\n\t                if (clearColor.colorStops) {\n\t                    // Cache canvas gradient\n\t                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n\t                        x: 0,\n\t                        y: 0,\n\t                        width: width,\n\t                        height: height\n\t                    });\n\t                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n\t                }    // Pattern\n\t                else if (clearColor.image) {\n\t                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n\t                }\n\t                ctx.save();\n\t                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n\t                ctx.fillRect(0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t            if (haveMotionBLur) {\n\t                var domBack = this.domBack;\n\t                ctx.save();\n\t                ctx.globalAlpha = lastFrameAlpha;\n\t                ctx.drawImage(domBack, 0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t        }\n\t    };\n\t    return Layer;\n\t});\n\tdefine('echarts/preprocessor/helper/compatStyle', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var POSSIBLE_STYLES = [\n\t            'areaStyle',\n\t            'lineStyle',\n\t            'nodeStyle',\n\t            'linkStyle',\n\t            'chordStyle',\n\t            'label',\n\t            'labelLine'\n\t        ];\n\t    function compatItemStyle(opt) {\n\t        var itemStyleOpt = opt && opt.itemStyle;\n\t        if (itemStyleOpt) {\n\t            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n\t                var normalItemStyleOpt = itemStyleOpt.normal;\n\t                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n\t                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n\t                    opt[styleName] = opt[styleName] || {};\n\t                    if (!opt[styleName].normal) {\n\t                        opt[styleName].normal = normalItemStyleOpt[styleName];\n\t                    } else {\n\t                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n\t                    }\n\t                    normalItemStyleOpt[styleName] = null;\n\t                }\n\t                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n\t                    opt[styleName] = opt[styleName] || {};\n\t                    if (!opt[styleName].emphasis) {\n\t                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n\t                    } else {\n\t                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n\t                    }\n\t                    emphasisItemStyleOpt[styleName] = null;\n\t                }\n\t            });\n\t        }\n\t    }\n\t    return function (seriesOpt) {\n\t        if (!seriesOpt) {\n\t            return;\n\t        }\n\t        compatItemStyle(seriesOpt);\n\t        compatItemStyle(seriesOpt.markPoint);\n\t        compatItemStyle(seriesOpt.markLine);\n\t        var data = seriesOpt.data;\n\t        if (data) {\n\t            for (var i = 0; i < data.length; i++) {\n\t                compatItemStyle(data[i]);\n\t            }\n\t            // mark point data\n\t            var markPoint = seriesOpt.markPoint;\n\t            if (markPoint && markPoint.data) {\n\t                var mpData = markPoint.data;\n\t                for (var i = 0; i < mpData.length; i++) {\n\t                    compatItemStyle(mpData[i]);\n\t                }\n\t            }\n\t            // mark line data\n\t            var markLine = seriesOpt.markLine;\n\t            if (markLine && markLine.data) {\n\t                var mlData = markLine.data;\n\t                for (var i = 0; i < mlData.length; i++) {\n\t                    if (zrUtil.isArray(mlData[i])) {\n\t                        compatItemStyle(mlData[i][0]);\n\t                        compatItemStyle(mlData[i][1]);\n\t                    } else {\n\t                        compatItemStyle(mlData[i]);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t});\n\tdefine('echarts/component/helper/selectableMixin', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    return {\n\t        updateSelectedMap: function (targetList) {\n\t            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n\t                targetMap[target.name] = target;\n\t                return targetMap;\n\t            }, {});\n\t        },\n\t        select: function (name) {\n\t            var targetMap = this._selectTargetMap;\n\t            var target = targetMap[name];\n\t            var selectedMode = this.get('selectedMode');\n\t            if (selectedMode === 'single') {\n\t                zrUtil.each(targetMap, function (target) {\n\t                    target.selected = false;\n\t                });\n\t            }\n\t            target && (target.selected = true);\n\t        },\n\t        unSelect: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            // var selectedMode = this.get('selectedMode');\n\t            // selectedMode !== 'single' && target && (target.selected = false);\n\t            target && (target.selected = false);\n\t        },\n\t        toggleSelected: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            if (target != null) {\n\t                this[target.selected ? 'unSelect' : 'select'](name);\n\t                return target.selected;\n\t            }\n\t        },\n\t        isSelected: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            return target && target.selected;\n\t        }\n\t    };\n\t});\n\tdefine('echarts/component/axis/AxisView', ['require', 'zrender/core/util', '../../util/graphic', './AxisBuilder', '../../echarts'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var graphic = require('../../util/graphic');\n\t    var AxisBuilder = require('./AxisBuilder');\n\t    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n\t    var getInterval = AxisBuilder.getInterval;\n\t    var axisBuilderAttrs = [\n\t            'axisLine',\n\t            'axisLabel',\n\t            'axisTick',\n\t            'axisName'\n\t        ];\n\t    var selfBuilderAttrs = [\n\t            'splitArea',\n\t            'splitLine'\n\t        ];\n\t    // function getAlignWithLabel(model, axisModel) {\n\t    //     var alignWithLabel = model.get('alignWithLabel');\n\t    //     if (alignWithLabel === 'auto') {\n\t    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n\t    //     }\n\t    //     return alignWithLabel;\n\t    // }\n\t    var AxisView = require('../../echarts').extendComponentView({\n\t            type: 'axis',\n\t            render: function (axisModel, ecModel) {\n\t                this.group.removeAll();\n\t                var oldAxisGroup = this._axisGroup;\n\t                this._axisGroup = new graphic.Group();\n\t                this.group.add(this._axisGroup);\n\t                if (!axisModel.get('show')) {\n\t                    return;\n\t                }\n\t                var gridModel = axisModel.findGridModel();\n\t                var layout = layoutAxis(gridModel, axisModel);\n\t                var axisBuilder = new AxisBuilder(axisModel, layout);\n\t                zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\t                this._axisGroup.add(axisBuilder.getGroup());\n\t                zrUtil.each(selfBuilderAttrs, function (name) {\n\t                    if (axisModel.get(name + '.show')) {\n\t                        this['_' + name](axisModel, gridModel, layout.labelInterval);\n\t                    }\n\t                }, this);\n\t                graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n\t            },\n\t            _splitLine: function (axisModel, gridModel, labelInterval) {\n\t                var axis = axisModel.axis;\n\t                var splitLineModel = axisModel.getModel('splitLine');\n\t                var lineStyleModel = splitLineModel.getModel('lineStyle');\n\t                var lineColors = lineStyleModel.get('color');\n\t                var lineInterval = getInterval(splitLineModel, labelInterval);\n\t                lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\t                var gridRect = gridModel.coordinateSystem.getRect();\n\t                var isHorizontal = axis.isHorizontal();\n\t                var lineCount = 0;\n\t                var ticksCoords = axis.getTicksCoords();\n\t                var ticks = axis.scale.getTicks();\n\t                var p1 = [];\n\t                var p2 = [];\n\t                // Simple optimization\n\t                // Batching the lines if color are the same\n\t                var lineStyle = lineStyleModel.getLineStyle();\n\t                for (var i = 0; i < ticksCoords.length; i++) {\n\t                    if (ifIgnoreOnTick(axis, i, lineInterval)) {\n\t                        continue;\n\t                    }\n\t                    var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\t                    if (isHorizontal) {\n\t                        p1[0] = tickCoord;\n\t                        p1[1] = gridRect.y;\n\t                        p2[0] = tickCoord;\n\t                        p2[1] = gridRect.y + gridRect.height;\n\t                    } else {\n\t                        p1[0] = gridRect.x;\n\t                        p1[1] = tickCoord;\n\t                        p2[0] = gridRect.x + gridRect.width;\n\t                        p2[1] = tickCoord;\n\t                    }\n\t                    var colorIndex = lineCount++ % lineColors.length;\n\t                    this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t                        anid: 'line_' + ticks[i],\n\t                        shape: {\n\t                            x1: p1[0],\n\t                            y1: p1[1],\n\t                            x2: p2[0],\n\t                            y2: p2[1]\n\t                        },\n\t                        style: zrUtil.defaults({ stroke: lineColors[colorIndex] }, lineStyle),\n\t                        silent: true\n\t                    })));\n\t                }\n\t            },\n\t            _splitArea: function (axisModel, gridModel, labelInterval) {\n\t                var axis = axisModel.axis;\n\t                var splitAreaModel = axisModel.getModel('splitArea');\n\t                var areaStyleModel = splitAreaModel.getModel('areaStyle');\n\t                var areaColors = areaStyleModel.get('color');\n\t                var gridRect = gridModel.coordinateSystem.getRect();\n\t                var ticksCoords = axis.getTicksCoords();\n\t                var ticks = axis.scale.getTicks();\n\t                var prevX = axis.toGlobalCoord(ticksCoords[0]);\n\t                var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\t                var count = 0;\n\t                var areaInterval = getInterval(splitAreaModel, labelInterval);\n\t                var areaStyle = areaStyleModel.getAreaStyle();\n\t                areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\t                for (var i = 1; i < ticksCoords.length; i++) {\n\t                    if (ifIgnoreOnTick(axis, i, areaInterval)) {\n\t                        continue;\n\t                    }\n\t                    var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\t                    var x;\n\t                    var y;\n\t                    var width;\n\t                    var height;\n\t                    if (axis.isHorizontal()) {\n\t                        x = prevX;\n\t                        y = gridRect.y;\n\t                        width = tickCoord - x;\n\t                        height = gridRect.height;\n\t                    } else {\n\t                        x = gridRect.x;\n\t                        y = prevY;\n\t                        width = gridRect.width;\n\t                        height = tickCoord - y;\n\t                    }\n\t                    var colorIndex = count++ % areaColors.length;\n\t                    this._axisGroup.add(new graphic.Rect({\n\t                        anid: 'area_' + ticks[i],\n\t                        shape: {\n\t                            x: x,\n\t                            y: y,\n\t                            width: width,\n\t                            height: height\n\t                        },\n\t                        style: zrUtil.defaults({ fill: areaColors[colorIndex] }, areaStyle),\n\t                        silent: true\n\t                    }));\n\t                    prevX = x + width;\n\t                    prevY = y + height;\n\t                }\n\t            }\n\t        });\n\t    AxisView.extend({ type: 'xAxis' });\n\t    AxisView.extend({ type: 'yAxis' });\n\t    /**\n\t     * @inner\n\t     */\n\t    function layoutAxis(gridModel, axisModel) {\n\t        var grid = gridModel.coordinateSystem;\n\t        var axis = axisModel.axis;\n\t        var layout = {};\n\t        var rawAxisPosition = axis.position;\n\t        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n\t        var axisDim = axis.dim;\n\t        // [left, right, top, bottom]\n\t        var rect = grid.getRect();\n\t        var rectBound = [\n\t                rect.x,\n\t                rect.x + rect.width,\n\t                rect.y,\n\t                rect.y + rect.height\n\t            ];\n\t        var axisOffset = axisModel.get('offset') || 0;\n\t        var posMap = {\n\t                x: {\n\t                    top: rectBound[2] - axisOffset,\n\t                    bottom: rectBound[3] + axisOffset\n\t                },\n\t                y: {\n\t                    left: rectBound[0] - axisOffset,\n\t                    right: rectBound[1] + axisOffset\n\t                }\n\t            };\n\t        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n\t        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\t        function getZero(dim, val) {\n\t            var theAxis = grid.getAxis(dim);\n\t            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n\t        }\n\t        // Axis position\n\t        layout.position = [\n\t            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n\t            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n\t        ];\n\t        // Axis rotation\n\t        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\t        // Tick and label direction, x y is axisDim\n\t        var dirMap = {\n\t                top: -1,\n\t                bottom: 1,\n\t                left: -1,\n\t                right: 1\n\t            };\n\t        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n\t        if (axis.onZero) {\n\t            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;\n\t        }\n\t        if (axisModel.getModel('axisTick').get('inside')) {\n\t            layout.tickDirection = -layout.tickDirection;\n\t        }\n\t        if (axisModel.getModel('axisLabel').get('inside')) {\n\t            layout.labelDirection = -layout.labelDirection;\n\t        }\n\t        // Special label rotation\n\t        var labelRotation = axisModel.getModel('axisLabel').get('rotate');\n\t        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n\t        // label interval when auto mode.\n\t        layout.labelInterval = axis.getLabelInterval();\n\t        // Over splitLine and splitArea\n\t        layout.z2 = 1;\n\t        return layout;\n\t    }\n\t});\n\tdefine('echarts/chart/pie/labelLayout', ['require', 'zrender/contain/text'], function (require) {\n\t    'use strict';\n\t    var textContain = require('zrender/contain/text');\n\t    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n\t        list.sort(function (a, b) {\n\t            return a.y - b.y;\n\t        });\n\t        // 压\n\t        function shiftDown(start, end, delta, dir) {\n\t            for (var j = start; j < end; j++) {\n\t                list[j].y += delta;\n\t                if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n\t                    shiftUp(j, delta / 2);\n\t                    return;\n\t                }\n\t            }\n\t            shiftUp(end - 1, delta / 2);\n\t        }\n\t        // 弹\n\t        function shiftUp(end, delta) {\n\t            for (var j = end; j >= 0; j--) {\n\t                list[j].y -= delta;\n\t                if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        function changeX(list, isDownList, cx, cy, r, dir) {\n\t            var lastDeltaX = dir > 0 ? isDownList ? Number.MAX_VALUE : 0 : isDownList ? Number.MAX_VALUE : 0;\n\t            // 上\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                // Not change x for center label\n\t                if (list[i].position === 'center') {\n\t                    continue;\n\t                }\n\t                var deltaY = Math.abs(list[i].y - cy);\n\t                var length = list[i].len;\n\t                var length2 = list[i].len2;\n\t                var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n\t                if (isDownList && deltaX >= lastDeltaX) {\n\t                    // 右下，左下\n\t                    deltaX = lastDeltaX - 10;\n\t                }\n\t                if (!isDownList && deltaX <= lastDeltaX) {\n\t                    // 右上，左上\n\t                    deltaX = lastDeltaX + 10;\n\t                }\n\t                list[i].x = cx + deltaX * dir;\n\t                lastDeltaX = deltaX;\n\t            }\n\t        }\n\t        var lastY = 0;\n\t        var delta;\n\t        var len = list.length;\n\t        var upList = [];\n\t        var downList = [];\n\t        for (var i = 0; i < len; i++) {\n\t            delta = list[i].y - lastY;\n\t            if (delta < 0) {\n\t                shiftDown(i, len, -delta, dir);\n\t            }\n\t            lastY = list[i].y + list[i].height;\n\t        }\n\t        if (viewHeight - lastY < 0) {\n\t            shiftUp(len - 1, lastY - viewHeight);\n\t        }\n\t        for (var i = 0; i < len; i++) {\n\t            if (list[i].y >= cy) {\n\t                downList.push(list[i]);\n\t            } else {\n\t                upList.push(list[i]);\n\t            }\n\t        }\n\t        changeX(upList, false, cx, cy, r, dir);\n\t        changeX(downList, true, cx, cy, r, dir);\n\t    }\n\t    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n\t        var leftList = [];\n\t        var rightList = [];\n\t        for (var i = 0; i < labelLayoutList.length; i++) {\n\t            if (labelLayoutList[i].x < cx) {\n\t                leftList.push(labelLayoutList[i]);\n\t            } else {\n\t                rightList.push(labelLayoutList[i]);\n\t            }\n\t        }\n\t        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n\t        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\t        for (var i = 0; i < labelLayoutList.length; i++) {\n\t            var linePoints = labelLayoutList[i].linePoints;\n\t            if (linePoints) {\n\t                var dist = linePoints[1][0] - linePoints[2][0];\n\t                if (labelLayoutList[i].x < cx) {\n\t                    linePoints[2][0] = labelLayoutList[i].x + 3;\n\t                } else {\n\t                    linePoints[2][0] = labelLayoutList[i].x - 3;\n\t                }\n\t                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n\t                linePoints[1][0] = linePoints[2][0] + dist;\n\t            }\n\t        }\n\t    }\n\t    return function (seriesModel, r, viewWidth, viewHeight) {\n\t        var data = seriesModel.getData();\n\t        var labelLayoutList = [];\n\t        var cx;\n\t        var cy;\n\t        var hasLabelRotate = false;\n\t        data.each(function (idx) {\n\t            var layout = data.getItemLayout(idx);\n\t            var itemModel = data.getItemModel(idx);\n\t            var labelModel = itemModel.getModel('label.normal');\n\t            // Use position in normal or emphasis\n\t            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\t            var labelLineModel = itemModel.getModel('labelLine.normal');\n\t            var labelLineLen = labelLineModel.get('length');\n\t            var labelLineLen2 = labelLineModel.get('length2');\n\t            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\t            var dx = Math.cos(midAngle);\n\t            var dy = Math.sin(midAngle);\n\t            var textX;\n\t            var textY;\n\t            var linePoints;\n\t            var textAlign;\n\t            cx = layout.cx;\n\t            cy = layout.cy;\n\t            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\t            if (labelPosition === 'center') {\n\t                textX = layout.cx;\n\t                textY = layout.cy;\n\t                textAlign = 'center';\n\t            } else {\n\t                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n\t                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\t                textX = x1 + dx * 3;\n\t                textY = y1 + dy * 3;\n\t                if (!isLabelInside) {\n\t                    // For roseType\n\t                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n\t                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n\t                    var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n\t                    var y3 = y2;\n\t                    textX = x3 + (dx < 0 ? -5 : 5);\n\t                    textY = y3;\n\t                    linePoints = [\n\t                        [\n\t                            x1,\n\t                            y1\n\t                        ],\n\t                        [\n\t                            x2,\n\t                            y2\n\t                        ],\n\t                        [\n\t                            x3,\n\t                            y3\n\t                        ]\n\t                    ];\n\t                }\n\t                textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n\t            }\n\t            var font = labelModel.getModel('textStyle').getFont();\n\t            var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n\t            var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n\t            var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n\t            hasLabelRotate = !!labelRotate;\n\t            layout.label = {\n\t                x: textX,\n\t                y: textY,\n\t                position: labelPosition,\n\t                height: textRect.height,\n\t                len: labelLineLen,\n\t                len2: labelLineLen2,\n\t                linePoints: linePoints,\n\t                textAlign: textAlign,\n\t                verticalAlign: 'middle',\n\t                font: font,\n\t                rotation: labelRotate\n\t            };\n\t            // Not layout the inside label\n\t            if (!isLabelInside) {\n\t                labelLayoutList.push(layout.label);\n\t            }\n\t        });\n\t        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n\t            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n\t        }\n\t    };\n\t});\n\tdefine('echarts/component/axis/AxisBuilder', ['require', 'zrender/core/util', '../../util/format', '../../util/graphic', '../../model/Model', '../../util/number', 'zrender/core/vector'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var formatUtil = require('../../util/format');\n\t    var graphic = require('../../util/graphic');\n\t    var Model = require('../../model/Model');\n\t    var numberUtil = require('../../util/number');\n\t    var remRadian = numberUtil.remRadian;\n\t    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n\t    var vec2 = require('zrender/core/vector');\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var retrieve = zrUtil.retrieve;\n\t    var PI = Math.PI;\n\t    function makeAxisEventDataBase(axisModel) {\n\t        var eventData = { componentType: axisModel.mainType };\n\t        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n\t        return eventData;\n\t    }\n\t    /**\n\t     * A final axis is translated and rotated from a \"standard axis\".\n\t     * So opt.position and opt.rotation is required.\n\t     *\n\t     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n\t     * for example: (0, 0) ------------> (0, 50)\n\t     *\n\t     * nameDirection or tickDirection or labelDirection is 1 means tick\n\t     * or label is below the standard axis, whereas is -1 means above\n\t     * the standard axis. labelOffset means offset between label and axis,\n\t     * which is useful when 'onZero', where axisLabel is in the grid and\n\t     * label in outside grid.\n\t     *\n\t     * Tips: like always,\n\t     * positive rotation represents anticlockwise, and negative rotation\n\t     * represents clockwise.\n\t     * The direction of position coordinate is the same as the direction\n\t     * of screen coordinate.\n\t     *\n\t     * Do not need to consider axis 'inverse', which is auto processed by\n\t     * axis extent.\n\t     *\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {Object} axisModel\n\t     * @param {Object} opt Standard axis parameters.\n\t     * @param {Array.<number>} opt.position [x, y]\n\t     * @param {number} opt.rotation by radian\n\t     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n\t     * @param {number} [opt.tickDirection=1] 1 or -1\n\t     * @param {number} [opt.labelDirection=1] 1 or -1\n\t     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n\t     * @param {string} [opt.axisLabelShow] default get from axisModel.\n\t     * @param {string} [opt.axisName] default get from axisModel.\n\t     * @param {number} [opt.axisNameAvailableWidth]\n\t     * @param {number} [opt.labelRotation] by degree, default get from axisModel.\n\t     * @param {number} [opt.labelInterval] Default label interval when label\n\t     *                                     interval from model is null or 'auto'.\n\t     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n\t     */\n\t    var AxisBuilder = function (axisModel, opt) {\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.opt = opt;\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.axisModel = axisModel;\n\t        // Default value\n\t        zrUtil.defaults(opt, {\n\t            labelOffset: 0,\n\t            nameDirection: 1,\n\t            tickDirection: 1,\n\t            labelDirection: 1,\n\t            silent: true\n\t        });\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.group = new graphic.Group();\n\t        // FIXME Not use a seperate text group?\n\t        var dumbGroup = new graphic.Group({\n\t                position: opt.position.slice(),\n\t                rotation: opt.rotation\n\t            });\n\t        // this.group.add(dumbGroup);\n\t        // this._dumbGroup = dumbGroup;\n\t        dumbGroup.updateTransform();\n\t        this._transform = dumbGroup.transform;\n\t        this._dumbGroup = dumbGroup;\n\t    };\n\t    AxisBuilder.prototype = {\n\t        constructor: AxisBuilder,\n\t        hasBuilder: function (name) {\n\t            return !!builders[name];\n\t        },\n\t        add: function (name) {\n\t            builders[name].call(this);\n\t        },\n\t        getGroup: function () {\n\t            return this.group;\n\t        }\n\t    };\n\t    var builders = {\n\t            axisLine: function () {\n\t                var opt = this.opt;\n\t                var axisModel = this.axisModel;\n\t                if (!axisModel.get('axisLine.show')) {\n\t                    return;\n\t                }\n\t                var extent = this.axisModel.axis.getExtent();\n\t                var matrix = this._transform;\n\t                var pt1 = [\n\t                        extent[0],\n\t                        0\n\t                    ];\n\t                var pt2 = [\n\t                        extent[1],\n\t                        0\n\t                    ];\n\t                if (matrix) {\n\t                    v2ApplyTransform(pt1, pt1, matrix);\n\t                    v2ApplyTransform(pt2, pt2, matrix);\n\t                }\n\t                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t                    anid: 'line',\n\t                    shape: {\n\t                        x1: pt1[0],\n\t                        y1: pt1[1],\n\t                        x2: pt2[0],\n\t                        y2: pt2[1]\n\t                    },\n\t                    style: zrUtil.extend({ lineCap: 'round' }, axisModel.getModel('axisLine.lineStyle').getLineStyle()),\n\t                    strokeContainThreshold: opt.strokeContainThreshold || 5,\n\t                    silent: true,\n\t                    z2: 1\n\t                })));\n\t            },\n\t            axisTick: function () {\n\t                var axisModel = this.axisModel;\n\t                if (!axisModel.get('axisTick.show')) {\n\t                    return;\n\t                }\n\t                var axis = axisModel.axis;\n\t                var tickModel = axisModel.getModel('axisTick');\n\t                var opt = this.opt;\n\t                var lineStyleModel = tickModel.getModel('lineStyle');\n\t                var tickLen = tickModel.get('length');\n\t                var tickInterval = getInterval(tickModel, opt.labelInterval);\n\t                var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n\t                var ticks = axis.scale.getTicks();\n\t                var pt1 = [];\n\t                var pt2 = [];\n\t                var matrix = this._transform;\n\t                for (var i = 0; i < ticksCoords.length; i++) {\n\t                    // Only ordinal scale support tick interval\n\t                    if (ifIgnoreOnTick(axis, i, tickInterval)) {\n\t                        continue;\n\t                    }\n\t                    var tickCoord = ticksCoords[i];\n\t                    pt1[0] = tickCoord;\n\t                    pt1[1] = 0;\n\t                    pt2[0] = tickCoord;\n\t                    pt2[1] = opt.tickDirection * tickLen;\n\t                    if (matrix) {\n\t                        v2ApplyTransform(pt1, pt1, matrix);\n\t                        v2ApplyTransform(pt2, pt2, matrix);\n\t                    }\n\t                    // Tick line, Not use group transform to have better line draw\n\t                    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t                        anid: 'tick_' + ticks[i],\n\t                        shape: {\n\t                            x1: pt1[0],\n\t                            y1: pt1[1],\n\t                            x2: pt2[0],\n\t                            y2: pt2[1]\n\t                        },\n\t                        style: zrUtil.defaults(lineStyleModel.getLineStyle(), { stroke: axisModel.get('axisLine.lineStyle.color') }),\n\t                        z2: 2,\n\t                        silent: true\n\t                    })));\n\t                }\n\t            },\n\t            axisLabel: function () {\n\t                var opt = this.opt;\n\t                var axisModel = this.axisModel;\n\t                var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\t                if (!show) {\n\t                    return;\n\t                }\n\t                var axis = axisModel.axis;\n\t                var labelModel = axisModel.getModel('axisLabel');\n\t                var textStyleModel = labelModel.getModel('textStyle');\n\t                var labelMargin = labelModel.get('margin');\n\t                var ticks = axis.scale.getTicks();\n\t                var labels = axisModel.getFormattedLabels();\n\t                // Special label rotate.\n\t                var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;\n\t                // To radian.\n\t                labelRotation = labelRotation * PI / 180;\n\t                var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);\n\t                var categoryData = axisModel.get('data');\n\t                var textEls = [];\n\t                var silent = isSilent(axisModel);\n\t                var triggerEvent = axisModel.get('triggerEvent');\n\t                for (var i = 0; i < ticks.length; i++) {\n\t                    if (ifIgnoreOnTick(axis, i, opt.labelInterval)) {\n\t                        continue;\n\t                    }\n\t                    var itemTextStyleModel = textStyleModel;\n\t                    if (categoryData && categoryData[i] && categoryData[i].textStyle) {\n\t                        itemTextStyleModel = new Model(categoryData[i].textStyle, textStyleModel, axisModel.ecModel);\n\t                    }\n\t                    var textColor = itemTextStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n\t                    var tickCoord = axis.dataToCoord(ticks[i]);\n\t                    var pos = [\n\t                            tickCoord,\n\t                            opt.labelOffset + opt.labelDirection * labelMargin\n\t                        ];\n\t                    var labelBeforeFormat = axis.scale.getLabel(ticks[i]);\n\t                    var textEl = new graphic.Text({\n\t                            anid: 'label_' + ticks[i],\n\t                            style: {\n\t                                text: labels[i],\n\t                                textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n\t                                textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,\n\t                                textFont: itemTextStyleModel.getFont(),\n\t                                fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor\n\t                            },\n\t                            position: pos,\n\t                            rotation: labelLayout.rotation,\n\t                            silent: silent,\n\t                            z2: 10\n\t                        });\n\t                    // Pack data for mouse event\n\t                    if (triggerEvent) {\n\t                        textEl.eventData = makeAxisEventDataBase(axisModel);\n\t                        textEl.eventData.targetType = 'axisLabel';\n\t                        textEl.eventData.value = labelBeforeFormat;\n\t                    }\n\t                    // FIXME\n\t                    this._dumbGroup.add(textEl);\n\t                    textEl.updateTransform();\n\t                    textEls.push(textEl);\n\t                    this.group.add(textEl);\n\t                    textEl.decomposeTransform();\n\t                }\n\t                function isTwoLabelOverlapped(current, next) {\n\t                    var firstRect = current && current.getBoundingRect().clone();\n\t                    var nextRect = next && next.getBoundingRect().clone();\n\t                    if (firstRect && nextRect) {\n\t                        firstRect.applyTransform(current.getLocalTransform());\n\t                        nextRect.applyTransform(next.getLocalTransform());\n\t                        return firstRect.intersect(nextRect);\n\t                    }\n\t                }\n\t                if (axis.type !== 'category') {\n\t                    // If min or max are user set, we need to check\n\t                    // If the tick on min(max) are overlap on their neighbour tick\n\t                    // If they are overlapped, we need to hide the min(max) tick label\n\t                    if (axisModel.getMin ? axisModel.getMin() : axisModel.get('min')) {\n\t                        var firstLabel = textEls[0];\n\t                        var nextLabel = textEls[1];\n\t                        if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n\t                            firstLabel.ignore = true;\n\t                        }\n\t                    }\n\t                    if (axisModel.getMax ? axisModel.getMax() : axisModel.get('max')) {\n\t                        var lastLabel = textEls[textEls.length - 1];\n\t                        var prevLabel = textEls[textEls.length - 2];\n\t                        if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n\t                            lastLabel.ignore = true;\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            axisName: function () {\n\t                var opt = this.opt;\n\t                var axisModel = this.axisModel;\n\t                var name = retrieve(opt.axisName, axisModel.get('name'));\n\t                if (!name) {\n\t                    return;\n\t                }\n\t                var nameLocation = axisModel.get('nameLocation');\n\t                var nameDirection = opt.nameDirection;\n\t                var textStyleModel = axisModel.getModel('nameTextStyle');\n\t                var gap = axisModel.get('nameGap') || 0;\n\t                var extent = this.axisModel.axis.getExtent();\n\t                var gapSignal = extent[0] > extent[1] ? -1 : 1;\n\t                var pos = [\n\t                        nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2,\n\t                        nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n\t                    ];\n\t                var labelLayout;\n\t                var nameRotation = axisModel.get('nameRotate');\n\t                if (nameRotation != null) {\n\t                    nameRotation = nameRotation * PI / 180;    // To radian.\n\t                }\n\t                var axisNameAvailableWidth;\n\t                if (nameLocation === 'middle') {\n\t                    labelLayout = innerTextLayout(opt, nameRotation != null ? nameRotation : opt.rotation, nameDirection);\n\t                } else {\n\t                    labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n\t                    axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\t                    if (axisNameAvailableWidth != null) {\n\t                        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n\t                        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n\t                    }\n\t                }\n\t                var textFont = textStyleModel.getFont();\n\t                var truncateOpt = axisModel.get('nameTruncate', true) || {};\n\t                var ellipsis = truncateOpt.ellipsis;\n\t                var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);\n\t                var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n\t                        minChar: 2,\n\t                        placeholder: truncateOpt.placeholder\n\t                    }) : name;\n\t                var tooltipOpt = axisModel.get('tooltip', true);\n\t                var mainType = axisModel.mainType;\n\t                var formatterParams = {\n\t                        componentType: mainType,\n\t                        name: name,\n\t                        $vars: ['name']\n\t                    };\n\t                formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\t                var textEl = new graphic.Text({\n\t                        anid: 'name',\n\t                        __fullText: name,\n\t                        __truncatedText: truncatedText,\n\t                        style: {\n\t                            text: truncatedText,\n\t                            textFont: textFont,\n\t                            fill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n\t                            textAlign: labelLayout.textAlign,\n\t                            textVerticalAlign: labelLayout.verticalAlign\n\t                        },\n\t                        position: pos,\n\t                        rotation: labelLayout.rotation,\n\t                        silent: isSilent(axisModel),\n\t                        z2: 1,\n\t                        tooltip: tooltipOpt && tooltipOpt.show ? zrUtil.extend({\n\t                            content: name,\n\t                            formatter: function () {\n\t                                return name;\n\t                            },\n\t                            formatterParams: formatterParams\n\t                        }, tooltipOpt) : null\n\t                    });\n\t                if (axisModel.get('triggerEvent')) {\n\t                    textEl.eventData = makeAxisEventDataBase(axisModel);\n\t                    textEl.eventData.targetType = 'axisName';\n\t                    textEl.eventData.name = name;\n\t                }\n\t                // FIXME\n\t                this._dumbGroup.add(textEl);\n\t                textEl.updateTransform();\n\t                this.group.add(textEl);\n\t                textEl.decomposeTransform();\n\t            }\n\t        };\n\t    /**\n\t     * @inner\n\t     */\n\t    function innerTextLayout(opt, textRotation, direction) {\n\t        var rotationDiff = remRadian(textRotation - opt.rotation);\n\t        var textAlign;\n\t        var verticalAlign;\n\t        if (isRadianAroundZero(rotationDiff)) {\n\t            // Label is parallel with axis line.\n\t            verticalAlign = direction > 0 ? 'top' : 'bottom';\n\t            textAlign = 'center';\n\t        } else if (isRadianAroundZero(rotationDiff - PI)) {\n\t            // Label is inverse parallel with axis line.\n\t            verticalAlign = direction > 0 ? 'bottom' : 'top';\n\t            textAlign = 'center';\n\t        } else {\n\t            verticalAlign = 'middle';\n\t            if (rotationDiff > 0 && rotationDiff < PI) {\n\t                textAlign = direction > 0 ? 'right' : 'left';\n\t            } else {\n\t                textAlign = direction > 0 ? 'left' : 'right';\n\t            }\n\t        }\n\t        return {\n\t            rotation: rotationDiff,\n\t            textAlign: textAlign,\n\t            verticalAlign: verticalAlign\n\t        };\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function endTextLayout(opt, textPosition, textRotate, extent) {\n\t        var rotationDiff = remRadian(textRotate - opt.rotation);\n\t        var textAlign;\n\t        var verticalAlign;\n\t        var inverse = extent[0] > extent[1];\n\t        var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\t        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n\t            verticalAlign = onLeft ? 'bottom' : 'top';\n\t            textAlign = 'center';\n\t        } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n\t            verticalAlign = onLeft ? 'top' : 'bottom';\n\t            textAlign = 'center';\n\t        } else {\n\t            verticalAlign = 'middle';\n\t            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n\t                textAlign = onLeft ? 'left' : 'right';\n\t            } else {\n\t                textAlign = onLeft ? 'right' : 'left';\n\t            }\n\t        }\n\t        return {\n\t            rotation: rotationDiff,\n\t            textAlign: textAlign,\n\t            verticalAlign: verticalAlign\n\t        };\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function isSilent(axisModel) {\n\t        var tooltipOpt = axisModel.get('tooltip');\n\t        return axisModel.get('silent') || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n\t    }\n\t    /**\n\t     * @static\n\t     */\n\t    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n\t            var rawTick;\n\t            var scale = axis.scale;\n\t            return scale.type === 'ordinal' && (typeof interval === 'function' ? (rawTick = scale.getTicks()[i], !interval(rawTick, scale.getLabel(rawTick))) : i % (interval + 1));\n\t        };\n\t    /**\n\t     * @static\n\t     */\n\t    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n\t            var interval = model.get('interval');\n\t            if (interval == null || interval == 'auto') {\n\t                interval = labelInterval;\n\t            }\n\t            return interval;\n\t        };\n\t    return AxisBuilder;\n\t});\n\tdefine('zrender', ['zrender/zrender'], function (zrender) { return zrender;});\n\tdefine('echarts', ['echarts/echarts'], function (echarts) { return echarts;});\n\tvar echarts = require('echarts');\n\t\n\techarts.graphic = require('echarts/util/graphic');\n\techarts.number = require('echarts/util/number');\n\techarts.format = require('echarts/util/format');\n\t\n\t\n\trequire('echarts/chart/bar');\n\t\n\trequire('echarts/chart/pie');\n\t\n\t\n\trequire('echarts/component/grid');\n\t\n\trequire('echarts/component/title');\n\t\n\t\n\t\n\t\n\treturn echarts;\n\t}));\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }\n]);\n\n\n/** WEBPACK FOOTER **\n ** build.js\n **/","import Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport {configRouter} from './router'\n\nVue.use(VueRouter)\n\nlet router = new VueRouter()\nconfigRouter(router)\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/main.js\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/css-loader/0.23.1/css-loader/lib/css-base.js\n ** module id = 1\n ** module chunks = 1\n **/","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\tvar sourceMap = obj.sourceMap;\n\n\tif (media) {\n\t\tstyleElement.setAttribute(\"media\", media);\n\t}\n\n\tif (sourceMap) {\n\t\t// https://developer.chrome.com/devtools/docs/javascript-debugging\n\t\t// this makes source maps inside style tags work properly in Chrome\n\t\tcss += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */';\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-style-loader/1.0.0/vue-style-loader/addStyles.js\n ** module id = 2\n ** module chunks = 1\n **/","module.exports = { \"default\": require(\"core-js/library/fn/json/stringify\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/babel-runtime/6.11.6/babel-runtime/core-js/json/stringify.js\n ** module id = 3\n ** module chunks = 1\n **/","var __vue_script__, __vue_template__\nrequire(\"!!vue-style-loader!css-loader!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!less!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Calendar.vue\")\n__vue_script__ = require(\"!!babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=script&index=0!./Calendar.vue\")\n__vue_template__ = require(\"!!vue-html-loader!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./Calendar.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/Calendar.vue\n ** module id = 5\n ** module chunks = 1\n **/","var __vue_script__, __vue_template__\nrequire(\"!!vue-style-loader!css-loader!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!less!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Index.vue\")\n__vue_script__ = require(\"!!babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=script&index=0!./Index.vue\")\n__vue_template__ = require(\"!!vue-html-loader!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./Index.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/Index.vue\n ** module id = 6\n ** module chunks = 1\n **/","/*!\n * Vue.js v1.0.26\n * (c) 2016 Evan You\n * Released under the MIT License.\n */\n'use strict';\n\nfunction set(obj, key, val) {\n  if (hasOwn(obj, key)) {\n    obj[key] = val;\n    return;\n  }\n  if (obj._isVue) {\n    set(obj._data, key, val);\n    return;\n  }\n  var ob = obj.__ob__;\n  if (!ob) {\n    obj[key] = val;\n    return;\n  }\n  ob.convert(key, val);\n  ob.dep.notify();\n  if (ob.vms) {\n    var i = ob.vms.length;\n    while (i--) {\n      var vm = ob.vms[i];\n      vm._proxy(key);\n      vm._digest();\n    }\n  }\n  return val;\n}\n\n/**\n * Delete a property and trigger change if necessary.\n *\n * @param {Object} obj\n * @param {String} key\n */\n\nfunction del(obj, key) {\n  if (!hasOwn(obj, key)) {\n    return;\n  }\n  delete obj[key];\n  var ob = obj.__ob__;\n  if (!ob) {\n    if (obj._isVue) {\n      delete obj._data[key];\n      obj._digest();\n    }\n    return;\n  }\n  ob.dep.notify();\n  if (ob.vms) {\n    var i = ob.vms.length;\n    while (i--) {\n      var vm = ob.vms[i];\n      vm._unproxy(key);\n      vm._digest();\n    }\n  }\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Check whether the object has the property.\n *\n * @param {Object} obj\n * @param {String} key\n * @return {Boolean}\n */\n\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n\n/**\n * Check if an expression is a literal value.\n *\n * @param {String} exp\n * @return {Boolean}\n */\n\nvar literalValueRE = /^\\s?(true|false|-?[\\d\\.]+|'[^']*'|\"[^\"]*\")\\s?$/;\n\nfunction isLiteral(exp) {\n  return literalValueRE.test(exp);\n}\n\n/**\n * Check if a string starts with $ or _\n *\n * @param {String} str\n * @return {Boolean}\n */\n\nfunction isReserved(str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F;\n}\n\n/**\n * Guard text output, make sure undefined outputs\n * empty string\n *\n * @param {*} value\n * @return {String}\n */\n\nfunction _toString(value) {\n  return value == null ? '' : value.toString();\n}\n\n/**\n * Check and convert possible numeric strings to numbers\n * before setting back to data\n *\n * @param {*} value\n * @return {*|Number}\n */\n\nfunction toNumber(value) {\n  if (typeof value !== 'string') {\n    return value;\n  } else {\n    var parsed = Number(value);\n    return isNaN(parsed) ? value : parsed;\n  }\n}\n\n/**\n * Convert string boolean literals into real booleans.\n *\n * @param {*} value\n * @return {*|Boolean}\n */\n\nfunction toBoolean(value) {\n  return value === 'true' ? true : value === 'false' ? false : value;\n}\n\n/**\n * Strip quotes from a string\n *\n * @param {String} str\n * @return {String | false}\n */\n\nfunction stripQuotes(str) {\n  var a = str.charCodeAt(0);\n  var b = str.charCodeAt(str.length - 1);\n  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;\n}\n\n/**\n * Camelize a hyphen-delmited string.\n *\n * @param {String} str\n * @return {String}\n */\n\nvar camelizeRE = /-(\\w)/g;\n\nfunction camelize(str) {\n  return str.replace(camelizeRE, toUpper);\n}\n\nfunction toUpper(_, c) {\n  return c ? c.toUpperCase() : '';\n}\n\n/**\n * Hyphenate a camelCase string.\n *\n * @param {String} str\n * @return {String}\n */\n\nvar hyphenateRE = /([a-z\\d])([A-Z])/g;\n\nfunction hyphenate(str) {\n  return str.replace(hyphenateRE, '$1-$2').toLowerCase();\n}\n\n/**\n * Converts hyphen/underscore/slash delimitered names into\n * camelized classNames.\n *\n * e.g. my-component => MyComponent\n *      some_else    => SomeElse\n *      some/comp    => SomeComp\n *\n * @param {String} str\n * @return {String}\n */\n\nvar classifyRE = /(?:^|[-_\\/])(\\w)/g;\n\nfunction classify(str) {\n  return str.replace(classifyRE, toUpper);\n}\n\n/**\n * Simple bind, faster than native\n *\n * @param {Function} fn\n * @param {Object} ctx\n * @return {Function}\n */\n\nfunction bind(fn, ctx) {\n  return function (a) {\n    var l = arguments.length;\n    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n  };\n}\n\n/**\n * Convert an Array-like object to a real Array.\n *\n * @param {Array-like} list\n * @param {Number} [start] - start index\n * @return {Array}\n */\n\nfunction toArray(list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret;\n}\n\n/**\n * Mix properties into target object.\n *\n * @param {Object} to\n * @param {Object} from\n */\n\nfunction extend(to, from) {\n  var keys = Object.keys(from);\n  var i = keys.length;\n  while (i--) {\n    to[keys[i]] = from[keys[i]];\n  }\n  return to;\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nfunction isObject(obj) {\n  return obj !== null && typeof obj === 'object';\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nvar toString = Object.prototype.toString;\nvar OBJECT_STRING = '[object Object]';\n\nfunction isPlainObject(obj) {\n  return toString.call(obj) === OBJECT_STRING;\n}\n\n/**\n * Array type check.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nvar isArray = Array.isArray;\n\n/**\n * Define a property.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n * @param {Boolean} [enumerable]\n */\n\nfunction def(obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Debounce a function so it only gets called after the\n * input stops arriving after the given wait period.\n *\n * @param {Function} func\n * @param {Number} wait\n * @return {Function} - the debounced function\n */\n\nfunction _debounce(func, wait) {\n  var timeout, args, context, timestamp, result;\n  var later = function later() {\n    var last = Date.now() - timestamp;\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    }\n  };\n  return function () {\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    if (!timeout) {\n      timeout = setTimeout(later, wait);\n    }\n    return result;\n  };\n}\n\n/**\n * Manual indexOf because it's slightly faster than\n * native.\n *\n * @param {Array} arr\n * @param {*} obj\n */\n\nfunction indexOf(arr, obj) {\n  var i = arr.length;\n  while (i--) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n}\n\n/**\n * Make a cancellable version of an async callback.\n *\n * @param {Function} fn\n * @return {Function}\n */\n\nfunction cancellable(fn) {\n  var cb = function cb() {\n    if (!cb.cancelled) {\n      return fn.apply(this, arguments);\n    }\n  };\n  cb.cancel = function () {\n    cb.cancelled = true;\n  };\n  return cb;\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n *\n * @param {*} a\n * @param {*} b\n * @return {Boolean}\n */\n\nfunction looseEqual(a, b) {\n  /* eslint-disable eqeqeq */\n  return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);\n  /* eslint-enable eqeqeq */\n}\n\nvar hasProto = ('__proto__' in {});\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n// UA sniffing for working around browser-specific quirks\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && UA.indexOf('trident') > 0;\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIos = UA && /(iphone|ipad|ipod|ios)/i.test(UA);\nvar iosVersionMatch = isIos && UA.match(/os ([\\d_]+)/);\nvar iosVersion = iosVersionMatch && iosVersionMatch[1].split('_');\n\n// detecting iOS UIWebView by indexedDB\nvar hasMutationObserverBug = iosVersion && Number(iosVersion[0]) >= 9 && Number(iosVersion[1]) >= 3 && !window.indexedDB;\n\nvar transitionProp = undefined;\nvar transitionEndEvent = undefined;\nvar animationProp = undefined;\nvar animationEndEvent = undefined;\n\n// Transition property/event sniffing\nif (inBrowser && !isIE9) {\n  var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;\n  var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;\n  transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';\n  transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';\n  animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';\n  animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';\n}\n\n/**\n * Defer a task to execute it asynchronously. Ideally this\n * should be executed as a microtask, so we leverage\n * MutationObserver if it's available, and fallback to\n * setTimeout(0).\n *\n * @param {Function} cb\n * @param {Object} ctx\n */\n\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n  function nextTickHandler() {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks = [];\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  /* istanbul ignore if */\n  if (typeof MutationObserver !== 'undefined' && !hasMutationObserverBug) {\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(counter);\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = counter;\n    };\n  } else {\n    // webpack attempts to inject a shim for setImmediate\n    // if it is used as a global, so we have to work around that to\n    // avoid bundling unnecessary code.\n    var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};\n    timerFunc = context.setImmediate || setTimeout;\n  }\n  return function (cb, ctx) {\n    var func = ctx ? function () {\n      cb.call(ctx);\n    } : cb;\n    callbacks.push(func);\n    if (pending) return;\n    pending = true;\n    timerFunc(nextTickHandler, 0);\n  };\n})();\n\nvar _Set = undefined;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = function () {\n    this.set = Object.create(null);\n  };\n  _Set.prototype.has = function (key) {\n    return this.set[key] !== undefined;\n  };\n  _Set.prototype.add = function (key) {\n    this.set[key] = 1;\n  };\n  _Set.prototype.clear = function () {\n    this.set = Object.create(null);\n  };\n}\n\nfunction Cache(limit) {\n  this.size = 0;\n  this.limit = limit;\n  this.head = this.tail = undefined;\n  this._keymap = Object.create(null);\n}\n\nvar p = Cache.prototype;\n\n/**\n * Put <value> into the cache associated with <key>.\n * Returns the entry which was removed to make room for\n * the new entry. Otherwise undefined is returned.\n * (i.e. if there was enough room already).\n *\n * @param {String} key\n * @param {*} value\n * @return {Entry|undefined}\n */\n\np.put = function (key, value) {\n  var removed;\n\n  var entry = this.get(key, true);\n  if (!entry) {\n    if (this.size === this.limit) {\n      removed = this.shift();\n    }\n    entry = {\n      key: key\n    };\n    this._keymap[key] = entry;\n    if (this.tail) {\n      this.tail.newer = entry;\n      entry.older = this.tail;\n    } else {\n      this.head = entry;\n    }\n    this.tail = entry;\n    this.size++;\n  }\n  entry.value = value;\n\n  return removed;\n};\n\n/**\n * Purge the least recently used (oldest) entry from the\n * cache. Returns the removed entry or undefined if the\n * cache was empty.\n */\n\np.shift = function () {\n  var entry = this.head;\n  if (entry) {\n    this.head = this.head.newer;\n    this.head.older = undefined;\n    entry.newer = entry.older = undefined;\n    this._keymap[entry.key] = undefined;\n    this.size--;\n  }\n  return entry;\n};\n\n/**\n * Get and register recent use of <key>. Returns the value\n * associated with <key> or undefined if not in cache.\n *\n * @param {String} key\n * @param {Boolean} returnEntry\n * @return {Entry|*}\n */\n\np.get = function (key, returnEntry) {\n  var entry = this._keymap[key];\n  if (entry === undefined) return;\n  if (entry === this.tail) {\n    return returnEntry ? entry : entry.value;\n  }\n  // HEAD--------------TAIL\n  //   <.older   .newer>\n  //  <--- add direction --\n  //   A  B  C  <D>  E\n  if (entry.newer) {\n    if (entry === this.head) {\n      this.head = entry.newer;\n    }\n    entry.newer.older = entry.older; // C <-- E.\n  }\n  if (entry.older) {\n    entry.older.newer = entry.newer; // C. --> E\n  }\n  entry.newer = undefined; // D --x\n  entry.older = this.tail; // D. --> E\n  if (this.tail) {\n    this.tail.newer = entry; // E. <-- D\n  }\n  this.tail = entry;\n  return returnEntry ? entry : entry.value;\n};\n\nvar cache$1 = new Cache(1000);\nvar filterTokenRE = /[^\\s'\"]+|'[^']*'|\"[^\"]*\"/g;\nvar reservedArgRE = /^in$|^-?\\d+/;\n\n/**\n * Parser state\n */\n\nvar str;\nvar dir;\nvar c;\nvar prev;\nvar i;\nvar l;\nvar lastFilterIndex;\nvar inSingle;\nvar inDouble;\nvar curly;\nvar square;\nvar paren;\n/**\n * Push a filter to the current directive object\n */\n\nfunction pushFilter() {\n  var exp = str.slice(lastFilterIndex, i).trim();\n  var filter;\n  if (exp) {\n    filter = {};\n    var tokens = exp.match(filterTokenRE);\n    filter.name = tokens[0];\n    if (tokens.length > 1) {\n      filter.args = tokens.slice(1).map(processFilterArg);\n    }\n  }\n  if (filter) {\n    (dir.filters = dir.filters || []).push(filter);\n  }\n  lastFilterIndex = i + 1;\n}\n\n/**\n * Check if an argument is dynamic and strip quotes.\n *\n * @param {String} arg\n * @return {Object}\n */\n\nfunction processFilterArg(arg) {\n  if (reservedArgRE.test(arg)) {\n    return {\n      value: toNumber(arg),\n      dynamic: false\n    };\n  } else {\n    var stripped = stripQuotes(arg);\n    var dynamic = stripped === arg;\n    return {\n      value: dynamic ? arg : stripped,\n      dynamic: dynamic\n    };\n  }\n}\n\n/**\n * Parse a directive value and extract the expression\n * and its filters into a descriptor.\n *\n * Example:\n *\n * \"a + 1 | uppercase\" will yield:\n * {\n *   expression: 'a + 1',\n *   filters: [\n *     { name: 'uppercase', args: null }\n *   ]\n * }\n *\n * @param {String} s\n * @return {Object}\n */\n\nfunction parseDirective(s) {\n  var hit = cache$1.get(s);\n  if (hit) {\n    return hit;\n  }\n\n  // reset parser state\n  str = s;\n  inSingle = inDouble = false;\n  curly = square = paren = 0;\n  lastFilterIndex = 0;\n  dir = {};\n\n  for (i = 0, l = str.length; i < l; i++) {\n    prev = c;\n    c = str.charCodeAt(i);\n    if (inSingle) {\n      // check single quote\n      if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;\n    } else if (inDouble) {\n      // check double quote\n      if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;\n    } else if (c === 0x7C && // pipe\n    str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {\n      if (dir.expression == null) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        dir.expression = str.slice(0, i).trim();\n      } else {\n        // already has filter\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22:\n          inDouble = true;break; // \"\n        case 0x27:\n          inSingle = true;break; // '\n        case 0x28:\n          paren++;break; // (\n        case 0x29:\n          paren--;break; // )\n        case 0x5B:\n          square++;break; // [\n        case 0x5D:\n          square--;break; // ]\n        case 0x7B:\n          curly++;break; // {\n        case 0x7D:\n          curly--;break; // }\n      }\n    }\n  }\n\n  if (dir.expression == null) {\n    dir.expression = str.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  cache$1.put(s, dir);\n  return dir;\n}\n\nvar directive = Object.freeze({\n  parseDirective: parseDirective\n});\n\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\nvar cache = undefined;\nvar tagRE = undefined;\nvar htmlRE = undefined;\n/**\n * Escape a string so it can be used in a RegExp\n * constructor.\n *\n * @param {String} str\n */\n\nfunction escapeRegex(str) {\n  return str.replace(regexEscapeRE, '\\\\$&');\n}\n\nfunction compileRegex() {\n  var open = escapeRegex(config.delimiters[0]);\n  var close = escapeRegex(config.delimiters[1]);\n  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);\n  var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);\n  tagRE = new RegExp(unsafeOpen + '((?:.|\\\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\\\n)+?)' + close, 'g');\n  htmlRE = new RegExp('^' + unsafeOpen + '((?:.|\\\\n)+?)' + unsafeClose + '$');\n  // reset cache\n  cache = new Cache(1000);\n}\n\n/**\n * Parse a template text string into an array of tokens.\n *\n * @param {String} text\n * @return {Array<Object> | null}\n *               - {String} type\n *               - {String} value\n *               - {Boolean} [html]\n *               - {Boolean} [oneTime]\n */\n\nfunction parseText(text) {\n  if (!cache) {\n    compileRegex();\n  }\n  var hit = cache.get(text);\n  if (hit) {\n    return hit;\n  }\n  if (!tagRE.test(text)) {\n    return null;\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, html, value, first, oneTime;\n  /* eslint-disable no-cond-assign */\n  while (match = tagRE.exec(text)) {\n    /* eslint-enable no-cond-assign */\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push({\n        value: text.slice(lastIndex, index)\n      });\n    }\n    // tag token\n    html = htmlRE.test(match[0]);\n    value = html ? match[1] : match[2];\n    first = value.charCodeAt(0);\n    oneTime = first === 42; // *\n    value = oneTime ? value.slice(1) : value;\n    tokens.push({\n      tag: true,\n      value: value.trim(),\n      html: html,\n      oneTime: oneTime\n    });\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push({\n      value: text.slice(lastIndex)\n    });\n  }\n  cache.put(text, tokens);\n  return tokens;\n}\n\n/**\n * Format a list of tokens into an expression.\n * e.g. tokens parsed from 'a {{b}} c' can be serialized\n * into one single expression as '\"a \" + b + \" c\"'.\n *\n * @param {Array} tokens\n * @param {Vue} [vm]\n * @return {String}\n */\n\nfunction tokensToExp(tokens, vm) {\n  if (tokens.length > 1) {\n    return tokens.map(function (token) {\n      return formatToken(token, vm);\n    }).join('+');\n  } else {\n    return formatToken(tokens[0], vm, true);\n  }\n}\n\n/**\n * Format a single token.\n *\n * @param {Object} token\n * @param {Vue} [vm]\n * @param {Boolean} [single]\n * @return {String}\n */\n\nfunction formatToken(token, vm, single) {\n  return token.tag ? token.oneTime && vm ? '\"' + vm.$eval(token.value) + '\"' : inlineFilters(token.value, single) : '\"' + token.value + '\"';\n}\n\n/**\n * For an attribute with multiple interpolation tags,\n * e.g. attr=\"some-{{thing | filter}}\", in order to combine\n * the whole thing into a single watchable expression, we\n * have to inline those filters. This function does exactly\n * that. This is a bit hacky but it avoids heavy changes\n * to directive parser and watcher mechanism.\n *\n * @param {String} exp\n * @param {Boolean} single\n * @return {String}\n */\n\nvar filterRE = /[^|]\\|[^|]/;\nfunction inlineFilters(exp, single) {\n  if (!filterRE.test(exp)) {\n    return single ? exp : '(' + exp + ')';\n  } else {\n    var dir = parseDirective(exp);\n    if (!dir.filters) {\n      return '(' + exp + ')';\n    } else {\n      return 'this._applyFilters(' + dir.expression + // value\n      ',null,' + // oldValue (null for read)\n      JSON.stringify(dir.filters) + // filter descriptors\n      ',false)'; // write?\n    }\n  }\n}\n\nvar text = Object.freeze({\n  compileRegex: compileRegex,\n  parseText: parseText,\n  tokensToExp: tokensToExp\n});\n\nvar delimiters = ['{{', '}}'];\nvar unsafeDelimiters = ['{{{', '}}}'];\n\nvar config = Object.defineProperties({\n\n  /**\n   * Whether to print debug messages.\n   * Also enables stack trace for warnings.\n   *\n   * @type {Boolean}\n   */\n\n  debug: false,\n\n  /**\n   * Whether to suppress warnings.\n   *\n   * @type {Boolean}\n   */\n\n  silent: false,\n\n  /**\n   * Whether to use async rendering.\n   */\n\n  async: true,\n\n  /**\n   * Whether to warn against errors caught when evaluating\n   * expressions.\n   */\n\n  warnExpressionErrors: true,\n\n  /**\n   * Whether to allow devtools inspection.\n   * Disabled by default in production builds.\n   */\n\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Internal flag to indicate the delimiters have been\n   * changed.\n   *\n   * @type {Boolean}\n   */\n\n  _delimitersChanged: true,\n\n  /**\n   * List of asset types that a component can own.\n   *\n   * @type {Array}\n   */\n\n  _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],\n\n  /**\n   * prop binding modes\n   */\n\n  _propBindingModes: {\n    ONE_WAY: 0,\n    TWO_WAY: 1,\n    ONE_TIME: 2\n  },\n\n  /**\n   * Max circular updates allowed in a batcher flush cycle.\n   */\n\n  _maxUpdateCount: 100\n\n}, {\n  delimiters: { /**\n                 * Interpolation delimiters. Changing these would trigger\n                 * the text parser to re-compile the regular expressions.\n                 *\n                 * @type {Array<String>}\n                 */\n\n    get: function get() {\n      return delimiters;\n    },\n    set: function set(val) {\n      delimiters = val;\n      compileRegex();\n    },\n    configurable: true,\n    enumerable: true\n  },\n  unsafeDelimiters: {\n    get: function get() {\n      return unsafeDelimiters;\n    },\n    set: function set(val) {\n      unsafeDelimiters = val;\n      compileRegex();\n    },\n    configurable: true,\n    enumerable: true\n  }\n});\n\nvar warn = undefined;\nvar formatComponentName = undefined;\n\nif (process.env.NODE_ENV !== 'production') {\n  (function () {\n    var hasConsole = typeof console !== 'undefined';\n\n    warn = function (msg, vm) {\n      if (hasConsole && !config.silent) {\n        console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));\n      }\n    };\n\n    formatComponentName = function (vm) {\n      var name = vm._isVue ? vm.$options.name : vm.name;\n      return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';\n    };\n  })();\n}\n\n/**\n * Append with transition.\n *\n * @param {Element} el\n * @param {Element} target\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nfunction appendWithTransition(el, target, vm, cb) {\n  applyTransition(el, 1, function () {\n    target.appendChild(el);\n  }, vm, cb);\n}\n\n/**\n * InsertBefore with transition.\n *\n * @param {Element} el\n * @param {Element} target\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nfunction beforeWithTransition(el, target, vm, cb) {\n  applyTransition(el, 1, function () {\n    before(el, target);\n  }, vm, cb);\n}\n\n/**\n * Remove with transition.\n *\n * @param {Element} el\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nfunction removeWithTransition(el, vm, cb) {\n  applyTransition(el, -1, function () {\n    remove(el);\n  }, vm, cb);\n}\n\n/**\n * Apply transitions with an operation callback.\n *\n * @param {Element} el\n * @param {Number} direction\n *                  1: enter\n *                 -1: leave\n * @param {Function} op - the actual DOM operation\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nfunction applyTransition(el, direction, op, vm, cb) {\n  var transition = el.__v_trans;\n  if (!transition ||\n  // skip if there are no js hooks and CSS transition is\n  // not supported\n  !transition.hooks && !transitionEndEvent ||\n  // skip transitions for initial compile\n  !vm._isCompiled ||\n  // if the vm is being manipulated by a parent directive\n  // during the parent's compilation phase, skip the\n  // animation.\n  vm.$parent && !vm.$parent._isCompiled) {\n    op();\n    if (cb) cb();\n    return;\n  }\n  var action = direction > 0 ? 'enter' : 'leave';\n  transition[action](op, cb);\n}\n\nvar transition = Object.freeze({\n  appendWithTransition: appendWithTransition,\n  beforeWithTransition: beforeWithTransition,\n  removeWithTransition: removeWithTransition,\n  applyTransition: applyTransition\n});\n\n/**\n * Query an element selector if it's not an element already.\n *\n * @param {String|Element} el\n * @return {Element}\n */\n\nfunction query(el) {\n  if (typeof el === 'string') {\n    var selector = el;\n    el = document.querySelector(el);\n    if (!el) {\n      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + selector);\n    }\n  }\n  return el;\n}\n\n/**\n * Check if a node is in the document.\n * Note: document.documentElement.contains should work here\n * but always returns false for comment nodes in phantomjs,\n * making unit tests difficult. This is fixed by doing the\n * contains() check on the node's parentNode instead of\n * the node itself.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nfunction inDoc(node) {\n  if (!node) return false;\n  var doc = node.ownerDocument.documentElement;\n  var parent = node.parentNode;\n  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));\n}\n\n/**\n * Get and remove an attribute from a node.\n *\n * @param {Node} node\n * @param {String} _attr\n */\n\nfunction getAttr(node, _attr) {\n  var val = node.getAttribute(_attr);\n  if (val !== null) {\n    node.removeAttribute(_attr);\n  }\n  return val;\n}\n\n/**\n * Get an attribute with colon or v-bind: prefix.\n *\n * @param {Node} node\n * @param {String} name\n * @return {String|null}\n */\n\nfunction getBindAttr(node, name) {\n  var val = getAttr(node, ':' + name);\n  if (val === null) {\n    val = getAttr(node, 'v-bind:' + name);\n  }\n  return val;\n}\n\n/**\n * Check the presence of a bind attribute.\n *\n * @param {Node} node\n * @param {String} name\n * @return {Boolean}\n */\n\nfunction hasBindAttr(node, name) {\n  return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);\n}\n\n/**\n * Insert el before target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nfunction before(el, target) {\n  target.parentNode.insertBefore(el, target);\n}\n\n/**\n * Insert el after target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nfunction after(el, target) {\n  if (target.nextSibling) {\n    before(el, target.nextSibling);\n  } else {\n    target.parentNode.appendChild(el);\n  }\n}\n\n/**\n * Remove el from DOM\n *\n * @param {Element} el\n */\n\nfunction remove(el) {\n  el.parentNode.removeChild(el);\n}\n\n/**\n * Prepend el to target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nfunction prepend(el, target) {\n  if (target.firstChild) {\n    before(el, target.firstChild);\n  } else {\n    target.appendChild(el);\n  }\n}\n\n/**\n * Replace target with el\n *\n * @param {Element} target\n * @param {Element} el\n */\n\nfunction replace(target, el) {\n  var parent = target.parentNode;\n  if (parent) {\n    parent.replaceChild(el, target);\n  }\n}\n\n/**\n * Add event listener shorthand.\n *\n * @param {Element} el\n * @param {String} event\n * @param {Function} cb\n * @param {Boolean} [useCapture]\n */\n\nfunction on(el, event, cb, useCapture) {\n  el.addEventListener(event, cb, useCapture);\n}\n\n/**\n * Remove event listener shorthand.\n *\n * @param {Element} el\n * @param {String} event\n * @param {Function} cb\n */\n\nfunction off(el, event, cb) {\n  el.removeEventListener(event, cb);\n}\n\n/**\n * For IE9 compat: when both class and :class are present\n * getAttribute('class') returns wrong value...\n *\n * @param {Element} el\n * @return {String}\n */\n\nfunction getClass(el) {\n  var classname = el.className;\n  if (typeof classname === 'object') {\n    classname = classname.baseVal || '';\n  }\n  return classname;\n}\n\n/**\n * In IE9, setAttribute('class') will result in empty class\n * if the element also has the :class attribute; However in\n * PhantomJS, setting `className` does not work on SVG elements...\n * So we have to do a conditional check here.\n *\n * @param {Element} el\n * @param {String} cls\n */\n\nfunction setClass(el, cls) {\n  /* istanbul ignore if */\n  if (isIE9 && !/svg$/.test(el.namespaceURI)) {\n    el.className = cls;\n  } else {\n    el.setAttribute('class', cls);\n  }\n}\n\n/**\n * Add class with compatibility for IE & SVG\n *\n * @param {Element} el\n * @param {String} cls\n */\n\nfunction addClass(el, cls) {\n  if (el.classList) {\n    el.classList.add(cls);\n  } else {\n    var cur = ' ' + getClass(el) + ' ';\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      setClass(el, (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for IE & SVG\n *\n * @param {Element} el\n * @param {String} cls\n */\n\nfunction removeClass(el, cls) {\n  if (el.classList) {\n    el.classList.remove(cls);\n  } else {\n    var cur = ' ' + getClass(el) + ' ';\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    setClass(el, cur.trim());\n  }\n  if (!el.className) {\n    el.removeAttribute('class');\n  }\n}\n\n/**\n * Extract raw content inside an element into a temporary\n * container div\n *\n * @param {Element} el\n * @param {Boolean} asFragment\n * @return {Element|DocumentFragment}\n */\n\nfunction extractContent(el, asFragment) {\n  var child;\n  var rawContent;\n  /* istanbul ignore if */\n  if (isTemplate(el) && isFragment(el.content)) {\n    el = el.content;\n  }\n  if (el.hasChildNodes()) {\n    trimNode(el);\n    rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');\n    /* eslint-disable no-cond-assign */\n    while (child = el.firstChild) {\n      /* eslint-enable no-cond-assign */\n      rawContent.appendChild(child);\n    }\n  }\n  return rawContent;\n}\n\n/**\n * Trim possible empty head/tail text and comment\n * nodes inside a parent.\n *\n * @param {Node} node\n */\n\nfunction trimNode(node) {\n  var child;\n  /* eslint-disable no-sequences */\n  while ((child = node.firstChild, isTrimmable(child))) {\n    node.removeChild(child);\n  }\n  while ((child = node.lastChild, isTrimmable(child))) {\n    node.removeChild(child);\n  }\n  /* eslint-enable no-sequences */\n}\n\nfunction isTrimmable(node) {\n  return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);\n}\n\n/**\n * Check if an element is a template tag.\n * Note if the template appears inside an SVG its tagName\n * will be in lowercase.\n *\n * @param {Element} el\n */\n\nfunction isTemplate(el) {\n  return el.tagName && el.tagName.toLowerCase() === 'template';\n}\n\n/**\n * Create an \"anchor\" for performing dom insertion/removals.\n * This is used in a number of scenarios:\n * - fragment instance\n * - v-html\n * - v-if\n * - v-for\n * - component\n *\n * @param {String} content\n * @param {Boolean} persist - IE trashes empty textNodes on\n *                            cloneNode(true), so in certain\n *                            cases the anchor needs to be\n *                            non-empty to be persisted in\n *                            templates.\n * @return {Comment|Text}\n */\n\nfunction createAnchor(content, persist) {\n  var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');\n  anchor.__v_anchor = true;\n  return anchor;\n}\n\n/**\n * Find a component ref attribute that starts with $.\n *\n * @param {Element} node\n * @return {String|undefined}\n */\n\nvar refRE = /^v-ref:/;\n\nfunction findRef(node) {\n  if (node.hasAttributes()) {\n    var attrs = node.attributes;\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      var name = attrs[i].name;\n      if (refRE.test(name)) {\n        return camelize(name.replace(refRE, ''));\n      }\n    }\n  }\n}\n\n/**\n * Map a function to a range of nodes .\n *\n * @param {Node} node\n * @param {Node} end\n * @param {Function} op\n */\n\nfunction mapNodeRange(node, end, op) {\n  var next;\n  while (node !== end) {\n    next = node.nextSibling;\n    op(node);\n    node = next;\n  }\n  op(end);\n}\n\n/**\n * Remove a range of nodes with transition, store\n * the nodes in a fragment with correct ordering,\n * and call callback when done.\n *\n * @param {Node} start\n * @param {Node} end\n * @param {Vue} vm\n * @param {DocumentFragment} frag\n * @param {Function} cb\n */\n\nfunction removeNodeRange(start, end, vm, frag, cb) {\n  var done = false;\n  var removed = 0;\n  var nodes = [];\n  mapNodeRange(start, end, function (node) {\n    if (node === end) done = true;\n    nodes.push(node);\n    removeWithTransition(node, vm, onRemoved);\n  });\n  function onRemoved() {\n    removed++;\n    if (done && removed >= nodes.length) {\n      for (var i = 0; i < nodes.length; i++) {\n        frag.appendChild(nodes[i]);\n      }\n      cb && cb();\n    }\n  }\n}\n\n/**\n * Check if a node is a DocumentFragment.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nfunction isFragment(node) {\n  return node && node.nodeType === 11;\n}\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n *\n * @param {Element} el\n * @return {String}\n */\n\nfunction getOuterHTML(el) {\n  if (el.outerHTML) {\n    return el.outerHTML;\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML;\n  }\n}\n\nvar commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;\nvar reservedTagRE = /^(slot|partial|component)$/i;\n\nvar isUnknownElement = undefined;\nif (process.env.NODE_ENV !== 'production') {\n  isUnknownElement = function (el, tag) {\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n    } else {\n      return (/HTMLUnknownElement/.test(el.toString()) &&\n        // Chrome returns unknown for several HTML5 elements.\n        // https://code.google.com/p/chromium/issues/detail?id=540526\n        // Firefox returns unknown for some \"Interactive elements.\"\n        !/^(data|time|rtc|rb|details|dialog|summary)$/.test(tag)\n      );\n    }\n  };\n}\n\n/**\n * Check if an element is a component, if yes return its\n * component id.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Object|undefined}\n */\n\nfunction checkComponentAttr(el, options) {\n  var tag = el.tagName.toLowerCase();\n  var hasAttrs = el.hasAttributes();\n  if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {\n    if (resolveAsset(options, 'components', tag)) {\n      return { id: tag };\n    } else {\n      var is = hasAttrs && getIsBinding(el, options);\n      if (is) {\n        return is;\n      } else if (process.env.NODE_ENV !== 'production') {\n        var expectedTag = options._componentNameMap && options._componentNameMap[tag];\n        if (expectedTag) {\n          warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');\n        } else if (isUnknownElement(el, tag)) {\n          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.');\n        }\n      }\n    }\n  } else if (hasAttrs) {\n    return getIsBinding(el, options);\n  }\n}\n\n/**\n * Get \"is\" binding from an element.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Object|undefined}\n */\n\nfunction getIsBinding(el, options) {\n  // dynamic syntax\n  var exp = el.getAttribute('is');\n  if (exp != null) {\n    if (resolveAsset(options, 'components', exp)) {\n      el.removeAttribute('is');\n      return { id: exp };\n    }\n  } else {\n    exp = getBindAttr(el, 'is');\n    if (exp != null) {\n      return { id: exp, dynamic: true };\n    }\n  }\n}\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n *\n * All strategy functions follow the same signature:\n *\n * @param {*} parentVal\n * @param {*} childVal\n * @param {Vue} [vm]\n */\n\nvar strats = config.optionMergeStrategies = Object.create(null);\n\n/**\n * Helper that recursively merges two data objects together.\n */\n\nfunction mergeData(to, from) {\n  var key, toVal, fromVal;\n  for (key in from) {\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isObject(toVal) && isObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to;\n}\n\n/**\n * Data\n */\n\nstrats.data = function (parentVal, childVal, vm) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal;\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n      return parentVal;\n    }\n    if (!parentVal) {\n      return childVal;\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn() {\n      return mergeData(childVal.call(this), parentVal.call(this));\n    };\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn() {\n      // instance merge\n      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\n      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData);\n      } else {\n        return defaultData;\n      }\n    };\n  }\n};\n\n/**\n * El\n */\n\nstrats.el = function (parentVal, childVal, vm) {\n  if (!vm && childVal && typeof childVal !== 'function') {\n    process.env.NODE_ENV !== 'production' && warn('The \"el\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n    return;\n  }\n  var ret = childVal || parentVal;\n  // invoke the element factory if this is instance merge\n  return vm && typeof ret === 'function' ? ret.call(vm) : ret;\n};\n\n/**\n * Hooks and param attributes are merged as arrays.\n */\n\nstrats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {\n  return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;\n};\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\n\nfunction mergeAssets(parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal ? extend(res, guardArrayAssets(childVal)) : res;\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Events & Watchers.\n *\n * Events & watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\n\nstrats.watch = strats.events = function (parentVal, childVal) {\n  if (!childVal) return parentVal;\n  if (!parentVal) return childVal;\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent ? parent.concat(child) : [child];\n  }\n  return ret;\n};\n\n/**\n * Other object hashes.\n */\n\nstrats.props = strats.methods = strats.computed = function (parentVal, childVal) {\n  if (!childVal) return parentVal;\n  if (!parentVal) return childVal;\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret;\n};\n\n/**\n * Default strategy.\n */\n\nvar defaultStrat = function defaultStrat(parentVal, childVal) {\n  return childVal === undefined ? parentVal : childVal;\n};\n\n/**\n * Make sure component options get converted to actual\n * constructors.\n *\n * @param {Object} options\n */\n\nfunction guardComponents(options) {\n  if (options.components) {\n    var components = options.components = guardArrayAssets(options.components);\n    var ids = Object.keys(components);\n    var def;\n    if (process.env.NODE_ENV !== 'production') {\n      var map = options._componentNameMap = {};\n    }\n    for (var i = 0, l = ids.length; i < l; i++) {\n      var key = ids[i];\n      if (commonTagRE.test(key) || reservedTagRE.test(key)) {\n        process.env.NODE_ENV !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\n        continue;\n      }\n      // record a all lowercase <-> kebab-case mapping for\n      // possible custom element case error warning\n      if (process.env.NODE_ENV !== 'production') {\n        map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);\n      }\n      def = components[key];\n      if (isPlainObject(def)) {\n        components[key] = Vue.extend(def);\n      }\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n *\n * @param {Object} options\n */\n\nfunction guardProps(options) {\n  var props = options.props;\n  var i, val;\n  if (isArray(props)) {\n    options.props = {};\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        options.props[val] = null;\n      } else if (val.name) {\n        options.props[val.name] = val;\n      }\n    }\n  } else if (isPlainObject(props)) {\n    var keys = Object.keys(props);\n    i = keys.length;\n    while (i--) {\n      val = props[keys[i]];\n      if (typeof val === 'function') {\n        props[keys[i]] = { type: val };\n      }\n    }\n  }\n}\n\n/**\n * Guard an Array-format assets option and converted it\n * into the key-value Object format.\n *\n * @param {Object|Array} assets\n * @return {Object}\n */\n\nfunction guardArrayAssets(assets) {\n  if (isArray(assets)) {\n    var res = {};\n    var i = assets.length;\n    var asset;\n    while (i--) {\n      asset = assets[i];\n      var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;\n      if (!id) {\n        process.env.NODE_ENV !== 'production' && warn('Array-syntax assets must provide a \"name\" or \"id\" field.');\n      } else {\n        res[id] = asset;\n      }\n    }\n    return res;\n  }\n  return assets;\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n *\n * @param {Object} parent\n * @param {Object} child\n * @param {Vue} [vm] - if vm is present, indicates this is\n *                     an instantiation merge.\n */\n\nfunction mergeOptions(parent, child, vm) {\n  guardComponents(child);\n  guardProps(child);\n  if (process.env.NODE_ENV !== 'production') {\n    if (child.propsData && !vm) {\n      warn('propsData can only be used as an instantiation option.');\n    }\n  }\n  var options = {};\n  var key;\n  if (child['extends']) {\n    parent = typeof child['extends'] === 'function' ? mergeOptions(parent, child['extends'].options, vm) : mergeOptions(parent, child['extends'], vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      var mixin = child.mixins[i];\n      var mixinOptions = mixin.prototype instanceof Vue ? mixin.options : mixin;\n      parent = mergeOptions(parent, mixinOptions, vm);\n    }\n  }\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField(key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options;\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n *\n * @param {Object} options\n * @param {String} type\n * @param {String} id\n * @param {Boolean} warnMissing\n * @return {Object|Function}\n */\n\nfunction resolveAsset(options, type, id, warnMissing) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return;\n  }\n  var assets = options[type];\n  var camelizedId;\n  var res = assets[id] ||\n  // camelCase ID\n  assets[camelizedId = camelize(id)] ||\n  // Pascal Case ID\n  assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n  }\n  return res;\n}\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n *\n * @constructor\n */\nfunction Dep() {\n  this.id = uid$1++;\n  this.subs = [];\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\n\n/**\n * Add a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.addSub = function (sub) {\n  this.subs.push(sub);\n};\n\n/**\n * Remove a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.removeSub = function (sub) {\n  this.subs.$remove(sub);\n};\n\n/**\n * Add self as a dependency to the target watcher.\n */\n\nDep.prototype.depend = function () {\n  Dep.target.addDep(this);\n};\n\n/**\n * Notify all subscribers of a new value.\n */\n\nDep.prototype.notify = function () {\n  // stablize the subscriber list first\n  var subs = toArray(this.subs);\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto)\n\n/**\n * Intercept mutating methods and emit events\n */\n\n;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator() {\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break;\n      case 'unshift':\n        inserted = args;\n        break;\n      case 'splice':\n        inserted = args.slice(2);\n        break;\n    }\n    if (inserted) ob.observeArray(inserted);\n    // notify change\n    ob.dep.notify();\n    return result;\n  });\n});\n\n/**\n * Swap the element at the given index with a new value\n * and emits corresponding event.\n *\n * @param {Number} index\n * @param {*} val\n * @return {*} - replaced element\n */\n\ndef(arrayProto, '$set', function $set(index, val) {\n  if (index >= this.length) {\n    this.length = Number(index) + 1;\n  }\n  return this.splice(index, 1, val)[0];\n});\n\n/**\n * Convenience method to remove the element at given index or target element reference.\n *\n * @param {*} item\n */\n\ndef(arrayProto, '$remove', function $remove(item) {\n  /* istanbul ignore if */\n  if (!this.length) return;\n  var index = indexOf(this, item);\n  if (index > -1) {\n    return this.splice(index, 1);\n  }\n});\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However in certain cases, e.g.\n * v-for scope alias and props, we don't want to force conversion\n * because the value may be a nested value under a frozen data structure.\n *\n * So whenever we want to set a reactive property without forcing\n * conversion on the new value, we wrap that call inside this function.\n */\n\nvar shouldConvert = true;\n\nfunction withoutConversion(fn) {\n  shouldConvert = false;\n  fn();\n  shouldConvert = true;\n}\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n *\n * @param {Array|Object} value\n * @constructor\n */\n\nfunction Observer(value) {\n  this.value = value;\n  this.dep = new Dep();\n  def(value, '__ob__', this);\n  if (isArray(value)) {\n    var augment = hasProto ? protoAugment : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n}\n\n// Instance methods\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n *\n * @param {Object} obj\n */\n\nObserver.prototype.walk = function (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    this.convert(keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n *\n * @param {Array} items\n */\n\nObserver.prototype.observeArray = function (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n/**\n * Convert a property into getter/setter so we can emit\n * the events when the property is accessed/changed.\n *\n * @param {String} key\n * @param {*} val\n */\n\nObserver.prototype.convert = function (key, val) {\n  defineReactive(this.value, key, val);\n};\n\n/**\n * Add an owner vm, so that when $set/$delete mutations\n * happen we can notify owner vms to proxy the keys and\n * digest the watchers. This is only called when the object\n * is observed as an instance's root $data.\n *\n * @param {Vue} vm\n */\n\nObserver.prototype.addVm = function (vm) {\n  (this.vms || (this.vms = [])).push(vm);\n};\n\n/**\n * Remove an owner vm. This is called when the object is\n * swapped out as an instance's $data object.\n *\n * @param {Vue} vm\n */\n\nObserver.prototype.removeVm = function (vm) {\n  this.vms.$remove(vm);\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n *\n * @param {Object|Array} target\n * @param {Object} src\n */\n\nfunction protoAugment(target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n *\n * @param {Object|Array} target\n * @param {Object} proto\n */\n\nfunction copyAugment(target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\n * @param {*} value\n * @param {Vue} [vm]\n * @return {Observer|undefined}\n * @static\n */\n\nfunction observe(value, vm) {\n  if (!value || typeof value !== 'object') {\n    return;\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n    ob = new Observer(value);\n  }\n  if (ob && vm) {\n    ob.addVm(vm);\n  }\n  return ob;\n}\n\n/**\n * Define a reactive property on an Object.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n */\n\nfunction defineReactive(obj, key, val) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return;\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (isArray(value)) {\n          for (var e, i = 0, l = value.length; i < l; i++) {\n            e = value[i];\n            e && e.__ob__ && e.__ob__.dep.depend();\n          }\n        }\n      }\n      return value;\n    },\n    set: function reactiveSetter(newVal) {\n      var value = getter ? getter.call(obj) : val;\n      if (newVal === value) {\n        return;\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n\n\nvar util = Object.freeze({\n\tdefineReactive: defineReactive,\n\tset: set,\n\tdel: del,\n\thasOwn: hasOwn,\n\tisLiteral: isLiteral,\n\tisReserved: isReserved,\n\t_toString: _toString,\n\ttoNumber: toNumber,\n\ttoBoolean: toBoolean,\n\tstripQuotes: stripQuotes,\n\tcamelize: camelize,\n\thyphenate: hyphenate,\n\tclassify: classify,\n\tbind: bind,\n\ttoArray: toArray,\n\textend: extend,\n\tisObject: isObject,\n\tisPlainObject: isPlainObject,\n\tdef: def,\n\tdebounce: _debounce,\n\tindexOf: indexOf,\n\tcancellable: cancellable,\n\tlooseEqual: looseEqual,\n\tisArray: isArray,\n\thasProto: hasProto,\n\tinBrowser: inBrowser,\n\tdevtools: devtools,\n\tisIE: isIE,\n\tisIE9: isIE9,\n\tisAndroid: isAndroid,\n\tisIos: isIos,\n\tiosVersionMatch: iosVersionMatch,\n\tiosVersion: iosVersion,\n\thasMutationObserverBug: hasMutationObserverBug,\n\tget transitionProp () { return transitionProp; },\n\tget transitionEndEvent () { return transitionEndEvent; },\n\tget animationProp () { return animationProp; },\n\tget animationEndEvent () { return animationEndEvent; },\n\tnextTick: nextTick,\n\tget _Set () { return _Set; },\n\tquery: query,\n\tinDoc: inDoc,\n\tgetAttr: getAttr,\n\tgetBindAttr: getBindAttr,\n\thasBindAttr: hasBindAttr,\n\tbefore: before,\n\tafter: after,\n\tremove: remove,\n\tprepend: prepend,\n\treplace: replace,\n\ton: on,\n\toff: off,\n\tsetClass: setClass,\n\taddClass: addClass,\n\tremoveClass: removeClass,\n\textractContent: extractContent,\n\ttrimNode: trimNode,\n\tisTemplate: isTemplate,\n\tcreateAnchor: createAnchor,\n\tfindRef: findRef,\n\tmapNodeRange: mapNodeRange,\n\tremoveNodeRange: removeNodeRange,\n\tisFragment: isFragment,\n\tgetOuterHTML: getOuterHTML,\n\tmergeOptions: mergeOptions,\n\tresolveAsset: resolveAsset,\n\tcheckComponentAttr: checkComponentAttr,\n\tcommonTagRE: commonTagRE,\n\treservedTagRE: reservedTagRE,\n\tget warn () { return warn; }\n});\n\nvar uid = 0;\n\nfunction initMixin (Vue) {\n  /**\n   * The main init sequence. This is called for every\n   * instance, including ones that are created from extended\n   * constructors.\n   *\n   * @param {Object} options - this options object should be\n   *                           the result of merging class\n   *                           options and the options passed\n   *                           in to the constructor.\n   */\n\n  Vue.prototype._init = function (options) {\n    options = options || {};\n\n    this.$el = null;\n    this.$parent = options.parent;\n    this.$root = this.$parent ? this.$parent.$root : this;\n    this.$children = [];\n    this.$refs = {}; // child vm references\n    this.$els = {}; // element references\n    this._watchers = []; // all watchers as an array\n    this._directives = []; // all directives\n\n    // a uid\n    this._uid = uid++;\n\n    // a flag to avoid this being observed\n    this._isVue = true;\n\n    // events bookkeeping\n    this._events = {}; // registered callbacks\n    this._eventsCount = {}; // for $broadcast optimization\n\n    // fragment instance properties\n    this._isFragment = false;\n    this._fragment = // @type {DocumentFragment}\n    this._fragmentStart = // @type {Text|Comment}\n    this._fragmentEnd = null; // @type {Text|Comment}\n\n    // lifecycle state\n    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;\n    this._unlinkFn = null;\n\n    // context:\n    // if this is a transcluded component, context\n    // will be the common parent vm of this instance\n    // and its host.\n    this._context = options._context || this.$parent;\n\n    // scope:\n    // if this is inside an inline v-for, the scope\n    // will be the intermediate scope created for this\n    // repeat fragment. this is used for linking props\n    // and container directives.\n    this._scope = options._scope;\n\n    // fragment:\n    // if this instance is compiled inside a Fragment, it\n    // needs to reigster itself as a child of that fragment\n    // for attach/detach to work properly.\n    this._frag = options._frag;\n    if (this._frag) {\n      this._frag.children.push(this);\n    }\n\n    // push self into parent / transclusion host\n    if (this.$parent) {\n      this.$parent.$children.push(this);\n    }\n\n    // merge options.\n    options = this.$options = mergeOptions(this.constructor.options, options, this);\n\n    // set ref\n    this._updateRef();\n\n    // initialize data as empty object.\n    // it will be filled up in _initData().\n    this._data = {};\n\n    // call init hook\n    this._callHook('init');\n\n    // initialize data observation and scope inheritance.\n    this._initState();\n\n    // setup event system and option events.\n    this._initEvents();\n\n    // call created hook\n    this._callHook('created');\n\n    // if `el` option is passed, start compilation.\n    if (options.el) {\n      this.$mount(options.el);\n    }\n  };\n}\n\nvar pathCache = new Cache(1000);\n\n// actions\nvar APPEND = 0;\nvar PUSH = 1;\nvar INC_SUB_PATH_DEPTH = 2;\nvar PUSH_SUB_PATH = 3;\n\n// states\nvar BEFORE_PATH = 0;\nvar IN_PATH = 1;\nvar BEFORE_IDENT = 2;\nvar IN_IDENT = 3;\nvar IN_SUB_PATH = 4;\nvar IN_SINGLE_QUOTE = 5;\nvar IN_DOUBLE_QUOTE = 6;\nvar AFTER_PATH = 7;\nvar ERROR = 8;\n\nvar pathStateMachine = [];\n\npathStateMachine[BEFORE_PATH] = {\n  'ws': [BEFORE_PATH],\n  'ident': [IN_IDENT, APPEND],\n  '[': [IN_SUB_PATH],\n  'eof': [AFTER_PATH]\n};\n\npathStateMachine[IN_PATH] = {\n  'ws': [IN_PATH],\n  '.': [BEFORE_IDENT],\n  '[': [IN_SUB_PATH],\n  'eof': [AFTER_PATH]\n};\n\npathStateMachine[BEFORE_IDENT] = {\n  'ws': [BEFORE_IDENT],\n  'ident': [IN_IDENT, APPEND]\n};\n\npathStateMachine[IN_IDENT] = {\n  'ident': [IN_IDENT, APPEND],\n  '0': [IN_IDENT, APPEND],\n  'number': [IN_IDENT, APPEND],\n  'ws': [IN_PATH, PUSH],\n  '.': [BEFORE_IDENT, PUSH],\n  '[': [IN_SUB_PATH, PUSH],\n  'eof': [AFTER_PATH, PUSH]\n};\n\npathStateMachine[IN_SUB_PATH] = {\n  \"'\": [IN_SINGLE_QUOTE, APPEND],\n  '\"': [IN_DOUBLE_QUOTE, APPEND],\n  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],\n  ']': [IN_PATH, PUSH_SUB_PATH],\n  'eof': ERROR,\n  'else': [IN_SUB_PATH, APPEND]\n};\n\npathStateMachine[IN_SINGLE_QUOTE] = {\n  \"'\": [IN_SUB_PATH, APPEND],\n  'eof': ERROR,\n  'else': [IN_SINGLE_QUOTE, APPEND]\n};\n\npathStateMachine[IN_DOUBLE_QUOTE] = {\n  '\"': [IN_SUB_PATH, APPEND],\n  'eof': ERROR,\n  'else': [IN_DOUBLE_QUOTE, APPEND]\n};\n\n/**\n * Determine the type of a character in a keypath.\n *\n * @param {Char} ch\n * @return {String} type\n */\n\nfunction getPathCharType(ch) {\n  if (ch === undefined) {\n    return 'eof';\n  }\n\n  var code = ch.charCodeAt(0);\n\n  switch (code) {\n    case 0x5B: // [\n    case 0x5D: // ]\n    case 0x2E: // .\n    case 0x22: // \"\n    case 0x27: // '\n    case 0x30:\n      // 0\n      return ch;\n\n    case 0x5F: // _\n    case 0x24:\n      // $\n      return 'ident';\n\n    case 0x20: // Space\n    case 0x09: // Tab\n    case 0x0A: // Newline\n    case 0x0D: // Return\n    case 0xA0: // No-break space\n    case 0xFEFF: // Byte Order Mark\n    case 0x2028: // Line Separator\n    case 0x2029:\n      // Paragraph Separator\n      return 'ws';\n  }\n\n  // a-z, A-Z\n  if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {\n    return 'ident';\n  }\n\n  // 1-9\n  if (code >= 0x31 && code <= 0x39) {\n    return 'number';\n  }\n\n  return 'else';\n}\n\n/**\n * Format a subPath, return its plain form if it is\n * a literal string or number. Otherwise prepend the\n * dynamic indicator (*).\n *\n * @param {String} path\n * @return {String}\n */\n\nfunction formatSubPath(path) {\n  var trimmed = path.trim();\n  // invalid leading 0\n  if (path.charAt(0) === '0' && isNaN(path)) {\n    return false;\n  }\n  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;\n}\n\n/**\n * Parse a string path into an array of segments\n *\n * @param {String} path\n * @return {Array|undefined}\n */\n\nfunction parse(path) {\n  var keys = [];\n  var index = -1;\n  var mode = BEFORE_PATH;\n  var subPathDepth = 0;\n  var c, newChar, key, type, transition, action, typeMap;\n\n  var actions = [];\n\n  actions[PUSH] = function () {\n    if (key !== undefined) {\n      keys.push(key);\n      key = undefined;\n    }\n  };\n\n  actions[APPEND] = function () {\n    if (key === undefined) {\n      key = newChar;\n    } else {\n      key += newChar;\n    }\n  };\n\n  actions[INC_SUB_PATH_DEPTH] = function () {\n    actions[APPEND]();\n    subPathDepth++;\n  };\n\n  actions[PUSH_SUB_PATH] = function () {\n    if (subPathDepth > 0) {\n      subPathDepth--;\n      mode = IN_SUB_PATH;\n      actions[APPEND]();\n    } else {\n      subPathDepth = 0;\n      key = formatSubPath(key);\n      if (key === false) {\n        return false;\n      } else {\n        actions[PUSH]();\n      }\n    }\n  };\n\n  function maybeUnescapeQuote() {\n    var nextChar = path[index + 1];\n    if (mode === IN_SINGLE_QUOTE && nextChar === \"'\" || mode === IN_DOUBLE_QUOTE && nextChar === '\"') {\n      index++;\n      newChar = '\\\\' + nextChar;\n      actions[APPEND]();\n      return true;\n    }\n  }\n\n  while (mode != null) {\n    index++;\n    c = path[index];\n\n    if (c === '\\\\' && maybeUnescapeQuote()) {\n      continue;\n    }\n\n    type = getPathCharType(c);\n    typeMap = pathStateMachine[mode];\n    transition = typeMap[type] || typeMap['else'] || ERROR;\n\n    if (transition === ERROR) {\n      return; // parse error\n    }\n\n    mode = transition[0];\n    action = actions[transition[1]];\n    if (action) {\n      newChar = transition[2];\n      newChar = newChar === undefined ? c : newChar;\n      if (action() === false) {\n        return;\n      }\n    }\n\n    if (mode === AFTER_PATH) {\n      keys.raw = path;\n      return keys;\n    }\n  }\n}\n\n/**\n * External parse that check for a cache hit first\n *\n * @param {String} path\n * @return {Array|undefined}\n */\n\nfunction parsePath(path) {\n  var hit = pathCache.get(path);\n  if (!hit) {\n    hit = parse(path);\n    if (hit) {\n      pathCache.put(path, hit);\n    }\n  }\n  return hit;\n}\n\n/**\n * Get from an object from a path string\n *\n * @param {Object} obj\n * @param {String} path\n */\n\nfunction getPath(obj, path) {\n  return parseExpression(path).get(obj);\n}\n\n/**\n * Warn against setting non-existent root path on a vm.\n */\n\nvar warnNonExistent;\nif (process.env.NODE_ENV !== 'production') {\n  warnNonExistent = function (path, vm) {\n    warn('You are setting a non-existent path \"' + path.raw + '\" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the \"data\" option for more reliable reactivity ' + 'and better performance.', vm);\n  };\n}\n\n/**\n * Set on an object from a path\n *\n * @param {Object} obj\n * @param {String | Array} path\n * @param {*} val\n */\n\nfunction setPath(obj, path, val) {\n  var original = obj;\n  if (typeof path === 'string') {\n    path = parse(path);\n  }\n  if (!path || !isObject(obj)) {\n    return false;\n  }\n  var last, key;\n  for (var i = 0, l = path.length; i < l; i++) {\n    last = obj;\n    key = path[i];\n    if (key.charAt(0) === '*') {\n      key = parseExpression(key.slice(1)).get.call(original, original);\n    }\n    if (i < l - 1) {\n      obj = obj[key];\n      if (!isObject(obj)) {\n        obj = {};\n        if (process.env.NODE_ENV !== 'production' && last._isVue) {\n          warnNonExistent(path, last);\n        }\n        set(last, key, obj);\n      }\n    } else {\n      if (isArray(obj)) {\n        obj.$set(key, val);\n      } else if (key in obj) {\n        obj[key] = val;\n      } else {\n        if (process.env.NODE_ENV !== 'production' && obj._isVue) {\n          warnNonExistent(path, obj);\n        }\n        set(obj, key, val);\n      }\n    }\n  }\n  return true;\n}\n\nvar path = Object.freeze({\n  parsePath: parsePath,\n  getPath: getPath,\n  setPath: setPath\n});\n\nvar expressionCache = new Cache(1000);\n\nvar allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';\nvar allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\n// keywords that don't make sense inside expressions\nvar improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';\nvar improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\nvar wsRE = /\\s/g;\nvar newlineRE = /\\n/g;\nvar saveRE = /[\\{,]\\s*[\\w\\$_]+\\s*:|('(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`)|new |typeof |void /g;\nvar restoreRE = /\"(\\d+)\"/g;\nvar pathTestRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*$/;\nvar identRE = /[^\\w$\\.](?:[A-Za-z_$][\\w$]*)/g;\nvar literalValueRE$1 = /^(?:true|false|null|undefined|Infinity|NaN)$/;\n\nfunction noop() {}\n\n/**\n * Save / Rewrite / Restore\n *\n * When rewriting paths found in an expression, it is\n * possible for the same letter sequences to be found in\n * strings and Object literal property keys. Therefore we\n * remove and store these parts in a temporary array, and\n * restore them after the path rewrite.\n */\n\nvar saved = [];\n\n/**\n * Save replacer\n *\n * The save regex can match two possible cases:\n * 1. An opening object literal\n * 2. A string\n * If matched as a plain string, we need to escape its\n * newlines, since the string needs to be preserved when\n * generating the function body.\n *\n * @param {String} str\n * @param {String} isString - str if matched as a string\n * @return {String} - placeholder with index\n */\n\nfunction save(str, isString) {\n  var i = saved.length;\n  saved[i] = isString ? str.replace(newlineRE, '\\\\n') : str;\n  return '\"' + i + '\"';\n}\n\n/**\n * Path rewrite replacer\n *\n * @param {String} raw\n * @return {String}\n */\n\nfunction rewrite(raw) {\n  var c = raw.charAt(0);\n  var path = raw.slice(1);\n  if (allowedKeywordsRE.test(path)) {\n    return raw;\n  } else {\n    path = path.indexOf('\"') > -1 ? path.replace(restoreRE, restore) : path;\n    return c + 'scope.' + path;\n  }\n}\n\n/**\n * Restore replacer\n *\n * @param {String} str\n * @param {String} i - matched save index\n * @return {String}\n */\n\nfunction restore(str, i) {\n  return saved[i];\n}\n\n/**\n * Rewrite an expression, prefixing all path accessors with\n * `scope.` and generate getter/setter functions.\n *\n * @param {String} exp\n * @return {Function}\n */\n\nfunction compileGetter(exp) {\n  if (improperKeywordsRE.test(exp)) {\n    process.env.NODE_ENV !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);\n  }\n  // reset state\n  saved.length = 0;\n  // save strings and object literal keys\n  var body = exp.replace(saveRE, save).replace(wsRE, '');\n  // rewrite all paths\n  // pad 1 space here because the regex matches 1 extra char\n  body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);\n  return makeGetterFn(body);\n}\n\n/**\n * Build a getter function. Requires eval.\n *\n * We isolate the try/catch so it doesn't affect the\n * optimization of the parse function when it is not called.\n *\n * @param {String} body\n * @return {Function|undefined}\n */\n\nfunction makeGetterFn(body) {\n  try {\n    /* eslint-disable no-new-func */\n    return new Function('scope', 'return ' + body + ';');\n    /* eslint-enable no-new-func */\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if (e.toString().match(/unsafe-eval|CSP/)) {\n        warn('It seems you are using the default build of Vue.js in an environment ' + 'with Content Security Policy that prohibits unsafe-eval. ' + 'Use the CSP-compliant build instead: ' + 'http://vuejs.org/guide/installation.html#CSP-compliant-build');\n      } else {\n        warn('Invalid expression. ' + 'Generated function body: ' + body);\n      }\n    }\n    return noop;\n  }\n}\n\n/**\n * Compile a setter function for the expression.\n *\n * @param {String} exp\n * @return {Function|undefined}\n */\n\nfunction compileSetter(exp) {\n  var path = parsePath(exp);\n  if (path) {\n    return function (scope, val) {\n      setPath(scope, path, val);\n    };\n  } else {\n    process.env.NODE_ENV !== 'production' && warn('Invalid setter expression: ' + exp);\n  }\n}\n\n/**\n * Parse an expression into re-written getter/setters.\n *\n * @param {String} exp\n * @param {Boolean} needSet\n * @return {Function}\n */\n\nfunction parseExpression(exp, needSet) {\n  exp = exp.trim();\n  // try cache\n  var hit = expressionCache.get(exp);\n  if (hit) {\n    if (needSet && !hit.set) {\n      hit.set = compileSetter(hit.exp);\n    }\n    return hit;\n  }\n  var res = { exp: exp };\n  res.get = isSimplePath(exp) && exp.indexOf('[') < 0\n  // optimized super simple getter\n  ? makeGetterFn('scope.' + exp)\n  // dynamic getter\n  : compileGetter(exp);\n  if (needSet) {\n    res.set = compileSetter(exp);\n  }\n  expressionCache.put(exp, res);\n  return res;\n}\n\n/**\n * Check if an expression is a simple path.\n *\n * @param {String} exp\n * @return {Boolean}\n */\n\nfunction isSimplePath(exp) {\n  return pathTestRE.test(exp) &&\n  // don't treat literal values as paths\n  !literalValueRE$1.test(exp) &&\n  // Math constants e.g. Math.PI, Math.E etc.\n  exp.slice(0, 5) !== 'Math.';\n}\n\nvar expression = Object.freeze({\n  parseExpression: parseExpression,\n  isSimplePath: isSimplePath\n});\n\n// we have two separate queues: one for directive updates\n// and one for user watcher registered via $watch().\n// we want to guarantee directive updates to be called\n// before user watchers so that when user watchers are\n// triggered, the DOM would have already been in updated\n// state.\n\nvar queue = [];\nvar userQueue = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\n\n/**\n * Reset the batcher's state.\n */\n\nfunction resetBatcherState() {\n  queue.length = 0;\n  userQueue.length = 0;\n  has = {};\n  circular = {};\n  waiting = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\n\nfunction flushBatcherQueue() {\n  var _again = true;\n\n  _function: while (_again) {\n    _again = false;\n\n    runBatcherQueue(queue);\n    runBatcherQueue(userQueue);\n    // user watchers triggered more watchers,\n    // keep flushing until it depletes\n    if (queue.length) {\n      _again = true;\n      continue _function;\n    }\n    // dev tool hook\n    /* istanbul ignore if */\n    if (devtools && config.devtools) {\n      devtools.emit('flush');\n    }\n    resetBatcherState();\n  }\n}\n\n/**\n * Run the watchers in a single queue.\n *\n * @param {Array} queue\n */\n\nfunction runBatcherQueue(queue) {\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (var i = 0; i < queue.length; i++) {\n    var watcher = queue[i];\n    var id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > config._maxUpdateCount) {\n        warn('You may have an infinite update loop for watcher ' + 'with expression \"' + watcher.expression + '\"', watcher.vm);\n        break;\n      }\n    }\n  }\n  queue.length = 0;\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n *\n * @param {Watcher} watcher\n *   properties:\n *   - {Number} id\n *   - {Function} run\n */\n\nfunction pushWatcher(watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    // push watcher into appropriate queue\n    var q = watcher.user ? userQueue : queue;\n    has[id] = q.length;\n    q.push(watcher);\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushBatcherQueue);\n    }\n  }\n}\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n *\n * @param {Vue} vm\n * @param {String|Function} expOrFn\n * @param {Function} cb\n * @param {Object} options\n *                 - {Array} filters\n *                 - {Boolean} twoWay\n *                 - {Boolean} deep\n *                 - {Boolean} user\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n *                 - {Function} [preProcess]\n *                 - {Function} [postProcess]\n * @constructor\n */\nfunction Watcher(vm, expOrFn, cb, options) {\n  // mix in options\n  if (options) {\n    extend(this, options);\n  }\n  var isFn = typeof expOrFn === 'function';\n  this.vm = vm;\n  vm._watchers.push(this);\n  this.expression = expOrFn;\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.prevError = null; // for async error stacks\n  // parse expression for getter/setter\n  if (isFn) {\n    this.getter = expOrFn;\n    this.setter = undefined;\n  } else {\n    var res = parseExpression(expOrFn, this.twoWay);\n    this.getter = res.get;\n    this.setter = res.set;\n  }\n  this.value = this.lazy ? undefined : this.get();\n  // state for avoiding false triggers for deep and Array\n  // watchers during vm._digest()\n  this.queued = this.shallow = false;\n}\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\n\nWatcher.prototype.get = function () {\n  this.beforeGet();\n  var scope = this.scope || this.vm;\n  var value;\n  try {\n    value = this.getter.call(scope, scope);\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {\n      warn('Error when evaluating expression ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\n    }\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  if (this.preProcess) {\n    value = this.preProcess(value);\n  }\n  if (this.filters) {\n    value = scope._applyFilters(value, null, this.filters, false);\n  }\n  if (this.postProcess) {\n    value = this.postProcess(value);\n  }\n  this.afterGet();\n  return value;\n};\n\n/**\n * Set the corresponding value with the setter.\n *\n * @param {*} value\n */\n\nWatcher.prototype.set = function (value) {\n  var scope = this.scope || this.vm;\n  if (this.filters) {\n    value = scope._applyFilters(value, this.value, this.filters, true);\n  }\n  try {\n    this.setter.call(scope, scope, value);\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {\n      warn('Error when evaluating setter ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\n    }\n  }\n  // two-way sync for v-for alias\n  var forContext = scope.$forContext;\n  if (forContext && forContext.alias === this.expression) {\n    if (forContext.filters) {\n      process.env.NODE_ENV !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);\n      return;\n    }\n    forContext._withLock(function () {\n      if (scope.$key) {\n        // original is an object\n        forContext.rawValue[scope.$key] = value;\n      } else {\n        forContext.rawValue.$set(scope.$index, value);\n      }\n    });\n  }\n};\n\n/**\n * Prepare for dependency collection.\n */\n\nWatcher.prototype.beforeGet = function () {\n  Dep.target = this;\n};\n\n/**\n * Add a dependency to this directive.\n *\n * @param {Dep} dep\n */\n\nWatcher.prototype.addDep = function (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\n\nWatcher.prototype.afterGet = function () {\n  Dep.target = null;\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this.deps[i];\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n *\n * @param {Boolean} shallow\n */\n\nWatcher.prototype.update = function (shallow) {\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync || !config.async) {\n    this.run();\n  } else {\n    // if queued, only overwrite shallow with non-shallow,\n    // but not the other way around.\n    this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;\n    this.queued = true;\n    // record before-push error stack in debug mode\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.debug) {\n      this.prevError = new Error('[vue] async stack trace');\n    }\n    pushWatcher(this);\n  }\n};\n\n/**\n * Batcher job interface.\n * Will be called by the batcher.\n */\n\nWatcher.prototype.run = function () {\n  if (this.active) {\n    var value = this.get();\n    if (value !== this.value ||\n    // Deep watchers and watchers on Object/Arrays should fire even\n    // when the value is the same, because the value may\n    // have mutated; but only do so if this is a\n    // non-shallow update (caused by a vm digest).\n    (isObject(value) || this.deep) && !this.shallow) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      // in debug + async mode, when a watcher callbacks\n      // throws, we also throw the saved before-push error\n      // so the full cross-tick stack trace is available.\n      var prevError = this.prevError;\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.debug && prevError) {\n        this.prevError = null;\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          nextTick(function () {\n            throw prevError;\n          }, 0);\n          throw e;\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n    this.queued = this.shallow = false;\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\n\nWatcher.prototype.evaluate = function () {\n  // avoid overwriting another watcher that is being\n  // collected.\n  var current = Dep.target;\n  this.value = this.get();\n  this.dirty = false;\n  Dep.target = current;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\n\nWatcher.prototype.depend = function () {\n  var i = this.deps.length;\n  while (i--) {\n    this.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subcriber list.\n */\n\nWatcher.prototype.teardown = function () {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed or is performing a v-for\n    // re-render (the watcher list is then filtered by v-for).\n    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {\n      this.vm._watchers.$remove(this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].removeSub(this);\n    }\n    this.active = false;\n    this.vm = this.cb = this.value = null;\n  }\n};\n\n/**\n * Recrusively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n *\n * @param {*} val\n */\n\nvar seenObjects = new _Set();\nfunction traverse(val, seen) {\n  var i = undefined,\n      keys = undefined;\n  if (!seen) {\n    seen = seenObjects;\n    seen.clear();\n  }\n  var isA = isArray(val);\n  var isO = isObject(val);\n  if ((isA || isO) && Object.isExtensible(val)) {\n    if (val.__ob__) {\n      var depId = val.__ob__.dep.id;\n      if (seen.has(depId)) {\n        return;\n      } else {\n        seen.add(depId);\n      }\n    }\n    if (isA) {\n      i = val.length;\n      while (i--) traverse(val[i], seen);\n    } else if (isO) {\n      keys = Object.keys(val);\n      i = keys.length;\n      while (i--) traverse(val[keys[i]], seen);\n    }\n  }\n}\n\nvar text$1 = {\n\n  bind: function bind() {\n    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';\n  },\n\n  update: function update(value) {\n    this.el[this.attr] = _toString(value);\n  }\n};\n\nvar templateCache = new Cache(1000);\nvar idSelectorCache = new Cache(1000);\n\nvar map = {\n  efault: [0, '', ''],\n  legend: [1, '<fieldset>', '</fieldset>'],\n  tr: [2, '<table><tbody>', '</tbody></table>'],\n  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']\n};\n\nmap.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\n\nmap.option = map.optgroup = [1, '<select multiple=\"multiple\">', '</select>'];\n\nmap.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];\n\nmap.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns=\"http://www.w3.org/2000/svg\" ' + 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' + 'xmlns:ev=\"http://www.w3.org/2001/xml-events\"' + 'version=\"1.1\">', '</svg>'];\n\n/**\n * Check if a node is a supported template node with a\n * DocumentFragment content.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nfunction isRealTemplate(node) {\n  return isTemplate(node) && isFragment(node.content);\n}\n\nvar tagRE$1 = /<([\\w:-]+)/;\nvar entityRE = /&#?\\w+?;/;\nvar commentRE = /<!--/;\n\n/**\n * Convert a string template to a DocumentFragment.\n * Determines correct wrapping by tag types. Wrapping\n * strategy found in jQuery & component/domify.\n *\n * @param {String} templateString\n * @param {Boolean} raw\n * @return {DocumentFragment}\n */\n\nfunction stringToFragment(templateString, raw) {\n  // try a cache hit first\n  var cacheKey = raw ? templateString : templateString.trim();\n  var hit = templateCache.get(cacheKey);\n  if (hit) {\n    return hit;\n  }\n\n  var frag = document.createDocumentFragment();\n  var tagMatch = templateString.match(tagRE$1);\n  var entityMatch = entityRE.test(templateString);\n  var commentMatch = commentRE.test(templateString);\n\n  if (!tagMatch && !entityMatch && !commentMatch) {\n    // text only, return a single text node.\n    frag.appendChild(document.createTextNode(templateString));\n  } else {\n    var tag = tagMatch && tagMatch[1];\n    var wrap = map[tag] || map.efault;\n    var depth = wrap[0];\n    var prefix = wrap[1];\n    var suffix = wrap[2];\n    var node = document.createElement('div');\n\n    node.innerHTML = prefix + templateString + suffix;\n    while (depth--) {\n      node = node.lastChild;\n    }\n\n    var child;\n    /* eslint-disable no-cond-assign */\n    while (child = node.firstChild) {\n      /* eslint-enable no-cond-assign */\n      frag.appendChild(child);\n    }\n  }\n  if (!raw) {\n    trimNode(frag);\n  }\n  templateCache.put(cacheKey, frag);\n  return frag;\n}\n\n/**\n * Convert a template node to a DocumentFragment.\n *\n * @param {Node} node\n * @return {DocumentFragment}\n */\n\nfunction nodeToFragment(node) {\n  // if its a template tag and the browser supports it,\n  // its content is already a document fragment. However, iOS Safari has\n  // bug when using directly cloned template content with touch\n  // events and can cause crashes when the nodes are removed from DOM, so we\n  // have to treat template elements as string templates. (#2805)\n  /* istanbul ignore if */\n  if (isRealTemplate(node)) {\n    return stringToFragment(node.innerHTML);\n  }\n  // script template\n  if (node.tagName === 'SCRIPT') {\n    return stringToFragment(node.textContent);\n  }\n  // normal node, clone it to avoid mutating the original\n  var clonedNode = cloneNode(node);\n  var frag = document.createDocumentFragment();\n  var child;\n  /* eslint-disable no-cond-assign */\n  while (child = clonedNode.firstChild) {\n    /* eslint-enable no-cond-assign */\n    frag.appendChild(child);\n  }\n  trimNode(frag);\n  return frag;\n}\n\n// Test for the presence of the Safari template cloning bug\n// https://bugs.webkit.org/showug.cgi?id=137755\nvar hasBrokenTemplate = (function () {\n  /* istanbul ignore else */\n  if (inBrowser) {\n    var a = document.createElement('div');\n    a.innerHTML = '<template>1</template>';\n    return !a.cloneNode(true).firstChild.innerHTML;\n  } else {\n    return false;\n  }\n})();\n\n// Test for IE10/11 textarea placeholder clone bug\nvar hasTextareaCloneBug = (function () {\n  /* istanbul ignore else */\n  if (inBrowser) {\n    var t = document.createElement('textarea');\n    t.placeholder = 't';\n    return t.cloneNode(true).value === 't';\n  } else {\n    return false;\n  }\n})();\n\n/**\n * 1. Deal with Safari cloning nested <template> bug by\n *    manually cloning all template instances.\n * 2. Deal with IE10/11 textarea placeholder bug by setting\n *    the correct value after cloning.\n *\n * @param {Element|DocumentFragment} node\n * @return {Element|DocumentFragment}\n */\n\nfunction cloneNode(node) {\n  /* istanbul ignore if */\n  if (!node.querySelectorAll) {\n    return node.cloneNode();\n  }\n  var res = node.cloneNode(true);\n  var i, original, cloned;\n  /* istanbul ignore if */\n  if (hasBrokenTemplate) {\n    var tempClone = res;\n    if (isRealTemplate(node)) {\n      node = node.content;\n      tempClone = res.content;\n    }\n    original = node.querySelectorAll('template');\n    if (original.length) {\n      cloned = tempClone.querySelectorAll('template');\n      i = cloned.length;\n      while (i--) {\n        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);\n      }\n    }\n  }\n  /* istanbul ignore if */\n  if (hasTextareaCloneBug) {\n    if (node.tagName === 'TEXTAREA') {\n      res.value = node.value;\n    } else {\n      original = node.querySelectorAll('textarea');\n      if (original.length) {\n        cloned = res.querySelectorAll('textarea');\n        i = cloned.length;\n        while (i--) {\n          cloned[i].value = original[i].value;\n        }\n      }\n    }\n  }\n  return res;\n}\n\n/**\n * Process the template option and normalizes it into a\n * a DocumentFragment that can be used as a partial or a\n * instance template.\n *\n * @param {*} template\n *        Possible values include:\n *        - DocumentFragment object\n *        - Node object of type Template\n *        - id selector: '#some-template-id'\n *        - template string: '<div><span>{{msg}}</span></div>'\n * @param {Boolean} shouldClone\n * @param {Boolean} raw\n *        inline HTML interpolation. Do not check for id\n *        selector and keep whitespace in the string.\n * @return {DocumentFragment|undefined}\n */\n\nfunction parseTemplate(template, shouldClone, raw) {\n  var node, frag;\n\n  // if the template is already a document fragment,\n  // do nothing\n  if (isFragment(template)) {\n    trimNode(template);\n    return shouldClone ? cloneNode(template) : template;\n  }\n\n  if (typeof template === 'string') {\n    // id selector\n    if (!raw && template.charAt(0) === '#') {\n      // id selector can be cached too\n      frag = idSelectorCache.get(template);\n      if (!frag) {\n        node = document.getElementById(template.slice(1));\n        if (node) {\n          frag = nodeToFragment(node);\n          // save selector to cache\n          idSelectorCache.put(template, frag);\n        }\n      }\n    } else {\n      // normal string template\n      frag = stringToFragment(template, raw);\n    }\n  } else if (template.nodeType) {\n    // a direct node\n    frag = nodeToFragment(template);\n  }\n\n  return frag && shouldClone ? cloneNode(frag) : frag;\n}\n\nvar template = Object.freeze({\n  cloneNode: cloneNode,\n  parseTemplate: parseTemplate\n});\n\nvar html = {\n\n  bind: function bind() {\n    // a comment node means this is a binding for\n    // {{{ inline unescaped html }}}\n    if (this.el.nodeType === 8) {\n      // hold nodes\n      this.nodes = [];\n      // replace the placeholder with proper anchor\n      this.anchor = createAnchor('v-html');\n      replace(this.el, this.anchor);\n    }\n  },\n\n  update: function update(value) {\n    value = _toString(value);\n    if (this.nodes) {\n      this.swap(value);\n    } else {\n      this.el.innerHTML = value;\n    }\n  },\n\n  swap: function swap(value) {\n    // remove old nodes\n    var i = this.nodes.length;\n    while (i--) {\n      remove(this.nodes[i]);\n    }\n    // convert new value to a fragment\n    // do not attempt to retrieve from id selector\n    var frag = parseTemplate(value, true, true);\n    // save a reference to these nodes so we can remove later\n    this.nodes = toArray(frag.childNodes);\n    before(frag, this.anchor);\n  }\n};\n\n/**\n * Abstraction for a partially-compiled fragment.\n * Can optionally compile content with a child scope.\n *\n * @param {Function} linker\n * @param {Vue} vm\n * @param {DocumentFragment} frag\n * @param {Vue} [host]\n * @param {Object} [scope]\n * @param {Fragment} [parentFrag]\n */\nfunction Fragment(linker, vm, frag, host, scope, parentFrag) {\n  this.children = [];\n  this.childFrags = [];\n  this.vm = vm;\n  this.scope = scope;\n  this.inserted = false;\n  this.parentFrag = parentFrag;\n  if (parentFrag) {\n    parentFrag.childFrags.push(this);\n  }\n  this.unlink = linker(vm, frag, host, scope, this);\n  var single = this.single = frag.childNodes.length === 1 &&\n  // do not go single mode if the only node is an anchor\n  !frag.childNodes[0].__v_anchor;\n  if (single) {\n    this.node = frag.childNodes[0];\n    this.before = singleBefore;\n    this.remove = singleRemove;\n  } else {\n    this.node = createAnchor('fragment-start');\n    this.end = createAnchor('fragment-end');\n    this.frag = frag;\n    prepend(this.node, frag);\n    frag.appendChild(this.end);\n    this.before = multiBefore;\n    this.remove = multiRemove;\n  }\n  this.node.__v_frag = this;\n}\n\n/**\n * Call attach/detach for all components contained within\n * this fragment. Also do so recursively for all child\n * fragments.\n *\n * @param {Function} hook\n */\n\nFragment.prototype.callHook = function (hook) {\n  var i, l;\n  for (i = 0, l = this.childFrags.length; i < l; i++) {\n    this.childFrags[i].callHook(hook);\n  }\n  for (i = 0, l = this.children.length; i < l; i++) {\n    hook(this.children[i]);\n  }\n};\n\n/**\n * Insert fragment before target, single node version\n *\n * @param {Node} target\n * @param {Boolean} withTransition\n */\n\nfunction singleBefore(target, withTransition) {\n  this.inserted = true;\n  var method = withTransition !== false ? beforeWithTransition : before;\n  method(this.node, target, this.vm);\n  if (inDoc(this.node)) {\n    this.callHook(attach);\n  }\n}\n\n/**\n * Remove fragment, single node version\n */\n\nfunction singleRemove() {\n  this.inserted = false;\n  var shouldCallRemove = inDoc(this.node);\n  var self = this;\n  this.beforeRemove();\n  removeWithTransition(this.node, this.vm, function () {\n    if (shouldCallRemove) {\n      self.callHook(detach);\n    }\n    self.destroy();\n  });\n}\n\n/**\n * Insert fragment before target, multi-nodes version\n *\n * @param {Node} target\n * @param {Boolean} withTransition\n */\n\nfunction multiBefore(target, withTransition) {\n  this.inserted = true;\n  var vm = this.vm;\n  var method = withTransition !== false ? beforeWithTransition : before;\n  mapNodeRange(this.node, this.end, function (node) {\n    method(node, target, vm);\n  });\n  if (inDoc(this.node)) {\n    this.callHook(attach);\n  }\n}\n\n/**\n * Remove fragment, multi-nodes version\n */\n\nfunction multiRemove() {\n  this.inserted = false;\n  var self = this;\n  var shouldCallRemove = inDoc(this.node);\n  this.beforeRemove();\n  removeNodeRange(this.node, this.end, this.vm, this.frag, function () {\n    if (shouldCallRemove) {\n      self.callHook(detach);\n    }\n    self.destroy();\n  });\n}\n\n/**\n * Prepare the fragment for removal.\n */\n\nFragment.prototype.beforeRemove = function () {\n  var i, l;\n  for (i = 0, l = this.childFrags.length; i < l; i++) {\n    // call the same method recursively on child\n    // fragments, depth-first\n    this.childFrags[i].beforeRemove(false);\n  }\n  for (i = 0, l = this.children.length; i < l; i++) {\n    // Call destroy for all contained instances,\n    // with remove:false and defer:true.\n    // Defer is necessary because we need to\n    // keep the children to call detach hooks\n    // on them.\n    this.children[i].$destroy(false, true);\n  }\n  var dirs = this.unlink.dirs;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    // disable the watchers on all the directives\n    // so that the rendered content stays the same\n    // during removal.\n    dirs[i]._watcher && dirs[i]._watcher.teardown();\n  }\n};\n\n/**\n * Destroy the fragment.\n */\n\nFragment.prototype.destroy = function () {\n  if (this.parentFrag) {\n    this.parentFrag.childFrags.$remove(this);\n  }\n  this.node.__v_frag = null;\n  this.unlink();\n};\n\n/**\n * Call attach hook for a Vue instance.\n *\n * @param {Vue} child\n */\n\nfunction attach(child) {\n  if (!child._isAttached && inDoc(child.$el)) {\n    child._callHook('attached');\n  }\n}\n\n/**\n * Call detach hook for a Vue instance.\n *\n * @param {Vue} child\n */\n\nfunction detach(child) {\n  if (child._isAttached && !inDoc(child.$el)) {\n    child._callHook('detached');\n  }\n}\n\nvar linkerCache = new Cache(5000);\n\n/**\n * A factory that can be used to create instances of a\n * fragment. Caches the compiled linker if possible.\n *\n * @param {Vue} vm\n * @param {Element|String} el\n */\nfunction FragmentFactory(vm, el) {\n  this.vm = vm;\n  var template;\n  var isString = typeof el === 'string';\n  if (isString || isTemplate(el) && !el.hasAttribute('v-if')) {\n    template = parseTemplate(el, true);\n  } else {\n    template = document.createDocumentFragment();\n    template.appendChild(el);\n  }\n  this.template = template;\n  // linker can be cached, but only for components\n  var linker;\n  var cid = vm.constructor.cid;\n  if (cid > 0) {\n    var cacheId = cid + (isString ? el : getOuterHTML(el));\n    linker = linkerCache.get(cacheId);\n    if (!linker) {\n      linker = compile(template, vm.$options, true);\n      linkerCache.put(cacheId, linker);\n    }\n  } else {\n    linker = compile(template, vm.$options, true);\n  }\n  this.linker = linker;\n}\n\n/**\n * Create a fragment instance with given host and scope.\n *\n * @param {Vue} host\n * @param {Object} scope\n * @param {Fragment} parentFrag\n */\n\nFragmentFactory.prototype.create = function (host, scope, parentFrag) {\n  var frag = cloneNode(this.template);\n  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);\n};\n\nvar ON = 700;\nvar MODEL = 800;\nvar BIND = 850;\nvar TRANSITION = 1100;\nvar EL = 1500;\nvar COMPONENT = 1500;\nvar PARTIAL = 1750;\nvar IF = 2100;\nvar FOR = 2200;\nvar SLOT = 2300;\n\nvar uid$3 = 0;\n\nvar vFor = {\n\n  priority: FOR,\n  terminal: true,\n\n  params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],\n\n  bind: function bind() {\n    // support \"item in/of items\" syntax\n    var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);\n    if (inMatch) {\n      var itMatch = inMatch[1].match(/\\((.*),(.*)\\)/);\n      if (itMatch) {\n        this.iterator = itMatch[1].trim();\n        this.alias = itMatch[2].trim();\n      } else {\n        this.alias = inMatch[1].trim();\n      }\n      this.expression = inMatch[2];\n    }\n\n    if (!this.alias) {\n      process.env.NODE_ENV !== 'production' && warn('Invalid v-for expression \"' + this.descriptor.raw + '\": ' + 'alias is required.', this.vm);\n      return;\n    }\n\n    // uid as a cache identifier\n    this.id = '__v-for__' + ++uid$3;\n\n    // check if this is an option list,\n    // so that we know if we need to update the <select>'s\n    // v-model when the option list has changed.\n    // because v-model has a lower priority than v-for,\n    // the v-model is not bound here yet, so we have to\n    // retrive it in the actual updateModel() function.\n    var tag = this.el.tagName;\n    this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';\n\n    // setup anchor nodes\n    this.start = createAnchor('v-for-start');\n    this.end = createAnchor('v-for-end');\n    replace(this.el, this.end);\n    before(this.start, this.end);\n\n    // cache\n    this.cache = Object.create(null);\n\n    // fragment factory\n    this.factory = new FragmentFactory(this.vm, this.el);\n  },\n\n  update: function update(data) {\n    this.diff(data);\n    this.updateRef();\n    this.updateModel();\n  },\n\n  /**\n   * Diff, based on new data and old data, determine the\n   * minimum amount of DOM manipulations needed to make the\n   * DOM reflect the new data Array.\n   *\n   * The algorithm diffs the new data Array by storing a\n   * hidden reference to an owner vm instance on previously\n   * seen data. This allows us to achieve O(n) which is\n   * better than a levenshtein distance based algorithm,\n   * which is O(m * n).\n   *\n   * @param {Array} data\n   */\n\n  diff: function diff(data) {\n    // check if the Array was converted from an Object\n    var item = data[0];\n    var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');\n\n    var trackByKey = this.params.trackBy;\n    var oldFrags = this.frags;\n    var frags = this.frags = new Array(data.length);\n    var alias = this.alias;\n    var iterator = this.iterator;\n    var start = this.start;\n    var end = this.end;\n    var inDocument = inDoc(start);\n    var init = !oldFrags;\n    var i, l, frag, key, value, primitive;\n\n    // First pass, go through the new Array and fill up\n    // the new frags array. If a piece of data has a cached\n    // instance for it, we reuse it. Otherwise build a new\n    // instance.\n    for (i = 0, l = data.length; i < l; i++) {\n      item = data[i];\n      key = convertedFromObject ? item.$key : null;\n      value = convertedFromObject ? item.$value : item;\n      primitive = !isObject(value);\n      frag = !init && this.getCachedFrag(value, i, key);\n      if (frag) {\n        // reusable fragment\n        frag.reused = true;\n        // update $index\n        frag.scope.$index = i;\n        // update $key\n        if (key) {\n          frag.scope.$key = key;\n        }\n        // update iterator\n        if (iterator) {\n          frag.scope[iterator] = key !== null ? key : i;\n        }\n        // update data for track-by, object repeat &\n        // primitive values.\n        if (trackByKey || convertedFromObject || primitive) {\n          withoutConversion(function () {\n            frag.scope[alias] = value;\n          });\n        }\n      } else {\n        // new isntance\n        frag = this.create(value, alias, i, key);\n        frag.fresh = !init;\n      }\n      frags[i] = frag;\n      if (init) {\n        frag.before(end);\n      }\n    }\n\n    // we're done for the initial render.\n    if (init) {\n      return;\n    }\n\n    // Second pass, go through the old fragments and\n    // destroy those who are not reused (and remove them\n    // from cache)\n    var removalIndex = 0;\n    var totalRemoved = oldFrags.length - frags.length;\n    // when removing a large number of fragments, watcher removal\n    // turns out to be a perf bottleneck, so we batch the watcher\n    // removals into a single filter call!\n    this.vm._vForRemoving = true;\n    for (i = 0, l = oldFrags.length; i < l; i++) {\n      frag = oldFrags[i];\n      if (!frag.reused) {\n        this.deleteCachedFrag(frag);\n        this.remove(frag, removalIndex++, totalRemoved, inDocument);\n      }\n    }\n    this.vm._vForRemoving = false;\n    if (removalIndex) {\n      this.vm._watchers = this.vm._watchers.filter(function (w) {\n        return w.active;\n      });\n    }\n\n    // Final pass, move/insert new fragments into the\n    // right place.\n    var targetPrev, prevEl, currentPrev;\n    var insertionIndex = 0;\n    for (i = 0, l = frags.length; i < l; i++) {\n      frag = frags[i];\n      // this is the frag that we should be after\n      targetPrev = frags[i - 1];\n      prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;\n      if (frag.reused && !frag.staggerCb) {\n        currentPrev = findPrevFrag(frag, start, this.id);\n        if (currentPrev !== targetPrev && (!currentPrev ||\n        // optimization for moving a single item.\n        // thanks to suggestions by @livoras in #1807\n        findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {\n          this.move(frag, prevEl);\n        }\n      } else {\n        // new instance, or still in stagger.\n        // insert with updated stagger index.\n        this.insert(frag, insertionIndex++, prevEl, inDocument);\n      }\n      frag.reused = frag.fresh = false;\n    }\n  },\n\n  /**\n   * Create a new fragment instance.\n   *\n   * @param {*} value\n   * @param {String} alias\n   * @param {Number} index\n   * @param {String} [key]\n   * @return {Fragment}\n   */\n\n  create: function create(value, alias, index, key) {\n    var host = this._host;\n    // create iteration scope\n    var parentScope = this._scope || this.vm;\n    var scope = Object.create(parentScope);\n    // ref holder for the scope\n    scope.$refs = Object.create(parentScope.$refs);\n    scope.$els = Object.create(parentScope.$els);\n    // make sure point $parent to parent scope\n    scope.$parent = parentScope;\n    // for two-way binding on alias\n    scope.$forContext = this;\n    // define scope properties\n    // important: define the scope alias without forced conversion\n    // so that frozen data structures remain non-reactive.\n    withoutConversion(function () {\n      defineReactive(scope, alias, value);\n    });\n    defineReactive(scope, '$index', index);\n    if (key) {\n      defineReactive(scope, '$key', key);\n    } else if (scope.$key) {\n      // avoid accidental fallback\n      def(scope, '$key', null);\n    }\n    if (this.iterator) {\n      defineReactive(scope, this.iterator, key !== null ? key : index);\n    }\n    var frag = this.factory.create(host, scope, this._frag);\n    frag.forId = this.id;\n    this.cacheFrag(value, frag, index, key);\n    return frag;\n  },\n\n  /**\n   * Update the v-ref on owner vm.\n   */\n\n  updateRef: function updateRef() {\n    var ref = this.descriptor.ref;\n    if (!ref) return;\n    var hash = (this._scope || this.vm).$refs;\n    var refs;\n    if (!this.fromObject) {\n      refs = this.frags.map(findVmFromFrag);\n    } else {\n      refs = {};\n      this.frags.forEach(function (frag) {\n        refs[frag.scope.$key] = findVmFromFrag(frag);\n      });\n    }\n    hash[ref] = refs;\n  },\n\n  /**\n   * For option lists, update the containing v-model on\n   * parent <select>.\n   */\n\n  updateModel: function updateModel() {\n    if (this.isOption) {\n      var parent = this.start.parentNode;\n      var model = parent && parent.__v_model;\n      if (model) {\n        model.forceUpdate();\n      }\n    }\n  },\n\n  /**\n   * Insert a fragment. Handles staggering.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Node} prevEl\n   * @param {Boolean} inDocument\n   */\n\n  insert: function insert(frag, index, prevEl, inDocument) {\n    if (frag.staggerCb) {\n      frag.staggerCb.cancel();\n      frag.staggerCb = null;\n    }\n    var staggerAmount = this.getStagger(frag, index, null, 'enter');\n    if (inDocument && staggerAmount) {\n      // create an anchor and insert it synchronously,\n      // so that we can resolve the correct order without\n      // worrying about some elements not inserted yet\n      var anchor = frag.staggerAnchor;\n      if (!anchor) {\n        anchor = frag.staggerAnchor = createAnchor('stagger-anchor');\n        anchor.__v_frag = frag;\n      }\n      after(anchor, prevEl);\n      var op = frag.staggerCb = cancellable(function () {\n        frag.staggerCb = null;\n        frag.before(anchor);\n        remove(anchor);\n      });\n      setTimeout(op, staggerAmount);\n    } else {\n      var target = prevEl.nextSibling;\n      /* istanbul ignore if */\n      if (!target) {\n        // reset end anchor position in case the position was messed up\n        // by an external drag-n-drop library.\n        after(this.end, prevEl);\n        target = this.end;\n      }\n      frag.before(target);\n    }\n  },\n\n  /**\n   * Remove a fragment. Handles staggering.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Number} total\n   * @param {Boolean} inDocument\n   */\n\n  remove: function remove(frag, index, total, inDocument) {\n    if (frag.staggerCb) {\n      frag.staggerCb.cancel();\n      frag.staggerCb = null;\n      // it's not possible for the same frag to be removed\n      // twice, so if we have a pending stagger callback,\n      // it means this frag is queued for enter but removed\n      // before its transition started. Since it is already\n      // destroyed, we can just leave it in detached state.\n      return;\n    }\n    var staggerAmount = this.getStagger(frag, index, total, 'leave');\n    if (inDocument && staggerAmount) {\n      var op = frag.staggerCb = cancellable(function () {\n        frag.staggerCb = null;\n        frag.remove();\n      });\n      setTimeout(op, staggerAmount);\n    } else {\n      frag.remove();\n    }\n  },\n\n  /**\n   * Move a fragment to a new position.\n   * Force no transition.\n   *\n   * @param {Fragment} frag\n   * @param {Node} prevEl\n   */\n\n  move: function move(frag, prevEl) {\n    // fix a common issue with Sortable:\n    // if prevEl doesn't have nextSibling, this means it's\n    // been dragged after the end anchor. Just re-position\n    // the end anchor to the end of the container.\n    /* istanbul ignore if */\n    if (!prevEl.nextSibling) {\n      this.end.parentNode.appendChild(this.end);\n    }\n    frag.before(prevEl.nextSibling, false);\n  },\n\n  /**\n   * Cache a fragment using track-by or the object key.\n   *\n   * @param {*} value\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {String} [key]\n   */\n\n  cacheFrag: function cacheFrag(value, frag, index, key) {\n    var trackByKey = this.params.trackBy;\n    var cache = this.cache;\n    var primitive = !isObject(value);\n    var id;\n    if (key || trackByKey || primitive) {\n      id = getTrackByKey(index, key, value, trackByKey);\n      if (!cache[id]) {\n        cache[id] = frag;\n      } else if (trackByKey !== '$index') {\n        process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);\n      }\n    } else {\n      id = this.id;\n      if (hasOwn(value, id)) {\n        if (value[id] === null) {\n          value[id] = frag;\n        } else {\n          process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);\n        }\n      } else if (Object.isExtensible(value)) {\n        def(value, id, frag);\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('Frozen v-for objects cannot be automatically tracked, make sure to ' + 'provide a track-by key.');\n      }\n    }\n    frag.raw = value;\n  },\n\n  /**\n   * Get a cached fragment from the value/index/key\n   *\n   * @param {*} value\n   * @param {Number} index\n   * @param {String} key\n   * @return {Fragment}\n   */\n\n  getCachedFrag: function getCachedFrag(value, index, key) {\n    var trackByKey = this.params.trackBy;\n    var primitive = !isObject(value);\n    var frag;\n    if (key || trackByKey || primitive) {\n      var id = getTrackByKey(index, key, value, trackByKey);\n      frag = this.cache[id];\n    } else {\n      frag = value[this.id];\n    }\n    if (frag && (frag.reused || frag.fresh)) {\n      process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);\n    }\n    return frag;\n  },\n\n  /**\n   * Delete a fragment from cache.\n   *\n   * @param {Fragment} frag\n   */\n\n  deleteCachedFrag: function deleteCachedFrag(frag) {\n    var value = frag.raw;\n    var trackByKey = this.params.trackBy;\n    var scope = frag.scope;\n    var index = scope.$index;\n    // fix #948: avoid accidentally fall through to\n    // a parent repeater which happens to have $key.\n    var key = hasOwn(scope, '$key') && scope.$key;\n    var primitive = !isObject(value);\n    if (trackByKey || key || primitive) {\n      var id = getTrackByKey(index, key, value, trackByKey);\n      this.cache[id] = null;\n    } else {\n      value[this.id] = null;\n      frag.raw = null;\n    }\n  },\n\n  /**\n   * Get the stagger amount for an insertion/removal.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Number} total\n   * @param {String} type\n   */\n\n  getStagger: function getStagger(frag, index, total, type) {\n    type = type + 'Stagger';\n    var trans = frag.node.__v_trans;\n    var hooks = trans && trans.hooks;\n    var hook = hooks && (hooks[type] || hooks.stagger);\n    return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);\n  },\n\n  /**\n   * Pre-process the value before piping it through the\n   * filters. This is passed to and called by the watcher.\n   */\n\n  _preProcess: function _preProcess(value) {\n    // regardless of type, store the un-filtered raw value.\n    this.rawValue = value;\n    return value;\n  },\n\n  /**\n   * Post-process the value after it has been piped through\n   * the filters. This is passed to and called by the watcher.\n   *\n   * It is necessary for this to be called during the\n   * watcher's dependency collection phase because we want\n   * the v-for to update when the source Object is mutated.\n   */\n\n  _postProcess: function _postProcess(value) {\n    if (isArray(value)) {\n      return value;\n    } else if (isPlainObject(value)) {\n      // convert plain object to array.\n      var keys = Object.keys(value);\n      var i = keys.length;\n      var res = new Array(i);\n      var key;\n      while (i--) {\n        key = keys[i];\n        res[i] = {\n          $key: key,\n          $value: value[key]\n        };\n      }\n      return res;\n    } else {\n      if (typeof value === 'number' && !isNaN(value)) {\n        value = range(value);\n      }\n      return value || [];\n    }\n  },\n\n  unbind: function unbind() {\n    if (this.descriptor.ref) {\n      (this._scope || this.vm).$refs[this.descriptor.ref] = null;\n    }\n    if (this.frags) {\n      var i = this.frags.length;\n      var frag;\n      while (i--) {\n        frag = this.frags[i];\n        this.deleteCachedFrag(frag);\n        frag.destroy();\n      }\n    }\n  }\n};\n\n/**\n * Helper to find the previous element that is a fragment\n * anchor. This is necessary because a destroyed frag's\n * element could still be lingering in the DOM before its\n * leaving transition finishes, but its inserted flag\n * should have been set to false so we can skip them.\n *\n * If this is a block repeat, we want to make sure we only\n * return frag that is bound to this v-for. (see #929)\n *\n * @param {Fragment} frag\n * @param {Comment|Text} anchor\n * @param {String} id\n * @return {Fragment}\n */\n\nfunction findPrevFrag(frag, anchor, id) {\n  var el = frag.node.previousSibling;\n  /* istanbul ignore if */\n  if (!el) return;\n  frag = el.__v_frag;\n  while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {\n    el = el.previousSibling;\n    /* istanbul ignore if */\n    if (!el) return;\n    frag = el.__v_frag;\n  }\n  return frag;\n}\n\n/**\n * Find a vm from a fragment.\n *\n * @param {Fragment} frag\n * @return {Vue|undefined}\n */\n\nfunction findVmFromFrag(frag) {\n  var node = frag.node;\n  // handle multi-node frag\n  if (frag.end) {\n    while (!node.__vue__ && node !== frag.end && node.nextSibling) {\n      node = node.nextSibling;\n    }\n  }\n  return node.__vue__;\n}\n\n/**\n * Create a range array from given number.\n *\n * @param {Number} n\n * @return {Array}\n */\n\nfunction range(n) {\n  var i = -1;\n  var ret = new Array(Math.floor(n));\n  while (++i < n) {\n    ret[i] = i;\n  }\n  return ret;\n}\n\n/**\n * Get the track by key for an item.\n *\n * @param {Number} index\n * @param {String} key\n * @param {*} value\n * @param {String} [trackByKey]\n */\n\nfunction getTrackByKey(index, key, value, trackByKey) {\n  return trackByKey ? trackByKey === '$index' ? index : trackByKey.charAt(0).match(/\\w/) ? getPath(value, trackByKey) : value[trackByKey] : key || value;\n}\n\nif (process.env.NODE_ENV !== 'production') {\n  vFor.warnDuplicate = function (value) {\n    warn('Duplicate value found in v-for=\"' + this.descriptor.raw + '\": ' + JSON.stringify(value) + '. Use track-by=\"$index\" if ' + 'you are expecting duplicate values.', this.vm);\n  };\n}\n\nvar vIf = {\n\n  priority: IF,\n  terminal: true,\n\n  bind: function bind() {\n    var el = this.el;\n    if (!el.__vue__) {\n      // check else block\n      var next = el.nextElementSibling;\n      if (next && getAttr(next, 'v-else') !== null) {\n        remove(next);\n        this.elseEl = next;\n      }\n      // check main block\n      this.anchor = createAnchor('v-if');\n      replace(el, this.anchor);\n    } else {\n      process.env.NODE_ENV !== 'production' && warn('v-if=\"' + this.expression + '\" cannot be ' + 'used on an instance root element.', this.vm);\n      this.invalid = true;\n    }\n  },\n\n  update: function update(value) {\n    if (this.invalid) return;\n    if (value) {\n      if (!this.frag) {\n        this.insert();\n      }\n    } else {\n      this.remove();\n    }\n  },\n\n  insert: function insert() {\n    if (this.elseFrag) {\n      this.elseFrag.remove();\n      this.elseFrag = null;\n    }\n    // lazy init factory\n    if (!this.factory) {\n      this.factory = new FragmentFactory(this.vm, this.el);\n    }\n    this.frag = this.factory.create(this._host, this._scope, this._frag);\n    this.frag.before(this.anchor);\n  },\n\n  remove: function remove() {\n    if (this.frag) {\n      this.frag.remove();\n      this.frag = null;\n    }\n    if (this.elseEl && !this.elseFrag) {\n      if (!this.elseFactory) {\n        this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);\n      }\n      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);\n      this.elseFrag.before(this.anchor);\n    }\n  },\n\n  unbind: function unbind() {\n    if (this.frag) {\n      this.frag.destroy();\n    }\n    if (this.elseFrag) {\n      this.elseFrag.destroy();\n    }\n  }\n};\n\nvar show = {\n\n  bind: function bind() {\n    // check else block\n    var next = this.el.nextElementSibling;\n    if (next && getAttr(next, 'v-else') !== null) {\n      this.elseEl = next;\n    }\n  },\n\n  update: function update(value) {\n    this.apply(this.el, value);\n    if (this.elseEl) {\n      this.apply(this.elseEl, !value);\n    }\n  },\n\n  apply: function apply(el, value) {\n    if (inDoc(el)) {\n      applyTransition(el, value ? 1 : -1, toggle, this.vm);\n    } else {\n      toggle();\n    }\n    function toggle() {\n      el.style.display = value ? '' : 'none';\n    }\n  }\n};\n\nvar text$2 = {\n\n  bind: function bind() {\n    var self = this;\n    var el = this.el;\n    var isRange = el.type === 'range';\n    var lazy = this.params.lazy;\n    var number = this.params.number;\n    var debounce = this.params.debounce;\n\n    // handle composition events.\n    //   http://blog.evanyou.me/2014/01/03/composition-event/\n    // skip this for Android because it handles composition\n    // events quite differently. Android doesn't trigger\n    // composition events for language input methods e.g.\n    // Chinese, but instead triggers them for spelling\n    // suggestions... (see Discussion/#162)\n    var composing = false;\n    if (!isAndroid && !isRange) {\n      this.on('compositionstart', function () {\n        composing = true;\n      });\n      this.on('compositionend', function () {\n        composing = false;\n        // in IE11 the \"compositionend\" event fires AFTER\n        // the \"input\" event, so the input handler is blocked\n        // at the end... have to call it here.\n        //\n        // #1327: in lazy mode this is unecessary.\n        if (!lazy) {\n          self.listener();\n        }\n      });\n    }\n\n    // prevent messing with the input when user is typing,\n    // and force update on blur.\n    this.focused = false;\n    if (!isRange && !lazy) {\n      this.on('focus', function () {\n        self.focused = true;\n      });\n      this.on('blur', function () {\n        self.focused = false;\n        // do not sync value after fragment removal (#2017)\n        if (!self._frag || self._frag.inserted) {\n          self.rawListener();\n        }\n      });\n    }\n\n    // Now attach the main listener\n    this.listener = this.rawListener = function () {\n      if (composing || !self._bound) {\n        return;\n      }\n      var val = number || isRange ? toNumber(el.value) : el.value;\n      self.set(val);\n      // force update on next tick to avoid lock & same value\n      // also only update when user is not typing\n      nextTick(function () {\n        if (self._bound && !self.focused) {\n          self.update(self._watcher.value);\n        }\n      });\n    };\n\n    // apply debounce\n    if (debounce) {\n      this.listener = _debounce(this.listener, debounce);\n    }\n\n    // Support jQuery events, since jQuery.trigger() doesn't\n    // trigger native events in some cases and some plugins\n    // rely on $.trigger()\n    //\n    // We want to make sure if a listener is attached using\n    // jQuery, it is also removed with jQuery, that's why\n    // we do the check for each directive instance and\n    // store that check result on itself. This also allows\n    // easier test coverage control by unsetting the global\n    // jQuery variable in tests.\n    this.hasjQuery = typeof jQuery === 'function';\n    if (this.hasjQuery) {\n      var method = jQuery.fn.on ? 'on' : 'bind';\n      jQuery(el)[method]('change', this.rawListener);\n      if (!lazy) {\n        jQuery(el)[method]('input', this.listener);\n      }\n    } else {\n      this.on('change', this.rawListener);\n      if (!lazy) {\n        this.on('input', this.listener);\n      }\n    }\n\n    // IE9 doesn't fire input event on backspace/del/cut\n    if (!lazy && isIE9) {\n      this.on('cut', function () {\n        nextTick(self.listener);\n      });\n      this.on('keyup', function (e) {\n        if (e.keyCode === 46 || e.keyCode === 8) {\n          self.listener();\n        }\n      });\n    }\n\n    // set initial value if present\n    if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {\n      this.afterBind = this.listener;\n    }\n  },\n\n  update: function update(value) {\n    // #3029 only update when the value changes. This prevent\n    // browsers from overwriting values like selectionStart\n    value = _toString(value);\n    if (value !== this.el.value) this.el.value = value;\n  },\n\n  unbind: function unbind() {\n    var el = this.el;\n    if (this.hasjQuery) {\n      var method = jQuery.fn.off ? 'off' : 'unbind';\n      jQuery(el)[method]('change', this.listener);\n      jQuery(el)[method]('input', this.listener);\n    }\n  }\n};\n\nvar radio = {\n\n  bind: function bind() {\n    var self = this;\n    var el = this.el;\n\n    this.getValue = function () {\n      // value overwrite via v-bind:value\n      if (el.hasOwnProperty('_value')) {\n        return el._value;\n      }\n      var val = el.value;\n      if (self.params.number) {\n        val = toNumber(val);\n      }\n      return val;\n    };\n\n    this.listener = function () {\n      self.set(self.getValue());\n    };\n    this.on('change', this.listener);\n\n    if (el.hasAttribute('checked')) {\n      this.afterBind = this.listener;\n    }\n  },\n\n  update: function update(value) {\n    this.el.checked = looseEqual(value, this.getValue());\n  }\n};\n\nvar select = {\n\n  bind: function bind() {\n    var _this = this;\n\n    var self = this;\n    var el = this.el;\n\n    // method to force update DOM using latest value.\n    this.forceUpdate = function () {\n      if (self._watcher) {\n        self.update(self._watcher.get());\n      }\n    };\n\n    // check if this is a multiple select\n    var multiple = this.multiple = el.hasAttribute('multiple');\n\n    // attach listener\n    this.listener = function () {\n      var value = getValue(el, multiple);\n      value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;\n      self.set(value);\n    };\n    this.on('change', this.listener);\n\n    // if has initial value, set afterBind\n    var initValue = getValue(el, multiple, true);\n    if (multiple && initValue.length || !multiple && initValue !== null) {\n      this.afterBind = this.listener;\n    }\n\n    // All major browsers except Firefox resets\n    // selectedIndex with value -1 to 0 when the element\n    // is appended to a new parent, therefore we have to\n    // force a DOM update whenever that happens...\n    this.vm.$on('hook:attached', function () {\n      nextTick(_this.forceUpdate);\n    });\n    if (!inDoc(el)) {\n      nextTick(this.forceUpdate);\n    }\n  },\n\n  update: function update(value) {\n    var el = this.el;\n    el.selectedIndex = -1;\n    var multi = this.multiple && isArray(value);\n    var options = el.options;\n    var i = options.length;\n    var op, val;\n    while (i--) {\n      op = options[i];\n      val = op.hasOwnProperty('_value') ? op._value : op.value;\n      /* eslint-disable eqeqeq */\n      op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);\n      /* eslint-enable eqeqeq */\n    }\n  },\n\n  unbind: function unbind() {\n    /* istanbul ignore next */\n    this.vm.$off('hook:attached', this.forceUpdate);\n  }\n};\n\n/**\n * Get select value\n *\n * @param {SelectElement} el\n * @param {Boolean} multi\n * @param {Boolean} init\n * @return {Array|*}\n */\n\nfunction getValue(el, multi, init) {\n  var res = multi ? [] : null;\n  var op, val, selected;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    op = el.options[i];\n    selected = init ? op.hasAttribute('selected') : op.selected;\n    if (selected) {\n      val = op.hasOwnProperty('_value') ? op._value : op.value;\n      if (multi) {\n        res.push(val);\n      } else {\n        return val;\n      }\n    }\n  }\n  return res;\n}\n\n/**\n * Native Array.indexOf uses strict equal, but in this\n * case we need to match string/numbers with custom equal.\n *\n * @param {Array} arr\n * @param {*} val\n */\n\nfunction indexOf$1(arr, val) {\n  var i = arr.length;\n  while (i--) {\n    if (looseEqual(arr[i], val)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nvar checkbox = {\n\n  bind: function bind() {\n    var self = this;\n    var el = this.el;\n\n    this.getValue = function () {\n      return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;\n    };\n\n    function getBooleanValue() {\n      var val = el.checked;\n      if (val && el.hasOwnProperty('_trueValue')) {\n        return el._trueValue;\n      }\n      if (!val && el.hasOwnProperty('_falseValue')) {\n        return el._falseValue;\n      }\n      return val;\n    }\n\n    this.listener = function () {\n      var model = self._watcher.value;\n      if (isArray(model)) {\n        var val = self.getValue();\n        if (el.checked) {\n          if (indexOf(model, val) < 0) {\n            model.push(val);\n          }\n        } else {\n          model.$remove(val);\n        }\n      } else {\n        self.set(getBooleanValue());\n      }\n    };\n\n    this.on('change', this.listener);\n    if (el.hasAttribute('checked')) {\n      this.afterBind = this.listener;\n    }\n  },\n\n  update: function update(value) {\n    var el = this.el;\n    if (isArray(value)) {\n      el.checked = indexOf(value, this.getValue()) > -1;\n    } else {\n      if (el.hasOwnProperty('_trueValue')) {\n        el.checked = looseEqual(value, el._trueValue);\n      } else {\n        el.checked = !!value;\n      }\n    }\n  }\n};\n\nvar handlers = {\n  text: text$2,\n  radio: radio,\n  select: select,\n  checkbox: checkbox\n};\n\nvar model = {\n\n  priority: MODEL,\n  twoWay: true,\n  handlers: handlers,\n  params: ['lazy', 'number', 'debounce'],\n\n  /**\n   * Possible elements:\n   *   <select>\n   *   <textarea>\n   *   <input type=\"*\">\n   *     - text\n   *     - checkbox\n   *     - radio\n   *     - number\n   */\n\n  bind: function bind() {\n    // friendly warning...\n    this.checkFilters();\n    if (this.hasRead && !this.hasWrite) {\n      process.env.NODE_ENV !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model=\"' + this.descriptor.raw + '\". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);\n    }\n    var el = this.el;\n    var tag = el.tagName;\n    var handler;\n    if (tag === 'INPUT') {\n      handler = handlers[el.type] || handlers.text;\n    } else if (tag === 'SELECT') {\n      handler = handlers.select;\n    } else if (tag === 'TEXTAREA') {\n      handler = handlers.text;\n    } else {\n      process.env.NODE_ENV !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);\n      return;\n    }\n    el.__v_model = this;\n    handler.bind.call(this);\n    this.update = handler.update;\n    this._unbind = handler.unbind;\n  },\n\n  /**\n   * Check read/write filter stats.\n   */\n\n  checkFilters: function checkFilters() {\n    var filters = this.filters;\n    if (!filters) return;\n    var i = filters.length;\n    while (i--) {\n      var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);\n      if (typeof filter === 'function' || filter.read) {\n        this.hasRead = true;\n      }\n      if (filter.write) {\n        this.hasWrite = true;\n      }\n    }\n  },\n\n  unbind: function unbind() {\n    this.el.__v_model = null;\n    this._unbind && this._unbind();\n  }\n};\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  'delete': [8, 46],\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40\n};\n\nfunction keyFilter(handler, keys) {\n  var codes = keys.map(function (key) {\n    var charCode = key.charCodeAt(0);\n    if (charCode > 47 && charCode < 58) {\n      return parseInt(key, 10);\n    }\n    if (key.length === 1) {\n      charCode = key.toUpperCase().charCodeAt(0);\n      if (charCode > 64 && charCode < 91) {\n        return charCode;\n      }\n    }\n    return keyCodes[key];\n  });\n  codes = [].concat.apply([], codes);\n  return function keyHandler(e) {\n    if (codes.indexOf(e.keyCode) > -1) {\n      return handler.call(this, e);\n    }\n  };\n}\n\nfunction stopFilter(handler) {\n  return function stopHandler(e) {\n    e.stopPropagation();\n    return handler.call(this, e);\n  };\n}\n\nfunction preventFilter(handler) {\n  return function preventHandler(e) {\n    e.preventDefault();\n    return handler.call(this, e);\n  };\n}\n\nfunction selfFilter(handler) {\n  return function selfHandler(e) {\n    if (e.target === e.currentTarget) {\n      return handler.call(this, e);\n    }\n  };\n}\n\nvar on$1 = {\n\n  priority: ON,\n  acceptStatement: true,\n  keyCodes: keyCodes,\n\n  bind: function bind() {\n    // deal with iframes\n    if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {\n      var self = this;\n      this.iframeBind = function () {\n        on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);\n      };\n      this.on('load', this.iframeBind);\n    }\n  },\n\n  update: function update(handler) {\n    // stub a noop for v-on with no value,\n    // e.g. @mousedown.prevent\n    if (!this.descriptor.raw) {\n      handler = function () {};\n    }\n\n    if (typeof handler !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn('v-on:' + this.arg + '=\"' + this.expression + '\" expects a function value, ' + 'got ' + handler, this.vm);\n      return;\n    }\n\n    // apply modifiers\n    if (this.modifiers.stop) {\n      handler = stopFilter(handler);\n    }\n    if (this.modifiers.prevent) {\n      handler = preventFilter(handler);\n    }\n    if (this.modifiers.self) {\n      handler = selfFilter(handler);\n    }\n    // key filter\n    var keys = Object.keys(this.modifiers).filter(function (key) {\n      return key !== 'stop' && key !== 'prevent' && key !== 'self' && key !== 'capture';\n    });\n    if (keys.length) {\n      handler = keyFilter(handler, keys);\n    }\n\n    this.reset();\n    this.handler = handler;\n\n    if (this.iframeBind) {\n      this.iframeBind();\n    } else {\n      on(this.el, this.arg, this.handler, this.modifiers.capture);\n    }\n  },\n\n  reset: function reset() {\n    var el = this.iframeBind ? this.el.contentWindow : this.el;\n    if (this.handler) {\n      off(el, this.arg, this.handler);\n    }\n  },\n\n  unbind: function unbind() {\n    this.reset();\n  }\n};\n\nvar prefixes = ['-webkit-', '-moz-', '-ms-'];\nvar camelPrefixes = ['Webkit', 'Moz', 'ms'];\nvar importantRE = /!important;?$/;\nvar propCache = Object.create(null);\n\nvar testEl = null;\n\nvar style = {\n\n  deep: true,\n\n  update: function update(value) {\n    if (typeof value === 'string') {\n      this.el.style.cssText = value;\n    } else if (isArray(value)) {\n      this.handleObject(value.reduce(extend, {}));\n    } else {\n      this.handleObject(value || {});\n    }\n  },\n\n  handleObject: function handleObject(value) {\n    // cache object styles so that only changed props\n    // are actually updated.\n    var cache = this.cache || (this.cache = {});\n    var name, val;\n    for (name in cache) {\n      if (!(name in value)) {\n        this.handleSingle(name, null);\n        delete cache[name];\n      }\n    }\n    for (name in value) {\n      val = value[name];\n      if (val !== cache[name]) {\n        cache[name] = val;\n        this.handleSingle(name, val);\n      }\n    }\n  },\n\n  handleSingle: function handleSingle(prop, value) {\n    prop = normalize(prop);\n    if (!prop) return; // unsupported prop\n    // cast possible numbers/booleans into strings\n    if (value != null) value += '';\n    if (value) {\n      var isImportant = importantRE.test(value) ? 'important' : '';\n      if (isImportant) {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          warn('It\\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');\n        }\n        value = value.replace(importantRE, '').trim();\n        this.el.style.setProperty(prop.kebab, value, isImportant);\n      } else {\n        this.el.style[prop.camel] = value;\n      }\n    } else {\n      this.el.style[prop.camel] = '';\n    }\n  }\n\n};\n\n/**\n * Normalize a CSS property name.\n * - cache result\n * - auto prefix\n * - camelCase -> dash-case\n *\n * @param {String} prop\n * @return {String}\n */\n\nfunction normalize(prop) {\n  if (propCache[prop]) {\n    return propCache[prop];\n  }\n  var res = prefix(prop);\n  propCache[prop] = propCache[res] = res;\n  return res;\n}\n\n/**\n * Auto detect the appropriate prefix for a CSS property.\n * https://gist.github.com/paulirish/523692\n *\n * @param {String} prop\n * @return {String}\n */\n\nfunction prefix(prop) {\n  prop = hyphenate(prop);\n  var camel = camelize(prop);\n  var upper = camel.charAt(0).toUpperCase() + camel.slice(1);\n  if (!testEl) {\n    testEl = document.createElement('div');\n  }\n  var i = prefixes.length;\n  var prefixed;\n  if (camel !== 'filter' && camel in testEl.style) {\n    return {\n      kebab: prop,\n      camel: camel\n    };\n  }\n  while (i--) {\n    prefixed = camelPrefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return {\n        kebab: prefixes[i] + prop,\n        camel: prefixed\n      };\n    }\n  }\n}\n\n// xlink\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xlinkRE = /^xlink:/;\n\n// check for attributes that prohibit interpolations\nvar disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;\n// these attributes should also set their corresponding properties\n// because they only affect the initial state of the element\nvar attrWithPropsRE = /^(?:value|checked|selected|muted)$/;\n// these attributes expect enumrated values of \"true\" or \"false\"\n// but are not boolean attributes\nvar enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;\n\n// these attributes should set a hidden property for\n// binding v-model to object values\nvar modelProps = {\n  value: '_value',\n  'true-value': '_trueValue',\n  'false-value': '_falseValue'\n};\n\nvar bind$1 = {\n\n  priority: BIND,\n\n  bind: function bind() {\n    var attr = this.arg;\n    var tag = this.el.tagName;\n    // should be deep watch on object mode\n    if (!attr) {\n      this.deep = true;\n    }\n    // handle interpolation bindings\n    var descriptor = this.descriptor;\n    var tokens = descriptor.interp;\n    if (tokens) {\n      // handle interpolations with one-time tokens\n      if (descriptor.hasOneTime) {\n        this.expression = tokensToExp(tokens, this._scope || this.vm);\n      }\n\n      // only allow binding on native attributes\n      if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {\n        process.env.NODE_ENV !== 'production' && warn(attr + '=\"' + descriptor.raw + '\": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);\n        this.el.removeAttribute(attr);\n        this.invalid = true;\n      }\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production') {\n        var raw = attr + '=\"' + descriptor.raw + '\": ';\n        // warn src\n        if (attr === 'src') {\n          warn(raw + 'interpolation in \"src\" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);\n        }\n\n        // warn style\n        if (attr === 'style') {\n          warn(raw + 'interpolation in \"style\" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);\n        }\n      }\n    }\n  },\n\n  update: function update(value) {\n    if (this.invalid) {\n      return;\n    }\n    var attr = this.arg;\n    if (this.arg) {\n      this.handleSingle(attr, value);\n    } else {\n      this.handleObject(value || {});\n    }\n  },\n\n  // share object handler with v-bind:class\n  handleObject: style.handleObject,\n\n  handleSingle: function handleSingle(attr, value) {\n    var el = this.el;\n    var interp = this.descriptor.interp;\n    if (this.modifiers.camel) {\n      attr = camelize(attr);\n    }\n    if (!interp && attrWithPropsRE.test(attr) && attr in el) {\n      var attrValue = attr === 'value' ? value == null // IE9 will set input.value to \"null\" for null...\n      ? '' : value : value;\n\n      if (el[attr] !== attrValue) {\n        el[attr] = attrValue;\n      }\n    }\n    // set model props\n    var modelProp = modelProps[attr];\n    if (!interp && modelProp) {\n      el[modelProp] = value;\n      // update v-model if present\n      var model = el.__v_model;\n      if (model) {\n        model.listener();\n      }\n    }\n    // do not set value attribute for textarea\n    if (attr === 'value' && el.tagName === 'TEXTAREA') {\n      el.removeAttribute(attr);\n      return;\n    }\n    // update attribute\n    if (enumeratedAttrRE.test(attr)) {\n      el.setAttribute(attr, value ? 'true' : 'false');\n    } else if (value != null && value !== false) {\n      if (attr === 'class') {\n        // handle edge case #1960:\n        // class interpolation should not overwrite Vue transition class\n        if (el.__v_trans) {\n          value += ' ' + el.__v_trans.id + '-transition';\n        }\n        setClass(el, value);\n      } else if (xlinkRE.test(attr)) {\n        el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);\n      } else {\n        el.setAttribute(attr, value === true ? '' : value);\n      }\n    } else {\n      el.removeAttribute(attr);\n    }\n  }\n};\n\nvar el = {\n\n  priority: EL,\n\n  bind: function bind() {\n    /* istanbul ignore if */\n    if (!this.arg) {\n      return;\n    }\n    var id = this.id = camelize(this.arg);\n    var refs = (this._scope || this.vm).$els;\n    if (hasOwn(refs, id)) {\n      refs[id] = this.el;\n    } else {\n      defineReactive(refs, id, this.el);\n    }\n  },\n\n  unbind: function unbind() {\n    var refs = (this._scope || this.vm).$els;\n    if (refs[this.id] === this.el) {\n      refs[this.id] = null;\n    }\n  }\n};\n\nvar ref = {\n  bind: function bind() {\n    process.env.NODE_ENV !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);\n  }\n};\n\nvar cloak = {\n  bind: function bind() {\n    var el = this.el;\n    this.vm.$once('pre-hook:compiled', function () {\n      el.removeAttribute('v-cloak');\n    });\n  }\n};\n\n// must export plain object\nvar directives = {\n  text: text$1,\n  html: html,\n  'for': vFor,\n  'if': vIf,\n  show: show,\n  model: model,\n  on: on$1,\n  bind: bind$1,\n  el: el,\n  ref: ref,\n  cloak: cloak\n};\n\nvar vClass = {\n\n  deep: true,\n\n  update: function update(value) {\n    if (!value) {\n      this.cleanup();\n    } else if (typeof value === 'string') {\n      this.setClass(value.trim().split(/\\s+/));\n    } else {\n      this.setClass(normalize$1(value));\n    }\n  },\n\n  setClass: function setClass(value) {\n    this.cleanup(value);\n    for (var i = 0, l = value.length; i < l; i++) {\n      var val = value[i];\n      if (val) {\n        apply(this.el, val, addClass);\n      }\n    }\n    this.prevKeys = value;\n  },\n\n  cleanup: function cleanup(value) {\n    var prevKeys = this.prevKeys;\n    if (!prevKeys) return;\n    var i = prevKeys.length;\n    while (i--) {\n      var key = prevKeys[i];\n      if (!value || value.indexOf(key) < 0) {\n        apply(this.el, key, removeClass);\n      }\n    }\n  }\n};\n\n/**\n * Normalize objects and arrays (potentially containing objects)\n * into array of strings.\n *\n * @param {Object|Array<String|Object>} value\n * @return {Array<String>}\n */\n\nfunction normalize$1(value) {\n  var res = [];\n  if (isArray(value)) {\n    for (var i = 0, l = value.length; i < l; i++) {\n      var _key = value[i];\n      if (_key) {\n        if (typeof _key === 'string') {\n          res.push(_key);\n        } else {\n          for (var k in _key) {\n            if (_key[k]) res.push(k);\n          }\n        }\n      }\n    }\n  } else if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) res.push(key);\n    }\n  }\n  return res;\n}\n\n/**\n * Add or remove a class/classes on an element\n *\n * @param {Element} el\n * @param {String} key The class name. This may or may not\n *                     contain a space character, in such a\n *                     case we'll deal with multiple class\n *                     names at once.\n * @param {Function} fn\n */\n\nfunction apply(el, key, fn) {\n  key = key.trim();\n  if (key.indexOf(' ') === -1) {\n    fn(el, key);\n    return;\n  }\n  // The key contains one or more space characters.\n  // Since a class name doesn't accept such characters, we\n  // treat it as multiple classes.\n  var keys = key.split(/\\s+/);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    fn(el, keys[i]);\n  }\n}\n\nvar component = {\n\n  priority: COMPONENT,\n\n  params: ['keep-alive', 'transition-mode', 'inline-template'],\n\n  /**\n   * Setup. Two possible usages:\n   *\n   * - static:\n   *   <comp> or <div v-component=\"comp\">\n   *\n   * - dynamic:\n   *   <component :is=\"view\">\n   */\n\n  bind: function bind() {\n    if (!this.el.__vue__) {\n      // keep-alive cache\n      this.keepAlive = this.params.keepAlive;\n      if (this.keepAlive) {\n        this.cache = {};\n      }\n      // check inline-template\n      if (this.params.inlineTemplate) {\n        // extract inline template as a DocumentFragment\n        this.inlineTemplate = extractContent(this.el, true);\n      }\n      // component resolution related state\n      this.pendingComponentCb = this.Component = null;\n      // transition related state\n      this.pendingRemovals = 0;\n      this.pendingRemovalCb = null;\n      // create a ref anchor\n      this.anchor = createAnchor('v-component');\n      replace(this.el, this.anchor);\n      // remove is attribute.\n      // this is removed during compilation, but because compilation is\n      // cached, when the component is used elsewhere this attribute\n      // will remain at link time.\n      this.el.removeAttribute('is');\n      this.el.removeAttribute(':is');\n      // remove ref, same as above\n      if (this.descriptor.ref) {\n        this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));\n      }\n      // if static, build right now.\n      if (this.literal) {\n        this.setComponent(this.expression);\n      }\n    } else {\n      process.env.NODE_ENV !== 'production' && warn('cannot mount component \"' + this.expression + '\" ' + 'on already mounted element: ' + this.el);\n    }\n  },\n\n  /**\n   * Public update, called by the watcher in the dynamic\n   * literal scenario, e.g. <component :is=\"view\">\n   */\n\n  update: function update(value) {\n    if (!this.literal) {\n      this.setComponent(value);\n    }\n  },\n\n  /**\n   * Switch dynamic components. May resolve the component\n   * asynchronously, and perform transition based on\n   * specified transition mode. Accepts a few additional\n   * arguments specifically for vue-router.\n   *\n   * The callback is called when the full transition is\n   * finished.\n   *\n   * @param {String} value\n   * @param {Function} [cb]\n   */\n\n  setComponent: function setComponent(value, cb) {\n    this.invalidatePending();\n    if (!value) {\n      // just remove current\n      this.unbuild(true);\n      this.remove(this.childVM, cb);\n      this.childVM = null;\n    } else {\n      var self = this;\n      this.resolveComponent(value, function () {\n        self.mountComponent(cb);\n      });\n    }\n  },\n\n  /**\n   * Resolve the component constructor to use when creating\n   * the child vm.\n   *\n   * @param {String|Function} value\n   * @param {Function} cb\n   */\n\n  resolveComponent: function resolveComponent(value, cb) {\n    var self = this;\n    this.pendingComponentCb = cancellable(function (Component) {\n      self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);\n      self.Component = Component;\n      cb();\n    });\n    this.vm._resolveComponent(value, this.pendingComponentCb);\n  },\n\n  /**\n   * Create a new instance using the current constructor and\n   * replace the existing instance. This method doesn't care\n   * whether the new component and the old one are actually\n   * the same.\n   *\n   * @param {Function} [cb]\n   */\n\n  mountComponent: function mountComponent(cb) {\n    // actual mount\n    this.unbuild(true);\n    var self = this;\n    var activateHooks = this.Component.options.activate;\n    var cached = this.getCached();\n    var newComponent = this.build();\n    if (activateHooks && !cached) {\n      this.waitingFor = newComponent;\n      callActivateHooks(activateHooks, newComponent, function () {\n        if (self.waitingFor !== newComponent) {\n          return;\n        }\n        self.waitingFor = null;\n        self.transition(newComponent, cb);\n      });\n    } else {\n      // update ref for kept-alive component\n      if (cached) {\n        newComponent._updateRef();\n      }\n      this.transition(newComponent, cb);\n    }\n  },\n\n  /**\n   * When the component changes or unbinds before an async\n   * constructor is resolved, we need to invalidate its\n   * pending callback.\n   */\n\n  invalidatePending: function invalidatePending() {\n    if (this.pendingComponentCb) {\n      this.pendingComponentCb.cancel();\n      this.pendingComponentCb = null;\n    }\n  },\n\n  /**\n   * Instantiate/insert a new child vm.\n   * If keep alive and has cached instance, insert that\n   * instance; otherwise build a new one and cache it.\n   *\n   * @param {Object} [extraOptions]\n   * @return {Vue} - the created instance\n   */\n\n  build: function build(extraOptions) {\n    var cached = this.getCached();\n    if (cached) {\n      return cached;\n    }\n    if (this.Component) {\n      // default options\n      var options = {\n        name: this.ComponentName,\n        el: cloneNode(this.el),\n        template: this.inlineTemplate,\n        // make sure to add the child with correct parent\n        // if this is a transcluded component, its parent\n        // should be the transclusion host.\n        parent: this._host || this.vm,\n        // if no inline-template, then the compiled\n        // linker can be cached for better performance.\n        _linkerCachable: !this.inlineTemplate,\n        _ref: this.descriptor.ref,\n        _asComponent: true,\n        _isRouterView: this._isRouterView,\n        // if this is a transcluded component, context\n        // will be the common parent vm of this instance\n        // and its host.\n        _context: this.vm,\n        // if this is inside an inline v-for, the scope\n        // will be the intermediate scope created for this\n        // repeat fragment. this is used for linking props\n        // and container directives.\n        _scope: this._scope,\n        // pass in the owner fragment of this component.\n        // this is necessary so that the fragment can keep\n        // track of its contained components in order to\n        // call attach/detach hooks for them.\n        _frag: this._frag\n      };\n      // extra options\n      // in 1.0.0 this is used by vue-router only\n      /* istanbul ignore if */\n      if (extraOptions) {\n        extend(options, extraOptions);\n      }\n      var child = new this.Component(options);\n      if (this.keepAlive) {\n        this.cache[this.Component.cid] = child;\n      }\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {\n        warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);\n      }\n      return child;\n    }\n  },\n\n  /**\n   * Try to get a cached instance of the current component.\n   *\n   * @return {Vue|undefined}\n   */\n\n  getCached: function getCached() {\n    return this.keepAlive && this.cache[this.Component.cid];\n  },\n\n  /**\n   * Teardown the current child, but defers cleanup so\n   * that we can separate the destroy and removal steps.\n   *\n   * @param {Boolean} defer\n   */\n\n  unbuild: function unbuild(defer) {\n    if (this.waitingFor) {\n      if (!this.keepAlive) {\n        this.waitingFor.$destroy();\n      }\n      this.waitingFor = null;\n    }\n    var child = this.childVM;\n    if (!child || this.keepAlive) {\n      if (child) {\n        // remove ref\n        child._inactive = true;\n        child._updateRef(true);\n      }\n      return;\n    }\n    // the sole purpose of `deferCleanup` is so that we can\n    // \"deactivate\" the vm right now and perform DOM removal\n    // later.\n    child.$destroy(false, defer);\n  },\n\n  /**\n   * Remove current destroyed child and manually do\n   * the cleanup after removal.\n   *\n   * @param {Function} cb\n   */\n\n  remove: function remove(child, cb) {\n    var keepAlive = this.keepAlive;\n    if (child) {\n      // we may have a component switch when a previous\n      // component is still being transitioned out.\n      // we want to trigger only one lastest insertion cb\n      // when the existing transition finishes. (#1119)\n      this.pendingRemovals++;\n      this.pendingRemovalCb = cb;\n      var self = this;\n      child.$remove(function () {\n        self.pendingRemovals--;\n        if (!keepAlive) child._cleanup();\n        if (!self.pendingRemovals && self.pendingRemovalCb) {\n          self.pendingRemovalCb();\n          self.pendingRemovalCb = null;\n        }\n      });\n    } else if (cb) {\n      cb();\n    }\n  },\n\n  /**\n   * Actually swap the components, depending on the\n   * transition mode. Defaults to simultaneous.\n   *\n   * @param {Vue} target\n   * @param {Function} [cb]\n   */\n\n  transition: function transition(target, cb) {\n    var self = this;\n    var current = this.childVM;\n    // for devtool inspection\n    if (current) current._inactive = true;\n    target._inactive = false;\n    this.childVM = target;\n    switch (self.params.transitionMode) {\n      case 'in-out':\n        target.$before(self.anchor, function () {\n          self.remove(current, cb);\n        });\n        break;\n      case 'out-in':\n        self.remove(current, function () {\n          target.$before(self.anchor, cb);\n        });\n        break;\n      default:\n        self.remove(current);\n        target.$before(self.anchor, cb);\n    }\n  },\n\n  /**\n   * Unbind.\n   */\n\n  unbind: function unbind() {\n    this.invalidatePending();\n    // Do not defer cleanup when unbinding\n    this.unbuild();\n    // destroy all keep-alive cached instances\n    if (this.cache) {\n      for (var key in this.cache) {\n        this.cache[key].$destroy();\n      }\n      this.cache = null;\n    }\n  }\n};\n\n/**\n * Call activate hooks in order (asynchronous)\n *\n * @param {Array} hooks\n * @param {Vue} vm\n * @param {Function} cb\n */\n\nfunction callActivateHooks(hooks, vm, cb) {\n  var total = hooks.length;\n  var called = 0;\n  hooks[0].call(vm, next);\n  function next() {\n    if (++called >= total) {\n      cb();\n    } else {\n      hooks[called].call(vm, next);\n    }\n  }\n}\n\nvar propBindingModes = config._propBindingModes;\nvar empty = {};\n\n// regexes\nvar identRE$1 = /^[$_a-zA-Z]+[\\w$]*$/;\nvar settablePathRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\[[^\\[\\]]+\\])*$/;\n\n/**\n * Compile props on a root element and return\n * a props link function.\n *\n * @param {Element|DocumentFragment} el\n * @param {Array} propOptions\n * @param {Vue} vm\n * @return {Function} propsLinkFn\n */\n\nfunction compileProps(el, propOptions, vm) {\n  var props = [];\n  var names = Object.keys(propOptions);\n  var i = names.length;\n  var options, name, attr, value, path, parsed, prop;\n  while (i--) {\n    name = names[i];\n    options = propOptions[name] || empty;\n\n    if (process.env.NODE_ENV !== 'production' && name === '$data') {\n      warn('Do not use $data as prop.', vm);\n      continue;\n    }\n\n    // props could contain dashes, which will be\n    // interpreted as minus calculations by the parser\n    // so we need to camelize the path here\n    path = camelize(name);\n    if (!identRE$1.test(path)) {\n      process.env.NODE_ENV !== 'production' && warn('Invalid prop key: \"' + name + '\". Prop keys ' + 'must be valid identifiers.', vm);\n      continue;\n    }\n\n    prop = {\n      name: name,\n      path: path,\n      options: options,\n      mode: propBindingModes.ONE_WAY,\n      raw: null\n    };\n\n    attr = hyphenate(name);\n    // first check dynamic version\n    if ((value = getBindAttr(el, attr)) === null) {\n      if ((value = getBindAttr(el, attr + '.sync')) !== null) {\n        prop.mode = propBindingModes.TWO_WAY;\n      } else if ((value = getBindAttr(el, attr + '.once')) !== null) {\n        prop.mode = propBindingModes.ONE_TIME;\n      }\n    }\n    if (value !== null) {\n      // has dynamic binding!\n      prop.raw = value;\n      parsed = parseDirective(value);\n      value = parsed.expression;\n      prop.filters = parsed.filters;\n      // check binding type\n      if (isLiteral(value) && !parsed.filters) {\n        // for expressions containing literal numbers and\n        // booleans, there's no need to setup a prop binding,\n        // so we can optimize them as a one-time set.\n        prop.optimizedLiteral = true;\n      } else {\n        prop.dynamic = true;\n        // check non-settable path for two-way bindings\n        if (process.env.NODE_ENV !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {\n          prop.mode = propBindingModes.ONE_WAY;\n          warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);\n        }\n      }\n      prop.parentPath = value;\n\n      // warn required two-way\n      if (process.env.NODE_ENV !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {\n        warn('Prop \"' + name + '\" expects a two-way binding type.', vm);\n      }\n    } else if ((value = getAttr(el, attr)) !== null) {\n      // has literal binding!\n      prop.raw = value;\n    } else if (process.env.NODE_ENV !== 'production') {\n      // check possible camelCase prop usage\n      var lowerCaseName = path.toLowerCase();\n      value = /[A-Z\\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));\n      if (value) {\n        warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);\n      } else if (options.required) {\n        // warn missing required\n        warn('Missing required prop: ' + name, vm);\n      }\n    }\n    // push prop\n    props.push(prop);\n  }\n  return makePropsLinkFn(props);\n}\n\n/**\n * Build a function that applies props to a vm.\n *\n * @param {Array} props\n * @return {Function} propsLinkFn\n */\n\nfunction makePropsLinkFn(props) {\n  return function propsLinkFn(vm, scope) {\n    // store resolved props info\n    vm._props = {};\n    var inlineProps = vm.$options.propsData;\n    var i = props.length;\n    var prop, path, options, value, raw;\n    while (i--) {\n      prop = props[i];\n      raw = prop.raw;\n      path = prop.path;\n      options = prop.options;\n      vm._props[path] = prop;\n      if (inlineProps && hasOwn(inlineProps, path)) {\n        initProp(vm, prop, inlineProps[path]);\n      }if (raw === null) {\n        // initialize absent prop\n        initProp(vm, prop, undefined);\n      } else if (prop.dynamic) {\n        // dynamic prop\n        if (prop.mode === propBindingModes.ONE_TIME) {\n          // one time binding\n          value = (scope || vm._context || vm).$get(prop.parentPath);\n          initProp(vm, prop, value);\n        } else {\n          if (vm._context) {\n            // dynamic binding\n            vm._bindDir({\n              name: 'prop',\n              def: propDef,\n              prop: prop\n            }, null, null, scope); // el, host, scope\n          } else {\n              // root instance\n              initProp(vm, prop, vm.$get(prop.parentPath));\n            }\n        }\n      } else if (prop.optimizedLiteral) {\n        // optimized literal, cast it and just set once\n        var stripped = stripQuotes(raw);\n        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;\n        initProp(vm, prop, value);\n      } else {\n        // string literal, but we need to cater for\n        // Boolean props with no value, or with same\n        // literal value (e.g. disabled=\"disabled\")\n        // see https://github.com/vuejs/vue-loader/issues/182\n        value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;\n        initProp(vm, prop, value);\n      }\n    }\n  };\n}\n\n/**\n * Process a prop with a rawValue, applying necessary coersions,\n * default values & assertions and call the given callback with\n * processed value.\n *\n * @param {Vue} vm\n * @param {Object} prop\n * @param {*} rawValue\n * @param {Function} fn\n */\n\nfunction processPropValue(vm, prop, rawValue, fn) {\n  var isSimple = prop.dynamic && isSimplePath(prop.parentPath);\n  var value = rawValue;\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop);\n  }\n  value = coerceProp(prop, value, vm);\n  var coerced = value !== rawValue;\n  if (!assertProp(prop, value, vm)) {\n    value = undefined;\n  }\n  if (isSimple && !coerced) {\n    withoutConversion(function () {\n      fn(value);\n    });\n  } else {\n    fn(value);\n  }\n}\n\n/**\n * Set a prop's initial value on a vm and its data object.\n *\n * @param {Vue} vm\n * @param {Object} prop\n * @param {*} value\n */\n\nfunction initProp(vm, prop, value) {\n  processPropValue(vm, prop, value, function (value) {\n    defineReactive(vm, prop.path, value);\n  });\n}\n\n/**\n * Update a prop's value on a vm.\n *\n * @param {Vue} vm\n * @param {Object} prop\n * @param {*} value\n */\n\nfunction updateProp(vm, prop, value) {\n  processPropValue(vm, prop, value, function (value) {\n    vm[prop.path] = value;\n  });\n}\n\n/**\n * Get the default value of a prop.\n *\n * @param {Vue} vm\n * @param {Object} prop\n * @return {*}\n */\n\nfunction getPropDefaultValue(vm, prop) {\n  // no default, return undefined\n  var options = prop.options;\n  if (!hasOwn(options, 'default')) {\n    // absent boolean value defaults to false\n    return options.type === Boolean ? false : undefined;\n  }\n  var def = options['default'];\n  // warn against non-factory defaults for Object & Array\n  if (isObject(def)) {\n    process.env.NODE_ENV !== 'production' && warn('Invalid default value for prop \"' + prop.name + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n  }\n  // call factory function for non-Function types\n  return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;\n}\n\n/**\n * Assert whether a prop is valid.\n *\n * @param {Object} prop\n * @param {*} value\n * @param {Vue} vm\n */\n\nfunction assertProp(prop, value, vm) {\n  if (!prop.options.required && ( // non-required\n  prop.raw === null || // abscent\n  value == null) // null or undefined\n  ) {\n      return true;\n    }\n  var options = prop.options;\n  var type = options.type;\n  var valid = !type;\n  var expectedTypes = [];\n  if (type) {\n    if (!isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType);\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    if (process.env.NODE_ENV !== 'production') {\n      warn('Invalid prop: type check failed for prop \"' + prop.name + '\".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);\n    }\n    return false;\n  }\n  var validator = options.validator;\n  if (validator) {\n    if (!validator(value)) {\n      process.env.NODE_ENV !== 'production' && warn('Invalid prop: custom validator check failed for prop \"' + prop.name + '\".', vm);\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Force parsing value with coerce option.\n *\n * @param {*} value\n * @param {Object} options\n * @return {*}\n */\n\nfunction coerceProp(prop, value, vm) {\n  var coerce = prop.options.coerce;\n  if (!coerce) {\n    return value;\n  }\n  if (typeof coerce === 'function') {\n    return coerce(value);\n  } else {\n    process.env.NODE_ENV !== 'production' && warn('Invalid coerce for prop \"' + prop.name + '\": expected function, got ' + typeof coerce + '.', vm);\n    return value;\n  }\n}\n\n/**\n * Assert the type of a value\n *\n * @param {*} value\n * @param {Function} type\n * @return {Object}\n */\n\nfunction assertType(value, type) {\n  var valid;\n  var expectedType;\n  if (type === String) {\n    expectedType = 'string';\n    valid = typeof value === expectedType;\n  } else if (type === Number) {\n    expectedType = 'number';\n    valid = typeof value === expectedType;\n  } else if (type === Boolean) {\n    expectedType = 'boolean';\n    valid = typeof value === expectedType;\n  } else if (type === Function) {\n    expectedType = 'function';\n    valid = typeof value === expectedType;\n  } else if (type === Object) {\n    expectedType = 'object';\n    valid = isPlainObject(value);\n  } else if (type === Array) {\n    expectedType = 'array';\n    valid = isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  };\n}\n\n/**\n * Format type for output\n *\n * @param {String} type\n * @return {String}\n */\n\nfunction formatType(type) {\n  return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';\n}\n\n/**\n * Format value\n *\n * @param {*} value\n * @return {String}\n */\n\nfunction formatValue(val) {\n  return Object.prototype.toString.call(val).slice(8, -1);\n}\n\nvar bindingModes = config._propBindingModes;\n\nvar propDef = {\n\n  bind: function bind() {\n    var child = this.vm;\n    var parent = child._context;\n    // passed in from compiler directly\n    var prop = this.descriptor.prop;\n    var childKey = prop.path;\n    var parentKey = prop.parentPath;\n    var twoWay = prop.mode === bindingModes.TWO_WAY;\n\n    var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {\n      updateProp(child, prop, val);\n    }, {\n      twoWay: twoWay,\n      filters: prop.filters,\n      // important: props need to be observed on the\n      // v-for scope if present\n      scope: this._scope\n    });\n\n    // set the child initial value.\n    initProp(child, prop, parentWatcher.value);\n\n    // setup two-way binding\n    if (twoWay) {\n      // important: defer the child watcher creation until\n      // the created hook (after data observation)\n      var self = this;\n      child.$once('pre-hook:created', function () {\n        self.childWatcher = new Watcher(child, childKey, function (val) {\n          parentWatcher.set(val);\n        }, {\n          // ensure sync upward before parent sync down.\n          // this is necessary in cases e.g. the child\n          // mutates a prop array, then replaces it. (#1683)\n          sync: true\n        });\n      });\n    }\n  },\n\n  unbind: function unbind() {\n    this.parentWatcher.teardown();\n    if (this.childWatcher) {\n      this.childWatcher.teardown();\n    }\n  }\n};\n\nvar queue$1 = [];\nvar queued = false;\n\n/**\n * Push a job into the queue.\n *\n * @param {Function} job\n */\n\nfunction pushJob(job) {\n  queue$1.push(job);\n  if (!queued) {\n    queued = true;\n    nextTick(flush);\n  }\n}\n\n/**\n * Flush the queue, and do one forced reflow before\n * triggering transitions.\n */\n\nfunction flush() {\n  // Force layout\n  var f = document.documentElement.offsetHeight;\n  for (var i = 0; i < queue$1.length; i++) {\n    queue$1[i]();\n  }\n  queue$1 = [];\n  queued = false;\n  // dummy return, so js linters don't complain about\n  // unused variable f\n  return f;\n}\n\nvar TYPE_TRANSITION = 'transition';\nvar TYPE_ANIMATION = 'animation';\nvar transDurationProp = transitionProp + 'Duration';\nvar animDurationProp = animationProp + 'Duration';\n\n/**\n * If a just-entered element is applied the\n * leave class while its enter transition hasn't started yet,\n * and the transitioned property has the same value for both\n * enter/leave, then the leave transition will be skipped and\n * the transitionend event never fires. This function ensures\n * its callback to be called after a transition has started\n * by waiting for double raf.\n *\n * It falls back to setTimeout on devices that support CSS\n * transitions but not raf (e.g. Android 4.2 browser) - since\n * these environments are usually slow, we are giving it a\n * relatively large timeout.\n */\n\nvar raf = inBrowser && window.requestAnimationFrame;\nvar waitForTransitionStart = raf\n/* istanbul ignore next */\n? function (fn) {\n  raf(function () {\n    raf(fn);\n  });\n} : function (fn) {\n  setTimeout(fn, 50);\n};\n\n/**\n * A Transition object that encapsulates the state and logic\n * of the transition.\n *\n * @param {Element} el\n * @param {String} id\n * @param {Object} hooks\n * @param {Vue} vm\n */\nfunction Transition(el, id, hooks, vm) {\n  this.id = id;\n  this.el = el;\n  this.enterClass = hooks && hooks.enterClass || id + '-enter';\n  this.leaveClass = hooks && hooks.leaveClass || id + '-leave';\n  this.hooks = hooks;\n  this.vm = vm;\n  // async state\n  this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;\n  this.justEntered = false;\n  this.entered = this.left = false;\n  this.typeCache = {};\n  // check css transition type\n  this.type = hooks && hooks.type;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production') {\n    if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {\n      warn('invalid CSS transition type for transition=\"' + this.id + '\": ' + this.type, vm);\n    }\n  }\n  // bind\n  var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {\n    self[m] = bind(self[m], self);\n  });\n}\n\nvar p$1 = Transition.prototype;\n\n/**\n * Start an entering transition.\n *\n * 1. enter transition triggered\n * 2. call beforeEnter hook\n * 3. add enter class\n * 4. insert/show element\n * 5. call enter hook (with possible explicit js callback)\n * 6. reflow\n * 7. based on transition type:\n *    - transition:\n *        remove class now, wait for transitionend,\n *        then done if there's no explicit js callback.\n *    - animation:\n *        wait for animationend, remove class,\n *        then done if there's no explicit js callback.\n *    - no css transition:\n *        done now if there's no explicit js callback.\n * 8. wait for either done or js callback, then call\n *    afterEnter hook.\n *\n * @param {Function} op - insert/show the element\n * @param {Function} [cb]\n */\n\np$1.enter = function (op, cb) {\n  this.cancelPending();\n  this.callHook('beforeEnter');\n  this.cb = cb;\n  addClass(this.el, this.enterClass);\n  op();\n  this.entered = false;\n  this.callHookWithCb('enter');\n  if (this.entered) {\n    return; // user called done synchronously.\n  }\n  this.cancel = this.hooks && this.hooks.enterCancelled;\n  pushJob(this.enterNextTick);\n};\n\n/**\n * The \"nextTick\" phase of an entering transition, which is\n * to be pushed into a queue and executed after a reflow so\n * that removing the class can trigger a CSS transition.\n */\n\np$1.enterNextTick = function () {\n  var _this = this;\n\n  // prevent transition skipping\n  this.justEntered = true;\n  waitForTransitionStart(function () {\n    _this.justEntered = false;\n  });\n  var enterDone = this.enterDone;\n  var type = this.getCssTransitionType(this.enterClass);\n  if (!this.pendingJsCb) {\n    if (type === TYPE_TRANSITION) {\n      // trigger transition by removing enter class now\n      removeClass(this.el, this.enterClass);\n      this.setupCssCb(transitionEndEvent, enterDone);\n    } else if (type === TYPE_ANIMATION) {\n      this.setupCssCb(animationEndEvent, enterDone);\n    } else {\n      enterDone();\n    }\n  } else if (type === TYPE_TRANSITION) {\n    removeClass(this.el, this.enterClass);\n  }\n};\n\n/**\n * The \"cleanup\" phase of an entering transition.\n */\n\np$1.enterDone = function () {\n  this.entered = true;\n  this.cancel = this.pendingJsCb = null;\n  removeClass(this.el, this.enterClass);\n  this.callHook('afterEnter');\n  if (this.cb) this.cb();\n};\n\n/**\n * Start a leaving transition.\n *\n * 1. leave transition triggered.\n * 2. call beforeLeave hook\n * 3. add leave class (trigger css transition)\n * 4. call leave hook (with possible explicit js callback)\n * 5. reflow if no explicit js callback is provided\n * 6. based on transition type:\n *    - transition or animation:\n *        wait for end event, remove class, then done if\n *        there's no explicit js callback.\n *    - no css transition:\n *        done if there's no explicit js callback.\n * 7. wait for either done or js callback, then call\n *    afterLeave hook.\n *\n * @param {Function} op - remove/hide the element\n * @param {Function} [cb]\n */\n\np$1.leave = function (op, cb) {\n  this.cancelPending();\n  this.callHook('beforeLeave');\n  this.op = op;\n  this.cb = cb;\n  addClass(this.el, this.leaveClass);\n  this.left = false;\n  this.callHookWithCb('leave');\n  if (this.left) {\n    return; // user called done synchronously.\n  }\n  this.cancel = this.hooks && this.hooks.leaveCancelled;\n  // only need to handle leaveDone if\n  // 1. the transition is already done (synchronously called\n  //    by the user, which causes this.op set to null)\n  // 2. there's no explicit js callback\n  if (this.op && !this.pendingJsCb) {\n    // if a CSS transition leaves immediately after enter,\n    // the transitionend event never fires. therefore we\n    // detect such cases and end the leave immediately.\n    if (this.justEntered) {\n      this.leaveDone();\n    } else {\n      pushJob(this.leaveNextTick);\n    }\n  }\n};\n\n/**\n * The \"nextTick\" phase of a leaving transition.\n */\n\np$1.leaveNextTick = function () {\n  var type = this.getCssTransitionType(this.leaveClass);\n  if (type) {\n    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;\n    this.setupCssCb(event, this.leaveDone);\n  } else {\n    this.leaveDone();\n  }\n};\n\n/**\n * The \"cleanup\" phase of a leaving transition.\n */\n\np$1.leaveDone = function () {\n  this.left = true;\n  this.cancel = this.pendingJsCb = null;\n  this.op();\n  removeClass(this.el, this.leaveClass);\n  this.callHook('afterLeave');\n  if (this.cb) this.cb();\n  this.op = null;\n};\n\n/**\n * Cancel any pending callbacks from a previously running\n * but not finished transition.\n */\n\np$1.cancelPending = function () {\n  this.op = this.cb = null;\n  var hasPending = false;\n  if (this.pendingCssCb) {\n    hasPending = true;\n    off(this.el, this.pendingCssEvent, this.pendingCssCb);\n    this.pendingCssEvent = this.pendingCssCb = null;\n  }\n  if (this.pendingJsCb) {\n    hasPending = true;\n    this.pendingJsCb.cancel();\n    this.pendingJsCb = null;\n  }\n  if (hasPending) {\n    removeClass(this.el, this.enterClass);\n    removeClass(this.el, this.leaveClass);\n  }\n  if (this.cancel) {\n    this.cancel.call(this.vm, this.el);\n    this.cancel = null;\n  }\n};\n\n/**\n * Call a user-provided synchronous hook function.\n *\n * @param {String} type\n */\n\np$1.callHook = function (type) {\n  if (this.hooks && this.hooks[type]) {\n    this.hooks[type].call(this.vm, this.el);\n  }\n};\n\n/**\n * Call a user-provided, potentially-async hook function.\n * We check for the length of arguments to see if the hook\n * expects a `done` callback. If true, the transition's end\n * will be determined by when the user calls that callback;\n * otherwise, the end is determined by the CSS transition or\n * animation.\n *\n * @param {String} type\n */\n\np$1.callHookWithCb = function (type) {\n  var hook = this.hooks && this.hooks[type];\n  if (hook) {\n    if (hook.length > 1) {\n      this.pendingJsCb = cancellable(this[type + 'Done']);\n    }\n    hook.call(this.vm, this.el, this.pendingJsCb);\n  }\n};\n\n/**\n * Get an element's transition type based on the\n * calculated styles.\n *\n * @param {String} className\n * @return {Number}\n */\n\np$1.getCssTransitionType = function (className) {\n  /* istanbul ignore if */\n  if (!transitionEndEvent ||\n  // skip CSS transitions if page is not visible -\n  // this solves the issue of transitionend events not\n  // firing until the page is visible again.\n  // pageVisibility API is supported in IE10+, same as\n  // CSS transitions.\n  document.hidden ||\n  // explicit js-only transition\n  this.hooks && this.hooks.css === false ||\n  // element is hidden\n  isHidden(this.el)) {\n    return;\n  }\n  var type = this.type || this.typeCache[className];\n  if (type) return type;\n  var inlineStyles = this.el.style;\n  var computedStyles = window.getComputedStyle(this.el);\n  var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];\n  if (transDuration && transDuration !== '0s') {\n    type = TYPE_TRANSITION;\n  } else {\n    var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];\n    if (animDuration && animDuration !== '0s') {\n      type = TYPE_ANIMATION;\n    }\n  }\n  if (type) {\n    this.typeCache[className] = type;\n  }\n  return type;\n};\n\n/**\n * Setup a CSS transitionend/animationend callback.\n *\n * @param {String} event\n * @param {Function} cb\n */\n\np$1.setupCssCb = function (event, cb) {\n  this.pendingCssEvent = event;\n  var self = this;\n  var el = this.el;\n  var onEnd = this.pendingCssCb = function (e) {\n    if (e.target === el) {\n      off(el, event, onEnd);\n      self.pendingCssEvent = self.pendingCssCb = null;\n      if (!self.pendingJsCb && cb) {\n        cb();\n      }\n    }\n  };\n  on(el, event, onEnd);\n};\n\n/**\n * Check if an element is hidden - in that case we can just\n * skip the transition alltogether.\n *\n * @param {Element} el\n * @return {Boolean}\n */\n\nfunction isHidden(el) {\n  if (/svg$/.test(el.namespaceURI)) {\n    // SVG elements do not have offset(Width|Height)\n    // so we need to check the client rect\n    var rect = el.getBoundingClientRect();\n    return !(rect.width || rect.height);\n  } else {\n    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\n  }\n}\n\nvar transition$1 = {\n\n  priority: TRANSITION,\n\n  update: function update(id, oldId) {\n    var el = this.el;\n    // resolve on owner vm\n    var hooks = resolveAsset(this.vm.$options, 'transitions', id);\n    id = id || 'v';\n    oldId = oldId || 'v';\n    el.__v_trans = new Transition(el, id, hooks, this.vm);\n    removeClass(el, oldId + '-transition');\n    addClass(el, id + '-transition');\n  }\n};\n\nvar internalDirectives = {\n  style: style,\n  'class': vClass,\n  component: component,\n  prop: propDef,\n  transition: transition$1\n};\n\n// special binding prefixes\nvar bindRE = /^v-bind:|^:/;\nvar onRE = /^v-on:|^@/;\nvar dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;\nvar modifierRE = /\\.[^\\.]+/g;\nvar transitionRE = /^(v-bind:|:)?transition$/;\n\n// default directive priority\nvar DEFAULT_PRIORITY = 1000;\nvar DEFAULT_TERMINAL_PRIORITY = 2000;\n\n/**\n * Compile a template and return a reusable composite link\n * function, which recursively contains more link functions\n * inside. This top level compile function would normally\n * be called on instance root nodes, but can also be used\n * for partial compilation if the partial argument is true.\n *\n * The returned composite link function, when called, will\n * return an unlink function that tearsdown all directives\n * created during the linking phase.\n *\n * @param {Element|DocumentFragment} el\n * @param {Object} options\n * @param {Boolean} partial\n * @return {Function}\n */\n\nfunction compile(el, options, partial) {\n  // link function for the node itself.\n  var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;\n  // link function for the childNodes\n  var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && !isScript(el) && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;\n\n  /**\n   * A composite linker function to be called on a already\n   * compiled piece of DOM, which instantiates all directive\n   * instances.\n   *\n   * @param {Vue} vm\n   * @param {Element|DocumentFragment} el\n   * @param {Vue} [host] - host vm of transcluded content\n   * @param {Object} [scope] - v-for scope\n   * @param {Fragment} [frag] - link context fragment\n   * @return {Function|undefined}\n   */\n\n  return function compositeLinkFn(vm, el, host, scope, frag) {\n    // cache childNodes before linking parent, fix #657\n    var childNodes = toArray(el.childNodes);\n    // link\n    var dirs = linkAndCapture(function compositeLinkCapturer() {\n      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);\n      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);\n    }, vm);\n    return makeUnlinkFn(vm, dirs);\n  };\n}\n\n/**\n * Apply a linker to a vm/element pair and capture the\n * directives created during the process.\n *\n * @param {Function} linker\n * @param {Vue} vm\n */\n\nfunction linkAndCapture(linker, vm) {\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV === 'production') {\n    // reset directives before every capture in production\n    // mode, so that when unlinking we don't need to splice\n    // them out (which turns out to be a perf hit).\n    // they are kept in development mode because they are\n    // useful for Vue's own tests.\n    vm._directives = [];\n  }\n  var originalDirCount = vm._directives.length;\n  linker();\n  var dirs = vm._directives.slice(originalDirCount);\n  dirs.sort(directiveComparator);\n  for (var i = 0, l = dirs.length; i < l; i++) {\n    dirs[i]._bind();\n  }\n  return dirs;\n}\n\n/**\n * Directive priority sort comparator\n *\n * @param {Object} a\n * @param {Object} b\n */\n\nfunction directiveComparator(a, b) {\n  a = a.descriptor.def.priority || DEFAULT_PRIORITY;\n  b = b.descriptor.def.priority || DEFAULT_PRIORITY;\n  return a > b ? -1 : a === b ? 0 : 1;\n}\n\n/**\n * Linker functions return an unlink function that\n * tearsdown all directives instances generated during\n * the process.\n *\n * We create unlink functions with only the necessary\n * information to avoid retaining additional closures.\n *\n * @param {Vue} vm\n * @param {Array} dirs\n * @param {Vue} [context]\n * @param {Array} [contextDirs]\n * @return {Function}\n */\n\nfunction makeUnlinkFn(vm, dirs, context, contextDirs) {\n  function unlink(destroying) {\n    teardownDirs(vm, dirs, destroying);\n    if (context && contextDirs) {\n      teardownDirs(context, contextDirs);\n    }\n  }\n  // expose linked directives\n  unlink.dirs = dirs;\n  return unlink;\n}\n\n/**\n * Teardown partial linked directives.\n *\n * @param {Vue} vm\n * @param {Array} dirs\n * @param {Boolean} destroying\n */\n\nfunction teardownDirs(vm, dirs, destroying) {\n  var i = dirs.length;\n  while (i--) {\n    dirs[i]._teardown();\n    if (process.env.NODE_ENV !== 'production' && !destroying) {\n      vm._directives.$remove(dirs[i]);\n    }\n  }\n}\n\n/**\n * Compile link props on an instance.\n *\n * @param {Vue} vm\n * @param {Element} el\n * @param {Object} props\n * @param {Object} [scope]\n * @return {Function}\n */\n\nfunction compileAndLinkProps(vm, el, props, scope) {\n  var propsLinkFn = compileProps(el, props, vm);\n  var propDirs = linkAndCapture(function () {\n    propsLinkFn(vm, scope);\n  }, vm);\n  return makeUnlinkFn(vm, propDirs);\n}\n\n/**\n * Compile the root element of an instance.\n *\n * 1. attrs on context container (context scope)\n * 2. attrs on the component template root node, if\n *    replace:true (child scope)\n *\n * If this is a fragment instance, we only need to compile 1.\n *\n * @param {Element} el\n * @param {Object} options\n * @param {Object} contextOptions\n * @return {Function}\n */\n\nfunction compileRoot(el, options, contextOptions) {\n  var containerAttrs = options._containerAttrs;\n  var replacerAttrs = options._replacerAttrs;\n  var contextLinkFn, replacerLinkFn;\n\n  // only need to compile other attributes for\n  // non-fragment instances\n  if (el.nodeType !== 11) {\n    // for components, container and replacer need to be\n    // compiled separately and linked in different scopes.\n    if (options._asComponent) {\n      // 2. container attributes\n      if (containerAttrs && contextOptions) {\n        contextLinkFn = compileDirectives(containerAttrs, contextOptions);\n      }\n      if (replacerAttrs) {\n        // 3. replacer attributes\n        replacerLinkFn = compileDirectives(replacerAttrs, options);\n      }\n    } else {\n      // non-component, just compile as a normal element.\n      replacerLinkFn = compileDirectives(el.attributes, options);\n    }\n  } else if (process.env.NODE_ENV !== 'production' && containerAttrs) {\n    // warn container directives for fragment instances\n    var names = containerAttrs.filter(function (attr) {\n      // allow vue-loader/vueify scoped css attributes\n      return attr.name.indexOf('_v-') < 0 &&\n      // allow event listeners\n      !onRE.test(attr.name) &&\n      // allow slots\n      attr.name !== 'slot';\n    }).map(function (attr) {\n      return '\"' + attr.name + '\"';\n    });\n    if (names.length) {\n      var plural = names.length > 1;\n      warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment-Instance');\n    }\n  }\n\n  options._containerAttrs = options._replacerAttrs = null;\n  return function rootLinkFn(vm, el, scope) {\n    // link context scope dirs\n    var context = vm._context;\n    var contextDirs;\n    if (context && contextLinkFn) {\n      contextDirs = linkAndCapture(function () {\n        contextLinkFn(context, el, null, scope);\n      }, context);\n    }\n\n    // link self\n    var selfDirs = linkAndCapture(function () {\n      if (replacerLinkFn) replacerLinkFn(vm, el);\n    }, vm);\n\n    // return the unlink function that tearsdown context\n    // container directives.\n    return makeUnlinkFn(vm, selfDirs, context, contextDirs);\n  };\n}\n\n/**\n * Compile a node and return a nodeLinkFn based on the\n * node type.\n *\n * @param {Node} node\n * @param {Object} options\n * @return {Function|null}\n */\n\nfunction compileNode(node, options) {\n  var type = node.nodeType;\n  if (type === 1 && !isScript(node)) {\n    return compileElement(node, options);\n  } else if (type === 3 && node.data.trim()) {\n    return compileTextNode(node, options);\n  } else {\n    return null;\n  }\n}\n\n/**\n * Compile an element and return a nodeLinkFn.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Function|null}\n */\n\nfunction compileElement(el, options) {\n  // preprocess textareas.\n  // textarea treats its text content as the initial value.\n  // just bind it as an attr directive for value.\n  if (el.tagName === 'TEXTAREA') {\n    var tokens = parseText(el.value);\n    if (tokens) {\n      el.setAttribute(':value', tokensToExp(tokens));\n      el.value = '';\n    }\n  }\n  var linkFn;\n  var hasAttrs = el.hasAttributes();\n  var attrs = hasAttrs && toArray(el.attributes);\n  // check terminal directives (for & if)\n  if (hasAttrs) {\n    linkFn = checkTerminalDirectives(el, attrs, options);\n  }\n  // check element directives\n  if (!linkFn) {\n    linkFn = checkElementDirectives(el, options);\n  }\n  // check component\n  if (!linkFn) {\n    linkFn = checkComponent(el, options);\n  }\n  // normal directives\n  if (!linkFn && hasAttrs) {\n    linkFn = compileDirectives(attrs, options);\n  }\n  return linkFn;\n}\n\n/**\n * Compile a textNode and return a nodeLinkFn.\n *\n * @param {TextNode} node\n * @param {Object} options\n * @return {Function|null} textNodeLinkFn\n */\n\nfunction compileTextNode(node, options) {\n  // skip marked text nodes\n  if (node._skip) {\n    return removeText;\n  }\n\n  var tokens = parseText(node.wholeText);\n  if (!tokens) {\n    return null;\n  }\n\n  // mark adjacent text nodes as skipped,\n  // because we are using node.wholeText to compile\n  // all adjacent text nodes together. This fixes\n  // issues in IE where sometimes it splits up a single\n  // text node into multiple ones.\n  var next = node.nextSibling;\n  while (next && next.nodeType === 3) {\n    next._skip = true;\n    next = next.nextSibling;\n  }\n\n  var frag = document.createDocumentFragment();\n  var el, token;\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);\n    frag.appendChild(el);\n  }\n  return makeTextNodeLinkFn(tokens, frag, options);\n}\n\n/**\n * Linker for an skipped text node.\n *\n * @param {Vue} vm\n * @param {Text} node\n */\n\nfunction removeText(vm, node) {\n  remove(node);\n}\n\n/**\n * Process a single text token.\n *\n * @param {Object} token\n * @param {Object} options\n * @return {Node}\n */\n\nfunction processTextToken(token, options) {\n  var el;\n  if (token.oneTime) {\n    el = document.createTextNode(token.value);\n  } else {\n    if (token.html) {\n      el = document.createComment('v-html');\n      setTokenType('html');\n    } else {\n      // IE will clean up empty textNodes during\n      // frag.cloneNode(true), so we have to give it\n      // something here...\n      el = document.createTextNode(' ');\n      setTokenType('text');\n    }\n  }\n  function setTokenType(type) {\n    if (token.descriptor) return;\n    var parsed = parseDirective(token.value);\n    token.descriptor = {\n      name: type,\n      def: directives[type],\n      expression: parsed.expression,\n      filters: parsed.filters\n    };\n  }\n  return el;\n}\n\n/**\n * Build a function that processes a textNode.\n *\n * @param {Array<Object>} tokens\n * @param {DocumentFragment} frag\n */\n\nfunction makeTextNodeLinkFn(tokens, frag) {\n  return function textNodeLinkFn(vm, el, host, scope) {\n    var fragClone = frag.cloneNode(true);\n    var childNodes = toArray(fragClone.childNodes);\n    var token, value, node;\n    for (var i = 0, l = tokens.length; i < l; i++) {\n      token = tokens[i];\n      value = token.value;\n      if (token.tag) {\n        node = childNodes[i];\n        if (token.oneTime) {\n          value = (scope || vm).$eval(value);\n          if (token.html) {\n            replace(node, parseTemplate(value, true));\n          } else {\n            node.data = _toString(value);\n          }\n        } else {\n          vm._bindDir(token.descriptor, node, host, scope);\n        }\n      }\n    }\n    replace(el, fragClone);\n  };\n}\n\n/**\n * Compile a node list and return a childLinkFn.\n *\n * @param {NodeList} nodeList\n * @param {Object} options\n * @return {Function|undefined}\n */\n\nfunction compileNodeList(nodeList, options) {\n  var linkFns = [];\n  var nodeLinkFn, childLinkFn, node;\n  for (var i = 0, l = nodeList.length; i < l; i++) {\n    node = nodeList[i];\n    nodeLinkFn = compileNode(node, options);\n    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;\n    linkFns.push(nodeLinkFn, childLinkFn);\n  }\n  return linkFns.length ? makeChildLinkFn(linkFns) : null;\n}\n\n/**\n * Make a child link function for a node's childNodes.\n *\n * @param {Array<Function>} linkFns\n * @return {Function} childLinkFn\n */\n\nfunction makeChildLinkFn(linkFns) {\n  return function childLinkFn(vm, nodes, host, scope, frag) {\n    var node, nodeLinkFn, childrenLinkFn;\n    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {\n      node = nodes[n];\n      nodeLinkFn = linkFns[i++];\n      childrenLinkFn = linkFns[i++];\n      // cache childNodes before linking parent, fix #657\n      var childNodes = toArray(node.childNodes);\n      if (nodeLinkFn) {\n        nodeLinkFn(vm, node, host, scope, frag);\n      }\n      if (childrenLinkFn) {\n        childrenLinkFn(vm, childNodes, host, scope, frag);\n      }\n    }\n  };\n}\n\n/**\n * Check for element directives (custom elements that should\n * be resovled as terminal directives).\n *\n * @param {Element} el\n * @param {Object} options\n */\n\nfunction checkElementDirectives(el, options) {\n  var tag = el.tagName.toLowerCase();\n  if (commonTagRE.test(tag)) {\n    return;\n  }\n  var def = resolveAsset(options, 'elementDirectives', tag);\n  if (def) {\n    return makeTerminalNodeLinkFn(el, tag, '', options, def);\n  }\n}\n\n/**\n * Check if an element is a component. If yes, return\n * a component link function.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Function|undefined}\n */\n\nfunction checkComponent(el, options) {\n  var component = checkComponentAttr(el, options);\n  if (component) {\n    var ref = findRef(el);\n    var descriptor = {\n      name: 'component',\n      ref: ref,\n      expression: component.id,\n      def: internalDirectives.component,\n      modifiers: {\n        literal: !component.dynamic\n      }\n    };\n    var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {\n      if (ref) {\n        defineReactive((scope || vm).$refs, ref, null);\n      }\n      vm._bindDir(descriptor, el, host, scope, frag);\n    };\n    componentLinkFn.terminal = true;\n    return componentLinkFn;\n  }\n}\n\n/**\n * Check an element for terminal directives in fixed order.\n * If it finds one, return a terminal link function.\n *\n * @param {Element} el\n * @param {Array} attrs\n * @param {Object} options\n * @return {Function} terminalLinkFn\n */\n\nfunction checkTerminalDirectives(el, attrs, options) {\n  // skip v-pre\n  if (getAttr(el, 'v-pre') !== null) {\n    return skip;\n  }\n  // skip v-else block, but only if following v-if\n  if (el.hasAttribute('v-else')) {\n    var prev = el.previousElementSibling;\n    if (prev && prev.hasAttribute('v-if')) {\n      return skip;\n    }\n  }\n\n  var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;\n  for (var i = 0, j = attrs.length; i < j; i++) {\n    attr = attrs[i];\n    name = attr.name.replace(modifierRE, '');\n    if (matched = name.match(dirAttrRE)) {\n      def = resolveAsset(options, 'directives', matched[1]);\n      if (def && def.terminal) {\n        if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {\n          termDef = def;\n          rawName = attr.name;\n          modifiers = parseModifiers(attr.name);\n          value = attr.value;\n          dirName = matched[1];\n          arg = matched[2];\n        }\n      }\n    }\n  }\n\n  if (termDef) {\n    return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);\n  }\n}\n\nfunction skip() {}\nskip.terminal = true;\n\n/**\n * Build a node link function for a terminal directive.\n * A terminal link function terminates the current\n * compilation recursion and handles compilation of the\n * subtree in the directive.\n *\n * @param {Element} el\n * @param {String} dirName\n * @param {String} value\n * @param {Object} options\n * @param {Object} def\n * @param {String} [rawName]\n * @param {String} [arg]\n * @param {Object} [modifiers]\n * @return {Function} terminalLinkFn\n */\n\nfunction makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {\n  var parsed = parseDirective(value);\n  var descriptor = {\n    name: dirName,\n    arg: arg,\n    expression: parsed.expression,\n    filters: parsed.filters,\n    raw: value,\n    attr: rawName,\n    modifiers: modifiers,\n    def: def\n  };\n  // check ref for v-for and router-view\n  if (dirName === 'for' || dirName === 'router-view') {\n    descriptor.ref = findRef(el);\n  }\n  var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {\n    if (descriptor.ref) {\n      defineReactive((scope || vm).$refs, descriptor.ref, null);\n    }\n    vm._bindDir(descriptor, el, host, scope, frag);\n  };\n  fn.terminal = true;\n  return fn;\n}\n\n/**\n * Compile the directives on an element and return a linker.\n *\n * @param {Array|NamedNodeMap} attrs\n * @param {Object} options\n * @return {Function}\n */\n\nfunction compileDirectives(attrs, options) {\n  var i = attrs.length;\n  var dirs = [];\n  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;\n  while (i--) {\n    attr = attrs[i];\n    name = rawName = attr.name;\n    value = rawValue = attr.value;\n    tokens = parseText(value);\n    // reset arg\n    arg = null;\n    // check modifiers\n    modifiers = parseModifiers(name);\n    name = name.replace(modifierRE, '');\n\n    // attribute interpolations\n    if (tokens) {\n      value = tokensToExp(tokens);\n      arg = name;\n      pushDir('bind', directives.bind, tokens);\n      // warn against mixing mustaches with v-bind\n      if (process.env.NODE_ENV !== 'production') {\n        if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {\n          return attr.name === ':class' || attr.name === 'v-bind:class';\n        })) {\n          warn('class=\"' + rawValue + '\": Do not mix mustache interpolation ' + 'and v-bind for \"class\" on the same element. Use one or the other.', options);\n        }\n      }\n    } else\n\n      // special attribute: transition\n      if (transitionRE.test(name)) {\n        modifiers.literal = !bindRE.test(name);\n        pushDir('transition', internalDirectives.transition);\n      } else\n\n        // event handlers\n        if (onRE.test(name)) {\n          arg = name.replace(onRE, '');\n          pushDir('on', directives.on);\n        } else\n\n          // attribute bindings\n          if (bindRE.test(name)) {\n            dirName = name.replace(bindRE, '');\n            if (dirName === 'style' || dirName === 'class') {\n              pushDir(dirName, internalDirectives[dirName]);\n            } else {\n              arg = dirName;\n              pushDir('bind', directives.bind);\n            }\n          } else\n\n            // normal directives\n            if (matched = name.match(dirAttrRE)) {\n              dirName = matched[1];\n              arg = matched[2];\n\n              // skip v-else (when used with v-show)\n              if (dirName === 'else') {\n                continue;\n              }\n\n              dirDef = resolveAsset(options, 'directives', dirName, true);\n              if (dirDef) {\n                pushDir(dirName, dirDef);\n              }\n            }\n  }\n\n  /**\n   * Push a directive.\n   *\n   * @param {String} dirName\n   * @param {Object|Function} def\n   * @param {Array} [interpTokens]\n   */\n\n  function pushDir(dirName, def, interpTokens) {\n    var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);\n    var parsed = !hasOneTimeToken && parseDirective(value);\n    dirs.push({\n      name: dirName,\n      attr: rawName,\n      raw: rawValue,\n      def: def,\n      arg: arg,\n      modifiers: modifiers,\n      // conversion from interpolation strings with one-time token\n      // to expression is differed until directive bind time so that we\n      // have access to the actual vm context for one-time bindings.\n      expression: parsed && parsed.expression,\n      filters: parsed && parsed.filters,\n      interp: interpTokens,\n      hasOneTime: hasOneTimeToken\n    });\n  }\n\n  if (dirs.length) {\n    return makeNodeLinkFn(dirs);\n  }\n}\n\n/**\n * Parse modifiers from directive attribute name.\n *\n * @param {String} name\n * @return {Object}\n */\n\nfunction parseModifiers(name) {\n  var res = Object.create(null);\n  var match = name.match(modifierRE);\n  if (match) {\n    var i = match.length;\n    while (i--) {\n      res[match[i].slice(1)] = true;\n    }\n  }\n  return res;\n}\n\n/**\n * Build a link function for all directives on a single node.\n *\n * @param {Array} directives\n * @return {Function} directivesLinkFn\n */\n\nfunction makeNodeLinkFn(directives) {\n  return function nodeLinkFn(vm, el, host, scope, frag) {\n    // reverse apply because it's sorted low to high\n    var i = directives.length;\n    while (i--) {\n      vm._bindDir(directives[i], el, host, scope, frag);\n    }\n  };\n}\n\n/**\n * Check if an interpolation string contains one-time tokens.\n *\n * @param {Array} tokens\n * @return {Boolean}\n */\n\nfunction hasOneTime(tokens) {\n  var i = tokens.length;\n  while (i--) {\n    if (tokens[i].oneTime) return true;\n  }\n}\n\nfunction isScript(el) {\n  return el.tagName === 'SCRIPT' && (!el.hasAttribute('type') || el.getAttribute('type') === 'text/javascript');\n}\n\nvar specialCharRE = /[^\\w\\-:\\.]/;\n\n/**\n * Process an element or a DocumentFragment based on a\n * instance option object. This allows us to transclude\n * a template node/fragment before the instance is created,\n * so the processed fragment can then be cloned and reused\n * in v-for.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Element|DocumentFragment}\n */\n\nfunction transclude(el, options) {\n  // extract container attributes to pass them down\n  // to compiler, because they need to be compiled in\n  // parent scope. we are mutating the options object here\n  // assuming the same object will be used for compile\n  // right after this.\n  if (options) {\n    options._containerAttrs = extractAttrs(el);\n  }\n  // for template tags, what we want is its content as\n  // a documentFragment (for fragment instances)\n  if (isTemplate(el)) {\n    el = parseTemplate(el);\n  }\n  if (options) {\n    if (options._asComponent && !options.template) {\n      options.template = '<slot></slot>';\n    }\n    if (options.template) {\n      options._content = extractContent(el);\n      el = transcludeTemplate(el, options);\n    }\n  }\n  if (isFragment(el)) {\n    // anchors for fragment instance\n    // passing in `persist: true` to avoid them being\n    // discarded by IE during template cloning\n    prepend(createAnchor('v-start', true), el);\n    el.appendChild(createAnchor('v-end', true));\n  }\n  return el;\n}\n\n/**\n * Process the template option.\n * If the replace option is true this will swap the $el.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Element|DocumentFragment}\n */\n\nfunction transcludeTemplate(el, options) {\n  var template = options.template;\n  var frag = parseTemplate(template, true);\n  if (frag) {\n    var replacer = frag.firstChild;\n    var tag = replacer.tagName && replacer.tagName.toLowerCase();\n    if (options.replace) {\n      /* istanbul ignore if */\n      if (el === document.body) {\n        process.env.NODE_ENV !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');\n      }\n      // there are many cases where the instance must\n      // become a fragment instance: basically anything that\n      // can create more than 1 root nodes.\n      if (\n      // multi-children template\n      frag.childNodes.length > 1 ||\n      // non-element template\n      replacer.nodeType !== 1 ||\n      // single nested component\n      tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||\n      // element directive\n      resolveAsset(options, 'elementDirectives', tag) ||\n      // for block\n      replacer.hasAttribute('v-for') ||\n      // if block\n      replacer.hasAttribute('v-if')) {\n        return frag;\n      } else {\n        options._replacerAttrs = extractAttrs(replacer);\n        mergeAttrs(el, replacer);\n        return replacer;\n      }\n    } else {\n      el.appendChild(frag);\n      return el;\n    }\n  } else {\n    process.env.NODE_ENV !== 'production' && warn('Invalid template option: ' + template);\n  }\n}\n\n/**\n * Helper to extract a component container's attributes\n * into a plain object array.\n *\n * @param {Element} el\n * @return {Array}\n */\n\nfunction extractAttrs(el) {\n  if (el.nodeType === 1 && el.hasAttributes()) {\n    return toArray(el.attributes);\n  }\n}\n\n/**\n * Merge the attributes of two elements, and make sure\n * the class names are merged properly.\n *\n * @param {Element} from\n * @param {Element} to\n */\n\nfunction mergeAttrs(from, to) {\n  var attrs = from.attributes;\n  var i = attrs.length;\n  var name, value;\n  while (i--) {\n    name = attrs[i].name;\n    value = attrs[i].value;\n    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {\n      to.setAttribute(name, value);\n    } else if (name === 'class' && !parseText(value) && (value = value.trim())) {\n      value.split(/\\s+/).forEach(function (cls) {\n        addClass(to, cls);\n      });\n    }\n  }\n}\n\n/**\n * Scan and determine slot content distribution.\n * We do this during transclusion instead at compile time so that\n * the distribution is decoupled from the compilation order of\n * the slots.\n *\n * @param {Element|DocumentFragment} template\n * @param {Element} content\n * @param {Vue} vm\n */\n\nfunction resolveSlots(vm, content) {\n  if (!content) {\n    return;\n  }\n  var contents = vm._slotContents = Object.create(null);\n  var el, name;\n  for (var i = 0, l = content.children.length; i < l; i++) {\n    el = content.children[i];\n    /* eslint-disable no-cond-assign */\n    if (name = el.getAttribute('slot')) {\n      (contents[name] || (contents[name] = [])).push(el);\n    }\n    /* eslint-enable no-cond-assign */\n    if (process.env.NODE_ENV !== 'production' && getBindAttr(el, 'slot')) {\n      warn('The \"slot\" attribute must be static.', vm.$parent);\n    }\n  }\n  for (name in contents) {\n    contents[name] = extractFragment(contents[name], content);\n  }\n  if (content.hasChildNodes()) {\n    var nodes = content.childNodes;\n    if (nodes.length === 1 && nodes[0].nodeType === 3 && !nodes[0].data.trim()) {\n      return;\n    }\n    contents['default'] = extractFragment(content.childNodes, content);\n  }\n}\n\n/**\n * Extract qualified content nodes from a node list.\n *\n * @param {NodeList} nodes\n * @return {DocumentFragment}\n */\n\nfunction extractFragment(nodes, parent) {\n  var frag = document.createDocumentFragment();\n  nodes = toArray(nodes);\n  for (var i = 0, l = nodes.length; i < l; i++) {\n    var node = nodes[i];\n    if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {\n      parent.removeChild(node);\n      node = parseTemplate(node, true);\n    }\n    frag.appendChild(node);\n  }\n  return frag;\n}\n\n\n\nvar compiler = Object.freeze({\n\tcompile: compile,\n\tcompileAndLinkProps: compileAndLinkProps,\n\tcompileRoot: compileRoot,\n\ttransclude: transclude,\n\tresolveSlots: resolveSlots\n});\n\nfunction stateMixin (Vue) {\n  /**\n   * Accessor for `$data` property, since setting $data\n   * requires observing the new object and updating\n   * proxied properties.\n   */\n\n  Object.defineProperty(Vue.prototype, '$data', {\n    get: function get() {\n      return this._data;\n    },\n    set: function set(newData) {\n      if (newData !== this._data) {\n        this._setData(newData);\n      }\n    }\n  });\n\n  /**\n   * Setup the scope of an instance, which contains:\n   * - observed data\n   * - computed properties\n   * - user methods\n   * - meta properties\n   */\n\n  Vue.prototype._initState = function () {\n    this._initProps();\n    this._initMeta();\n    this._initMethods();\n    this._initData();\n    this._initComputed();\n  };\n\n  /**\n   * Initialize props.\n   */\n\n  Vue.prototype._initProps = function () {\n    var options = this.$options;\n    var el = options.el;\n    var props = options.props;\n    if (props && !el) {\n      process.env.NODE_ENV !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);\n    }\n    // make sure to convert string selectors into element now\n    el = options.el = query(el);\n    this._propsUnlinkFn = el && el.nodeType === 1 && props\n    // props must be linked in proper scope if inside v-for\n    ? compileAndLinkProps(this, el, props, this._scope) : null;\n  };\n\n  /**\n   * Initialize the data.\n   */\n\n  Vue.prototype._initData = function () {\n    var dataFn = this.$options.data;\n    var data = this._data = dataFn ? dataFn() : {};\n    if (!isPlainObject(data)) {\n      data = {};\n      process.env.NODE_ENV !== 'production' && warn('data functions should return an object.', this);\n    }\n    var props = this._props;\n    // proxy data on instance\n    var keys = Object.keys(data);\n    var i, key;\n    i = keys.length;\n    while (i--) {\n      key = keys[i];\n      // there are two scenarios where we can proxy a data key:\n      // 1. it's not already defined as a prop\n      // 2. it's provided via a instantiation option AND there are no\n      //    template prop present\n      if (!props || !hasOwn(props, key)) {\n        this._proxy(key);\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('Data field \"' + key + '\" is already defined ' + 'as a prop. To provide default value for a prop, use the \"default\" ' + 'prop option; if you want to pass prop values to an instantiation ' + 'call, use the \"propsData\" option.', this);\n      }\n    }\n    // observe data\n    observe(data, this);\n  };\n\n  /**\n   * Swap the instance's $data. Called in $data's setter.\n   *\n   * @param {Object} newData\n   */\n\n  Vue.prototype._setData = function (newData) {\n    newData = newData || {};\n    var oldData = this._data;\n    this._data = newData;\n    var keys, key, i;\n    // unproxy keys not present in new data\n    keys = Object.keys(oldData);\n    i = keys.length;\n    while (i--) {\n      key = keys[i];\n      if (!(key in newData)) {\n        this._unproxy(key);\n      }\n    }\n    // proxy keys not already proxied,\n    // and trigger change for changed values\n    keys = Object.keys(newData);\n    i = keys.length;\n    while (i--) {\n      key = keys[i];\n      if (!hasOwn(this, key)) {\n        // new property\n        this._proxy(key);\n      }\n    }\n    oldData.__ob__.removeVm(this);\n    observe(newData, this);\n    this._digest();\n  };\n\n  /**\n   * Proxy a property, so that\n   * vm.prop === vm._data.prop\n   *\n   * @param {String} key\n   */\n\n  Vue.prototype._proxy = function (key) {\n    if (!isReserved(key)) {\n      // need to store ref to self here\n      // because these getter/setters might\n      // be called by child scopes via\n      // prototype inheritance.\n      var self = this;\n      Object.defineProperty(self, key, {\n        configurable: true,\n        enumerable: true,\n        get: function proxyGetter() {\n          return self._data[key];\n        },\n        set: function proxySetter(val) {\n          self._data[key] = val;\n        }\n      });\n    }\n  };\n\n  /**\n   * Unproxy a property.\n   *\n   * @param {String} key\n   */\n\n  Vue.prototype._unproxy = function (key) {\n    if (!isReserved(key)) {\n      delete this[key];\n    }\n  };\n\n  /**\n   * Force update on every watcher in scope.\n   */\n\n  Vue.prototype._digest = function () {\n    for (var i = 0, l = this._watchers.length; i < l; i++) {\n      this._watchers[i].update(true); // shallow updates\n    }\n  };\n\n  /**\n   * Setup computed properties. They are essentially\n   * special getter/setters\n   */\n\n  function noop() {}\n  Vue.prototype._initComputed = function () {\n    var computed = this.$options.computed;\n    if (computed) {\n      for (var key in computed) {\n        var userDef = computed[key];\n        var def = {\n          enumerable: true,\n          configurable: true\n        };\n        if (typeof userDef === 'function') {\n          def.get = makeComputedGetter(userDef, this);\n          def.set = noop;\n        } else {\n          def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;\n          def.set = userDef.set ? bind(userDef.set, this) : noop;\n        }\n        Object.defineProperty(this, key, def);\n      }\n    }\n  };\n\n  function makeComputedGetter(getter, owner) {\n    var watcher = new Watcher(owner, getter, null, {\n      lazy: true\n    });\n    return function computedGetter() {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value;\n    };\n  }\n\n  /**\n   * Setup instance methods. Methods must be bound to the\n   * instance since they might be passed down as a prop to\n   * child components.\n   */\n\n  Vue.prototype._initMethods = function () {\n    var methods = this.$options.methods;\n    if (methods) {\n      for (var key in methods) {\n        this[key] = bind(methods[key], this);\n      }\n    }\n  };\n\n  /**\n   * Initialize meta information like $index, $key & $value.\n   */\n\n  Vue.prototype._initMeta = function () {\n    var metas = this.$options._meta;\n    if (metas) {\n      for (var key in metas) {\n        defineReactive(this, key, metas[key]);\n      }\n    }\n  };\n}\n\nvar eventRE = /^v-on:|^@/;\n\nfunction eventsMixin (Vue) {\n  /**\n   * Setup the instance's option events & watchers.\n   * If the value is a string, we pull it from the\n   * instance's methods by name.\n   */\n\n  Vue.prototype._initEvents = function () {\n    var options = this.$options;\n    if (options._asComponent) {\n      registerComponentEvents(this, options.el);\n    }\n    registerCallbacks(this, '$on', options.events);\n    registerCallbacks(this, '$watch', options.watch);\n  };\n\n  /**\n   * Register v-on events on a child component\n   *\n   * @param {Vue} vm\n   * @param {Element} el\n   */\n\n  function registerComponentEvents(vm, el) {\n    var attrs = el.attributes;\n    var name, value, handler;\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      name = attrs[i].name;\n      if (eventRE.test(name)) {\n        name = name.replace(eventRE, '');\n        // force the expression into a statement so that\n        // it always dynamically resolves the method to call (#2670)\n        // kinda ugly hack, but does the job.\n        value = attrs[i].value;\n        if (isSimplePath(value)) {\n          value += '.apply(this, $arguments)';\n        }\n        handler = (vm._scope || vm._context).$eval(value, true);\n        handler._fromParent = true;\n        vm.$on(name.replace(eventRE), handler);\n      }\n    }\n  }\n\n  /**\n   * Register callbacks for option events and watchers.\n   *\n   * @param {Vue} vm\n   * @param {String} action\n   * @param {Object} hash\n   */\n\n  function registerCallbacks(vm, action, hash) {\n    if (!hash) return;\n    var handlers, key, i, j;\n    for (key in hash) {\n      handlers = hash[key];\n      if (isArray(handlers)) {\n        for (i = 0, j = handlers.length; i < j; i++) {\n          register(vm, action, key, handlers[i]);\n        }\n      } else {\n        register(vm, action, key, handlers);\n      }\n    }\n  }\n\n  /**\n   * Helper to register an event/watch callback.\n   *\n   * @param {Vue} vm\n   * @param {String} action\n   * @param {String} key\n   * @param {Function|String|Object} handler\n   * @param {Object} [options]\n   */\n\n  function register(vm, action, key, handler, options) {\n    var type = typeof handler;\n    if (type === 'function') {\n      vm[action](key, handler, options);\n    } else if (type === 'string') {\n      var methods = vm.$options.methods;\n      var method = methods && methods[handler];\n      if (method) {\n        vm[action](key, method, options);\n      } else {\n        process.env.NODE_ENV !== 'production' && warn('Unknown method: \"' + handler + '\" when ' + 'registering callback for ' + action + ': \"' + key + '\".', vm);\n      }\n    } else if (handler && type === 'object') {\n      register(vm, action, key, handler.handler, handler);\n    }\n  }\n\n  /**\n   * Setup recursive attached/detached calls\n   */\n\n  Vue.prototype._initDOMHooks = function () {\n    this.$on('hook:attached', onAttached);\n    this.$on('hook:detached', onDetached);\n  };\n\n  /**\n   * Callback to recursively call attached hook on children\n   */\n\n  function onAttached() {\n    if (!this._isAttached) {\n      this._isAttached = true;\n      this.$children.forEach(callAttach);\n    }\n  }\n\n  /**\n   * Iterator to call attached hook\n   *\n   * @param {Vue} child\n   */\n\n  function callAttach(child) {\n    if (!child._isAttached && inDoc(child.$el)) {\n      child._callHook('attached');\n    }\n  }\n\n  /**\n   * Callback to recursively call detached hook on children\n   */\n\n  function onDetached() {\n    if (this._isAttached) {\n      this._isAttached = false;\n      this.$children.forEach(callDetach);\n    }\n  }\n\n  /**\n   * Iterator to call detached hook\n   *\n   * @param {Vue} child\n   */\n\n  function callDetach(child) {\n    if (child._isAttached && !inDoc(child.$el)) {\n      child._callHook('detached');\n    }\n  }\n\n  /**\n   * Trigger all handlers for a hook\n   *\n   * @param {String} hook\n   */\n\n  Vue.prototype._callHook = function (hook) {\n    this.$emit('pre-hook:' + hook);\n    var handlers = this.$options[hook];\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        handlers[i].call(this);\n      }\n    }\n    this.$emit('hook:' + hook);\n  };\n}\n\nfunction noop$1() {}\n\n/**\n * A directive links a DOM element with a piece of data,\n * which is the result of evaluating an expression.\n * It registers a watcher with the expression and calls\n * the DOM update function when a change is triggered.\n *\n * @param {Object} descriptor\n *                 - {String} name\n *                 - {Object} def\n *                 - {String} expression\n *                 - {Array<Object>} [filters]\n *                 - {Object} [modifiers]\n *                 - {Boolean} literal\n *                 - {String} attr\n *                 - {String} arg\n *                 - {String} raw\n *                 - {String} [ref]\n *                 - {Array<Object>} [interp]\n *                 - {Boolean} [hasOneTime]\n * @param {Vue} vm\n * @param {Node} el\n * @param {Vue} [host] - transclusion host component\n * @param {Object} [scope] - v-for scope\n * @param {Fragment} [frag] - owner fragment\n * @constructor\n */\nfunction Directive(descriptor, vm, el, host, scope, frag) {\n  this.vm = vm;\n  this.el = el;\n  // copy descriptor properties\n  this.descriptor = descriptor;\n  this.name = descriptor.name;\n  this.expression = descriptor.expression;\n  this.arg = descriptor.arg;\n  this.modifiers = descriptor.modifiers;\n  this.filters = descriptor.filters;\n  this.literal = this.modifiers && this.modifiers.literal;\n  // private\n  this._locked = false;\n  this._bound = false;\n  this._listeners = null;\n  // link context\n  this._host = host;\n  this._scope = scope;\n  this._frag = frag;\n  // store directives on node in dev mode\n  if (process.env.NODE_ENV !== 'production' && this.el) {\n    this.el._vue_directives = this.el._vue_directives || [];\n    this.el._vue_directives.push(this);\n  }\n}\n\n/**\n * Initialize the directive, mixin definition properties,\n * setup the watcher, call definition bind() and update()\n * if present.\n */\n\nDirective.prototype._bind = function () {\n  var name = this.name;\n  var descriptor = this.descriptor;\n\n  // remove attribute\n  if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {\n    var attr = descriptor.attr || 'v-' + name;\n    this.el.removeAttribute(attr);\n  }\n\n  // copy def properties\n  var def = descriptor.def;\n  if (typeof def === 'function') {\n    this.update = def;\n  } else {\n    extend(this, def);\n  }\n\n  // setup directive params\n  this._setupParams();\n\n  // initial bind\n  if (this.bind) {\n    this.bind();\n  }\n  this._bound = true;\n\n  if (this.literal) {\n    this.update && this.update(descriptor.raw);\n  } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {\n    // wrapped updater for context\n    var dir = this;\n    if (this.update) {\n      this._update = function (val, oldVal) {\n        if (!dir._locked) {\n          dir.update(val, oldVal);\n        }\n      };\n    } else {\n      this._update = noop$1;\n    }\n    var preProcess = this._preProcess ? bind(this._preProcess, this) : null;\n    var postProcess = this._postProcess ? bind(this._postProcess, this) : null;\n    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback\n    {\n      filters: this.filters,\n      twoWay: this.twoWay,\n      deep: this.deep,\n      preProcess: preProcess,\n      postProcess: postProcess,\n      scope: this._scope\n    });\n    // v-model with inital inline value need to sync back to\n    // model instead of update to DOM on init. They would\n    // set the afterBind hook to indicate that.\n    if (this.afterBind) {\n      this.afterBind();\n    } else if (this.update) {\n      this.update(watcher.value);\n    }\n  }\n};\n\n/**\n * Setup all param attributes, e.g. track-by,\n * transition-mode, etc...\n */\n\nDirective.prototype._setupParams = function () {\n  if (!this.params) {\n    return;\n  }\n  var params = this.params;\n  // swap the params array with a fresh object.\n  this.params = Object.create(null);\n  var i = params.length;\n  var key, val, mappedKey;\n  while (i--) {\n    key = hyphenate(params[i]);\n    mappedKey = camelize(key);\n    val = getBindAttr(this.el, key);\n    if (val != null) {\n      // dynamic\n      this._setupParamWatcher(mappedKey, val);\n    } else {\n      // static\n      val = getAttr(this.el, key);\n      if (val != null) {\n        this.params[mappedKey] = val === '' ? true : val;\n      }\n    }\n  }\n};\n\n/**\n * Setup a watcher for a dynamic param.\n *\n * @param {String} key\n * @param {String} expression\n */\n\nDirective.prototype._setupParamWatcher = function (key, expression) {\n  var self = this;\n  var called = false;\n  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {\n    self.params[key] = val;\n    // since we are in immediate mode,\n    // only call the param change callbacks if this is not the first update.\n    if (called) {\n      var cb = self.paramWatchers && self.paramWatchers[key];\n      if (cb) {\n        cb.call(self, val, oldVal);\n      }\n    } else {\n      called = true;\n    }\n  }, {\n    immediate: true,\n    user: false\n  });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);\n};\n\n/**\n * Check if the directive is a function caller\n * and if the expression is a callable one. If both true,\n * we wrap up the expression and use it as the event\n * handler.\n *\n * e.g. on-click=\"a++\"\n *\n * @return {Boolean}\n */\n\nDirective.prototype._checkStatement = function () {\n  var expression = this.expression;\n  if (expression && this.acceptStatement && !isSimplePath(expression)) {\n    var fn = parseExpression(expression).get;\n    var scope = this._scope || this.vm;\n    var handler = function handler(e) {\n      scope.$event = e;\n      fn.call(scope, scope);\n      scope.$event = null;\n    };\n    if (this.filters) {\n      handler = scope._applyFilters(handler, null, this.filters);\n    }\n    this.update(handler);\n    return true;\n  }\n};\n\n/**\n * Set the corresponding value with the setter.\n * This should only be used in two-way directives\n * e.g. v-model.\n *\n * @param {*} value\n * @public\n */\n\nDirective.prototype.set = function (value) {\n  /* istanbul ignore else */\n  if (this.twoWay) {\n    this._withLock(function () {\n      this._watcher.set(value);\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn('Directive.set() can only be used inside twoWay' + 'directives.');\n  }\n};\n\n/**\n * Execute a function while preventing that function from\n * triggering updates on this directive instance.\n *\n * @param {Function} fn\n */\n\nDirective.prototype._withLock = function (fn) {\n  var self = this;\n  self._locked = true;\n  fn.call(self);\n  nextTick(function () {\n    self._locked = false;\n  });\n};\n\n/**\n * Convenience method that attaches a DOM event listener\n * to the directive element and autometically tears it down\n * during unbind.\n *\n * @param {String} event\n * @param {Function} handler\n * @param {Boolean} [useCapture]\n */\n\nDirective.prototype.on = function (event, handler, useCapture) {\n  on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);\n};\n\n/**\n * Teardown the watcher and call unbind.\n */\n\nDirective.prototype._teardown = function () {\n  if (this._bound) {\n    this._bound = false;\n    if (this.unbind) {\n      this.unbind();\n    }\n    if (this._watcher) {\n      this._watcher.teardown();\n    }\n    var listeners = this._listeners;\n    var i;\n    if (listeners) {\n      i = listeners.length;\n      while (i--) {\n        off(this.el, listeners[i][0], listeners[i][1]);\n      }\n    }\n    var unwatchFns = this._paramUnwatchFns;\n    if (unwatchFns) {\n      i = unwatchFns.length;\n      while (i--) {\n        unwatchFns[i]();\n      }\n    }\n    if (process.env.NODE_ENV !== 'production' && this.el) {\n      this.el._vue_directives.$remove(this);\n    }\n    this.vm = this.el = this._watcher = this._listeners = null;\n  }\n};\n\nfunction lifecycleMixin (Vue) {\n  /**\n   * Update v-ref for component.\n   *\n   * @param {Boolean} remove\n   */\n\n  Vue.prototype._updateRef = function (remove) {\n    var ref = this.$options._ref;\n    if (ref) {\n      var refs = (this._scope || this._context).$refs;\n      if (remove) {\n        if (refs[ref] === this) {\n          refs[ref] = null;\n        }\n      } else {\n        refs[ref] = this;\n      }\n    }\n  };\n\n  /**\n   * Transclude, compile and link element.\n   *\n   * If a pre-compiled linker is available, that means the\n   * passed in element will be pre-transcluded and compiled\n   * as well - all we need to do is to call the linker.\n   *\n   * Otherwise we need to call transclude/compile/link here.\n   *\n   * @param {Element} el\n   */\n\n  Vue.prototype._compile = function (el) {\n    var options = this.$options;\n\n    // transclude and init element\n    // transclude can potentially replace original\n    // so we need to keep reference; this step also injects\n    // the template and caches the original attributes\n    // on the container node and replacer node.\n    var original = el;\n    el = transclude(el, options);\n    this._initElement(el);\n\n    // handle v-pre on root node (#2026)\n    if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {\n      return;\n    }\n\n    // root is always compiled per-instance, because\n    // container attrs and props can be different every time.\n    var contextOptions = this._context && this._context.$options;\n    var rootLinker = compileRoot(el, options, contextOptions);\n\n    // resolve slot distribution\n    resolveSlots(this, options._content);\n\n    // compile and link the rest\n    var contentLinkFn;\n    var ctor = this.constructor;\n    // component compilation can be cached\n    // as long as it's not using inline-template\n    if (options._linkerCachable) {\n      contentLinkFn = ctor.linker;\n      if (!contentLinkFn) {\n        contentLinkFn = ctor.linker = compile(el, options);\n      }\n    }\n\n    // link phase\n    // make sure to link root with prop scope!\n    var rootUnlinkFn = rootLinker(this, el, this._scope);\n    var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);\n\n    // register composite unlink function\n    // to be called during instance destruction\n    this._unlinkFn = function () {\n      rootUnlinkFn();\n      // passing destroying: true to avoid searching and\n      // splicing the directives\n      contentUnlinkFn(true);\n    };\n\n    // finally replace original\n    if (options.replace) {\n      replace(original, el);\n    }\n\n    this._isCompiled = true;\n    this._callHook('compiled');\n  };\n\n  /**\n   * Initialize instance element. Called in the public\n   * $mount() method.\n   *\n   * @param {Element} el\n   */\n\n  Vue.prototype._initElement = function (el) {\n    if (isFragment(el)) {\n      this._isFragment = true;\n      this.$el = this._fragmentStart = el.firstChild;\n      this._fragmentEnd = el.lastChild;\n      // set persisted text anchors to empty\n      if (this._fragmentStart.nodeType === 3) {\n        this._fragmentStart.data = this._fragmentEnd.data = '';\n      }\n      this._fragment = el;\n    } else {\n      this.$el = el;\n    }\n    this.$el.__vue__ = this;\n    this._callHook('beforeCompile');\n  };\n\n  /**\n   * Create and bind a directive to an element.\n   *\n   * @param {Object} descriptor - parsed directive descriptor\n   * @param {Node} node   - target node\n   * @param {Vue} [host] - transclusion host component\n   * @param {Object} [scope] - v-for scope\n   * @param {Fragment} [frag] - owner fragment\n   */\n\n  Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {\n    this._directives.push(new Directive(descriptor, this, node, host, scope, frag));\n  };\n\n  /**\n   * Teardown an instance, unobserves the data, unbind all the\n   * directives, turn off all the event listeners, etc.\n   *\n   * @param {Boolean} remove - whether to remove the DOM node.\n   * @param {Boolean} deferCleanup - if true, defer cleanup to\n   *                                 be called later\n   */\n\n  Vue.prototype._destroy = function (remove, deferCleanup) {\n    if (this._isBeingDestroyed) {\n      if (!deferCleanup) {\n        this._cleanup();\n      }\n      return;\n    }\n\n    var destroyReady;\n    var pendingRemoval;\n\n    var self = this;\n    // Cleanup should be called either synchronously or asynchronoysly as\n    // callback of this.$remove(), or if remove and deferCleanup are false.\n    // In any case it should be called after all other removing, unbinding and\n    // turning of is done\n    var cleanupIfPossible = function cleanupIfPossible() {\n      if (destroyReady && !pendingRemoval && !deferCleanup) {\n        self._cleanup();\n      }\n    };\n\n    // remove DOM element\n    if (remove && this.$el) {\n      pendingRemoval = true;\n      this.$remove(function () {\n        pendingRemoval = false;\n        cleanupIfPossible();\n      });\n    }\n\n    this._callHook('beforeDestroy');\n    this._isBeingDestroyed = true;\n    var i;\n    // remove self from parent. only necessary\n    // if parent is not being destroyed as well.\n    var parent = this.$parent;\n    if (parent && !parent._isBeingDestroyed) {\n      parent.$children.$remove(this);\n      // unregister ref (remove: true)\n      this._updateRef(true);\n    }\n    // destroy all children.\n    i = this.$children.length;\n    while (i--) {\n      this.$children[i].$destroy();\n    }\n    // teardown props\n    if (this._propsUnlinkFn) {\n      this._propsUnlinkFn();\n    }\n    // teardown all directives. this also tearsdown all\n    // directive-owned watchers.\n    if (this._unlinkFn) {\n      this._unlinkFn();\n    }\n    i = this._watchers.length;\n    while (i--) {\n      this._watchers[i].teardown();\n    }\n    // remove reference to self on $el\n    if (this.$el) {\n      this.$el.__vue__ = null;\n    }\n\n    destroyReady = true;\n    cleanupIfPossible();\n  };\n\n  /**\n   * Clean up to ensure garbage collection.\n   * This is called after the leave transition if there\n   * is any.\n   */\n\n  Vue.prototype._cleanup = function () {\n    if (this._isDestroyed) {\n      return;\n    }\n    // remove self from owner fragment\n    // do it in cleanup so that we can call $destroy with\n    // defer right when a fragment is about to be removed.\n    if (this._frag) {\n      this._frag.children.$remove(this);\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (this._data && this._data.__ob__) {\n      this._data.__ob__.removeVm(this);\n    }\n    // Clean up references to private properties and other\n    // instances. preserve reference to _data so that proxy\n    // accessors still work. The only potential side effect\n    // here is that mutating the instance after it's destroyed\n    // may affect the state of other components that are still\n    // observing the same object, but that seems to be a\n    // reasonable responsibility for the user rather than\n    // always throwing an error on them.\n    this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;\n    // call the last hook...\n    this._isDestroyed = true;\n    this._callHook('destroyed');\n    // turn off all instance listeners.\n    this.$off();\n  };\n}\n\nfunction miscMixin (Vue) {\n  /**\n   * Apply a list of filter (descriptors) to a value.\n   * Using plain for loops here because this will be called in\n   * the getter of any watcher with filters so it is very\n   * performance sensitive.\n   *\n   * @param {*} value\n   * @param {*} [oldValue]\n   * @param {Array} filters\n   * @param {Boolean} write\n   * @return {*}\n   */\n\n  Vue.prototype._applyFilters = function (value, oldValue, filters, write) {\n    var filter, fn, args, arg, offset, i, l, j, k;\n    for (i = 0, l = filters.length; i < l; i++) {\n      filter = filters[write ? l - i - 1 : i];\n      fn = resolveAsset(this.$options, 'filters', filter.name, true);\n      if (!fn) continue;\n      fn = write ? fn.write : fn.read || fn;\n      if (typeof fn !== 'function') continue;\n      args = write ? [value, oldValue] : [value];\n      offset = write ? 2 : 1;\n      if (filter.args) {\n        for (j = 0, k = filter.args.length; j < k; j++) {\n          arg = filter.args[j];\n          args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;\n        }\n      }\n      value = fn.apply(this, args);\n    }\n    return value;\n  };\n\n  /**\n   * Resolve a component, depending on whether the component\n   * is defined normally or using an async factory function.\n   * Resolves synchronously if already resolved, otherwise\n   * resolves asynchronously and caches the resolved\n   * constructor on the factory.\n   *\n   * @param {String|Function} value\n   * @param {Function} cb\n   */\n\n  Vue.prototype._resolveComponent = function (value, cb) {\n    var factory;\n    if (typeof value === 'function') {\n      factory = value;\n    } else {\n      factory = resolveAsset(this.$options, 'components', value, true);\n    }\n    /* istanbul ignore if */\n    if (!factory) {\n      return;\n    }\n    // async component factory\n    if (!factory.options) {\n      if (factory.resolved) {\n        // cached\n        cb(factory.resolved);\n      } else if (factory.requested) {\n        // pool callbacks\n        factory.pendingCallbacks.push(cb);\n      } else {\n        factory.requested = true;\n        var cbs = factory.pendingCallbacks = [cb];\n        factory.call(this, function resolve(res) {\n          if (isPlainObject(res)) {\n            res = Vue.extend(res);\n          }\n          // cache resolved\n          factory.resolved = res;\n          // invoke callbacks\n          for (var i = 0, l = cbs.length; i < l; i++) {\n            cbs[i](res);\n          }\n        }, function reject(reason) {\n          process.env.NODE_ENV !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\\nReason: ' + reason : ''));\n        });\n      }\n    } else {\n      // normal component\n      cb(factory);\n    }\n  };\n}\n\nvar filterRE$1 = /[^|]\\|[^|]/;\n\nfunction dataAPI (Vue) {\n  /**\n   * Get the value from an expression on this vm.\n   *\n   * @param {String} exp\n   * @param {Boolean} [asStatement]\n   * @return {*}\n   */\n\n  Vue.prototype.$get = function (exp, asStatement) {\n    var res = parseExpression(exp);\n    if (res) {\n      if (asStatement) {\n        var self = this;\n        return function statementHandler() {\n          self.$arguments = toArray(arguments);\n          var result = res.get.call(self, self);\n          self.$arguments = null;\n          return result;\n        };\n      } else {\n        try {\n          return res.get.call(this, this);\n        } catch (e) {}\n      }\n    }\n  };\n\n  /**\n   * Set the value from an expression on this vm.\n   * The expression must be a valid left-hand\n   * expression in an assignment.\n   *\n   * @param {String} exp\n   * @param {*} val\n   */\n\n  Vue.prototype.$set = function (exp, val) {\n    var res = parseExpression(exp, true);\n    if (res && res.set) {\n      res.set.call(this, this, val);\n    }\n  };\n\n  /**\n   * Delete a property on the VM\n   *\n   * @param {String} key\n   */\n\n  Vue.prototype.$delete = function (key) {\n    del(this._data, key);\n  };\n\n  /**\n   * Watch an expression, trigger callback when its\n   * value changes.\n   *\n   * @param {String|Function} expOrFn\n   * @param {Function} cb\n   * @param {Object} [options]\n   *                 - {Boolean} deep\n   *                 - {Boolean} immediate\n   * @return {Function} - unwatchFn\n   */\n\n  Vue.prototype.$watch = function (expOrFn, cb, options) {\n    var vm = this;\n    var parsed;\n    if (typeof expOrFn === 'string') {\n      parsed = parseDirective(expOrFn);\n      expOrFn = parsed.expression;\n    }\n    var watcher = new Watcher(vm, expOrFn, cb, {\n      deep: options && options.deep,\n      sync: options && options.sync,\n      filters: parsed && parsed.filters,\n      user: !options || options.user !== false\n    });\n    if (options && options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn() {\n      watcher.teardown();\n    };\n  };\n\n  /**\n   * Evaluate a text directive, including filters.\n   *\n   * @param {String} text\n   * @param {Boolean} [asStatement]\n   * @return {String}\n   */\n\n  Vue.prototype.$eval = function (text, asStatement) {\n    // check for filters.\n    if (filterRE$1.test(text)) {\n      var dir = parseDirective(text);\n      // the filter regex check might give false positive\n      // for pipes inside strings, so it's possible that\n      // we don't get any filters here\n      var val = this.$get(dir.expression, asStatement);\n      return dir.filters ? this._applyFilters(val, null, dir.filters) : val;\n    } else {\n      // no filter\n      return this.$get(text, asStatement);\n    }\n  };\n\n  /**\n   * Interpolate a piece of template text.\n   *\n   * @param {String} text\n   * @return {String}\n   */\n\n  Vue.prototype.$interpolate = function (text) {\n    var tokens = parseText(text);\n    var vm = this;\n    if (tokens) {\n      if (tokens.length === 1) {\n        return vm.$eval(tokens[0].value) + '';\n      } else {\n        return tokens.map(function (token) {\n          return token.tag ? vm.$eval(token.value) : token.value;\n        }).join('');\n      }\n    } else {\n      return text;\n    }\n  };\n\n  /**\n   * Log instance data as a plain JS object\n   * so that it is easier to inspect in console.\n   * This method assumes console is available.\n   *\n   * @param {String} [path]\n   */\n\n  Vue.prototype.$log = function (path) {\n    var data = path ? getPath(this._data, path) : this._data;\n    if (data) {\n      data = clean(data);\n    }\n    // include computed fields\n    if (!path) {\n      var key;\n      for (key in this.$options.computed) {\n        data[key] = clean(this[key]);\n      }\n      if (this._props) {\n        for (key in this._props) {\n          data[key] = clean(this[key]);\n        }\n      }\n    }\n    console.log(data);\n  };\n\n  /**\n   * \"clean\" a getter/setter converted object into a plain\n   * object copy.\n   *\n   * @param {Object} - obj\n   * @return {Object}\n   */\n\n  function clean(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n}\n\nfunction domAPI (Vue) {\n  /**\n   * Convenience on-instance nextTick. The callback is\n   * auto-bound to the instance, and this avoids component\n   * modules having to rely on the global Vue.\n   *\n   * @param {Function} fn\n   */\n\n  Vue.prototype.$nextTick = function (fn) {\n    nextTick(fn, this);\n  };\n\n  /**\n   * Append instance to target\n   *\n   * @param {Node} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$appendTo = function (target, cb, withTransition) {\n    return insert(this, target, cb, withTransition, append, appendWithTransition);\n  };\n\n  /**\n   * Prepend instance to target\n   *\n   * @param {Node} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$prependTo = function (target, cb, withTransition) {\n    target = query(target);\n    if (target.hasChildNodes()) {\n      this.$before(target.firstChild, cb, withTransition);\n    } else {\n      this.$appendTo(target, cb, withTransition);\n    }\n    return this;\n  };\n\n  /**\n   * Insert instance before target\n   *\n   * @param {Node} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$before = function (target, cb, withTransition) {\n    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);\n  };\n\n  /**\n   * Insert instance after target\n   *\n   * @param {Node} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$after = function (target, cb, withTransition) {\n    target = query(target);\n    if (target.nextSibling) {\n      this.$before(target.nextSibling, cb, withTransition);\n    } else {\n      this.$appendTo(target.parentNode, cb, withTransition);\n    }\n    return this;\n  };\n\n  /**\n   * Remove instance from DOM\n   *\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$remove = function (cb, withTransition) {\n    if (!this.$el.parentNode) {\n      return cb && cb();\n    }\n    var inDocument = this._isAttached && inDoc(this.$el);\n    // if we are not in document, no need to check\n    // for transitions\n    if (!inDocument) withTransition = false;\n    var self = this;\n    var realCb = function realCb() {\n      if (inDocument) self._callHook('detached');\n      if (cb) cb();\n    };\n    if (this._isFragment) {\n      removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);\n    } else {\n      var op = withTransition === false ? removeWithCb : removeWithTransition;\n      op(this.$el, this, realCb);\n    }\n    return this;\n  };\n\n  /**\n   * Shared DOM insertion function.\n   *\n   * @param {Vue} vm\n   * @param {Element} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition]\n   * @param {Function} op1 - op for non-transition insert\n   * @param {Function} op2 - op for transition insert\n   * @return vm\n   */\n\n  function insert(vm, target, cb, withTransition, op1, op2) {\n    target = query(target);\n    var targetIsDetached = !inDoc(target);\n    var op = withTransition === false || targetIsDetached ? op1 : op2;\n    var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);\n    if (vm._isFragment) {\n      mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {\n        op(node, target, vm);\n      });\n      cb && cb();\n    } else {\n      op(vm.$el, target, vm, cb);\n    }\n    if (shouldCallHook) {\n      vm._callHook('attached');\n    }\n    return vm;\n  }\n\n  /**\n   * Check for selectors\n   *\n   * @param {String|Element} el\n   */\n\n  function query(el) {\n    return typeof el === 'string' ? document.querySelector(el) : el;\n  }\n\n  /**\n   * Append operation that takes a callback.\n   *\n   * @param {Node} el\n   * @param {Node} target\n   * @param {Vue} vm - unused\n   * @param {Function} [cb]\n   */\n\n  function append(el, target, vm, cb) {\n    target.appendChild(el);\n    if (cb) cb();\n  }\n\n  /**\n   * InsertBefore operation that takes a callback.\n   *\n   * @param {Node} el\n   * @param {Node} target\n   * @param {Vue} vm - unused\n   * @param {Function} [cb]\n   */\n\n  function beforeWithCb(el, target, vm, cb) {\n    before(el, target);\n    if (cb) cb();\n  }\n\n  /**\n   * Remove operation that takes a callback.\n   *\n   * @param {Node} el\n   * @param {Vue} vm - unused\n   * @param {Function} [cb]\n   */\n\n  function removeWithCb(el, vm, cb) {\n    remove(el);\n    if (cb) cb();\n  }\n}\n\nfunction eventsAPI (Vue) {\n  /**\n   * Listen on the given `event` with `fn`.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   */\n\n  Vue.prototype.$on = function (event, fn) {\n    (this._events[event] || (this._events[event] = [])).push(fn);\n    modifyListenerCount(this, event, 1);\n    return this;\n  };\n\n  /**\n   * Adds an `event` listener that will be invoked a single\n   * time then automatically removed.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   */\n\n  Vue.prototype.$once = function (event, fn) {\n    var self = this;\n    function on() {\n      self.$off(event, on);\n      fn.apply(this, arguments);\n    }\n    on.fn = fn;\n    this.$on(event, on);\n    return this;\n  };\n\n  /**\n   * Remove the given callback for `event` or all\n   * registered callbacks.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   */\n\n  Vue.prototype.$off = function (event, fn) {\n    var cbs;\n    // all\n    if (!arguments.length) {\n      if (this.$parent) {\n        for (event in this._events) {\n          cbs = this._events[event];\n          if (cbs) {\n            modifyListenerCount(this, event, -cbs.length);\n          }\n        }\n      }\n      this._events = {};\n      return this;\n    }\n    // specific event\n    cbs = this._events[event];\n    if (!cbs) {\n      return this;\n    }\n    if (arguments.length === 1) {\n      modifyListenerCount(this, event, -cbs.length);\n      this._events[event] = null;\n      return this;\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        modifyListenerCount(this, event, -1);\n        cbs.splice(i, 1);\n        break;\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Trigger an event on self.\n   *\n   * @param {String|Object} event\n   * @return {Boolean} shouldPropagate\n   */\n\n  Vue.prototype.$emit = function (event) {\n    var isSource = typeof event === 'string';\n    event = isSource ? event : event.name;\n    var cbs = this._events[event];\n    var shouldPropagate = isSource || !cbs;\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      // this is a somewhat hacky solution to the question raised\n      // in #2102: for an inline component listener like <comp @test=\"doThis\">,\n      // the propagation handling is somewhat broken. Therefore we\n      // need to treat these inline callbacks differently.\n      var hasParentCbs = isSource && cbs.some(function (cb) {\n        return cb._fromParent;\n      });\n      if (hasParentCbs) {\n        shouldPropagate = false;\n      }\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        var cb = cbs[i];\n        var res = cb.apply(this, args);\n        if (res === true && (!hasParentCbs || cb._fromParent)) {\n          shouldPropagate = true;\n        }\n      }\n    }\n    return shouldPropagate;\n  };\n\n  /**\n   * Recursively broadcast an event to all children instances.\n   *\n   * @param {String|Object} event\n   * @param {...*} additional arguments\n   */\n\n  Vue.prototype.$broadcast = function (event) {\n    var isSource = typeof event === 'string';\n    event = isSource ? event : event.name;\n    // if no child has registered for this event,\n    // then there's no need to broadcast.\n    if (!this._eventsCount[event]) return;\n    var children = this.$children;\n    var args = toArray(arguments);\n    if (isSource) {\n      // use object event to indicate non-source emit\n      // on children\n      args[0] = { name: event, source: this };\n    }\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      var shouldPropagate = child.$emit.apply(child, args);\n      if (shouldPropagate) {\n        child.$broadcast.apply(child, args);\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Recursively propagate an event up the parent chain.\n   *\n   * @param {String} event\n   * @param {...*} additional arguments\n   */\n\n  Vue.prototype.$dispatch = function (event) {\n    var shouldPropagate = this.$emit.apply(this, arguments);\n    if (!shouldPropagate) return;\n    var parent = this.$parent;\n    var args = toArray(arguments);\n    // use object event to indicate non-source emit\n    // on parents\n    args[0] = { name: event, source: this };\n    while (parent) {\n      shouldPropagate = parent.$emit.apply(parent, args);\n      parent = shouldPropagate ? parent.$parent : null;\n    }\n    return this;\n  };\n\n  /**\n   * Modify the listener counts on all parents.\n   * This bookkeeping allows $broadcast to return early when\n   * no child has listened to a certain event.\n   *\n   * @param {Vue} vm\n   * @param {String} event\n   * @param {Number} count\n   */\n\n  var hookRE = /^hook:/;\n  function modifyListenerCount(vm, event, count) {\n    var parent = vm.$parent;\n    // hooks do not get broadcasted so no need\n    // to do bookkeeping for them\n    if (!parent || !count || hookRE.test(event)) return;\n    while (parent) {\n      parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;\n      parent = parent.$parent;\n    }\n  }\n}\n\nfunction lifecycleAPI (Vue) {\n  /**\n   * Set instance target element and kick off the compilation\n   * process. The passed in `el` can be a selector string, an\n   * existing Element, or a DocumentFragment (for block\n   * instances).\n   *\n   * @param {Element|DocumentFragment|string} el\n   * @public\n   */\n\n  Vue.prototype.$mount = function (el) {\n    if (this._isCompiled) {\n      process.env.NODE_ENV !== 'production' && warn('$mount() should be called only once.', this);\n      return;\n    }\n    el = query(el);\n    if (!el) {\n      el = document.createElement('div');\n    }\n    this._compile(el);\n    this._initDOMHooks();\n    if (inDoc(this.$el)) {\n      this._callHook('attached');\n      ready.call(this);\n    } else {\n      this.$once('hook:attached', ready);\n    }\n    return this;\n  };\n\n  /**\n   * Mark an instance as ready.\n   */\n\n  function ready() {\n    this._isAttached = true;\n    this._isReady = true;\n    this._callHook('ready');\n  }\n\n  /**\n   * Teardown the instance, simply delegate to the internal\n   * _destroy.\n   *\n   * @param {Boolean} remove\n   * @param {Boolean} deferCleanup\n   */\n\n  Vue.prototype.$destroy = function (remove, deferCleanup) {\n    this._destroy(remove, deferCleanup);\n  };\n\n  /**\n   * Partially compile a piece of DOM and return a\n   * decompile function.\n   *\n   * @param {Element|DocumentFragment} el\n   * @param {Vue} [host]\n   * @param {Object} [scope]\n   * @param {Fragment} [frag]\n   * @return {Function}\n   */\n\n  Vue.prototype.$compile = function (el, host, scope, frag) {\n    return compile(el, this.$options, true)(this, el, host, scope, frag);\n  };\n}\n\n/**\n * The exposed Vue constructor.\n *\n * API conventions:\n * - public API methods/properties are prefixed with `$`\n * - internal methods/properties are prefixed with `_`\n * - non-prefixed properties are assumed to be proxied user\n *   data.\n *\n * @constructor\n * @param {Object} [options]\n * @public\n */\n\nfunction Vue(options) {\n  this._init(options);\n}\n\n// install internals\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nmiscMixin(Vue);\n\n// install instance APIs\ndataAPI(Vue);\ndomAPI(Vue);\neventsAPI(Vue);\nlifecycleAPI(Vue);\n\nvar slot = {\n\n  priority: SLOT,\n  params: ['name'],\n\n  bind: function bind() {\n    // this was resolved during component transclusion\n    var name = this.params.name || 'default';\n    var content = this.vm._slotContents && this.vm._slotContents[name];\n    if (!content || !content.hasChildNodes()) {\n      this.fallback();\n    } else {\n      this.compile(content.cloneNode(true), this.vm._context, this.vm);\n    }\n  },\n\n  compile: function compile(content, context, host) {\n    if (content && context) {\n      if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {\n        // if the inserted slot has v-if\n        // inject fallback content as the v-else\n        var elseBlock = document.createElement('template');\n        elseBlock.setAttribute('v-else', '');\n        elseBlock.innerHTML = this.el.innerHTML;\n        // the else block should be compiled in child scope\n        elseBlock._context = this.vm;\n        content.appendChild(elseBlock);\n      }\n      var scope = host ? host._scope : this._scope;\n      this.unlink = context.$compile(content, host, scope, this._frag);\n    }\n    if (content) {\n      replace(this.el, content);\n    } else {\n      remove(this.el);\n    }\n  },\n\n  fallback: function fallback() {\n    this.compile(extractContent(this.el, true), this.vm);\n  },\n\n  unbind: function unbind() {\n    if (this.unlink) {\n      this.unlink();\n    }\n  }\n};\n\nvar partial = {\n\n  priority: PARTIAL,\n\n  params: ['name'],\n\n  // watch changes to name for dynamic partials\n  paramWatchers: {\n    name: function name(value) {\n      vIf.remove.call(this);\n      if (value) {\n        this.insert(value);\n      }\n    }\n  },\n\n  bind: function bind() {\n    this.anchor = createAnchor('v-partial');\n    replace(this.el, this.anchor);\n    this.insert(this.params.name);\n  },\n\n  insert: function insert(id) {\n    var partial = resolveAsset(this.vm.$options, 'partials', id, true);\n    if (partial) {\n      this.factory = new FragmentFactory(this.vm, partial);\n      vIf.insert.call(this);\n    }\n  },\n\n  unbind: function unbind() {\n    if (this.frag) {\n      this.frag.destroy();\n    }\n  }\n};\n\nvar elementDirectives = {\n  slot: slot,\n  partial: partial\n};\n\nvar convertArray = vFor._postProcess;\n\n/**\n * Limit filter for arrays\n *\n * @param {Number} n\n * @param {Number} offset (Decimal expected)\n */\n\nfunction limitBy(arr, n, offset) {\n  offset = offset ? parseInt(offset, 10) : 0;\n  n = toNumber(n);\n  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;\n}\n\n/**\n * Filter filter for arrays\n *\n * @param {String} search\n * @param {String} [delimiter]\n * @param {String} ...dataKeys\n */\n\nfunction filterBy(arr, search, delimiter) {\n  arr = convertArray(arr);\n  if (search == null) {\n    return arr;\n  }\n  if (typeof search === 'function') {\n    return arr.filter(search);\n  }\n  // cast to lowercase string\n  search = ('' + search).toLowerCase();\n  // allow optional `in` delimiter\n  // because why not\n  var n = delimiter === 'in' ? 3 : 2;\n  // extract and flatten keys\n  var keys = Array.prototype.concat.apply([], toArray(arguments, n));\n  var res = [];\n  var item, key, val, j;\n  for (var i = 0, l = arr.length; i < l; i++) {\n    item = arr[i];\n    val = item && item.$value || item;\n    j = keys.length;\n    if (j) {\n      while (j--) {\n        key = keys[j];\n        if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {\n          res.push(item);\n          break;\n        }\n      }\n    } else if (contains(item, search)) {\n      res.push(item);\n    }\n  }\n  return res;\n}\n\n/**\n * Filter filter for arrays\n *\n * @param {String|Array<String>|Function} ...sortKeys\n * @param {Number} [order]\n */\n\nfunction orderBy(arr) {\n  var comparator = null;\n  var sortKeys = undefined;\n  arr = convertArray(arr);\n\n  // determine order (last argument)\n  var args = toArray(arguments, 1);\n  var order = args[args.length - 1];\n  if (typeof order === 'number') {\n    order = order < 0 ? -1 : 1;\n    args = args.length > 1 ? args.slice(0, -1) : args;\n  } else {\n    order = 1;\n  }\n\n  // determine sortKeys & comparator\n  var firstArg = args[0];\n  if (!firstArg) {\n    return arr;\n  } else if (typeof firstArg === 'function') {\n    // custom comparator\n    comparator = function (a, b) {\n      return firstArg(a, b) * order;\n    };\n  } else {\n    // string keys. flatten first\n    sortKeys = Array.prototype.concat.apply([], args);\n    comparator = function (a, b, i) {\n      i = i || 0;\n      return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);\n    };\n  }\n\n  function baseCompare(a, b, sortKeyIndex) {\n    var sortKey = sortKeys[sortKeyIndex];\n    if (sortKey) {\n      if (sortKey !== '$key') {\n        if (isObject(a) && '$value' in a) a = a.$value;\n        if (isObject(b) && '$value' in b) b = b.$value;\n      }\n      a = isObject(a) ? getPath(a, sortKey) : a;\n      b = isObject(b) ? getPath(b, sortKey) : b;\n    }\n    return a === b ? 0 : a > b ? order : -order;\n  }\n\n  // sort on a copy to avoid mutating original array\n  return arr.slice().sort(comparator);\n}\n\n/**\n * String contain helper\n *\n * @param {*} val\n * @param {String} search\n */\n\nfunction contains(val, search) {\n  var i;\n  if (isPlainObject(val)) {\n    var keys = Object.keys(val);\n    i = keys.length;\n    while (i--) {\n      if (contains(val[keys[i]], search)) {\n        return true;\n      }\n    }\n  } else if (isArray(val)) {\n    i = val.length;\n    while (i--) {\n      if (contains(val[i], search)) {\n        return true;\n      }\n    }\n  } else if (val != null) {\n    return val.toString().toLowerCase().indexOf(search) > -1;\n  }\n}\n\nvar digitsRE = /(\\d{3})(?=\\d)/g;\n\n// asset collections must be a plain object.\nvar filters = {\n\n  orderBy: orderBy,\n  filterBy: filterBy,\n  limitBy: limitBy,\n\n  /**\n   * Stringify value.\n   *\n   * @param {Number} indent\n   */\n\n  json: {\n    read: function read(value, indent) {\n      return typeof value === 'string' ? value : JSON.stringify(value, null, arguments.length > 1 ? indent : 2);\n    },\n    write: function write(value) {\n      try {\n        return JSON.parse(value);\n      } catch (e) {\n        return value;\n      }\n    }\n  },\n\n  /**\n   * 'abc' => 'Abc'\n   */\n\n  capitalize: function capitalize(value) {\n    if (!value && value !== 0) return '';\n    value = value.toString();\n    return value.charAt(0).toUpperCase() + value.slice(1);\n  },\n\n  /**\n   * 'abc' => 'ABC'\n   */\n\n  uppercase: function uppercase(value) {\n    return value || value === 0 ? value.toString().toUpperCase() : '';\n  },\n\n  /**\n   * 'AbC' => 'abc'\n   */\n\n  lowercase: function lowercase(value) {\n    return value || value === 0 ? value.toString().toLowerCase() : '';\n  },\n\n  /**\n   * 12345 => $12,345.00\n   *\n   * @param {String} sign\n   * @param {Number} decimals Decimal places\n   */\n\n  currency: function currency(value, _currency, decimals) {\n    value = parseFloat(value);\n    if (!isFinite(value) || !value && value !== 0) return '';\n    _currency = _currency != null ? _currency : '$';\n    decimals = decimals != null ? decimals : 2;\n    var stringified = Math.abs(value).toFixed(decimals);\n    var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified;\n    var i = _int.length % 3;\n    var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';\n    var _float = decimals ? stringified.slice(-1 - decimals) : '';\n    var sign = value < 0 ? '-' : '';\n    return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;\n  },\n\n  /**\n   * 'item' => 'items'\n   *\n   * @params\n   *  an array of strings corresponding to\n   *  the single, double, triple ... forms of the word to\n   *  be pluralized. When the number to be pluralized\n   *  exceeds the length of the args, it will use the last\n   *  entry in the array.\n   *\n   *  e.g. ['single', 'double', 'triple', 'multiple']\n   */\n\n  pluralize: function pluralize(value) {\n    var args = toArray(arguments, 1);\n    var length = args.length;\n    if (length > 1) {\n      var index = value % 10 - 1;\n      return index in args ? args[index] : args[length - 1];\n    } else {\n      return args[0] + (value === 1 ? '' : 's');\n    }\n  },\n\n  /**\n   * Debounce a handler function.\n   *\n   * @param {Function} handler\n   * @param {Number} delay = 300\n   * @return {Function}\n   */\n\n  debounce: function debounce(handler, delay) {\n    if (!handler) return;\n    if (!delay) {\n      delay = 300;\n    }\n    return _debounce(handler, delay);\n  }\n};\n\nfunction installGlobalAPI (Vue) {\n  /**\n   * Vue and every constructor that extends Vue has an\n   * associated options object, which can be accessed during\n   * compilation steps as `this.constructor.options`.\n   *\n   * These can be seen as the default options of every\n   * Vue instance.\n   */\n\n  Vue.options = {\n    directives: directives,\n    elementDirectives: elementDirectives,\n    filters: filters,\n    transitions: {},\n    components: {},\n    partials: {},\n    replace: true\n  };\n\n  /**\n   * Expose useful internals\n   */\n\n  Vue.util = util;\n  Vue.config = config;\n  Vue.set = set;\n  Vue['delete'] = del;\n  Vue.nextTick = nextTick;\n\n  /**\n   * The following are exposed for advanced usage / plugins\n   */\n\n  Vue.compiler = compiler;\n  Vue.FragmentFactory = FragmentFactory;\n  Vue.internalDirectives = internalDirectives;\n  Vue.parsers = {\n    path: path,\n    text: text,\n    template: template,\n    directive: directive,\n    expression: expression\n  };\n\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   *\n   * @param {Object} extendOptions\n   */\n\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var isFirstExtend = Super.cid === 0;\n    if (isFirstExtend && extendOptions._Ctor) {\n      return extendOptions._Ctor;\n    }\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');\n        name = null;\n      }\n    }\n    var Sub = createClass(name || 'VueComponent');\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(Super.options, extendOptions);\n    Sub['super'] = Super;\n    // allow further extension\n    Sub.extend = Super.extend;\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    config._assetTypes.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n    // cache constructor\n    if (isFirstExtend) {\n      extendOptions._Ctor = Sub;\n    }\n    return Sub;\n  };\n\n  /**\n   * A function that returns a sub-class constructor with the\n   * given name. This gives us much nicer output when\n   * logging instances in the console.\n   *\n   * @param {String} name\n   * @return {Function}\n   */\n\n  function createClass(name) {\n    /* eslint-disable no-new-func */\n    return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();\n    /* eslint-enable no-new-func */\n  }\n\n  /**\n   * Plugin system\n   *\n   * @param {Object} plugin\n   */\n\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return;\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this;\n  };\n\n  /**\n   * Apply a global mixin by merging it into the default\n   * options.\n   */\n\n  Vue.mixin = function (mixin) {\n    Vue.options = mergeOptions(Vue.options, mixin);\n  };\n\n  /**\n   * Create asset registration methods with the following\n   * signature:\n   *\n   * @param {String} id\n   * @param {*} definition\n   */\n\n  config._assetTypes.forEach(function (type) {\n    Vue[type] = function (id, definition) {\n      if (!definition) {\n        return this.options[type + 's'][id];\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {\n            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          if (!definition.name) {\n            definition.name = id;\n          }\n          definition = Vue.extend(definition);\n        }\n        this.options[type + 's'][id] = definition;\n        return definition;\n      }\n    };\n  });\n\n  // expose internal transition API\n  extend(Vue.transition, transition);\n}\n\ninstallGlobalAPI(Vue);\n\nVue.version = '1.0.26';\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue);\n    } else if (process.env.NODE_ENV !== 'production' && inBrowser && /Chrome\\/\\d+/.test(window.navigator.userAgent)) {\n      console.log('Download the Vue Devtools for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n    }\n  }\n}, 0);\n\nmodule.exports = Vue;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue/1.0.26/vue/dist/vue.common.js\n ** module id = 7\n ** module chunks = 1\n **/","import App from './App'\r\n\r\nexport function configRouter(router) {\r\n    /*router.map({\r\n        '/index': {\r\n            component: function(resolve) {\r\n                require(['./components/Index'], resolve)\r\n            }\r\n        },\r\n        '/create': {\r\n            component: function(resolve) {\r\n                require(['./components/Create'], resolve)\r\n            }\r\n        },\r\n        '/edit/:questId': {\r\n            component: function(resolve) {\r\n                require(['./components/Edit'], resolve)\r\n            }\r\n        },\r\n        '/preview/:questId': {\r\n            component: function(resolve) {\r\n                require(['./components/Preview'], resolve)\r\n            }\r\n        },\r\n        '/data/:questId': {\r\n            component: function(resolve) {\r\n                require(['./components/Data'], resolve)\r\n            }\r\n        }\r\n    })*/\r\n    router.map({\r\n            '/index': {\r\n                component: require('./components/Index')\r\n            },\r\n            '/create': {\r\n                component: require('./components/Create')\r\n            },\r\n            '/edit/:questId': {\r\n                component: require('./components/Edit')\r\n            },\r\n            '/preview/:questId': {\r\n                component: require('./components/Preview')\r\n            },\r\n            '/data/:questId': {\r\n                component: require('./components/Data')\r\n            }\r\n        })\r\n    router.redirect({\r\n        '*': '/index'\r\n    })\r\n    router.start(App, 'app')\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/router.js\n **/","/**\r\n * 问卷的存储格式：\r\n * var questionnaire = {\r\n *     title: String,\r\n *     deadline: Number,\r\n *     state: String [未发布、已发布、已结束],\r\n *     id: Date.now(), 每一个问卷都有一个唯一的ID\r\n *     questItemList: Array [questItem] \r\n * }\r\n * var questItem = {\r\n *     type: radio, checkbox, textarea,\r\n *     title: '',\r\n *     name: Date.now()\r\n *     selections: []\r\n * }\r\n *使用localStorage来存储：KEY: questionnaireList, type: Array\r\n */\r\n\r\nimport Vuex from 'vuex'\r\nimport Vue from 'vue'\r\n\r\nVue.use(Vuex)\r\n\r\nconst KEY = 'questionnaireList'\r\nlet questionnaire01 = {\r\n    \"title\": \"问卷调查一\",\r\n    \"deadline\": 1471622400000,\r\n    \"state\": \"未发布\",\r\n    \"questItemList\": [\r\n        {\r\n            \"type\": \"radio\",\r\n            \"title\": \"性别\",\r\n            \"selections\": [\r\n                \"男\",\r\n                \"女\"\r\n            ],\r\n            \"name\": 1471528977004\r\n        },\r\n        {\r\n            \"type\": \"checkbox\",\r\n            \"title\": \"爱好\",\r\n            \"selections\": [\r\n                \"篮球\",\r\n                \"足球\",\r\n                \"网球\"\r\n            ],\r\n            \"name\": 1471528987079\r\n        },\r\n        {\r\n            \"type\": \"textarea\",\r\n            \"title\": \"自我评价\"\r\n        }\r\n    ],\r\n    \"id\": 1471528999124\r\n}\r\nlet questionnaire02 = {\r\n    \"title\": \"问卷调查二\",\r\n    \"deadline\": 1471622400000,\r\n    \"state\": \"已发布\",\r\n    \"questItemList\": [\r\n        {\r\n            \"type\": \"radio\",\r\n            \"title\": \"性别\",\r\n            \"selections\": [\r\n                \"男\",\r\n                \"女\"\r\n            ],\r\n            \"name\": 1471528977004\r\n        },\r\n        {\r\n            \"type\": \"checkbox\",\r\n            \"title\": \"爱好\",\r\n            \"selections\": [\r\n                \"篮球\",\r\n                \"足球\",\r\n                \"网球\"\r\n            ],\r\n            \"name\": 1471528987079\r\n        },\r\n        {\r\n            \"type\": \"textarea\",\r\n            \"title\": \"自我评价\"\r\n        }\r\n    ],\r\n    \"id\": 1471528999124\r\n}\r\nlet questionnaire03 = {\r\n    \"title\": \"问卷调查三\",\r\n    \"deadline\": 1471622400000,\r\n    \"state\": \"已发布\",\r\n    \"questItemList\": [\r\n        {\r\n            \"type\": \"radio\",\r\n            \"title\": \"性别\",\r\n            \"selections\": [\r\n                \"男\",\r\n                \"女\"\r\n            ],\r\n            \"name\": 1471528977004\r\n        },\r\n        {\r\n            \"type\": \"checkbox\",\r\n            \"title\": \"爱好\",\r\n            \"selections\": [\r\n                \"篮球\",\r\n                \"足球\",\r\n                \"网球\"\r\n            ],\r\n            \"name\": 1471528987079\r\n        },\r\n        {\r\n            \"type\": \"textarea\",\r\n            \"title\": \"自我评价\"\r\n        }\r\n    ],\r\n    \"id\": 1471528999124\r\n}\r\nif(!localStorage.getItem(KEY)) {\r\n    localStorage.setItem(KEY, JSON.stringify([questionnaire01, questionnaire02, questionnaire03]))\r\n}\r\n\r\nconst state = {\r\n    questionnaireList: JSON.parse(localStorage.getItem(KEY)),   // 所有的调查问卷,type: Array\r\n    currentQuestionnaire: null  // 当前正在操作的调查问卷, type: {}\r\n}\r\n\r\nconst mutations = {\r\n    // 增加一个新的问卷，item即为新的问卷\r\n    ADD_QUEST(state, item) {\r\n        state.questionnaireList.push(item)\r\n        state.currentQuestionnaire = item\r\n        updateStorage(state)\r\n    },\r\n    // 删除一个问卷，item即为将要被删除的问卷\r\n    RM_QUEST(state, item) {\r\n        let index = state.questionnaireList.indexOf(item)\r\n        if(item !== -1) {\r\n            state.questionnaireList.splice(index, 1)\r\n            updateStorage(state)\r\n        } else {\r\n            throw new Error(\"该问卷不存在！\")\r\n        }\r\n    },\r\n    // 保存一个问卷，用于对还未发布的问卷的更新\r\n    UPDATE_QUEST(state, item) {\r\n        let index = state.questionnaireList.indexOf(item)\r\n        if(index !== -1) {\r\n            state.questionnaireList.splice(index, 1, item)\r\n            state.currentQuestionnaire = item\r\n            updateStorage(state)\r\n        } else {\r\n            throw new Error(\"该问卷不存在！\")\r\n        }\r\n    },\r\n    // 设置当前需要操作的问卷\r\n    SET_QUEST(state, item) {\r\n        if(state.currentQuestionnaire === item) {return}\r\n        state.currentQuestionnaire = item\r\n    }\r\n}\r\n\r\n// 每当questionnaire有更新时，就更新localStorage\r\nfunction updateStorage(state) {\r\n    localStorage.setItem(KEY, JSON.stringify(state.questionnaireList))\r\n}\r\n\r\nexport default new Vuex.Store({\r\n    state, \r\n    mutations\r\n})\n\n\n/** WEBPACK FOOTER **\n ** ./src/vuex/store.js\n **/","<template>\n    <div id=\"app\">\n        <v-header></v-header>\n        <router-view keep-alive></router-view>\n    </div>\n</template>\n\n<script>\n    import Header from './components/Header'\n    import Index from './components/Index'\n    import store from './vuex/store'\n\n    export default {\n        data () {\n            return {\n              // note: changing this line won't causes changes\n              // with hot-reload because the reloaded component\n              // preserves its current state and we are modifying\n              // its initial state.\n              msg: 'Hello Vue!'\n            }\n        },\n        components: {\n            'v-header': Header,\n            Index\n        },\n        store\n    }\n</script>\n  \n<style>\n    html, body{\n    width: 100%;\n    height: 100%;\n    font-family:  Helvetica, 'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', Arial, sans-serif,  fontawesome;\n    }\n    html, body, div, h1, h2, h3, p, button{\n    padding: 0;\n    margin: 0;\n    line-height: 1;\n    }\n    html{\n        font-size: 100px;\n        min-width: 980px;\n    }\n    button{\n        cursor: pointer;\n        outline: none;\n        border: none;\n        font-size: .16rem;\n    }\n    input, textarea{\n        outline: none;\n    }\n    a{\n        text-decoration: none;\n    }\n    li{\n        list-style: none;\n    }\n    .checkbox, .radio{\n        display: none;\n    }\n    .checkbox + label, .radio + label{\n        position: relative;\n        font-size: 16px;\n        padding-left: 23px;  /* label和选框之间的间隔 */\n        cursor: pointer;\n        -webkit-user-select: none; /* 禁止label中的文字双击时被选中 */\n        -moz-user-select: none;\n        -ms-user-select: none;\n    }\n    .checkbox + label::before, .radio + label::before{\n        position: absolute;\n        content: \"\";\n        top: 48%;\n        margin-top: -8px;\n        left: 0;\n        width: 16px;\n        height: 16px;\n        border: 1px solid #c0c0c0;\n        background-color: #fff;\n    }\n    .checkbox + label::before{\n        border-radius: 3px;\n    }\n    .radio + label::before{\n        border-radius: 50%;\n    }\n    .checkbox:checked + label::after{\n        position: absolute;\n        content: \"\";\n        width: 5px;\n        height: 10px;\n        top: 48%;\n        margin-top: -7px;\n        left: 6px;\n        transform: rotate(45deg);   /*对号由长方形的两个边框旋转90°构成*/\n        border-bottom: 2px solid #fff;\n        border-right: 2px solid #fff;\n    }\n    .checkbox:checked + label::before{\n        background-color: #3e97eb;\n        border: 1px solid #3e97eb;\n    }\n    .radio:checked + label::before{\n        border: 1px solid #3e97eb;\n    }\n    .radio:checked + label::after{\n        position: absolute;\n        content: \"\";\n        width: 6px;   /* radio中心原点的大小 */\n        height: 6px;\n        top: 50%;\n        margin-top: -3px;\n        left: 6px;\n        border-radius: 50%;\n        background-color: #3e97eb;\n    }\n</style>\n\n\n\n/** WEBPACK FOOTER **\n ** App.vue?653d8aaa\n **/","<template>\r\n    <div id=\"calendar\">\r\n        <div class=\"calendar-selections\">\r\n            <span class=\"calendar-selections_last\"\r\n                @click=\"decrMonth\">\r\n                <i class=\"fa fa-chevron-left\"></i>\r\n            </span>\r\n            <select name=\"year\" class=\"calendar-selections_year\"\r\n                v-model=\"currentYear\">\r\n                <option v-for=\"year in yearList\">{{year}}</option>\r\n            </select>\r\n            <select class=\"calendar-selections_month\"\r\n                v-model=\"currentMonth\">\r\n                <option v-for=\"month in monthList\">{{month}}</option>\r\n            </select>\r\n            <span class=\"calendar-selelctions_next\"\r\n                @click=\"incrMonth\">\r\n                <i class=\"fa fa-chevron-right\"></i>\r\n            </span>\r\n        </div>\r\n        <table @click.stop=\"handleClick($event)\">\r\n            <thead>\r\n                <tr><th v-for=\"week in weekList\">{{week}}</th></tr>\r\n            </thead>\r\n            <tbody>\r\n                <tr v-for=\"row in tableData\">\r\n                    <td v-for=\"date in row\"\r\n                        :class=\"{'not-current-month': date.getMonth()!==currentMonth-1}\"\r\n                        :data-date=\"date.getTime()\">\r\n                        {{date.getDate()}}\r\n                    </td>\r\n                </tr>\r\n            </tbody>\r\n        </table>\r\n    </div>\r\n</template>\r\n<script>\r\n    var date = new Date()\r\n\r\n    export default{\r\n        props: ['showCalendar'],\r\n        data() {\r\n            return {\r\n                weekList: ['日', '一', '二', '三', '四', '五', '六'],\r\n                currentYear: date.getFullYear(),\r\n                currentMonth: date.getMonth() + 1,\r\n            }\r\n        },\r\n        computed: {\r\n            yearList() {\r\n                let yearList = []\r\n                for(let i=1900; i<2051; i++) {\r\n                    yearList.push(i)\r\n                }\r\n                return yearList\r\n            },\r\n            monthList() {\r\n                let monthList = []\r\n                for(let i=1; i<=12; i++) {\r\n                    monthList.push(i)\r\n                }\r\n                return monthList\r\n            },\r\n            tableData() {\r\n                let currentDateList = [] //当前表中所显示的所有日期数据，存储的格式为毫秒数(getTime())\r\n                let date = new Date(this.currentYear, this.currentMonth-1, 1) //当前年月第一天的日期对象\r\n                let oneDayMilliseconds = 24*60*60*1000 // 一天的毫秒数\r\n                let dateWeek = date.getDay() // 当前年月第一天的星期\r\n                let firstDate = date.getTime() - dateWeek*oneDayMilliseconds // 当前表格第一格所显示日期的毫秒数\r\n                //按照6行7列存储时间数据（毫秒）\r\n                for(let i=0; i<6; i++) {\r\n                    currentDateList[i] = []\r\n                    for(let m=0; m<7; m++) {\r\n                        currentDateList[i].push(new Date(firstDate))\r\n                        firstDate += oneDayMilliseconds\r\n                    }\r\n                }\r\n                return currentDateList\r\n            }\r\n        },\r\n        methods: {\r\n            incrMonth() {\r\n                if(this.currentMonth === 12) {\r\n                    this.currentMonth = 1\r\n                    this.currentYear++\r\n                } else{\r\n                    this.currentMonth++\r\n                }\r\n            },\r\n            decrMonth() {\r\n                if(this.currentMonth === 1) {\r\n                    this.currentMonth = 12\r\n                    this.currentYear--\r\n                }else{\r\n                    this.currentMonth--\r\n                }\r\n            },\r\n            handleClick(event) {\r\n                if(event.target.dataset.date) {\r\n                    let date = new Date(parseInt(event.target.dataset.date))\r\n                    this.currentYear = date.getFullYear()\r\n                    this.currentMonth = date.getMonth() + 1\r\n                    // this.currentDate = date\r\n                    this.$dispatch(\"date-change\", date) // 把选中的 日期传给父组件，再通过父组件传给其他子组件\r\n                    this.showCalendar = false\r\n                }\r\n                \r\n            }\r\n        }\r\n    }\r\n</script>\r\n<style lang=\"less\">\r\n    @import \"../color\";\r\n\r\n    #calendar{\r\n        // display: none;\r\n        width: 300px;\r\n        // height: 200px;\r\n        border: 1px solid #ccc;\r\n        border-radius: 3px;\r\n        box-sizing: border-box;\r\n        padding: 10px;\r\n        font-size: 14px;\r\n        user-select: none;\r\n        .calendar-selections{\r\n            display: flex;\r\n            justify-content: space-around;\r\n            width: 100%;\r\n            height: 30px;\r\n            span{\r\n                display: inline-block;\r\n                height: 24px;\r\n                line-height: 24px;\r\n                cursor: pointer;\r\n            }\r\n        }\r\n        .calendar-selections_year, .calendar-selections_month{\r\n            width: 90px;\r\n            height: 24px;\r\n            option{\r\n                text-align: center;\r\n            }\r\n        }\r\n        table{\r\n            width: 100%;\r\n            text-align: center;\r\n            border-collapse: collapse;\r\n        }\r\n        table, th, td{\r\n            border: none;\r\n        }\r\n        tr{\r\n            height: 26px;\r\n        }\r\n        td{\r\n            cursor: pointer;\r\n            transition: background-color .2s;\r\n        }\r\n        td:hover{\r\n            background-color: @light;\r\n        }\r\n        .not-current-month{\r\n            color: #aaa;\r\n        }\r\n    }\r\n</style>\n\n\n/** WEBPACK FOOTER **\n ** Calendar.vue?6125c850\n **/","<template>\r\n    <div id=\"create\">\r\n        <div class=\"quest\">\r\n            <div class=\"quest-title\">\r\n                <input type=\"text\" class=\"quest-title_input\" placeholder=\"请输入问卷的标题\"\r\n                    v-model=\"questionnaire.title\" />\r\n            </div>\r\n            <div v-for=\"questItem in questionnaire.questItemList\" class=\"questItem\" track-by=\"$index\">\r\n                <p class=\"questItem-title\">\r\n                    <span>{{$index+1}}、{{typeMap[questItem.type]}}：</span>\r\n                    <span v-text=\"questItem.title\"></span>\r\n                </p>\r\n                <div v-if=\"questItem.type==='textarea'\">\r\n                    <textarea></textarea>\r\n                </div>\r\n                <div v-else>\r\n                    <div v-for=\"selection in questItem.selections\" class=\"selection\">\r\n                        <input :type=\"questItem.type\" :name=\"questItem.name\" \r\n                            :id=\"questItem.name+$index\"\r\n                            :class=\"questItem.type\"/>\r\n                        <label v-text=\"selection\" :for=\"questItem.name+$index\"></label>\r\n                    </div>\r\n                </div>\r\n                <div class=\"item-operation\" @click=\"handleItemOperation($event, questItem)\">\r\n                    <button type=\"button\" v-if=\"$index != 0\" data-operation=\"up\">上移</button>\r\n                    <button type=\"button\" v-if=\"$index != questionnaire.questItemList.length-1\"\r\n                        data-operation=\"down\">下移</button>\r\n                    <button type=\"button\" data-operation=\"remove\">删除</button>\r\n                    <button type=\"button\" data-operation=\"reuse\">复用</button>\r\n                </div>\r\n            </div>\r\n            <div class=\"add\">\r\n                <div class=\"add-items\" \r\n                    v-show=\"showSelections\"\r\n                    transition=\"expand\"\r\n                    @click.stop=\"addItem($event)\">\r\n                    <span data-type=\"radio\">单选题</span>\r\n                    <span class=\"middle\" data-type=\"checkbox\">多选题</span>\r\n                    <span data-type=\"textarea\">文本题</span>\r\n                </div>\r\n                <div class=\"add-button\">\r\n                    <button type=\"button\" @click.stop=\"showSelections=!showSelections\">添加问题</button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div class=\"mask\" v-if=\"showMask\">\r\n            <div class=\"mask-prompt\">\r\n                <div class=\"prompt-header\">请输入详细信息</div>\r\n                <div class=\"prompt-body\">\r\n                    <div>\r\n                        <label>问题名称：</label>\r\n                        <input type=\"text\" placeholder=\"请输入标题\" v-el:item-title />\r\n                    </div>\r\n                    <div>\r\n                        <label>选项：</label>\r\n                        <input type=\"text\" placeholder=\"请输入选项\" v-el:item-selections \r\n                            :disabled=\"questItem.type === 'textarea'\" />\r\n                        <p class=\"prompt\">*&nbsp;不同选项之间请以空格隔开</p>\r\n                    </div>\r\n                </div>\r\n                <div class=\"prompt-footer\" @click.stop=\"handleInput($event)\">\r\n                    <button type=\"button\" data-operation=\"confirm\">确定</button>\r\n                    <button type=\"button\" data-operation=\"cancel\">取消</button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div class=\"submit\">\r\n            <div class=\"deadline\">\r\n                <label>问卷截止日期：</label>\r\n                <input type=\"text\" placeholder=\"点击选择问卷截止日期\" readonly \r\n                    v-el:deadline\r\n                    @click.stop=\"showCalendar=!showCalendar\"/>\r\n                <Calendar :show-calendar.sync=\"showCalendar\" v-if=\"showCalendar\"></Calendar>\r\n            </div>\r\n            <div @click=\"submit($event)\">\r\n                <button type=\"button\" data-operation=\"save\">保存问卷</button>\r\n                <button type=\"button\" data-operation=\"publish\">发布问卷</button>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</template>\r\n<script>\r\n    import Calendar from './Calendar'\r\n\r\n    export default{\r\n        data() {\r\n            return {\r\n                showSelections: false,\r\n                showMask: false,\r\n                showCalendar: false,\r\n                questionnaire: {\r\n                    title: '',\r\n                    deadline:  '',\r\n                    state: '',\r\n                    questItemList: []\r\n                },\r\n                questItem: {},\r\n                typeMap: {\r\n                    radio: '单选',\r\n                    checkbox: '多选',\r\n                    textarea: '问答'\r\n                }\r\n            }\r\n        },\r\n        methods: {\r\n            // 添加问题的类型\r\n            addItem(event) {\r\n                let target = event.target\r\n                if(target.nodeName.toLowerCase() === 'span') {\r\n                    this.showMask = true    // 显示弹出框\r\n                    this.questItem.type = target.dataset.type   // 设置问题的类型\r\n                }\r\n            },\r\n            // 处理弹出框中的点击事件\r\n            handleInput(event) {\r\n                let target = event.target\r\n                if(target.nodeName.toLowerCase() !== 'button') {\r\n                    return\r\n                }\r\n                let itemTitle = this.$els.itemTitle\r\n                let itemSelections = this.$els.itemSelections\r\n                if(target.dataset.operation === \"confirm\") {\r\n                    if(this.questItem.type === \"textarea\") {\r\n                        this.addTextarea(itemTitle)\r\n                    } else {\r\n                        this.addSelections(itemTitle, itemSelections)\r\n                    }\r\n                } else {\r\n                    this.handleCancel()\r\n                }\r\n            },\r\n            // 添加文本问题\r\n            addTextarea(itemTitle) {\r\n                if(itemTitle.value.trim() === '') {\r\n                    return\r\n                }\r\n                this.questItem.title = itemTitle.value.trim()\r\n                this.questionnaire.questItemList.push(this.questItem)\r\n                this.handleCancel()\r\n            },\r\n            // 添加选项问题\r\n            addSelections(itemTitle, itemSelections) {\r\n                if(itemTitle.value.trim() === '' || itemSelections.value.trim() === '') {\r\n                    return\r\n                }\r\n                this.questItem.title = itemTitle.value.trim()\r\n                this.questItem.selections = itemSelections.value.trim().split(/\\s+/)\r\n                this.questItem.name = Date.now()\r\n                this.questionnaire.questItemList.push(this.questItem)\r\n                this.handleCancel()\r\n            },\r\n            // 处理取消事件\r\n            handleCancel() {\r\n                this.$els.itemTitle.value = ''\r\n                this.$els.itemSelections.value = ''\r\n                this.questItem = {}\r\n                this.showMask = false\r\n            },\r\n            // 处理上移、下移、删除和复用操作\r\n            handleItemOperation(event, questItem) {\r\n                let operation = event.target.dataset.operation\r\n                switch(operation) {\r\n                    case 'up':\r\n                        this.moveUp(questItem)\r\n                        break\r\n                    case 'down':\r\n                        this.moveDown(questItem)\r\n                        break\r\n                    case 'remove':\r\n                        this.removeQuestItem(questItem)\r\n                        break\r\n                    case 'reuse':\r\n                        this.reuseQuestItem(questItem)\r\n                        break\r\n                    default: \r\n                        throw new Error(\"该操作\" + \"operation\" + \"不存在！\")\r\n                }\r\n            },\r\n            // 上移\r\n            moveUp(questItem) {\r\n                let index = this.questionnaire.questItemList.indexOf(questItem)\r\n                this.questionnaire.questItemList.$remove(questItem)\r\n                this.questionnaire.questItemList.splice(index-1, 0, questItem)\r\n            },\r\n            // 下移，其实就是把后边那个上移\r\n            moveDown(questItem) {\r\n                let index = this.questionnaire.questItemList.indexOf(questItem)\r\n                this.moveUp(this.questionnaire.questItemList[index+1])\r\n            },\r\n            // 删除\r\n            removeQuestItem(questItem) {\r\n                this.questionnaire.questItemList.$remove(questItem)\r\n            },\r\n            // 复用\r\n            reuseQuestItem(questItem) {\r\n                let index = this.questionnaire.questItemList.indexOf(questItem)\r\n                // 为了完整的克隆一个对象，先把对象转换成JSON，再转换成对象\r\n                let newQuestItem = JSON.parse(JSON.stringify(questItem))\r\n                if(newQuestItem.type !== 'textarea') {\r\n                    newQuestItem.name = Date.now()\r\n                }\r\n                this.questionnaire.questItemList.splice(index+1, 0, newQuestItem)\r\n            },\r\n            // 处理提交\r\n            submit(event) {\r\n                let operation = event.target.dataset.operation\r\n                let oneDayTime = 24*60*60*1000\r\n                if(this.questionnaire.title.trim() === '') {\r\n                    alert(\"问卷的标题不能为空！\")\r\n                    return\r\n                }\r\n                if(this.questionnaire.questItemList.length === 0) {\r\n                    alert(\"请至少设置一个问题！\")\r\n                    return\r\n                }\r\n                if(!this.questionnaire.deadline || this.questionnaire.deadline<Date.now()) {\r\n                    alert(\"问卷的截止时间必须在今天之后！\")\r\n                    return\r\n                }\r\n                if(operation === 'save') {\r\n                    this.save()\r\n                } else {\r\n                    this.publish()\r\n                }\r\n            }\r\n        },\r\n        components: {\r\n            Calendar\r\n        },\r\n        events: {\r\n            'date-change': function(msg) {\r\n                let date = new Date(msg)\r\n                this.$els.deadline.value = date.toLocaleDateString()\r\n                this.questionnaire.deadline = date.getTime()\r\n            }\r\n        },\r\n        vuex: {\r\n            actions: {\r\n                save({dispatch}) {\r\n                    this.questionnaire.state = \"未发布\"\r\n                    this.questionnaire.id = Date.now()\r\n                    dispatch('ADD_QUEST', this.questionnaire)\r\n                    this.$router.go(`/preview/${this.questionnaire.id}`)\r\n                },\r\n                publish({dispatch}) {\r\n                    this.questionnaire.state = \"已发布\"\r\n                    if(!this.questionnaire.id) {\r\n                        this.questionnaire.id = Date.now()\r\n                    }\r\n                    dispatch('ADD_QUEST', this.questionnaire)\r\n                    this.$router.go(`/preview/${this.questionnaire.id}`)\r\n                }\r\n            }\r\n        }\r\n    }\r\n</script>\r\n<style lang=\"less\">\r\n    @import '../color.less';\r\n\r\n    #create{\r\n        width: 10rem;\r\n        border: .03rem solid #ccc;\r\n        border-radius: .05rem;\r\n        margin: .4rem auto;\r\n        font-size: .16rem;\r\n        box-sizing: border-box;\r\n        padding: .1rem .2rem;\r\n        .item-operation{\r\n            display: flex;\r\n            justify-content: flex-end;\r\n            button{\r\n                width: .4rem;\r\n                padding: .05rem 0;\r\n                margin-right: .1rem;\r\n                border-radius: .02rem;\r\n            }\r\n        }\r\n        .questItem:hover{\r\n            background-color: @light;\r\n        }\r\n        .deadline{\r\n            position: relative;\r\n        }\r\n        #calendar{\r\n            position: absolute;\r\n            top: -240px;\r\n            left: 0;\r\n            background-color: #fff;\r\n        }\r\n        .deadline{\r\n            input{\r\n                width: 1.5rem;\r\n                padding-left: .1rem;\r\n                height: .25rem;\r\n                border-radius: .02rem;\r\n                border: 1px solid #ccc;\r\n            }\r\n        }\r\n        .submit{\r\n            display: flex;\r\n            justify-content: space-around;\r\n            align-items: center;\r\n            margin-top: .2rem;\r\n            button{\r\n                width: .9rem;\r\n                background-color: @base;\r\n                margin-right: .2rem;\r\n                padding: .1rem 0;\r\n                color: #fff;\r\n                border-radius: .03rem;\r\n            }\r\n            button:hover{\r\n                background-color: @light;\r\n                color: #555;\r\n            }\r\n        }\r\n        .questItem{\r\n            padding: .15rem .2rem;\r\n            font-size: .17rem;\r\n            transition: background-color .1s;\r\n            textarea{\r\n                resize: none;\r\n                width: 3.3rem;\r\n                height: 1.7rem;\r\n                border-radius: .03rem;\r\n            }\r\n        }\r\n        .questItem-title{\r\n            margin-bottom: .15rem;\r\n        }\r\n        .questItem-title + div{\r\n            margin-left: .2rem;\r\n        }\r\n        .selection{\r\n            margin-bottom: .15rem;\r\n        }\r\n        .mask-prompt{\r\n            display: flex;\r\n            flex-direction: column;\r\n\r\n            position: absolute;\r\n            width: 4rem;\r\n            height: 2rem;\r\n            top: 40%;\r\n            left: 50%;\r\n            margin-left: -2rem;\r\n            margin-top: -1rem;\r\n        }\r\n        .prompt{\r\n            font-size: .12px;\r\n            text-align: center;\r\n            margin-top: .1rem;\r\n        }\r\n        .prompt-header{\r\n            width: 100%;\r\n            background-color: @base;\r\n            height: .3rem;\r\n            text-align: center;\r\n            line-height: .3rem;\r\n            color: #fff;\r\n            font-weight: bold;\r\n            font-size: .18rem;\r\n        }\r\n        .prompt-body{\r\n            background-color: #fff;\r\n            flex: 1;\r\n            display: flex;\r\n            flex-direction: column;\r\n            justify-content: space-around;\r\n            padding: 0 .5rem;\r\n            label{\r\n                display: inline-block;\r\n                width: .85rem;\r\n                text-align: right;\r\n            }\r\n        }\r\n        .prompt-footer{\r\n            height: .3rem;\r\n            background-color: #fff;\r\n            display: flex;\r\n            justify-content: space-around;\r\n            align-item: center;\r\n            padding: .1rem .5rem;\r\n            button{\r\n                background-color: @base;\r\n                text-align: center;\r\n                width: .7rem;\r\n                color: #fff;\r\n                border-radius: .03rem;\r\n            }\r\n        }\r\n        .mask{\r\n            position: fixed;\r\n            width: 100%;\r\n            height: 100%;\r\n            left: 0;\r\n            top: 0;\r\n            background-color: rgba(0, 0, 0, .15);\r\n            z-index: 10;\r\n        }\r\n        .expand-transition{\r\n            transition: all .3s;\r\n            width: 100%;\r\n            height: .3rem;\r\n            overflow: hidden;\r\n        }\r\n        .expand-enter, .expand-leave{\r\n            height: 0;\r\n            opacity: 0;\r\n        }\r\n        .quest{\r\n            border-bottom: 2px solid #ccc;\r\n        }\r\n        .quest-title_input{\r\n            width: 100%;\r\n            height: .3rem;\r\n            border: none;\r\n            font-size: .25rem;\r\n            text-align: center;\r\n            font-weight: bold;\r\n            letter-spacing: .05rem;\r\n        }\r\n        .quest-title{\r\n            border-bottom: .02rem solid #ccc;\r\n            padding-bottom: .1rem;\r\n        }\r\n        .add{\r\n            width: 95%;\r\n            margin: .1rem auto;\r\n            border: .01px solid #ccc;\r\n            padding: .1rem 0;\r\n        }\r\n        .add-button{\r\n            margin-top: .1rem;\r\n            button{\r\n                display: block;\r\n                width: 100%;\r\n                 background-color: #ddd;\r\n                border-radius: 3px;\r\n                padding: .2rem 0;\r\n                color: #444;\r\n                font-size: .23rem;\r\n                transition: background-color .1s;\r\n            }\r\n            button:hover{\r\n                background-color: #efefef;\r\n            }\r\n\r\n        }\r\n        .add-items{\r\n            display: flex;\r\n            justify-content: center;\r\n            align-items: center;\r\n            span{\r\n                background-color: #ddd;\r\n                color: #444;\r\n                cursor: pointer;\r\n                width: .85rem;\r\n                text-align: center;\r\n                padding: .05rem 0;\r\n                border-radius: .02rem;\r\n            }\r\n            span:hover{\r\n                background-color: #efefef;\r\n            }\r\n        }\r\n        .middle{\r\n            margin: 0 .4rem;\r\n        }\r\n    }\r\n</style>\n\n\n/** WEBPACK FOOTER **\n ** Create.vue?40e7fd43\n **/","<template>\r\n    <div id=\"create\" v-if=\"!$loadingRouteData\">\r\n        <div class=\"quest\">\r\n            <div class=\"quest-title\">\r\n                <h2 v-text=\"questionnaire.title\" class=\"quest-title_preview\"></h2>\r\n            </div>\r\n            <div v-for=\"questItem in questionnaire.questItemList\" class=\"questItem-data\" track-by=\"$index\">\r\n                <div class=\"chart\" v-echarts=\"questItem\"></div>\r\n            </div>\r\n        </div>\r\n        <p class=\"preview-deadline\">问卷截止日期：{{new Date(questionnaire.deadline).toLocaleDateString()}}</p>\r\n    </div>\r\n</template>\r\n<script>\r\n    import echarts from '../echarts'\r\n\r\n    export default{\r\n        data() {\r\n            return {\r\n                typeMap: {\r\n                    radio: '单选',\r\n                    checkbox: '多选',\r\n                    textarea: '问答'\r\n                }\r\n            }\r\n        },\r\n        vuex: {\r\n            getters: {\r\n                questionnaire: state => state.currentQuestionnaire,\r\n                questionnaireList: state => state.questionnaireList\r\n            },\r\n            actions: {\r\n                setCurrentQuest({dispatch}, item) {\r\n                    dispatch(\"SET_QUEST\", item)\r\n                }\r\n            }\r\n        },\r\n        route: {\r\n            data({to, next}) {\r\n                let id = to.params.questId\r\n                if(!this.questionnaire) {\r\n                    this.questionnaireList.forEach(item => {\r\n                        if(parseInt(item.id) === parseInt(id)) {\r\n                            this.setCurrentQuest(item)\r\n                            return\r\n                        }\r\n                    })\r\n                }\r\n                // 渲染图表\r\n                next()\r\n            }\r\n        },\r\n        directives: {\r\n            'echarts': {\r\n                bind: function() {\r\n                    let self = this\r\n                    this.vm.$nextTick(function() {\r\n                        self.instance = echarts.init(self.el)\r\n                    })\r\n                },\r\n                update: function(newVal, oldVal) {\r\n                    let self = this\r\n                    let seriesData = []\r\n                    let option = {}\r\n                    // 如果不是文本类问题，则画柱状图；否则话饼图\r\n                    if(newVal.type !== 'textarea') {\r\n                        newVal.selections.forEach(item => {\r\n                            seriesData.push(parseInt(Math.random()*100))\r\n                        })\r\n                        option = {\r\n                            grid: {\r\n                                top: 40,\r\n                                bottom: 25\r\n                            },\r\n                            title: {\r\n                                text: self.vm.typeMap[newVal.type] + '.' +  newVal.title,\r\n                                textAlign: \"left\"\r\n                            },\r\n                            yAxis: {\r\n\r\n                            },\r\n                            xAxis: {\r\n                                data: newVal.selections\r\n                            },\r\n                            series:[{\r\n                                type: 'bar',\r\n                                data: seriesData\r\n                            }]\r\n                        }\r\n                    } else {\r\n                        seriesData.push(parseInt(Math.random()*100))\r\n                        seriesData.push(100 - seriesData[0])\r\n                        option = {\r\n                            title: {\r\n                                text: self.vm.typeMap[newVal.type] + '.' +  newVal.title,\r\n                                textAlign: \"left\"\r\n                            },\r\n                            series : [{\r\n                                type: 'pie',\r\n                                radius: \"60%\",\r\n                                data: [\r\n                                    {name: '有效回答', value: seriesData[0]},\r\n                                    {name: '无效回答', value: seriesData[1]}\r\n                                ]\r\n                            }]\r\n                        }\r\n                    }\r\n                    this.vm.$nextTick(function() {\r\n                        self.instance.setOption(option)\r\n                    })\r\n                    \r\n                },\r\n                unbind: function() {\r\n                    this.instance.dispose()\r\n                }\r\n            }\r\n        }\r\n    }\r\n</script>\r\n<style lang=\"less\">\r\n    #create{\r\n        .preview-deadline{\r\n            font-size: .14rem;\r\n            margin-top: .2rem;\r\n            text-align: center;\r\n        }\r\n        .quest-title_preview{\r\n            text-align: center;\r\n            letter-spacing: .05rem;\r\n            font-size: .28rem;\r\n            font-weight: bold;\r\n        }\r\n         .questItem-data{\r\n            margin: .1rem 0;\r\n            border: 1px solid #ccc;\r\n            border-radius: .03rem;\r\n        } \r\n        .chart{\r\n            min-height: 2rem;\r\n            width: 4rem;\r\n            margin: 0 auto;\r\n        }\r\n    }\r\n</style>\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** Data.vue?c8856686\n **/","<template>\r\n    <div id=\"create\" v-if=\"!$loadingRouteData\">\r\n        <div class=\"quest\">\r\n            <div class=\"quest-title\">\r\n                <input type=\"text\" class=\"quest-title_input\" placeholder=\"请输入问卷的标题\"\r\n                    v-model=\"questionnaire.title\" />\r\n            </div>\r\n            <div v-for=\"questItem in questionnaire.questItemList\" class=\"questItem\" track-by=\"$index\">\r\n                <p class=\"questItem-title\">\r\n                    <span>{{$index+1}}、{{typeMap[questItem.type]}}：</span>\r\n                    <span v-text=\"questItem.title\"></span>\r\n                </p>\r\n                <div v-if=\"questItem.type==='textarea'\">\r\n                    <textarea></textarea>\r\n                </div>\r\n                <div v-else>\r\n                    <div v-for=\"selection in questItem.selections\" class=\"selection\">\r\n                        <input :type=\"questItem.type\" :name=\"questItem.name\" \r\n                            :id=\"questItem.name+$index\"\r\n                            :class=\"questItem.type\"/>\r\n                        <label v-text=\"selection\" :for=\"questItem.name+$index\"></label>\r\n                    </div>\r\n                </div>\r\n                <div class=\"item-operation\" @click=\"handleItemOperation($event, questItem)\">\r\n                    <button type=\"button\" v-if=\"$index != 0\" data-operation=\"up\">上移</button>\r\n                    <button type=\"button\" v-if=\"$index != questionnaire.questItemList.length-1\"\r\n                        data-operation=\"down\">下移</button>\r\n                    <button type=\"button\" data-operation=\"remove\">删除</button>\r\n                    <button type=\"button\" data-operation=\"reuse\">复用</button>\r\n                </div>\r\n            </div>\r\n            <div class=\"add\">\r\n                <div class=\"add-items\" \r\n                    v-show=\"showSelections\"\r\n                    transition=\"expand\"\r\n                    @click.stop=\"addItem($event)\">\r\n                    <span data-type=\"radio\">单选题</span>\r\n                    <span class=\"middle\" data-type=\"checkbox\">多选题</span>\r\n                    <span data-type=\"textarea\">文本题</span>\r\n                </div>\r\n                <div class=\"add-button\">\r\n                    <button type=\"button\" @click.stop=\"showSelections=!showSelections\">添加问题</button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div class=\"mask\" v-if=\"showMask\">\r\n            <div class=\"mask-prompt\">\r\n                <div class=\"prompt-header\">请输入详细信息</div>\r\n                <div class=\"prompt-body\">\r\n                    <div>\r\n                        <label>问题名称：</label>\r\n                        <input type=\"text\" placeholder=\"请输入标题\" v-el:item-title />\r\n                    </div>\r\n                    <div>\r\n                        <label>选项：</label>\r\n                        <input type=\"text\" placeholder=\"请输入选项\" v-el:item-selections \r\n                            :disabled=\"questItem.type === 'textarea'\" />\r\n                        <p class=\"prompt\">*&nbsp;不同选项之间请以空格隔开</p>\r\n                    </div>\r\n                </div>\r\n                <div class=\"prompt-footer\" @click.stop=\"handleInput($event)\">\r\n                    <button type=\"button\" data-operation=\"confirm\">确定</button>\r\n                    <button type=\"button\" data-operation=\"cancel\">取消</button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div class=\"submit\">\r\n            <div class=\"deadline\">\r\n                <label>问卷截止日期：</label>\r\n                <input type=\"text\" placeholder=\"点击选择问卷截止日期\" readonly \r\n                    v-el:deadline\r\n                    :value=\"new Date(questionnaire.deadline).toLocaleDateString()\"\r\n                    @click.stop=\"showCalendar=!showCalendar\"/>\r\n                <Calendar :show-calendar.sync=\"showCalendar\" v-if=\"showCalendar\"></Calendar>\r\n            </div>\r\n            <div @click=\"submit($event)\">\r\n                <button type=\"button\" data-operation=\"save\">保存问卷</button>\r\n                <button type=\"button\" data-operation=\"publish\">发布问卷</button>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</template>\r\n<script>\r\n    import Calendar from './Calendar'\r\n\r\n    export default{\r\n        data() {\r\n            return {\r\n                showSelections: false,\r\n                showMask: false,\r\n                showCalendar: false,\r\n                questItem: {},\r\n                typeMap: {\r\n                    radio: '单选',\r\n                    checkbox: '多选',\r\n                    textarea: '问答'\r\n                }\r\n            }\r\n        },\r\n        methods: {\r\n            // 添加问题的类型\r\n            addItem(event) {\r\n                let target = event.target\r\n                if(target.nodeName.toLowerCase() === 'span') {\r\n                    this.showMask = true    // 显示弹出框\r\n                    this.questItem.type = target.dataset.type   // 设置问题的类型\r\n                }\r\n            },\r\n            // 处理弹出框中的点击事件\r\n            handleInput(event) {\r\n                let target = event.target\r\n                if(target.nodeName.toLowerCase() !== 'button') {\r\n                    return\r\n                }\r\n                let itemTitle = this.$els.itemTitle\r\n                let itemSelections = this.$els.itemSelections\r\n                if(target.dataset.operation === \"confirm\") {\r\n                    if(this.questItem.type === \"textarea\") {\r\n                        this.addTextarea(itemTitle)\r\n                    } else {\r\n                        this.addSelections(itemTitle, itemSelections)\r\n                    }\r\n                } else {\r\n                    this.handleCancel()\r\n                }\r\n            },\r\n            // 添加文本问题\r\n            addTextarea(itemTitle) {\r\n                if(itemTitle.value.trim() === '') {\r\n                    return\r\n                }\r\n                this.questItem.title = itemTitle.value.trim()\r\n                this.questionnaire.questItemList.push(this.questItem)\r\n                this.handleCancel()\r\n            },\r\n            // 添加选项问题\r\n            addSelections(itemTitle, itemSelections) {\r\n                if(itemTitle.value.trim() === '' || itemSelections.value.trim() === '') {\r\n                    return\r\n                }\r\n                this.questItem.title = itemTitle.value.trim()\r\n                this.questItem.selections = itemSelections.value.trim().split(/\\s+/)\r\n                this.questItem.name = Date.now()\r\n                this.questionnaire.questItemList.push(this.questItem)\r\n                this.handleCancel()\r\n            },\r\n            // 处理取消事件\r\n            handleCancel() {\r\n                this.$els.itemTitle.value = ''\r\n                this.$els.itemSelections.value = ''\r\n                this.questItem = {}\r\n                this.showMask = false\r\n            },\r\n            // 处理上移、下移、删除和复用操作\r\n            handleItemOperation(event, questItem) {\r\n                let operation = event.target.dataset.operation\r\n                switch(operation) {\r\n                    case 'up':\r\n                        this.moveUp(questItem)\r\n                        break\r\n                    case 'down':\r\n                        this.moveDown(questItem)\r\n                        break\r\n                    case 'remove':\r\n                        this.removeQuestItem(questItem)\r\n                        break\r\n                    case 'reuse':\r\n                        this.reuseQuestItem(questItem)\r\n                        break\r\n                    default: \r\n                        throw new Error(\"该操作\" + \"operation\" + \"不存在！\")\r\n                }\r\n            },\r\n            // 上移\r\n            moveUp(questItem) {\r\n                let index = this.questionnaire.questItemList.indexOf(questItem)\r\n                this.questionnaire.questItemList.$remove(questItem)\r\n                this.questionnaire.questItemList.splice(index-1, 0, questItem)\r\n            },\r\n            // 下移，其实就是把后边那个上移\r\n            moveDown(questItem) {\r\n                let index = this.questionnaire.questItemList.indexOf(questItem)\r\n                this.moveUp(this.questionnaire.questItemList[index+1])\r\n            },\r\n            // 删除\r\n            removeQuestItem(questItem) {\r\n                this.questionnaire.questItemList.$remove(questItem)\r\n            },\r\n            // 复用\r\n            reuseQuestItem(questItem) {\r\n                let index = this.questionnaire.questItemList.indexOf(questItem)\r\n                // 为了完整的克隆一个对象，先把对象转换成JSON，再转换成对象\r\n                let newQuestItem = JSON.parse(JSON.stringify(questItem))\r\n                if(newQuestItem.type !== 'textarea') {\r\n                    newQuestItem.name = Date.now()\r\n                }\r\n                this.questionnaire.questItemList.splice(index+1, 0, newQuestItem)\r\n            },\r\n            // 处理提交\r\n            submit(event) {\r\n                let operation = event.target.dataset.operation\r\n                let oneDayTime = 24*60*60*1000\r\n                if(this.questionnaire.title.trim() === '') {\r\n                    alert(\"问卷的标题不能为空！\")\r\n                    return\r\n                }\r\n                if(this.questionnaire.questItemList.length === 0) {\r\n                    alert(\"请至少设置一个问题！\")\r\n                    return\r\n                }\r\n                if(!this.questionnaire.deadline || this.questionnaire.deadline<Date.now()) {\r\n                    alert(\"问卷的截止时间必须在今天之后！\")\r\n                    return\r\n                }\r\n                if(operation === 'save') {\r\n                    this.save()\r\n                } else {\r\n                    this.publish()\r\n                }\r\n            }\r\n        },\r\n        components: {\r\n            Calendar\r\n        },\r\n        events: {\r\n            'date-change': function(msg) {\r\n                let date = new Date(msg)\r\n                this.$els.deadline.value = date.toLocaleDateString()\r\n                this.questionnaire.deadline = date.getTime()\r\n            }\r\n        },\r\n        vuex: {\r\n            actions: {\r\n                save({dispatch}) {\r\n                    this.questionnaire.state = \"未发布\"\r\n                    dispatch('UPDATE_QUEST', this.questionnaire)\r\n                    this.$router.go(`/preview/${this.questionnaire.id}`)\r\n                },\r\n                publish({dispatch}) {\r\n                    this.questionnaire.state = \"已发布\"\r\n                    dispatch('UPDATE_QUEST', this.questionnaire)\r\n                    this.$router.go(`/preview/${this.questionnaire.id}`)\r\n                },\r\n                setCurrentQuest({dispatch}, item) {\r\n                    dispatch(\"SET_QUEST\", item)\r\n                }\r\n            },\r\n            getters: {\r\n                questionnaire: state => state.currentQuestionnaire,\r\n                questionnaireList: state => state.questionnaireList\r\n            }\r\n        },\r\n        route: {\r\n            data({to, next}) {\r\n                let id = to.params.questId\r\n                if(!this.questionnaire) {\r\n                    this.questionnaireList.forEach(item => {\r\n                        if(parseInt(item.id) === parseInt(id)) {\r\n                            this.setCurrentQuest(item)\r\n                            return\r\n                        }\r\n                    })\r\n                }\r\n                next()\r\n            }\r\n        }\r\n    }\r\n</script>\n\n\n/** WEBPACK FOOTER **\n ** Edit.vue?0f669ee4\n **/","<template>\r\n    <div id=\"index\">\r\n        <div class=\"empty\" v-if=\"questionnaireList.length === 0\">\r\n            <button type=\"button\" @click.stop=\"createQuest\">新建问卷</button>\r\n        </div>\r\n        <div class=\"full\" v-else>\r\n            <table>\r\n                <thead>\r\n                    <tr>\r\n                        <th></th><th>标题</th><th>截止时间</th><th>状态</th><th>操作</th>\r\n                    </tr>\r\n                </thead>\r\n                <tbody>\r\n                    <tr v-for=\"questionnaire in questionnaireList\" class=\"quest\"\r\n                        @click=\"handleOperation($event, questionnaire)\">\r\n                        <td class=\"col01\">\r\n                            <input type=\"checkbox\" :name=\"name\" :id=\"name+$index\" class=\"checkbox\"/>\r\n                            <label :for=\"name+$index\" data-operation=\"checked\"></label>\r\n                        </td>\r\n                        <td class=\"col02\">\r\n                            <span v-text=\"questionnaire.title\"></span>\r\n                        </td>\r\n                        <td v-text=\"new Date(questionnaire.deadline).toLocaleDateString()\"></td>\r\n                        <td v-text=\"questionnaire.state\"></td>\r\n                        <td v-if=\"questionnaire.state==='未发布'\" >\r\n                            <button data-operation=\"preview\">预览问卷</button>&nbsp;&nbsp;&nbsp;\r\n                            <button data-operation=\"edit\">编辑问卷</button>\r\n                        </td>\r\n                        <td v-else>\r\n                            <button data-operation=\"preview\">预览问卷</button>&nbsp;&nbsp;&nbsp;\r\n                            <button data-operation=\"data\">数据统计</button>\r\n                        </td>\r\n                    </tr>\r\n                    <tr class=\"last-row\" @click=\"createOrRm($event)\">\r\n                        <td colspan=\"2\" class=\"left\">\r\n                            <!-- <input type=\"checkbox\" id=\"check-all\" class=\"checkbox\" />\r\n                            <label for=\"check-all\" data-operation=\"checkAll\" data-checked=\"false\">全选</label> -->\r\n                            <button type=\"button\" data-operation=\"rmChecked\">删除</button>\r\n                        </td>\r\n                        <td colspan=\"3\" class=\"center\">\r\n                            <button type=\"button\" data-operation=\"create\">新建问卷</button>\r\n                        </td>\r\n                    </tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    </div>\r\n</template>\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                name: Date.now(),   // 用于标记checkbox\r\n                checkedQuest: []    // 被选中的问卷列表\r\n            };\r\n        },\r\n        vuex: {\r\n            getters: {\r\n                questionnaireList: state => state.questionnaireList\r\n            },\r\n            actions: {\r\n                setQuest({dispatch}, item) {\r\n                    dispatch('SET_QUEST', item)\r\n                },\r\n                removeQuest({dispatch}, item) {\r\n                    dispatch('RM_QUEST', item)\r\n                }\r\n            }\r\n        },\r\n        methods: {\r\n            createQuest() {\r\n                this.$router.go('/create')\r\n            },\r\n            // 处理每个问卷后面的两个按钮，以及选中按钮\r\n            handleOperation(event, questionnaire) {\r\n                let operation = event.target.dataset.operation\r\n                if(operation === \"edit\") {\r\n                    this.setQuest(questionnaire)\r\n                    this.$router.go(`/edit/${questionnaire.id}`)\r\n                } else if(operation === \"preview\") {\r\n                    this.setQuest(questionnaire) \r\n                    this.$router.go(`/preview/${questionnaire.id}`)\r\n                } else if(operation === \"checked\") {\r\n                    this.handleChecked(questionnaire)\r\n                } else if(operation === \"data\") {\r\n                    this.setQuest(questionnaire)\r\n                    this.$router.go(`/data/${questionnaire.id}`)\r\n                }\r\n            },\r\n            // 处理每个问卷的checked事件\r\n            handleChecked(questionnaire) {\r\n                let index = this.checkedQuest.indexOf(questionnaire)\r\n                // 每次点击checkbox，如果该问卷在选中的问卷列表中则在列表中删除该问卷\r\n                // 如果不在列表中，则添加该问卷到列表\r\n                if(index === -1) {\r\n                    this.checkedQuest.push(questionnaire)\r\n                } else {\r\n                    this.checkedQuest.splice(index, 1)\r\n                }\r\n            },\r\n            // 处理新建、删除按钮和全选\r\n            createOrRm(event) {\r\n                let operation = event.target.dataset.operation\r\n                if(operation === 'create') {\r\n                    this.createQuest()\r\n                } else if (operation === 'rmChecked') {\r\n                    this.remove()\r\n                }\r\n            },\r\n            // 删除问卷\r\n            remove() {\r\n                while(this.checkedQuest.length > 0) {\r\n                    let questionnaire = this.checkedQuest.shift()\r\n                    this.removeQuest(questionnaire)\r\n                }\r\n            }\r\n        }\r\n    }\r\n</script>\r\n<style lang=\"less\">\r\n    @import '../color.less';\r\n\r\n    #index{\r\n        width: 100%;\r\n        .col01{\r\n            width: 5%;\r\n            text-align: left;\r\n        }\r\n        .col02{\r\n            width: 30%;\r\n        }\r\n        .buttons{\r\n            display: flex;\r\n            justify-content: space-around;\r\n        }\r\n        .quest{\r\n            td{\r\n                padding: .15rem 0;\r\n                border-bottom: 1px solid #cdcdcd;\r\n            }\r\n        }\r\n        .quest:hover{\r\n            background-color: @light;\r\n        }\r\n        .last-row{\r\n            td{\r\n                padding: .2rem 0;\r\n            }\r\n            button{\r\n                margin-left: .2rem;\r\n            }\r\n        }\r\n        .center{\r\n            text-align: center\r\n        }\r\n        .left{\r\n            text-align: left;\r\n        }\r\n        .full{\r\n            width: 10rem;\r\n            margin: .2rem auto;\r\n            border: .02rem solid #ccc;\r\n            border-radius: .04rem;\r\n            table{\r\n                border-collapse: collapse;\r\n                width: 90%;\r\n                margin: 0 auto;\r\n                text-align: center;\r\n            }\r\n            thead{\r\n                font-size: .18rem;\r\n            }\r\n            tbody{\r\n                font-size: .17rem;\r\n                \r\n            }\r\n            th{\r\n                padding: .2rem 0;\r\n            }\r\n            \r\n            button{\r\n                background-color: #fff;\r\n                border: 1px solid #ccc;\r\n                border-radius: .02rem;\r\n                width: .9rem;\r\n                text-align: center;\r\n                padding: .05rem 0;\r\n            }\r\n            button:hover{\r\n                background-color: @light;\r\n            }\r\n        }\r\n        .empty{\r\n            width: 6rem;\r\n            height: 3rem;\r\n            margin: 0.4rem auto;\r\n            border: 0.03rem solid #ccc;\r\n            font-size: 0.2rem;\r\n            border-radius: .08rem;\r\n            display: flex;\r\n            justify-content: center;\r\n            align-items: center;\r\n            button{\r\n                font-size: 0.2rem;\r\n                background-color: @base;\r\n                border: none;\r\n                border-radius: 0.04rem;\r\n                color: #fff;\r\n                width: 2rem;\r\n                text-align: center;\r\n                padding: 0.1rem 0;\r\n            }\r\n            button:hover{\r\n                background-color: @light;\r\n            }\r\n        }\r\n    }\r\n</style>\n\n\n/** WEBPACK FOOTER **\n ** Index.vue?08b4c385\n **/","<template>\r\n    <div id=\"create\" v-if=\"!$loadingRouteData\">\r\n        <div class=\"quest\">\r\n            <div class=\"quest-title\">\r\n                <h2 v-text=\"questionnaire.title\" class=\"quest-title_preview\"></h2>\r\n            </div>\r\n            <div v-for=\"questItem in questionnaire.questItemList\" class=\"questItem\" track-by=\"$index\">\r\n                <p class=\"questItem-title\">\r\n                    <span>{{$index+1}}、{{typeMap[questItem.type]}}：</span>\r\n                    <span v-text=\"questItem.title\"></span>\r\n                </p>\r\n                <div v-if=\"questItem.type==='textarea'\">\r\n                    <textarea></textarea>\r\n                </div>\r\n                <div v-else>\r\n                    <div v-for=\"selection in questItem.selections\" class=\"selection\">\r\n                        <input :type=\"questItem.type\" :name=\"questItem.name\" \r\n                            :id=\"questItem.name+$index\"\r\n                            :class=\"questItem.type\"/>\r\n                        <label v-text=\"selection\" :for=\"questItem.name+$index\"></label>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <p class=\"preview-deadline\">问卷截止日期：{{new Date(questionnaire.deadline).toLocaleDateString()}}</p>\r\n    </div>\r\n</template>\r\n<script>\r\n    export default{\r\n        data() {\r\n            return {\r\n                typeMap: {\r\n                    radio: '单选',\r\n                    checkbox: '多选',\r\n                    textarea: '问答'\r\n                }\r\n            }\r\n        },\r\n        vuex: {\r\n            getters: {\r\n                questionnaire: state => state.currentQuestionnaire,\r\n                questionnaireList: state => state.questionnaireList\r\n            },\r\n            actions: {\r\n                setCurrentQuest({dispatch}, item) {\r\n                    dispatch(\"SET_QUEST\", item)\r\n                }\r\n            }\r\n        },\r\n        route: {\r\n            data({to, next}) {\r\n                let id = to.params.questId\r\n                if(!this.questionnaire) {\r\n                    this.questionnaireList.forEach(item => {\r\n                        if(parseInt(item.id) === parseInt(id)) {\r\n                            this.setCurrentQuest(item)\r\n                            return\r\n                        }\r\n                    })\r\n                }\r\n                next()\r\n            }\r\n        }\r\n    }\r\n</script>\r\n<style lang=\"less\">\r\n    #create{\r\n        .preview-deadline{\r\n            font-size: .14rem;\r\n            margin-top: .2rem;\r\n            text-align: center;\r\n        }\r\n        .quest-title_preview{\r\n            text-align: center;\r\n            letter-spacing: .05rem;\r\n            font-size: .28rem;\r\n            font-weight: bold;\r\n        }\r\n    }\r\n</style>\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** Preview.vue?d4ea2df8\n **/","var core  = require('../../modules/_core')\n  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});\nmodule.exports = function stringify(it){ // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/core-js/2.4.1/core-js/library/fn/json/stringify.js\n ** module id = 18\n ** module chunks = 1\n **/","var core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/core-js/2.4.1/core-js/library/modules/_core.js\n ** module id = 19\n ** module chunks = 1\n **/","exports = module.exports = require(\"./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"#calendar{width:300px;border:1px solid #ccc;border-radius:3px;box-sizing:border-box;padding:10px;font-size:14px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}#calendar .calendar-selections{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-pack:distribute;justify-content:space-around;width:100%;height:30px}#calendar .calendar-selections span{display:inline-block;height:24px;line-height:24px;cursor:pointer}#calendar .calendar-selections_month,#calendar .calendar-selections_year{width:90px;height:24px}#calendar .calendar-selections_month option,#calendar .calendar-selections_year option,#calendar table{text-align:center}#calendar table{width:100%;border-collapse:collapse}#calendar table,#calendar td,#calendar th{border:none}#calendar tr{height:26px}#calendar td{cursor:pointer;-webkit-transition:background-color .2s;transition:background-color .2s}#calendar td:hover{background-color:#cce5ff}#calendar .not-current-month{color:#aaa}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/css-loader/0.23.1/css-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./~/.npminstall/less-loader/2.2.3/less-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./src/components/Calendar.vue\n ** module id = 20\n ** module chunks = 1\n **/","exports = module.exports = require(\"./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"#create{width:10rem;border:.03rem solid #ccc;border-radius:.05rem;margin:.4rem auto;font-size:.16rem;box-sizing:border-box;padding:.1rem .2rem}#create .item-operation{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end}#create .item-operation button{width:.4rem;padding:.05rem 0;margin-right:.1rem;border-radius:.02rem}#create .questItem:hover{background-color:#cce5ff}#create .deadline{position:relative}#create #calendar{position:absolute;top:-240px;left:0;background-color:#fff}#create .deadline input{width:1.5rem;padding-left:.1rem;height:.25rem;border-radius:.02rem;border:1px solid #ccc}#create .submit{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-pack:distribute;justify-content:space-around;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin-top:.2rem}#create .submit button{width:.9rem;background-color:#007fff;margin-right:.2rem;padding:.1rem 0;color:#fff;border-radius:.03rem}#create .submit button:hover{background-color:#cce5ff;color:#555}#create .questItem{padding:.15rem .2rem;font-size:.17rem;-webkit-transition:background-color .1s;transition:background-color .1s}#create .questItem textarea{resize:none;width:3.3rem;height:1.7rem;border-radius:.03rem}#create .questItem-title{margin-bottom:.15rem}#create .questItem-title+div{margin-left:.2rem}#create .selection{margin-bottom:.15rem}#create .mask-prompt{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;position:absolute;width:4rem;height:2rem;top:40%;left:50%;margin-left:-2rem;margin-top:-1rem}#create .prompt{font-size:.12px;text-align:center;margin-top:.1rem}#create .prompt-header{width:100%;background-color:#007fff;height:.3rem;text-align:center;line-height:.3rem;color:#fff;font-weight:700;font-size:.18rem}#create .prompt-body{background-color:#fff;-webkit-box-flex:1;-ms-flex:1;flex:1;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:distribute;justify-content:space-around;padding:0 .5rem}#create .prompt-body label{display:inline-block;width:.85rem;text-align:right}#create .prompt-footer{height:.3rem;background-color:#fff;display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-pack:distribute;justify-content:space-around;align-item:center;padding:.1rem .5rem}#create .prompt-footer button{background-color:#007fff;text-align:center;width:.7rem;color:#fff;border-radius:.03rem}#create .mask{position:fixed;width:100%;height:100%;left:0;top:0;background-color:rgba(0,0,0,.15);z-index:10}#create .expand-transition{-webkit-transition:all .3s;transition:all .3s;width:100%;height:.3rem;overflow:hidden}#create .expand-enter,#create .expand-leave{height:0;opacity:0}#create .quest{border-bottom:2px solid #ccc}#create .quest-title_input{width:100%;height:.3rem;border:none;font-size:.25rem;text-align:center;font-weight:700;letter-spacing:.05rem}#create .quest-title{border-bottom:.02rem solid #ccc;padding-bottom:.1rem}#create .add{width:95%;margin:.1rem auto;border:.01px solid #ccc;padding:.1rem 0}#create .add-button{margin-top:.1rem}#create .add-button button{display:block;width:100%;background-color:#ddd;border-radius:3px;padding:.2rem 0;color:#444;font-size:.23rem;-webkit-transition:background-color .1s;transition:background-color .1s}#create .add-button button:hover{background-color:#efefef}#create .add-items{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}#create .add-items span{background-color:#ddd;color:#444;cursor:pointer;width:.85rem;text-align:center;padding:.05rem 0;border-radius:.02rem}#create .add-items span:hover{background-color:#efefef}#create .middle{margin:0 .4rem}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/css-loader/0.23.1/css-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./~/.npminstall/less-loader/2.2.3/less-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./src/components/Create.vue\n ** module id = 21\n ** module chunks = 1\n **/","exports = module.exports = require(\"./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"#create .preview-deadline{font-size:.14rem;margin-top:.2rem;text-align:center}#create .quest-title_preview{text-align:center;letter-spacing:.05rem;font-size:.28rem;font-weight:700}#create .questItem-data{margin:.1rem 0;border:1px solid #ccc;border-radius:.03rem}#create .chart{min-height:2rem;width:4rem;margin:0 auto}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/css-loader/0.23.1/css-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./~/.npminstall/less-loader/2.2.3/less-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./src/components/Data.vue\n ** module id = 22\n ** module chunks = 1\n **/","exports = module.exports = require(\"./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"#header{width:100%;height:.4rem;background-color:#007fff;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:#fff}#header h1{font-size:.22rem;font-weight:700;margin-left:.22rem}#header h1 a{color:#fff}#header h1:before{content:'\\\\F29C';margin-right:5px}#header h2{font-size:.18rem;font-weight:400;margin-left:.25rem}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/css-loader/0.23.1/css-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./~/.npminstall/less-loader/2.2.3/less-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./src/components/Header.vue\n ** module id = 23\n ** module chunks = 1\n **/","exports = module.exports = require(\"./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"#index{width:100%}#index .col01{width:5%;text-align:left}#index .col02{width:30%}#index .buttons{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-pack:distribute;justify-content:space-around}#index .quest td{padding:.15rem 0;border-bottom:1px solid #cdcdcd}#index .quest:hover{background-color:#cce5ff}#index .last-row td{padding:.2rem 0}#index .last-row button{margin-left:.2rem}#index .center{text-align:center}#index .left{text-align:left}#index .full{width:10rem;margin:.2rem auto;border:.02rem solid #ccc;border-radius:.04rem}#index .full table{border-collapse:collapse;width:90%;margin:0 auto;text-align:center}#index .full thead{font-size:.18rem}#index .full tbody{font-size:.17rem}#index .full th{padding:.2rem 0}#index .full button{background-color:#fff;border:1px solid #ccc;border-radius:.02rem;width:.9rem;text-align:center;padding:.05rem 0}#index .full button:hover{background-color:#cce5ff}#index .empty{width:6rem;height:3rem;margin:.4rem auto;border:.03rem solid #ccc;font-size:.2rem;border-radius:.08rem;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}#index .empty button{font-size:.2rem;background-color:#007fff;border:none;border-radius:.04rem;color:#fff;width:2rem;text-align:center;padding:.1rem 0}#index .empty button:hover{background-color:#cce5ff}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/css-loader/0.23.1/css-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./~/.npminstall/less-loader/2.2.3/less-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./src/components/Index.vue\n ** module id = 24\n ** module chunks = 1\n **/","exports = module.exports = require(\"./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"#create .preview-deadline{font-size:.14rem;margin-top:.2rem;text-align:center}#create .quest-title_preview{text-align:center;letter-spacing:.05rem;font-size:.28rem;font-weight:700}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/css-loader/0.23.1/css-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./~/.npminstall/less-loader/2.2.3/less-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./src/components/Preview.vue\n ** module id = 25\n ** module chunks = 1\n **/","exports = module.exports = require(\"./../node_modules/.npminstall/css-loader/0.23.1/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"body,html{width:100%;height:100%;font-family:Helvetica,Hiragino Sans GB,Microsoft Yahei,\\\\\\\\5FAE\\\\8F6F\\\\96C5\\\\9ED1,Arial,sans-serif}body,button,div,h1,h2,h3,html,p{padding:0;margin:0;line-height:1}html{font-size:100px;min-width:980px}button{cursor:pointer;border:none;font-size:.16rem}button,input,textarea{outline:none}a{text-decoration:none}li{list-style:none}.checkbox,.radio{display:none}.checkbox+label,.radio+label{position:relative;font-size:16px;padding-left:23px;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.checkbox+label:before,.radio+label:before{position:absolute;content:\\\"\\\";top:48%;margin-top:-8px;left:0;width:16px;height:16px;border:1px solid silver;background-color:#fff}.checkbox+label:before{border-radius:3px}.radio+label:before{border-radius:50%}.checkbox:checked+label:after{position:absolute;content:\\\"\\\";width:5px;height:10px;top:48%;margin-top:-7px;left:6px;-webkit-transform:rotate(45deg);transform:rotate(45deg);border-bottom:2px solid #fff;border-right:2px solid #fff}.checkbox:checked+label:before{background-color:#3e97eb;border:1px solid #3e97eb}.radio:checked+label:before{border:1px solid #3e97eb}.radio:checked+label:after{position:absolute;content:\\\"\\\";width:6px;height:6px;top:50%;margin-top:-3px;left:6px;border-radius:50%;background-color:#3e97eb}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/css-loader/0.23.1/css-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./src/App.vue\n ** module id = 26\n ** module chunks = 1\n **/","module.exports = \" <div id=app> <v-header></v-header> <router-view keep-alive></router-view> </div> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-html-loader/1.2.3/vue-html-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./src/App.vue\n ** module id = 27\n ** module chunks = 1\n **/","module.exports = \" <div id=calendar> <div class=calendar-selections> <span class=calendar-selections_last @click=decrMonth> <i class=\\\"fa fa-chevron-left\\\"></i> </span> <select name=year class=calendar-selections_year v-model=currentYear> <option v-for=\\\"year in yearList\\\">{{year}}</option> </select> <select class=calendar-selections_month v-model=currentMonth> <option v-for=\\\"month in monthList\\\">{{month}}</option> </select> <span class=calendar-selelctions_next @click=incrMonth> <i class=\\\"fa fa-chevron-right\\\"></i> </span> </div> <table @click.stop=handleClick($event)> <thead> <tr><th v-for=\\\"week in weekList\\\">{{week}}</th></tr> </thead> <tbody> <tr v-for=\\\"row in tableData\\\"> <td v-for=\\\"date in row\\\" :class=\\\"{'not-current-month': date.getMonth()!==currentMonth-1}\\\" :data-date=date.getTime()> {{date.getDate()}} </td> </tr> </tbody> </table> </div> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-html-loader/1.2.3/vue-html-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./src/components/Calendar.vue\n ** module id = 28\n ** module chunks = 1\n **/","module.exports = \" <div id=create> <div class=quest> <div class=quest-title> <input type=text class=quest-title_input placeholder=请输入问卷的标题 v-model=questionnaire.title /> </div> <div v-for=\\\"questItem in questionnaire.questItemList\\\" class=questItem track-by=$index> <p class=questItem-title> <span>{{$index+1}}、{{typeMap[questItem.type]}}：</span> <span v-text=questItem.title></span> </p> <div v-if=\\\"questItem.type==='textarea'\\\"> <textarea></textarea> </div> <div v-else> <div v-for=\\\"selection in questItem.selections\\\" class=selection> <input :type=questItem.type :name=questItem.name :id=questItem.name+$index :class=questItem.type /> <label v-text=selection :for=questItem.name+$index></label> </div> </div> <div class=item-operation @click=\\\"handleItemOperation($event, questItem)\\\"> <button type=button v-if=\\\"$index != 0\\\" data-operation=up>上移</button> <button type=button v-if=\\\"$index != questionnaire.questItemList.length-1\\\" data-operation=down>下移</button> <button type=button data-operation=remove>删除</button> <button type=button data-operation=reuse>复用</button> </div> </div> <div class=add> <div class=add-items v-show=showSelections transition=expand @click.stop=addItem($event)> <span data-type=radio>单选题</span> <span class=middle data-type=checkbox>多选题</span> <span data-type=textarea>文本题</span> </div> <div class=add-button> <button type=button @click.stop=\\\"showSelections=!showSelections\\\">添加问题</button> </div> </div> </div> <div class=mask v-if=showMask> <div class=mask-prompt> <div class=prompt-header>请输入详细信息</div> <div class=prompt-body> <div> <label>问题名称：</label> <input type=text placeholder=请输入标题 v-el:item-title/> </div> <div> <label>选项：</label> <input type=text placeholder=请输入选项 v-el:item-selections :disabled=\\\"questItem.type === 'textarea'\\\"/> <p class=prompt>*&nbsp;不同选项之间请以空格隔开</p> </div> </div> <div class=prompt-footer @click.stop=handleInput($event)> <button type=button data-operation=confirm>确定</button> <button type=button data-operation=cancel>取消</button> </div> </div> </div> <div class=submit> <div class=deadline> <label>问卷截止日期：</label> <input type=text placeholder=点击选择问卷截止日期 readonly=readonly v-el:deadline @click.stop=\\\"showCalendar=!showCalendar\\\"/> <calendar :show-calendar.sync=showCalendar v-if=showCalendar></calendar> </div> <div @click=submit($event)> <button type=button data-operation=save>保存问卷</button> <button type=button data-operation=publish>发布问卷</button> </div> </div> </div> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-html-loader/1.2.3/vue-html-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./src/components/Create.vue\n ** module id = 29\n ** module chunks = 1\n **/","module.exports = \" <div id=create v-if=!$loadingRouteData> <div class=quest> <div class=quest-title> <h2 v-text=questionnaire.title class=quest-title_preview></h2> </div> <div v-for=\\\"questItem in questionnaire.questItemList\\\" class=questItem-data track-by=$index> <div class=chart v-echarts=questItem></div> </div> </div> <p class=preview-deadline>问卷截止日期：{{new Date(questionnaire.deadline).toLocaleDateString()}}</p> </div> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-html-loader/1.2.3/vue-html-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./src/components/Data.vue\n ** module id = 30\n ** module chunks = 1\n **/","module.exports = \" <div id=create v-if=!$loadingRouteData> <div class=quest> <div class=quest-title> <input type=text class=quest-title_input placeholder=请输入问卷的标题 v-model=questionnaire.title /> </div> <div v-for=\\\"questItem in questionnaire.questItemList\\\" class=questItem track-by=$index> <p class=questItem-title> <span>{{$index+1}}、{{typeMap[questItem.type]}}：</span> <span v-text=questItem.title></span> </p> <div v-if=\\\"questItem.type==='textarea'\\\"> <textarea></textarea> </div> <div v-else> <div v-for=\\\"selection in questItem.selections\\\" class=selection> <input :type=questItem.type :name=questItem.name :id=questItem.name+$index :class=questItem.type /> <label v-text=selection :for=questItem.name+$index></label> </div> </div> <div class=item-operation @click=\\\"handleItemOperation($event, questItem)\\\"> <button type=button v-if=\\\"$index != 0\\\" data-operation=up>上移</button> <button type=button v-if=\\\"$index != questionnaire.questItemList.length-1\\\" data-operation=down>下移</button> <button type=button data-operation=remove>删除</button> <button type=button data-operation=reuse>复用</button> </div> </div> <div class=add> <div class=add-items v-show=showSelections transition=expand @click.stop=addItem($event)> <span data-type=radio>单选题</span> <span class=middle data-type=checkbox>多选题</span> <span data-type=textarea>文本题</span> </div> <div class=add-button> <button type=button @click.stop=\\\"showSelections=!showSelections\\\">添加问题</button> </div> </div> </div> <div class=mask v-if=showMask> <div class=mask-prompt> <div class=prompt-header>请输入详细信息</div> <div class=prompt-body> <div> <label>问题名称：</label> <input type=text placeholder=请输入标题 v-el:item-title/> </div> <div> <label>选项：</label> <input type=text placeholder=请输入选项 v-el:item-selections :disabled=\\\"questItem.type === 'textarea'\\\"/> <p class=prompt>*&nbsp;不同选项之间请以空格隔开</p> </div> </div> <div class=prompt-footer @click.stop=handleInput($event)> <button type=button data-operation=confirm>确定</button> <button type=button data-operation=cancel>取消</button> </div> </div> </div> <div class=submit> <div class=deadline> <label>问卷截止日期：</label> <input type=text placeholder=点击选择问卷截止日期 readonly=readonly v-el:deadline :value=\\\"new Date(questionnaire.deadline).toLocaleDateString()\\\" @click.stop=\\\"showCalendar=!showCalendar\\\"/> <calendar :show-calendar.sync=showCalendar v-if=showCalendar></calendar> </div> <div @click=submit($event)> <button type=button data-operation=save>保存问卷</button> <button type=button data-operation=publish>发布问卷</button> </div> </div> </div> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-html-loader/1.2.3/vue-html-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./src/components/Edit.vue\n ** module id = 31\n ** module chunks = 1\n **/","module.exports = \" <div id=header> <h1><a v-link=\\\"'#/index'\\\">问卷管理</a></h1> <h2>我的问卷</h2> </div> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-html-loader/1.2.3/vue-html-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./src/components/Header.vue\n ** module id = 32\n ** module chunks = 1\n **/","module.exports = \" <div id=index> <div class=empty v-if=\\\"questionnaireList.length === 0\\\"> <button type=button @click.stop=createQuest>新建问卷</button> </div> <div class=full v-else> <table> <thead> <tr> <th></th><th>标题</th><th>截止时间</th><th>状态</th><th>操作</th> </tr> </thead> <tbody> <tr v-for=\\\"questionnaire in questionnaireList\\\" class=quest @click=\\\"handleOperation($event, questionnaire)\\\"> <td class=col01> <input type=checkbox :name=name :id=name+$index class=checkbox /> <label :for=name+$index data-operation=checked></label> </td> <td class=col02> <span v-text=questionnaire.title></span> </td> <td v-text=\\\"new Date(questionnaire.deadline).toLocaleDateString()\\\"></td> <td v-text=questionnaire.state></td> <td v-if=\\\"questionnaire.state==='未发布'\\\"> <button data-operation=preview>预览问卷</button>&nbsp;&nbsp;&nbsp; <button data-operation=edit>编辑问卷</button> </td> <td v-else> <button data-operation=preview>预览问卷</button>&nbsp;&nbsp;&nbsp; <button data-operation=data>数据统计</button> </td> </tr> <tr class=last-row @click=createOrRm($event)> <td colspan=2 class=left> <button type=button data-operation=rmChecked>删除</button> </td> <td colspan=3 class=center> <button type=button data-operation=create>新建问卷</button> </td> </tr> </tbody> </table> </div> </div> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-html-loader/1.2.3/vue-html-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./src/components/Index.vue\n ** module id = 33\n ** module chunks = 1\n **/","module.exports = \" <div id=create v-if=!$loadingRouteData> <div class=quest> <div class=quest-title> <h2 v-text=questionnaire.title class=quest-title_preview></h2> </div> <div v-for=\\\"questItem in questionnaire.questItemList\\\" class=questItem track-by=$index> <p class=questItem-title> <span>{{$index+1}}、{{typeMap[questItem.type]}}：</span> <span v-text=questItem.title></span> </p> <div v-if=\\\"questItem.type==='textarea'\\\"> <textarea></textarea> </div> <div v-else> <div v-for=\\\"selection in questItem.selections\\\" class=selection> <input :type=questItem.type :name=questItem.name :id=questItem.name+$index :class=questItem.type /> <label v-text=selection :for=questItem.name+$index></label> </div> </div> </div> </div> <p class=preview-deadline>问卷截止日期：{{new Date(questionnaire.deadline).toLocaleDateString()}}</p> </div> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-html-loader/1.2.3/vue-html-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./src/components/Preview.vue\n ** module id = 34\n ** module chunks = 1\n **/","var __vue_script__, __vue_template__\nrequire(\"!!vue-style-loader!css-loader!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./App.vue\")\n__vue_script__ = require(\"!!babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=script&index=0!./App.vue\")\n__vue_template__ = require(\"!!vue-html-loader!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./App.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/App.vue\n ** module id = 35\n ** module chunks = 1\n **/","var __vue_script__, __vue_template__\nrequire(\"!!vue-style-loader!css-loader!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!less!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Create.vue\")\n__vue_script__ = require(\"!!babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=script&index=0!./Create.vue\")\n__vue_template__ = require(\"!!vue-html-loader!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./Create.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/Create.vue\n ** module id = 36\n ** module chunks = 1\n **/","var __vue_script__, __vue_template__\nrequire(\"!!vue-style-loader!css-loader!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!less!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Data.vue\")\n__vue_script__ = require(\"!!babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=script&index=0!./Data.vue\")\n__vue_template__ = require(\"!!vue-html-loader!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./Data.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/Data.vue\n ** module id = 37\n ** module chunks = 1\n **/","var __vue_script__, __vue_template__\n__vue_script__ = require(\"!!babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=script&index=0!./Edit.vue\")\n__vue_template__ = require(\"!!vue-html-loader!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./Edit.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/Edit.vue\n ** module id = 38\n ** module chunks = 1\n **/","var __vue_script__, __vue_template__\nrequire(\"!!vue-style-loader!css-loader!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!less!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Header.vue\")\n__vue_script__ = require(\"!!babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=script&index=0!./Header.vue\")\n__vue_template__ = require(\"!!vue-html-loader!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./Header.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/Header.vue\n ** module id = 39\n ** module chunks = 1\n **/","var __vue_script__, __vue_template__\nrequire(\"!!vue-style-loader!css-loader!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!less!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Preview.vue\")\n__vue_script__ = require(\"!!babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=script&index=0!./Preview.vue\")\n__vue_template__ = require(\"!!vue-html-loader!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./Preview.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/Preview.vue\n ** module id = 40\n ** module chunks = 1\n **/","/*!\n * vue-router v0.7.13\n * (c) 2016 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.VueRouter = factory();\n}(this, function () { 'use strict';\n\n  var babelHelpers = {};\n\n  babelHelpers.classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n  function Target(path, matcher, delegate) {\n    this.path = path;\n    this.matcher = matcher;\n    this.delegate = delegate;\n  }\n\n  Target.prototype = {\n    to: function to(target, callback) {\n      var delegate = this.delegate;\n\n      if (delegate && delegate.willAddRoute) {\n        target = delegate.willAddRoute(this.matcher.target, target);\n      }\n\n      this.matcher.add(this.path, target);\n\n      if (callback) {\n        if (callback.length === 0) {\n          throw new Error(\"You must have an argument in the function passed to `to`\");\n        }\n        this.matcher.addChild(this.path, target, callback, this.delegate);\n      }\n      return this;\n    }\n  };\n\n  function Matcher(target) {\n    this.routes = {};\n    this.children = {};\n    this.target = target;\n  }\n\n  Matcher.prototype = {\n    add: function add(path, handler) {\n      this.routes[path] = handler;\n    },\n\n    addChild: function addChild(path, target, callback, delegate) {\n      var matcher = new Matcher(target);\n      this.children[path] = matcher;\n\n      var match = generateMatch(path, matcher, delegate);\n\n      if (delegate && delegate.contextEntered) {\n        delegate.contextEntered(target, match);\n      }\n\n      callback(match);\n    }\n  };\n\n  function generateMatch(startingPath, matcher, delegate) {\n    return function (path, nestedCallback) {\n      var fullPath = startingPath + path;\n\n      if (nestedCallback) {\n        nestedCallback(generateMatch(fullPath, matcher, delegate));\n      } else {\n        return new Target(startingPath + path, matcher, delegate);\n      }\n    };\n  }\n\n  function addRoute(routeArray, path, handler) {\n    var len = 0;\n    for (var i = 0, l = routeArray.length; i < l; i++) {\n      len += routeArray[i].path.length;\n    }\n\n    path = path.substr(len);\n    var route = { path: path, handler: handler };\n    routeArray.push(route);\n  }\n\n  function eachRoute(baseRoute, matcher, callback, binding) {\n    var routes = matcher.routes;\n\n    for (var path in routes) {\n      if (routes.hasOwnProperty(path)) {\n        var routeArray = baseRoute.slice();\n        addRoute(routeArray, path, routes[path]);\n\n        if (matcher.children[path]) {\n          eachRoute(routeArray, matcher.children[path], callback, binding);\n        } else {\n          callback.call(binding, routeArray);\n        }\n      }\n    }\n  }\n\n  function map (callback, addRouteCallback) {\n    var matcher = new Matcher();\n\n    callback(generateMatch(\"\", matcher, this.delegate));\n\n    eachRoute([], matcher, function (route) {\n      if (addRouteCallback) {\n        addRouteCallback(this, route);\n      } else {\n        this.add(route);\n      }\n    }, this);\n  }\n\n  var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\'];\n\n  var escapeRegex = new RegExp('(\\\\' + specials.join('|\\\\') + ')', 'g');\n\n  var noWarning = false;\n  function warn(msg) {\n    if (!noWarning && typeof console !== 'undefined') {\n      console.error('[vue-router] ' + msg);\n    }\n  }\n\n  function tryDecode(uri, asComponent) {\n    try {\n      return asComponent ? decodeURIComponent(uri) : decodeURI(uri);\n    } catch (e) {\n      warn('malformed URI' + (asComponent ? ' component: ' : ': ') + uri);\n    }\n  }\n\n  function isArray(test) {\n    return Object.prototype.toString.call(test) === \"[object Array]\";\n  }\n\n  // A Segment represents a segment in the original route description.\n  // Each Segment type provides an `eachChar` and `regex` method.\n  //\n  // The `eachChar` method invokes the callback with one or more character\n  // specifications. A character specification consumes one or more input\n  // characters.\n  //\n  // The `regex` method returns a regex fragment for the segment. If the\n  // segment is a dynamic of star segment, the regex fragment also includes\n  // a capture.\n  //\n  // A character specification contains:\n  //\n  // * `validChars`: a String with a list of all valid characters, or\n  // * `invalidChars`: a String with a list of all invalid characters\n  // * `repeat`: true if the character specification can repeat\n\n  function StaticSegment(string) {\n    this.string = string;\n  }\n  StaticSegment.prototype = {\n    eachChar: function eachChar(callback) {\n      var string = this.string,\n          ch;\n\n      for (var i = 0, l = string.length; i < l; i++) {\n        ch = string.charAt(i);\n        callback({ validChars: ch });\n      }\n    },\n\n    regex: function regex() {\n      return this.string.replace(escapeRegex, '\\\\$1');\n    },\n\n    generate: function generate() {\n      return this.string;\n    }\n  };\n\n  function DynamicSegment(name) {\n    this.name = name;\n  }\n  DynamicSegment.prototype = {\n    eachChar: function eachChar(callback) {\n      callback({ invalidChars: \"/\", repeat: true });\n    },\n\n    regex: function regex() {\n      return \"([^/]+)\";\n    },\n\n    generate: function generate(params) {\n      var val = params[this.name];\n      return val == null ? \":\" + this.name : val;\n    }\n  };\n\n  function StarSegment(name) {\n    this.name = name;\n  }\n  StarSegment.prototype = {\n    eachChar: function eachChar(callback) {\n      callback({ invalidChars: \"\", repeat: true });\n    },\n\n    regex: function regex() {\n      return \"(.+)\";\n    },\n\n    generate: function generate(params) {\n      var val = params[this.name];\n      return val == null ? \":\" + this.name : val;\n    }\n  };\n\n  function EpsilonSegment() {}\n  EpsilonSegment.prototype = {\n    eachChar: function eachChar() {},\n    regex: function regex() {\n      return \"\";\n    },\n    generate: function generate() {\n      return \"\";\n    }\n  };\n\n  function parse(route, names, specificity) {\n    // normalize route as not starting with a \"/\". Recognition will\n    // also normalize.\n    if (route.charAt(0) === \"/\") {\n      route = route.substr(1);\n    }\n\n    var segments = route.split(\"/\"),\n        results = [];\n\n    // A routes has specificity determined by the order that its different segments\n    // appear in. This system mirrors how the magnitude of numbers written as strings\n    // works.\n    // Consider a number written as: \"abc\". An example would be \"200\". Any other number written\n    // \"xyz\" will be smaller than \"abc\" so long as `a > z`. For instance, \"199\" is smaller\n    // then \"200\", even though \"y\" and \"z\" (which are both 9) are larger than \"0\" (the value\n    // of (`b` and `c`). This is because the leading symbol, \"2\", is larger than the other\n    // leading symbol, \"1\".\n    // The rule is that symbols to the left carry more weight than symbols to the right\n    // when a number is written out as a string. In the above strings, the leading digit\n    // represents how many 100's are in the number, and it carries more weight than the middle\n    // number which represents how many 10's are in the number.\n    // This system of number magnitude works well for route specificity, too. A route written as\n    // `a/b/c` will be more specific than `x/y/z` as long as `a` is more specific than\n    // `x`, irrespective of the other parts.\n    // Because of this similarity, we assign each type of segment a number value written as a\n    // string. We can find the specificity of compound routes by concatenating these strings\n    // together, from left to right. After we have looped through all of the segments,\n    // we convert the string to a number.\n    specificity.val = '';\n\n    for (var i = 0, l = segments.length; i < l; i++) {\n      var segment = segments[i],\n          match;\n\n      if (match = segment.match(/^:([^\\/]+)$/)) {\n        results.push(new DynamicSegment(match[1]));\n        names.push(match[1]);\n        specificity.val += '3';\n      } else if (match = segment.match(/^\\*([^\\/]+)$/)) {\n        results.push(new StarSegment(match[1]));\n        specificity.val += '2';\n        names.push(match[1]);\n      } else if (segment === \"\") {\n        results.push(new EpsilonSegment());\n        specificity.val += '1';\n      } else {\n        results.push(new StaticSegment(segment));\n        specificity.val += '4';\n      }\n    }\n\n    specificity.val = +specificity.val;\n\n    return results;\n  }\n\n  // A State has a character specification and (`charSpec`) and a list of possible\n  // subsequent states (`nextStates`).\n  //\n  // If a State is an accepting state, it will also have several additional\n  // properties:\n  //\n  // * `regex`: A regular expression that is used to extract parameters from paths\n  //   that reached this accepting state.\n  // * `handlers`: Information on how to convert the list of captures into calls\n  //   to registered handlers with the specified parameters\n  // * `types`: How many static, dynamic or star segments in this route. Used to\n  //   decide which route to use if multiple registered routes match a path.\n  //\n  // Currently, State is implemented naively by looping over `nextStates` and\n  // comparing a character specification against a character. A more efficient\n  // implementation would use a hash of keys pointing at one or more next states.\n\n  function State(charSpec) {\n    this.charSpec = charSpec;\n    this.nextStates = [];\n  }\n\n  State.prototype = {\n    get: function get(charSpec) {\n      var nextStates = this.nextStates;\n\n      for (var i = 0, l = nextStates.length; i < l; i++) {\n        var child = nextStates[i];\n\n        var isEqual = child.charSpec.validChars === charSpec.validChars;\n        isEqual = isEqual && child.charSpec.invalidChars === charSpec.invalidChars;\n\n        if (isEqual) {\n          return child;\n        }\n      }\n    },\n\n    put: function put(charSpec) {\n      var state;\n\n      // If the character specification already exists in a child of the current\n      // state, just return that state.\n      if (state = this.get(charSpec)) {\n        return state;\n      }\n\n      // Make a new state for the character spec\n      state = new State(charSpec);\n\n      // Insert the new state as a child of the current state\n      this.nextStates.push(state);\n\n      // If this character specification repeats, insert the new state as a child\n      // of itself. Note that this will not trigger an infinite loop because each\n      // transition during recognition consumes a character.\n      if (charSpec.repeat) {\n        state.nextStates.push(state);\n      }\n\n      // Return the new state\n      return state;\n    },\n\n    // Find a list of child states matching the next character\n    match: function match(ch) {\n      // DEBUG \"Processing `\" + ch + \"`:\"\n      var nextStates = this.nextStates,\n          child,\n          charSpec,\n          chars;\n\n      // DEBUG \"  \" + debugState(this)\n      var returned = [];\n\n      for (var i = 0, l = nextStates.length; i < l; i++) {\n        child = nextStates[i];\n\n        charSpec = child.charSpec;\n\n        if (typeof (chars = charSpec.validChars) !== 'undefined') {\n          if (chars.indexOf(ch) !== -1) {\n            returned.push(child);\n          }\n        } else if (typeof (chars = charSpec.invalidChars) !== 'undefined') {\n          if (chars.indexOf(ch) === -1) {\n            returned.push(child);\n          }\n        }\n      }\n\n      return returned;\n    }\n\n    /** IF DEBUG\n    , debug: function() {\n      var charSpec = this.charSpec,\n          debug = \"[\",\n          chars = charSpec.validChars || charSpec.invalidChars;\n       if (charSpec.invalidChars) { debug += \"^\"; }\n      debug += chars;\n      debug += \"]\";\n       if (charSpec.repeat) { debug += \"+\"; }\n       return debug;\n    }\n    END IF **/\n  };\n\n  /** IF DEBUG\n  function debug(log) {\n    console.log(log);\n  }\n\n  function debugState(state) {\n    return state.nextStates.map(function(n) {\n      if (n.nextStates.length === 0) { return \"( \" + n.debug() + \" [accepting] )\"; }\n      return \"( \" + n.debug() + \" <then> \" + n.nextStates.map(function(s) { return s.debug() }).join(\" or \") + \" )\";\n    }).join(\", \")\n  }\n  END IF **/\n\n  // Sort the routes by specificity\n  function sortSolutions(states) {\n    return states.sort(function (a, b) {\n      return b.specificity.val - a.specificity.val;\n    });\n  }\n\n  function recognizeChar(states, ch) {\n    var nextStates = [];\n\n    for (var i = 0, l = states.length; i < l; i++) {\n      var state = states[i];\n\n      nextStates = nextStates.concat(state.match(ch));\n    }\n\n    return nextStates;\n  }\n\n  var oCreate = Object.create || function (proto) {\n    function F() {}\n    F.prototype = proto;\n    return new F();\n  };\n\n  function RecognizeResults(queryParams) {\n    this.queryParams = queryParams || {};\n  }\n  RecognizeResults.prototype = oCreate({\n    splice: Array.prototype.splice,\n    slice: Array.prototype.slice,\n    push: Array.prototype.push,\n    length: 0,\n    queryParams: null\n  });\n\n  function findHandler(state, path, queryParams) {\n    var handlers = state.handlers,\n        regex = state.regex;\n    var captures = path.match(regex),\n        currentCapture = 1;\n    var result = new RecognizeResults(queryParams);\n\n    for (var i = 0, l = handlers.length; i < l; i++) {\n      var handler = handlers[i],\n          names = handler.names,\n          params = {};\n\n      for (var j = 0, m = names.length; j < m; j++) {\n        params[names[j]] = captures[currentCapture++];\n      }\n\n      result.push({ handler: handler.handler, params: params, isDynamic: !!names.length });\n    }\n\n    return result;\n  }\n\n  function addSegment(currentState, segment) {\n    segment.eachChar(function (ch) {\n      var state;\n\n      currentState = currentState.put(ch);\n    });\n\n    return currentState;\n  }\n\n  function decodeQueryParamPart(part) {\n    // http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1\n    part = part.replace(/\\+/gm, '%20');\n    return tryDecode(part, true);\n  }\n\n  // The main interface\n\n  var RouteRecognizer = function RouteRecognizer() {\n    this.rootState = new State();\n    this.names = {};\n  };\n\n  RouteRecognizer.prototype = {\n    add: function add(routes, options) {\n      var currentState = this.rootState,\n          regex = \"^\",\n          specificity = {},\n          handlers = [],\n          allSegments = [],\n          name;\n\n      var isEmpty = true;\n\n      for (var i = 0, l = routes.length; i < l; i++) {\n        var route = routes[i],\n            names = [];\n\n        var segments = parse(route.path, names, specificity);\n\n        allSegments = allSegments.concat(segments);\n\n        for (var j = 0, m = segments.length; j < m; j++) {\n          var segment = segments[j];\n\n          if (segment instanceof EpsilonSegment) {\n            continue;\n          }\n\n          isEmpty = false;\n\n          // Add a \"/\" for the new segment\n          currentState = currentState.put({ validChars: \"/\" });\n          regex += \"/\";\n\n          // Add a representation of the segment to the NFA and regex\n          currentState = addSegment(currentState, segment);\n          regex += segment.regex();\n        }\n\n        var handler = { handler: route.handler, names: names };\n        handlers.push(handler);\n      }\n\n      if (isEmpty) {\n        currentState = currentState.put({ validChars: \"/\" });\n        regex += \"/\";\n      }\n\n      currentState.handlers = handlers;\n      currentState.regex = new RegExp(regex + \"$\");\n      currentState.specificity = specificity;\n\n      if (name = options && options.as) {\n        this.names[name] = {\n          segments: allSegments,\n          handlers: handlers\n        };\n      }\n    },\n\n    handlersFor: function handlersFor(name) {\n      var route = this.names[name],\n          result = [];\n      if (!route) {\n        throw new Error(\"There is no route named \" + name);\n      }\n\n      for (var i = 0, l = route.handlers.length; i < l; i++) {\n        result.push(route.handlers[i]);\n      }\n\n      return result;\n    },\n\n    hasRoute: function hasRoute(name) {\n      return !!this.names[name];\n    },\n\n    generate: function generate(name, params) {\n      var route = this.names[name],\n          output = \"\";\n      if (!route) {\n        throw new Error(\"There is no route named \" + name);\n      }\n\n      var segments = route.segments;\n\n      for (var i = 0, l = segments.length; i < l; i++) {\n        var segment = segments[i];\n\n        if (segment instanceof EpsilonSegment) {\n          continue;\n        }\n\n        output += \"/\";\n        output += segment.generate(params);\n      }\n\n      if (output.charAt(0) !== '/') {\n        output = '/' + output;\n      }\n\n      if (params && params.queryParams) {\n        output += this.generateQueryString(params.queryParams);\n      }\n\n      return output;\n    },\n\n    generateQueryString: function generateQueryString(params) {\n      var pairs = [];\n      var keys = [];\n      for (var key in params) {\n        if (params.hasOwnProperty(key)) {\n          keys.push(key);\n        }\n      }\n      keys.sort();\n      for (var i = 0, len = keys.length; i < len; i++) {\n        key = keys[i];\n        var value = params[key];\n        if (value == null) {\n          continue;\n        }\n        var pair = encodeURIComponent(key);\n        if (isArray(value)) {\n          for (var j = 0, l = value.length; j < l; j++) {\n            var arrayPair = key + '[]' + '=' + encodeURIComponent(value[j]);\n            pairs.push(arrayPair);\n          }\n        } else {\n          pair += \"=\" + encodeURIComponent(value);\n          pairs.push(pair);\n        }\n      }\n\n      if (pairs.length === 0) {\n        return '';\n      }\n\n      return \"?\" + pairs.join(\"&\");\n    },\n\n    parseQueryString: function parseQueryString(queryString) {\n      var pairs = queryString.split(\"&\"),\n          queryParams = {};\n      for (var i = 0; i < pairs.length; i++) {\n        var pair = pairs[i].split('='),\n            key = decodeQueryParamPart(pair[0]),\n            keyLength = key.length,\n            isArray = false,\n            value;\n        if (pair.length === 1) {\n          value = 'true';\n        } else {\n          //Handle arrays\n          if (keyLength > 2 && key.slice(keyLength - 2) === '[]') {\n            isArray = true;\n            key = key.slice(0, keyLength - 2);\n            if (!queryParams[key]) {\n              queryParams[key] = [];\n            }\n          }\n          value = pair[1] ? decodeQueryParamPart(pair[1]) : '';\n        }\n        if (isArray) {\n          queryParams[key].push(value);\n        } else {\n          queryParams[key] = value;\n        }\n      }\n      return queryParams;\n    },\n\n    recognize: function recognize(path, silent) {\n      noWarning = silent;\n      var states = [this.rootState],\n          pathLen,\n          i,\n          l,\n          queryStart,\n          queryParams = {},\n          isSlashDropped = false;\n\n      queryStart = path.indexOf('?');\n      if (queryStart !== -1) {\n        var queryString = path.substr(queryStart + 1, path.length);\n        path = path.substr(0, queryStart);\n        if (queryString) {\n          queryParams = this.parseQueryString(queryString);\n        }\n      }\n\n      path = tryDecode(path);\n      if (!path) return;\n\n      // DEBUG GROUP path\n\n      if (path.charAt(0) !== \"/\") {\n        path = \"/\" + path;\n      }\n\n      pathLen = path.length;\n      if (pathLen > 1 && path.charAt(pathLen - 1) === \"/\") {\n        path = path.substr(0, pathLen - 1);\n        isSlashDropped = true;\n      }\n\n      for (i = 0, l = path.length; i < l; i++) {\n        states = recognizeChar(states, path.charAt(i));\n        if (!states.length) {\n          break;\n        }\n      }\n\n      // END DEBUG GROUP\n\n      var solutions = [];\n      for (i = 0, l = states.length; i < l; i++) {\n        if (states[i].handlers) {\n          solutions.push(states[i]);\n        }\n      }\n\n      states = sortSolutions(solutions);\n\n      var state = solutions[0];\n\n      if (state && state.handlers) {\n        // if a trailing slash was dropped and a star segment is the last segment\n        // specified, put the trailing slash back\n        if (isSlashDropped && state.regex.source.slice(-5) === \"(.+)$\") {\n          path = path + \"/\";\n        }\n        return findHandler(state, path, queryParams);\n      }\n    }\n  };\n\n  RouteRecognizer.prototype.map = map;\n\n  var genQuery = RouteRecognizer.prototype.generateQueryString;\n\n  // export default for holding the Vue reference\n  var exports$1 = {};\n  /**\n   * Warn stuff.\n   *\n   * @param {String} msg\n   */\n\n  function warn$1(msg) {\n    /* istanbul ignore next */\n    if (typeof console !== 'undefined') {\n      console.error('[vue-router] ' + msg);\n    }\n  }\n\n  /**\n   * Resolve a relative path.\n   *\n   * @param {String} base\n   * @param {String} relative\n   * @param {Boolean} append\n   * @return {String}\n   */\n\n  function resolvePath(base, relative, append) {\n    var query = base.match(/(\\?.*)$/);\n    if (query) {\n      query = query[1];\n      base = base.slice(0, -query.length);\n    }\n    // a query!\n    if (relative.charAt(0) === '?') {\n      return base + relative;\n    }\n    var stack = base.split('/');\n    // remove trailing segment if:\n    // - not appending\n    // - appending to trailing slash (last segment is empty)\n    if (!append || !stack[stack.length - 1]) {\n      stack.pop();\n    }\n    // resolve relative path\n    var segments = relative.replace(/^\\//, '').split('/');\n    for (var i = 0; i < segments.length; i++) {\n      var segment = segments[i];\n      if (segment === '.') {\n        continue;\n      } else if (segment === '..') {\n        stack.pop();\n      } else {\n        stack.push(segment);\n      }\n    }\n    // ensure leading slash\n    if (stack[0] !== '') {\n      stack.unshift('');\n    }\n    return stack.join('/');\n  }\n\n  /**\n   * Forgiving check for a promise\n   *\n   * @param {Object} p\n   * @return {Boolean}\n   */\n\n  function isPromise(p) {\n    return p && typeof p.then === 'function';\n  }\n\n  /**\n   * Retrive a route config field from a component instance\n   * OR a component contructor.\n   *\n   * @param {Function|Vue} component\n   * @param {String} name\n   * @return {*}\n   */\n\n  function getRouteConfig(component, name) {\n    var options = component && (component.$options || component.options);\n    return options && options.route && options.route[name];\n  }\n\n  /**\n   * Resolve an async component factory. Have to do a dirty\n   * mock here because of Vue core's internal API depends on\n   * an ID check.\n   *\n   * @param {Object} handler\n   * @param {Function} cb\n   */\n\n  var resolver = undefined;\n\n  function resolveAsyncComponent(handler, cb) {\n    if (!resolver) {\n      resolver = {\n        resolve: exports$1.Vue.prototype._resolveComponent,\n        $options: {\n          components: {\n            _: handler.component\n          }\n        }\n      };\n    } else {\n      resolver.$options.components._ = handler.component;\n    }\n    resolver.resolve('_', function (Component) {\n      handler.component = Component;\n      cb(Component);\n    });\n  }\n\n  /**\n   * Map the dynamic segments in a path to params.\n   *\n   * @param {String} path\n   * @param {Object} params\n   * @param {Object} query\n   */\n\n  function mapParams(path, params, query) {\n    if (params === undefined) params = {};\n\n    path = path.replace(/:([^\\/]+)/g, function (_, key) {\n      var val = params[key];\n      /* istanbul ignore if */\n      if (!val) {\n        warn$1('param \"' + key + '\" not found when generating ' + 'path for \"' + path + '\" with params ' + JSON.stringify(params));\n      }\n      return val || '';\n    });\n    if (query) {\n      path += genQuery(query);\n    }\n    return path;\n  }\n\n  var hashRE = /#.*$/;\n\n  var HTML5History = (function () {\n    function HTML5History(_ref) {\n      var root = _ref.root;\n      var onChange = _ref.onChange;\n      babelHelpers.classCallCheck(this, HTML5History);\n\n      if (root && root !== '/') {\n        // make sure there's the starting slash\n        if (root.charAt(0) !== '/') {\n          root = '/' + root;\n        }\n        // remove trailing slash\n        this.root = root.replace(/\\/$/, '');\n        this.rootRE = new RegExp('^\\\\' + this.root);\n      } else {\n        this.root = null;\n      }\n      this.onChange = onChange;\n      // check base tag\n      var baseEl = document.querySelector('base');\n      this.base = baseEl && baseEl.getAttribute('href');\n    }\n\n    HTML5History.prototype.start = function start() {\n      var _this = this;\n\n      this.listener = function (e) {\n        var url = location.pathname + location.search;\n        if (_this.root) {\n          url = url.replace(_this.rootRE, '');\n        }\n        _this.onChange(url, e && e.state, location.hash);\n      };\n      window.addEventListener('popstate', this.listener);\n      this.listener();\n    };\n\n    HTML5History.prototype.stop = function stop() {\n      window.removeEventListener('popstate', this.listener);\n    };\n\n    HTML5History.prototype.go = function go(path, replace, append) {\n      var url = this.formatPath(path, append);\n      if (replace) {\n        history.replaceState({}, '', url);\n      } else {\n        // record scroll position by replacing current state\n        history.replaceState({\n          pos: {\n            x: window.pageXOffset,\n            y: window.pageYOffset\n          }\n        }, '', location.href);\n        // then push new state\n        history.pushState({}, '', url);\n      }\n      var hashMatch = path.match(hashRE);\n      var hash = hashMatch && hashMatch[0];\n      path = url\n      // strip hash so it doesn't mess up params\n      .replace(hashRE, '')\n      // remove root before matching\n      .replace(this.rootRE, '');\n      this.onChange(path, null, hash);\n    };\n\n    HTML5History.prototype.formatPath = function formatPath(path, append) {\n      return path.charAt(0) === '/'\n      // absolute path\n      ? this.root ? this.root + '/' + path.replace(/^\\//, '') : path : resolvePath(this.base || location.pathname, path, append);\n    };\n\n    return HTML5History;\n  })();\n\n  var HashHistory = (function () {\n    function HashHistory(_ref) {\n      var hashbang = _ref.hashbang;\n      var onChange = _ref.onChange;\n      babelHelpers.classCallCheck(this, HashHistory);\n\n      this.hashbang = hashbang;\n      this.onChange = onChange;\n    }\n\n    HashHistory.prototype.start = function start() {\n      var self = this;\n      this.listener = function () {\n        var path = location.hash;\n        var raw = path.replace(/^#!?/, '');\n        // always\n        if (raw.charAt(0) !== '/') {\n          raw = '/' + raw;\n        }\n        var formattedPath = self.formatPath(raw);\n        if (formattedPath !== path) {\n          location.replace(formattedPath);\n          return;\n        }\n        // determine query\n        // note it's possible to have queries in both the actual URL\n        // and the hash fragment itself.\n        var query = location.search && path.indexOf('?') > -1 ? '&' + location.search.slice(1) : location.search;\n        self.onChange(path.replace(/^#!?/, '') + query);\n      };\n      window.addEventListener('hashchange', this.listener);\n      this.listener();\n    };\n\n    HashHistory.prototype.stop = function stop() {\n      window.removeEventListener('hashchange', this.listener);\n    };\n\n    HashHistory.prototype.go = function go(path, replace, append) {\n      path = this.formatPath(path, append);\n      if (replace) {\n        location.replace(path);\n      } else {\n        location.hash = path;\n      }\n    };\n\n    HashHistory.prototype.formatPath = function formatPath(path, append) {\n      var isAbsoloute = path.charAt(0) === '/';\n      var prefix = '#' + (this.hashbang ? '!' : '');\n      return isAbsoloute ? prefix + path : prefix + resolvePath(location.hash.replace(/^#!?/, ''), path, append);\n    };\n\n    return HashHistory;\n  })();\n\n  var AbstractHistory = (function () {\n    function AbstractHistory(_ref) {\n      var onChange = _ref.onChange;\n      babelHelpers.classCallCheck(this, AbstractHistory);\n\n      this.onChange = onChange;\n      this.currentPath = '/';\n    }\n\n    AbstractHistory.prototype.start = function start() {\n      this.onChange('/');\n    };\n\n    AbstractHistory.prototype.stop = function stop() {\n      // noop\n    };\n\n    AbstractHistory.prototype.go = function go(path, replace, append) {\n      path = this.currentPath = this.formatPath(path, append);\n      this.onChange(path);\n    };\n\n    AbstractHistory.prototype.formatPath = function formatPath(path, append) {\n      return path.charAt(0) === '/' ? path : resolvePath(this.currentPath, path, append);\n    };\n\n    return AbstractHistory;\n  })();\n\n  /**\n   * Determine the reusability of an existing router view.\n   *\n   * @param {Directive} view\n   * @param {Object} handler\n   * @param {Transition} transition\n   */\n\n  function canReuse(view, handler, transition) {\n    var component = view.childVM;\n    if (!component || !handler) {\n      return false;\n    }\n    // important: check view.Component here because it may\n    // have been changed in activate hook\n    if (view.Component !== handler.component) {\n      return false;\n    }\n    var canReuseFn = getRouteConfig(component, 'canReuse');\n    return typeof canReuseFn === 'boolean' ? canReuseFn : canReuseFn ? canReuseFn.call(component, {\n      to: transition.to,\n      from: transition.from\n    }) : true; // defaults to true\n  }\n\n  /**\n   * Check if a component can deactivate.\n   *\n   * @param {Directive} view\n   * @param {Transition} transition\n   * @param {Function} next\n   */\n\n  function canDeactivate(view, transition, next) {\n    var fromComponent = view.childVM;\n    var hook = getRouteConfig(fromComponent, 'canDeactivate');\n    if (!hook) {\n      next();\n    } else {\n      transition.callHook(hook, fromComponent, next, {\n        expectBoolean: true\n      });\n    }\n  }\n\n  /**\n   * Check if a component can activate.\n   *\n   * @param {Object} handler\n   * @param {Transition} transition\n   * @param {Function} next\n   */\n\n  function canActivate(handler, transition, next) {\n    resolveAsyncComponent(handler, function (Component) {\n      // have to check due to async-ness\n      if (transition.aborted) {\n        return;\n      }\n      // determine if this component can be activated\n      var hook = getRouteConfig(Component, 'canActivate');\n      if (!hook) {\n        next();\n      } else {\n        transition.callHook(hook, null, next, {\n          expectBoolean: true\n        });\n      }\n    });\n  }\n\n  /**\n   * Call deactivate hooks for existing router-views.\n   *\n   * @param {Directive} view\n   * @param {Transition} transition\n   * @param {Function} next\n   */\n\n  function deactivate(view, transition, next) {\n    var component = view.childVM;\n    var hook = getRouteConfig(component, 'deactivate');\n    if (!hook) {\n      next();\n    } else {\n      transition.callHooks(hook, component, next);\n    }\n  }\n\n  /**\n   * Activate / switch component for a router-view.\n   *\n   * @param {Directive} view\n   * @param {Transition} transition\n   * @param {Number} depth\n   * @param {Function} [cb]\n   */\n\n  function activate(view, transition, depth, cb, reuse) {\n    var handler = transition.activateQueue[depth];\n    if (!handler) {\n      saveChildView(view);\n      if (view._bound) {\n        view.setComponent(null);\n      }\n      cb && cb();\n      return;\n    }\n\n    var Component = view.Component = handler.component;\n    var activateHook = getRouteConfig(Component, 'activate');\n    var dataHook = getRouteConfig(Component, 'data');\n    var waitForData = getRouteConfig(Component, 'waitForData');\n\n    view.depth = depth;\n    view.activated = false;\n\n    var component = undefined;\n    var loading = !!(dataHook && !waitForData);\n\n    // \"reuse\" is a flag passed down when the parent view is\n    // either reused via keep-alive or as a child of a kept-alive view.\n    // of course we can only reuse if the current kept-alive instance\n    // is of the correct type.\n    reuse = reuse && view.childVM && view.childVM.constructor === Component;\n\n    if (reuse) {\n      // just reuse\n      component = view.childVM;\n      component.$loadingRouteData = loading;\n    } else {\n      saveChildView(view);\n\n      // unbuild current component. this step also destroys\n      // and removes all nested child views.\n      view.unbuild(true);\n\n      // build the new component. this will also create the\n      // direct child view of the current one. it will register\n      // itself as view.childView.\n      component = view.build({\n        _meta: {\n          $loadingRouteData: loading\n        },\n        created: function created() {\n          this._routerView = view;\n        }\n      });\n\n      // handle keep-alive.\n      // when a kept-alive child vm is restored, we need to\n      // add its cached child views into the router's view list,\n      // and also properly update current view's child view.\n      if (view.keepAlive) {\n        component.$loadingRouteData = loading;\n        var cachedChildView = component._keepAliveRouterView;\n        if (cachedChildView) {\n          view.childView = cachedChildView;\n          component._keepAliveRouterView = null;\n        }\n      }\n    }\n\n    // cleanup the component in case the transition is aborted\n    // before the component is ever inserted.\n    var cleanup = function cleanup() {\n      component.$destroy();\n    };\n\n    // actually insert the component and trigger transition\n    var insert = function insert() {\n      if (reuse) {\n        cb && cb();\n        return;\n      }\n      var router = transition.router;\n      if (router._rendered || router._transitionOnLoad) {\n        view.transition(component);\n      } else {\n        // no transition on first render, manual transition\n        /* istanbul ignore if */\n        if (view.setCurrent) {\n          // 0.12 compat\n          view.setCurrent(component);\n        } else {\n          // 1.0\n          view.childVM = component;\n        }\n        component.$before(view.anchor, null, false);\n      }\n      cb && cb();\n    };\n\n    var afterData = function afterData() {\n      // activate the child view\n      if (view.childView) {\n        activate(view.childView, transition, depth + 1, null, reuse || view.keepAlive);\n      }\n      insert();\n    };\n\n    // called after activation hook is resolved\n    var afterActivate = function afterActivate() {\n      view.activated = true;\n      if (dataHook && waitForData) {\n        // wait until data loaded to insert\n        loadData(component, transition, dataHook, afterData, cleanup);\n      } else {\n        // load data and insert at the same time\n        if (dataHook) {\n          loadData(component, transition, dataHook);\n        }\n        afterData();\n      }\n    };\n\n    if (activateHook) {\n      transition.callHooks(activateHook, component, afterActivate, {\n        cleanup: cleanup,\n        postActivate: true\n      });\n    } else {\n      afterActivate();\n    }\n  }\n\n  /**\n   * Reuse a view, just reload data if necessary.\n   *\n   * @param {Directive} view\n   * @param {Transition} transition\n   */\n\n  function reuse(view, transition) {\n    var component = view.childVM;\n    var dataHook = getRouteConfig(component, 'data');\n    if (dataHook) {\n      loadData(component, transition, dataHook);\n    }\n  }\n\n  /**\n   * Asynchronously load and apply data to component.\n   *\n   * @param {Vue} component\n   * @param {Transition} transition\n   * @param {Function} hook\n   * @param {Function} cb\n   * @param {Function} cleanup\n   */\n\n  function loadData(component, transition, hook, cb, cleanup) {\n    component.$loadingRouteData = true;\n    transition.callHooks(hook, component, function () {\n      component.$loadingRouteData = false;\n      component.$emit('route-data-loaded', component);\n      cb && cb();\n    }, {\n      cleanup: cleanup,\n      postActivate: true,\n      processData: function processData(data) {\n        // handle promise sugar syntax\n        var promises = [];\n        if (isPlainObject(data)) {\n          Object.keys(data).forEach(function (key) {\n            var val = data[key];\n            if (isPromise(val)) {\n              promises.push(val.then(function (resolvedVal) {\n                component.$set(key, resolvedVal);\n              }));\n            } else {\n              component.$set(key, val);\n            }\n          });\n        }\n        if (promises.length) {\n          return promises[0].constructor.all(promises);\n        }\n      }\n    });\n  }\n\n  /**\n   * Save the child view for a kept-alive view so that\n   * we can restore it when it is switched back to.\n   *\n   * @param {Directive} view\n   */\n\n  function saveChildView(view) {\n    if (view.keepAlive && view.childVM && view.childView) {\n      view.childVM._keepAliveRouterView = view.childView;\n    }\n    view.childView = null;\n  }\n\n  /**\n   * Check plain object.\n   *\n   * @param {*} val\n   */\n\n  function isPlainObject(val) {\n    return Object.prototype.toString.call(val) === '[object Object]';\n  }\n\n  /**\n   * A RouteTransition object manages the pipeline of a\n   * router-view switching process. This is also the object\n   * passed into user route hooks.\n   *\n   * @param {Router} router\n   * @param {Route} to\n   * @param {Route} from\n   */\n\n  var RouteTransition = (function () {\n    function RouteTransition(router, to, from) {\n      babelHelpers.classCallCheck(this, RouteTransition);\n\n      this.router = router;\n      this.to = to;\n      this.from = from;\n      this.next = null;\n      this.aborted = false;\n      this.done = false;\n    }\n\n    /**\n     * Abort current transition and return to previous location.\n     */\n\n    RouteTransition.prototype.abort = function abort() {\n      if (!this.aborted) {\n        this.aborted = true;\n        // if the root path throws an error during validation\n        // on initial load, it gets caught in an infinite loop.\n        var abortingOnLoad = !this.from.path && this.to.path === '/';\n        if (!abortingOnLoad) {\n          this.router.replace(this.from.path || '/');\n        }\n      }\n    };\n\n    /**\n     * Abort current transition and redirect to a new location.\n     *\n     * @param {String} path\n     */\n\n    RouteTransition.prototype.redirect = function redirect(path) {\n      if (!this.aborted) {\n        this.aborted = true;\n        if (typeof path === 'string') {\n          path = mapParams(path, this.to.params, this.to.query);\n        } else {\n          path.params = path.params || this.to.params;\n          path.query = path.query || this.to.query;\n        }\n        this.router.replace(path);\n      }\n    };\n\n    /**\n     * A router view transition's pipeline can be described as\n     * follows, assuming we are transitioning from an existing\n     * <router-view> chain [Component A, Component B] to a new\n     * chain [Component A, Component C]:\n     *\n     *  A    A\n     *  | => |\n     *  B    C\n     *\n     * 1. Reusablity phase:\n     *   -> canReuse(A, A)\n     *   -> canReuse(B, C)\n     *   -> determine new queues:\n     *      - deactivation: [B]\n     *      - activation: [C]\n     *\n     * 2. Validation phase:\n     *   -> canDeactivate(B)\n     *   -> canActivate(C)\n     *\n     * 3. Activation phase:\n     *   -> deactivate(B)\n     *   -> activate(C)\n     *\n     * Each of these steps can be asynchronous, and any\n     * step can potentially abort the transition.\n     *\n     * @param {Function} cb\n     */\n\n    RouteTransition.prototype.start = function start(cb) {\n      var transition = this;\n\n      // determine the queue of views to deactivate\n      var deactivateQueue = [];\n      var view = this.router._rootView;\n      while (view) {\n        deactivateQueue.unshift(view);\n        view = view.childView;\n      }\n      var reverseDeactivateQueue = deactivateQueue.slice().reverse();\n\n      // determine the queue of route handlers to activate\n      var activateQueue = this.activateQueue = toArray(this.to.matched).map(function (match) {\n        return match.handler;\n      });\n\n      // 1. Reusability phase\n      var i = undefined,\n          reuseQueue = undefined;\n      for (i = 0; i < reverseDeactivateQueue.length; i++) {\n        if (!canReuse(reverseDeactivateQueue[i], activateQueue[i], transition)) {\n          break;\n        }\n      }\n      if (i > 0) {\n        reuseQueue = reverseDeactivateQueue.slice(0, i);\n        deactivateQueue = reverseDeactivateQueue.slice(i).reverse();\n        activateQueue = activateQueue.slice(i);\n      }\n\n      // 2. Validation phase\n      transition.runQueue(deactivateQueue, canDeactivate, function () {\n        transition.runQueue(activateQueue, canActivate, function () {\n          transition.runQueue(deactivateQueue, deactivate, function () {\n            // 3. Activation phase\n\n            // Update router current route\n            transition.router._onTransitionValidated(transition);\n\n            // trigger reuse for all reused views\n            reuseQueue && reuseQueue.forEach(function (view) {\n              return reuse(view, transition);\n            });\n\n            // the root of the chain that needs to be replaced\n            // is the top-most non-reusable view.\n            if (deactivateQueue.length) {\n              var _view = deactivateQueue[deactivateQueue.length - 1];\n              var depth = reuseQueue ? reuseQueue.length : 0;\n              activate(_view, transition, depth, cb);\n            } else {\n              cb();\n            }\n          });\n        });\n      });\n    };\n\n    /**\n     * Asynchronously and sequentially apply a function to a\n     * queue.\n     *\n     * @param {Array} queue\n     * @param {Function} fn\n     * @param {Function} cb\n     */\n\n    RouteTransition.prototype.runQueue = function runQueue(queue, fn, cb) {\n      var transition = this;\n      step(0);\n      function step(index) {\n        if (index >= queue.length) {\n          cb();\n        } else {\n          fn(queue[index], transition, function () {\n            step(index + 1);\n          });\n        }\n      }\n    };\n\n    /**\n     * Call a user provided route transition hook and handle\n     * the response (e.g. if the user returns a promise).\n     *\n     * If the user neither expects an argument nor returns a\n     * promise, the hook is assumed to be synchronous.\n     *\n     * @param {Function} hook\n     * @param {*} [context]\n     * @param {Function} [cb]\n     * @param {Object} [options]\n     *                 - {Boolean} expectBoolean\n     *                 - {Boolean} postActive\n     *                 - {Function} processData\n     *                 - {Function} cleanup\n     */\n\n    RouteTransition.prototype.callHook = function callHook(hook, context, cb) {\n      var _ref = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n      var _ref$expectBoolean = _ref.expectBoolean;\n      var expectBoolean = _ref$expectBoolean === undefined ? false : _ref$expectBoolean;\n      var _ref$postActivate = _ref.postActivate;\n      var postActivate = _ref$postActivate === undefined ? false : _ref$postActivate;\n      var processData = _ref.processData;\n      var cleanup = _ref.cleanup;\n\n      var transition = this;\n      var nextCalled = false;\n\n      // abort the transition\n      var abort = function abort() {\n        cleanup && cleanup();\n        transition.abort();\n      };\n\n      // handle errors\n      var onError = function onError(err) {\n        postActivate ? next() : abort();\n        if (err && !transition.router._suppress) {\n          warn$1('Uncaught error during transition: ');\n          throw err instanceof Error ? err : new Error(err);\n        }\n      };\n\n      // since promise swallows errors, we have to\n      // throw it in the next tick...\n      var onPromiseError = function onPromiseError(err) {\n        try {\n          onError(err);\n        } catch (e) {\n          setTimeout(function () {\n            throw e;\n          }, 0);\n        }\n      };\n\n      // advance the transition to the next step\n      var next = function next() {\n        if (nextCalled) {\n          warn$1('transition.next() should be called only once.');\n          return;\n        }\n        nextCalled = true;\n        if (transition.aborted) {\n          cleanup && cleanup();\n          return;\n        }\n        cb && cb();\n      };\n\n      var nextWithBoolean = function nextWithBoolean(res) {\n        if (typeof res === 'boolean') {\n          res ? next() : abort();\n        } else if (isPromise(res)) {\n          res.then(function (ok) {\n            ok ? next() : abort();\n          }, onPromiseError);\n        } else if (!hook.length) {\n          next();\n        }\n      };\n\n      var nextWithData = function nextWithData(data) {\n        var res = undefined;\n        try {\n          res = processData(data);\n        } catch (err) {\n          return onError(err);\n        }\n        if (isPromise(res)) {\n          res.then(next, onPromiseError);\n        } else {\n          next();\n        }\n      };\n\n      // expose a clone of the transition object, so that each\n      // hook gets a clean copy and prevent the user from\n      // messing with the internals.\n      var exposed = {\n        to: transition.to,\n        from: transition.from,\n        abort: abort,\n        next: processData ? nextWithData : next,\n        redirect: function redirect() {\n          transition.redirect.apply(transition, arguments);\n        }\n      };\n\n      // actually call the hook\n      var res = undefined;\n      try {\n        res = hook.call(context, exposed);\n      } catch (err) {\n        return onError(err);\n      }\n\n      if (expectBoolean) {\n        // boolean hooks\n        nextWithBoolean(res);\n      } else if (isPromise(res)) {\n        // promise\n        if (processData) {\n          res.then(nextWithData, onPromiseError);\n        } else {\n          res.then(next, onPromiseError);\n        }\n      } else if (processData && isPlainOjbect(res)) {\n        // data promise sugar\n        nextWithData(res);\n      } else if (!hook.length) {\n        next();\n      }\n    };\n\n    /**\n     * Call a single hook or an array of async hooks in series.\n     *\n     * @param {Array} hooks\n     * @param {*} context\n     * @param {Function} cb\n     * @param {Object} [options]\n     */\n\n    RouteTransition.prototype.callHooks = function callHooks(hooks, context, cb, options) {\n      var _this = this;\n\n      if (Array.isArray(hooks)) {\n        this.runQueue(hooks, function (hook, _, next) {\n          if (!_this.aborted) {\n            _this.callHook(hook, context, next, options);\n          }\n        }, cb);\n      } else {\n        this.callHook(hooks, context, cb, options);\n      }\n    };\n\n    return RouteTransition;\n  })();\n\n  function isPlainOjbect(val) {\n    return Object.prototype.toString.call(val) === '[object Object]';\n  }\n\n  function toArray(val) {\n    return val ? Array.prototype.slice.call(val) : [];\n  }\n\n  var internalKeysRE = /^(component|subRoutes|fullPath)$/;\n\n  /**\n   * Route Context Object\n   *\n   * @param {String} path\n   * @param {Router} router\n   */\n\n  var Route = function Route(path, router) {\n    var _this = this;\n\n    babelHelpers.classCallCheck(this, Route);\n\n    var matched = router._recognizer.recognize(path);\n    if (matched) {\n      // copy all custom fields from route configs\n      [].forEach.call(matched, function (match) {\n        for (var key in match.handler) {\n          if (!internalKeysRE.test(key)) {\n            _this[key] = match.handler[key];\n          }\n        }\n      });\n      // set query and params\n      this.query = matched.queryParams;\n      this.params = [].reduce.call(matched, function (prev, cur) {\n        if (cur.params) {\n          for (var key in cur.params) {\n            prev[key] = cur.params[key];\n          }\n        }\n        return prev;\n      }, {});\n    }\n    // expose path and router\n    this.path = path;\n    // for internal use\n    this.matched = matched || router._notFoundHandler;\n    // internal reference to router\n    Object.defineProperty(this, 'router', {\n      enumerable: false,\n      value: router\n    });\n    // Important: freeze self to prevent observation\n    Object.freeze(this);\n  };\n\n  function applyOverride (Vue) {\n    var _Vue$util = Vue.util;\n    var extend = _Vue$util.extend;\n    var isArray = _Vue$util.isArray;\n    var defineReactive = _Vue$util.defineReactive;\n\n    // override Vue's init and destroy process to keep track of router instances\n    var init = Vue.prototype._init;\n    Vue.prototype._init = function (options) {\n      options = options || {};\n      var root = options._parent || options.parent || this;\n      var router = root.$router;\n      var route = root.$route;\n      if (router) {\n        // expose router\n        this.$router = router;\n        router._children.push(this);\n        /* istanbul ignore if */\n        if (this._defineMeta) {\n          // 0.12\n          this._defineMeta('$route', route);\n        } else {\n          // 1.0\n          defineReactive(this, '$route', route);\n        }\n      }\n      init.call(this, options);\n    };\n\n    var destroy = Vue.prototype._destroy;\n    Vue.prototype._destroy = function () {\n      if (!this._isBeingDestroyed && this.$router) {\n        this.$router._children.$remove(this);\n      }\n      destroy.apply(this, arguments);\n    };\n\n    // 1.0 only: enable route mixins\n    var strats = Vue.config.optionMergeStrategies;\n    var hooksToMergeRE = /^(data|activate|deactivate)$/;\n\n    if (strats) {\n      strats.route = function (parentVal, childVal) {\n        if (!childVal) return parentVal;\n        if (!parentVal) return childVal;\n        var ret = {};\n        extend(ret, parentVal);\n        for (var key in childVal) {\n          var a = ret[key];\n          var b = childVal[key];\n          // for data, activate and deactivate, we need to merge them into\n          // arrays similar to lifecycle hooks.\n          if (a && hooksToMergeRE.test(key)) {\n            ret[key] = (isArray(a) ? a : [a]).concat(b);\n          } else {\n            ret[key] = b;\n          }\n        }\n        return ret;\n      };\n    }\n  }\n\n  function View (Vue) {\n\n    var _ = Vue.util;\n    var componentDef =\n    // 0.12\n    Vue.directive('_component') ||\n    // 1.0\n    Vue.internalDirectives.component;\n    // <router-view> extends the internal component directive\n    var viewDef = _.extend({}, componentDef);\n\n    // with some overrides\n    _.extend(viewDef, {\n\n      _isRouterView: true,\n\n      bind: function bind() {\n        var route = this.vm.$route;\n        /* istanbul ignore if */\n        if (!route) {\n          warn$1('<router-view> can only be used inside a ' + 'router-enabled app.');\n          return;\n        }\n        // force dynamic directive so v-component doesn't\n        // attempt to build right now\n        this._isDynamicLiteral = true;\n        // finally, init by delegating to v-component\n        componentDef.bind.call(this);\n\n        // locate the parent view\n        var parentView = undefined;\n        var parent = this.vm;\n        while (parent) {\n          if (parent._routerView) {\n            parentView = parent._routerView;\n            break;\n          }\n          parent = parent.$parent;\n        }\n        if (parentView) {\n          // register self as a child of the parent view,\n          // instead of activating now. This is so that the\n          // child's activate hook is called after the\n          // parent's has resolved.\n          this.parentView = parentView;\n          parentView.childView = this;\n        } else {\n          // this is the root view!\n          var router = route.router;\n          router._rootView = this;\n        }\n\n        // handle late-rendered view\n        // two possibilities:\n        // 1. root view rendered after transition has been\n        //    validated;\n        // 2. child view rendered after parent view has been\n        //    activated.\n        var transition = route.router._currentTransition;\n        if (!parentView && transition.done || parentView && parentView.activated) {\n          var depth = parentView ? parentView.depth + 1 : 0;\n          activate(this, transition, depth);\n        }\n      },\n\n      unbind: function unbind() {\n        if (this.parentView) {\n          this.parentView.childView = null;\n        }\n        componentDef.unbind.call(this);\n      }\n    });\n\n    Vue.elementDirective('router-view', viewDef);\n  }\n\n  var trailingSlashRE = /\\/$/;\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n  var queryStringRE = /\\?.*$/;\n\n  // install v-link, which provides navigation support for\n  // HTML5 history mode\n  function Link (Vue) {\n    var _Vue$util = Vue.util;\n    var _bind = _Vue$util.bind;\n    var isObject = _Vue$util.isObject;\n    var addClass = _Vue$util.addClass;\n    var removeClass = _Vue$util.removeClass;\n\n    var onPriority = Vue.directive('on').priority;\n    var LINK_UPDATE = '__vue-router-link-update__';\n\n    var activeId = 0;\n\n    Vue.directive('link-active', {\n      priority: 9999,\n      bind: function bind() {\n        var _this = this;\n\n        var id = String(activeId++);\n        // collect v-links contained within this element.\n        // we need do this here before the parent-child relationship\n        // gets messed up by terminal directives (if, for, components)\n        var childLinks = this.el.querySelectorAll('[v-link]');\n        for (var i = 0, l = childLinks.length; i < l; i++) {\n          var link = childLinks[i];\n          var existingId = link.getAttribute(LINK_UPDATE);\n          var value = existingId ? existingId + ',' + id : id;\n          // leave a mark on the link element which can be persisted\n          // through fragment clones.\n          link.setAttribute(LINK_UPDATE, value);\n        }\n        this.vm.$on(LINK_UPDATE, this.cb = function (link, path) {\n          if (link.activeIds.indexOf(id) > -1) {\n            link.updateClasses(path, _this.el);\n          }\n        });\n      },\n      unbind: function unbind() {\n        this.vm.$off(LINK_UPDATE, this.cb);\n      }\n    });\n\n    Vue.directive('link', {\n      priority: onPriority - 2,\n\n      bind: function bind() {\n        var vm = this.vm;\n        /* istanbul ignore if */\n        if (!vm.$route) {\n          warn$1('v-link can only be used inside a router-enabled app.');\n          return;\n        }\n        this.router = vm.$route.router;\n        // update things when the route changes\n        this.unwatch = vm.$watch('$route', _bind(this.onRouteUpdate, this));\n        // check v-link-active ids\n        var activeIds = this.el.getAttribute(LINK_UPDATE);\n        if (activeIds) {\n          this.el.removeAttribute(LINK_UPDATE);\n          this.activeIds = activeIds.split(',');\n        }\n        // no need to handle click if link expects to be opened\n        // in a new window/tab.\n        /* istanbul ignore if */\n        if (this.el.tagName === 'A' && this.el.getAttribute('target') === '_blank') {\n          return;\n        }\n        // handle click\n        this.handler = _bind(this.onClick, this);\n        this.el.addEventListener('click', this.handler);\n      },\n\n      update: function update(target) {\n        this.target = target;\n        if (isObject(target)) {\n          this.append = target.append;\n          this.exact = target.exact;\n          this.prevActiveClass = this.activeClass;\n          this.activeClass = target.activeClass;\n        }\n        this.onRouteUpdate(this.vm.$route);\n      },\n\n      onClick: function onClick(e) {\n        // don't redirect with control keys\n        /* istanbul ignore if */\n        if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n        // don't redirect when preventDefault called\n        /* istanbul ignore if */\n        if (e.defaultPrevented) return;\n        // don't redirect on right click\n        /* istanbul ignore if */\n        if (e.button !== 0) return;\n\n        var target = this.target;\n        if (target) {\n          // v-link with expression, just go\n          e.preventDefault();\n          this.router.go(target);\n        } else {\n          // no expression, delegate for an <a> inside\n          var el = e.target;\n          while (el.tagName !== 'A' && el !== this.el) {\n            el = el.parentNode;\n          }\n          if (el.tagName === 'A' && sameOrigin(el)) {\n            e.preventDefault();\n            var path = el.pathname;\n            if (this.router.history.root) {\n              path = path.replace(this.router.history.rootRE, '');\n            }\n            this.router.go({\n              path: path,\n              replace: target && target.replace,\n              append: target && target.append\n            });\n          }\n        }\n      },\n\n      onRouteUpdate: function onRouteUpdate(route) {\n        // router.stringifyPath is dependent on current route\n        // and needs to be called again whenver route changes.\n        var newPath = this.router.stringifyPath(this.target);\n        if (this.path !== newPath) {\n          this.path = newPath;\n          this.updateActiveMatch();\n          this.updateHref();\n        }\n        if (this.activeIds) {\n          this.vm.$emit(LINK_UPDATE, this, route.path);\n        } else {\n          this.updateClasses(route.path, this.el);\n        }\n      },\n\n      updateActiveMatch: function updateActiveMatch() {\n        this.activeRE = this.path && !this.exact ? new RegExp('^' + this.path.replace(/\\/$/, '').replace(queryStringRE, '').replace(regexEscapeRE, '\\\\$&') + '(\\\\/|$)') : null;\n      },\n\n      updateHref: function updateHref() {\n        if (this.el.tagName !== 'A') {\n          return;\n        }\n        var path = this.path;\n        var router = this.router;\n        var isAbsolute = path.charAt(0) === '/';\n        // do not format non-hash relative paths\n        var href = path && (router.mode === 'hash' || isAbsolute) ? router.history.formatPath(path, this.append) : path;\n        if (href) {\n          this.el.href = href;\n        } else {\n          this.el.removeAttribute('href');\n        }\n      },\n\n      updateClasses: function updateClasses(path, el) {\n        var activeClass = this.activeClass || this.router._linkActiveClass;\n        // clear old class\n        if (this.prevActiveClass && this.prevActiveClass !== activeClass) {\n          toggleClasses(el, this.prevActiveClass, removeClass);\n        }\n        // remove query string before matching\n        var dest = this.path.replace(queryStringRE, '');\n        path = path.replace(queryStringRE, '');\n        // add new class\n        if (this.exact) {\n          if (dest === path ||\n          // also allow additional trailing slash\n          dest.charAt(dest.length - 1) !== '/' && dest === path.replace(trailingSlashRE, '')) {\n            toggleClasses(el, activeClass, addClass);\n          } else {\n            toggleClasses(el, activeClass, removeClass);\n          }\n        } else {\n          if (this.activeRE && this.activeRE.test(path)) {\n            toggleClasses(el, activeClass, addClass);\n          } else {\n            toggleClasses(el, activeClass, removeClass);\n          }\n        }\n      },\n\n      unbind: function unbind() {\n        this.el.removeEventListener('click', this.handler);\n        this.unwatch && this.unwatch();\n      }\n    });\n\n    function sameOrigin(link) {\n      return link.protocol === location.protocol && link.hostname === location.hostname && link.port === location.port;\n    }\n\n    // this function is copied from v-bind:class implementation until\n    // we properly expose it...\n    function toggleClasses(el, key, fn) {\n      key = key.trim();\n      if (key.indexOf(' ') === -1) {\n        fn(el, key);\n        return;\n      }\n      var keys = key.split(/\\s+/);\n      for (var i = 0, l = keys.length; i < l; i++) {\n        fn(el, keys[i]);\n      }\n    }\n  }\n\n  var historyBackends = {\n    abstract: AbstractHistory,\n    hash: HashHistory,\n    html5: HTML5History\n  };\n\n  // late bind during install\n  var Vue = undefined;\n\n  /**\n   * Router constructor\n   *\n   * @param {Object} [options]\n   */\n\n  var Router = (function () {\n    function Router() {\n      var _this = this;\n\n      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var _ref$hashbang = _ref.hashbang;\n      var hashbang = _ref$hashbang === undefined ? true : _ref$hashbang;\n      var _ref$abstract = _ref.abstract;\n      var abstract = _ref$abstract === undefined ? false : _ref$abstract;\n      var _ref$history = _ref.history;\n      var history = _ref$history === undefined ? false : _ref$history;\n      var _ref$saveScrollPosition = _ref.saveScrollPosition;\n      var saveScrollPosition = _ref$saveScrollPosition === undefined ? false : _ref$saveScrollPosition;\n      var _ref$transitionOnLoad = _ref.transitionOnLoad;\n      var transitionOnLoad = _ref$transitionOnLoad === undefined ? false : _ref$transitionOnLoad;\n      var _ref$suppressTransitionError = _ref.suppressTransitionError;\n      var suppressTransitionError = _ref$suppressTransitionError === undefined ? false : _ref$suppressTransitionError;\n      var _ref$root = _ref.root;\n      var root = _ref$root === undefined ? null : _ref$root;\n      var _ref$linkActiveClass = _ref.linkActiveClass;\n      var linkActiveClass = _ref$linkActiveClass === undefined ? 'v-link-active' : _ref$linkActiveClass;\n      babelHelpers.classCallCheck(this, Router);\n\n      /* istanbul ignore if */\n      if (!Router.installed) {\n        throw new Error('Please install the Router with Vue.use() before ' + 'creating an instance.');\n      }\n\n      // Vue instances\n      this.app = null;\n      this._children = [];\n\n      // route recognizer\n      this._recognizer = new RouteRecognizer();\n      this._guardRecognizer = new RouteRecognizer();\n\n      // state\n      this._started = false;\n      this._startCb = null;\n      this._currentRoute = {};\n      this._currentTransition = null;\n      this._previousTransition = null;\n      this._notFoundHandler = null;\n      this._notFoundRedirect = null;\n      this._beforeEachHooks = [];\n      this._afterEachHooks = [];\n\n      // trigger transition on initial render?\n      this._rendered = false;\n      this._transitionOnLoad = transitionOnLoad;\n\n      // history mode\n      this._root = root;\n      this._abstract = abstract;\n      this._hashbang = hashbang;\n\n      // check if HTML5 history is available\n      var hasPushState = typeof window !== 'undefined' && window.history && window.history.pushState;\n      this._history = history && hasPushState;\n      this._historyFallback = history && !hasPushState;\n\n      // create history object\n      var inBrowser = Vue.util.inBrowser;\n      this.mode = !inBrowser || this._abstract ? 'abstract' : this._history ? 'html5' : 'hash';\n\n      var History = historyBackends[this.mode];\n      this.history = new History({\n        root: root,\n        hashbang: this._hashbang,\n        onChange: function onChange(path, state, anchor) {\n          _this._match(path, state, anchor);\n        }\n      });\n\n      // other options\n      this._saveScrollPosition = saveScrollPosition;\n      this._linkActiveClass = linkActiveClass;\n      this._suppress = suppressTransitionError;\n    }\n\n    /**\n     * Allow directly passing components to a route\n     * definition.\n     *\n     * @param {String} path\n     * @param {Object} handler\n     */\n\n    // API ===================================================\n\n    /**\n    * Register a map of top-level paths.\n    *\n    * @param {Object} map\n    */\n\n    Router.prototype.map = function map(_map) {\n      for (var route in _map) {\n        this.on(route, _map[route]);\n      }\n      return this;\n    };\n\n    /**\n     * Register a single root-level path\n     *\n     * @param {String} rootPath\n     * @param {Object} handler\n     *                 - {String} component\n     *                 - {Object} [subRoutes]\n     *                 - {Boolean} [forceRefresh]\n     *                 - {Function} [before]\n     *                 - {Function} [after]\n     */\n\n    Router.prototype.on = function on(rootPath, handler) {\n      if (rootPath === '*') {\n        this._notFound(handler);\n      } else {\n        this._addRoute(rootPath, handler, []);\n      }\n      return this;\n    };\n\n    /**\n     * Set redirects.\n     *\n     * @param {Object} map\n     */\n\n    Router.prototype.redirect = function redirect(map) {\n      for (var path in map) {\n        this._addRedirect(path, map[path]);\n      }\n      return this;\n    };\n\n    /**\n     * Set aliases.\n     *\n     * @param {Object} map\n     */\n\n    Router.prototype.alias = function alias(map) {\n      for (var path in map) {\n        this._addAlias(path, map[path]);\n      }\n      return this;\n    };\n\n    /**\n     * Set global before hook.\n     *\n     * @param {Function} fn\n     */\n\n    Router.prototype.beforeEach = function beforeEach(fn) {\n      this._beforeEachHooks.push(fn);\n      return this;\n    };\n\n    /**\n     * Set global after hook.\n     *\n     * @param {Function} fn\n     */\n\n    Router.prototype.afterEach = function afterEach(fn) {\n      this._afterEachHooks.push(fn);\n      return this;\n    };\n\n    /**\n     * Navigate to a given path.\n     * The path can be an object describing a named path in\n     * the format of { name: '...', params: {}, query: {}}\n     * The path is assumed to be already decoded, and will\n     * be resolved against root (if provided)\n     *\n     * @param {String|Object} path\n     * @param {Boolean} [replace]\n     */\n\n    Router.prototype.go = function go(path) {\n      var replace = false;\n      var append = false;\n      if (Vue.util.isObject(path)) {\n        replace = path.replace;\n        append = path.append;\n      }\n      path = this.stringifyPath(path);\n      if (path) {\n        this.history.go(path, replace, append);\n      }\n    };\n\n    /**\n     * Short hand for replacing current path\n     *\n     * @param {String} path\n     */\n\n    Router.prototype.replace = function replace(path) {\n      if (typeof path === 'string') {\n        path = { path: path };\n      }\n      path.replace = true;\n      this.go(path);\n    };\n\n    /**\n     * Start the router.\n     *\n     * @param {VueConstructor} App\n     * @param {String|Element} container\n     * @param {Function} [cb]\n     */\n\n    Router.prototype.start = function start(App, container, cb) {\n      /* istanbul ignore if */\n      if (this._started) {\n        warn$1('already started.');\n        return;\n      }\n      this._started = true;\n      this._startCb = cb;\n      if (!this.app) {\n        /* istanbul ignore if */\n        if (!App || !container) {\n          throw new Error('Must start vue-router with a component and a ' + 'root container.');\n        }\n        /* istanbul ignore if */\n        if (App instanceof Vue) {\n          throw new Error('Must start vue-router with a component, not a ' + 'Vue instance.');\n        }\n        this._appContainer = container;\n        var Ctor = this._appConstructor = typeof App === 'function' ? App : Vue.extend(App);\n        // give it a name for better debugging\n        Ctor.options.name = Ctor.options.name || 'RouterApp';\n      }\n\n      // handle history fallback in browsers that do not\n      // support HTML5 history API\n      if (this._historyFallback) {\n        var _location = window.location;\n        var _history = new HTML5History({ root: this._root });\n        var path = _history.root ? _location.pathname.replace(_history.rootRE, '') : _location.pathname;\n        if (path && path !== '/') {\n          _location.assign((_history.root || '') + '/' + this.history.formatPath(path) + _location.search);\n          return;\n        }\n      }\n\n      this.history.start();\n    };\n\n    /**\n     * Stop listening to route changes.\n     */\n\n    Router.prototype.stop = function stop() {\n      this.history.stop();\n      this._started = false;\n    };\n\n    /**\n     * Normalize named route object / string paths into\n     * a string.\n     *\n     * @param {Object|String|Number} path\n     * @return {String}\n     */\n\n    Router.prototype.stringifyPath = function stringifyPath(path) {\n      var generatedPath = '';\n      if (path && typeof path === 'object') {\n        if (path.name) {\n          var extend = Vue.util.extend;\n          var currentParams = this._currentTransition && this._currentTransition.to.params;\n          var targetParams = path.params || {};\n          var params = currentParams ? extend(extend({}, currentParams), targetParams) : targetParams;\n          generatedPath = encodeURI(this._recognizer.generate(path.name, params));\n        } else if (path.path) {\n          generatedPath = encodeURI(path.path);\n        }\n        if (path.query) {\n          // note: the generated query string is pre-URL-encoded by the recognizer\n          var query = this._recognizer.generateQueryString(path.query);\n          if (generatedPath.indexOf('?') > -1) {\n            generatedPath += '&' + query.slice(1);\n          } else {\n            generatedPath += query;\n          }\n        }\n      } else {\n        generatedPath = encodeURI(path ? path + '' : '');\n      }\n      return generatedPath;\n    };\n\n    // Internal methods ======================================\n\n    /**\n    * Add a route containing a list of segments to the internal\n    * route recognizer. Will be called recursively to add all\n    * possible sub-routes.\n    *\n    * @param {String} path\n    * @param {Object} handler\n    * @param {Array} segments\n    */\n\n    Router.prototype._addRoute = function _addRoute(path, handler, segments) {\n      guardComponent(path, handler);\n      handler.path = path;\n      handler.fullPath = (segments.reduce(function (path, segment) {\n        return path + segment.path;\n      }, '') + path).replace('//', '/');\n      segments.push({\n        path: path,\n        handler: handler\n      });\n      this._recognizer.add(segments, {\n        as: handler.name\n      });\n      // add sub routes\n      if (handler.subRoutes) {\n        for (var subPath in handler.subRoutes) {\n          // recursively walk all sub routes\n          this._addRoute(subPath, handler.subRoutes[subPath],\n          // pass a copy in recursion to avoid mutating\n          // across branches\n          segments.slice());\n        }\n      }\n    };\n\n    /**\n     * Set the notFound route handler.\n     *\n     * @param {Object} handler\n     */\n\n    Router.prototype._notFound = function _notFound(handler) {\n      guardComponent('*', handler);\n      this._notFoundHandler = [{ handler: handler }];\n    };\n\n    /**\n     * Add a redirect record.\n     *\n     * @param {String} path\n     * @param {String} redirectPath\n     */\n\n    Router.prototype._addRedirect = function _addRedirect(path, redirectPath) {\n      if (path === '*') {\n        this._notFoundRedirect = redirectPath;\n      } else {\n        this._addGuard(path, redirectPath, this.replace);\n      }\n    };\n\n    /**\n     * Add an alias record.\n     *\n     * @param {String} path\n     * @param {String} aliasPath\n     */\n\n    Router.prototype._addAlias = function _addAlias(path, aliasPath) {\n      this._addGuard(path, aliasPath, this._match);\n    };\n\n    /**\n     * Add a path guard.\n     *\n     * @param {String} path\n     * @param {String} mappedPath\n     * @param {Function} handler\n     */\n\n    Router.prototype._addGuard = function _addGuard(path, mappedPath, _handler) {\n      var _this2 = this;\n\n      this._guardRecognizer.add([{\n        path: path,\n        handler: function handler(match, query) {\n          var realPath = mapParams(mappedPath, match.params, query);\n          _handler.call(_this2, realPath);\n        }\n      }]);\n    };\n\n    /**\n     * Check if a path matches any redirect records.\n     *\n     * @param {String} path\n     * @return {Boolean} - if true, will skip normal match.\n     */\n\n    Router.prototype._checkGuard = function _checkGuard(path) {\n      var matched = this._guardRecognizer.recognize(path, true);\n      if (matched) {\n        matched[0].handler(matched[0], matched.queryParams);\n        return true;\n      } else if (this._notFoundRedirect) {\n        matched = this._recognizer.recognize(path);\n        if (!matched) {\n          this.replace(this._notFoundRedirect);\n          return true;\n        }\n      }\n    };\n\n    /**\n     * Match a URL path and set the route context on vm,\n     * triggering view updates.\n     *\n     * @param {String} path\n     * @param {Object} [state]\n     * @param {String} [anchor]\n     */\n\n    Router.prototype._match = function _match(path, state, anchor) {\n      var _this3 = this;\n\n      if (this._checkGuard(path)) {\n        return;\n      }\n\n      var currentRoute = this._currentRoute;\n      var currentTransition = this._currentTransition;\n\n      if (currentTransition) {\n        if (currentTransition.to.path === path) {\n          // do nothing if we have an active transition going to the same path\n          return;\n        } else if (currentRoute.path === path) {\n          // We are going to the same path, but we also have an ongoing but\n          // not-yet-validated transition. Abort that transition and reset to\n          // prev transition.\n          currentTransition.aborted = true;\n          this._currentTransition = this._prevTransition;\n          return;\n        } else {\n          // going to a totally different path. abort ongoing transition.\n          currentTransition.aborted = true;\n        }\n      }\n\n      // construct new route and transition context\n      var route = new Route(path, this);\n      var transition = new RouteTransition(this, route, currentRoute);\n\n      // current transition is updated right now.\n      // however, current route will only be updated after the transition has\n      // been validated.\n      this._prevTransition = currentTransition;\n      this._currentTransition = transition;\n\n      if (!this.app) {\n        (function () {\n          // initial render\n          var router = _this3;\n          _this3.app = new _this3._appConstructor({\n            el: _this3._appContainer,\n            created: function created() {\n              this.$router = router;\n            },\n            _meta: {\n              $route: route\n            }\n          });\n        })();\n      }\n\n      // check global before hook\n      var beforeHooks = this._beforeEachHooks;\n      var startTransition = function startTransition() {\n        transition.start(function () {\n          _this3._postTransition(route, state, anchor);\n        });\n      };\n\n      if (beforeHooks.length) {\n        transition.runQueue(beforeHooks, function (hook, _, next) {\n          if (transition === _this3._currentTransition) {\n            transition.callHook(hook, null, next, {\n              expectBoolean: true\n            });\n          }\n        }, startTransition);\n      } else {\n        startTransition();\n      }\n\n      if (!this._rendered && this._startCb) {\n        this._startCb.call(null);\n      }\n\n      // HACK:\n      // set rendered to true after the transition start, so\n      // that components that are acitvated synchronously know\n      // whether it is the initial render.\n      this._rendered = true;\n    };\n\n    /**\n     * Set current to the new transition.\n     * This is called by the transition object when the\n     * validation of a route has succeeded.\n     *\n     * @param {Transition} transition\n     */\n\n    Router.prototype._onTransitionValidated = function _onTransitionValidated(transition) {\n      // set current route\n      var route = this._currentRoute = transition.to;\n      // update route context for all children\n      if (this.app.$route !== route) {\n        this.app.$route = route;\n        this._children.forEach(function (child) {\n          child.$route = route;\n        });\n      }\n      // call global after hook\n      if (this._afterEachHooks.length) {\n        this._afterEachHooks.forEach(function (hook) {\n          return hook.call(null, {\n            to: transition.to,\n            from: transition.from\n          });\n        });\n      }\n      this._currentTransition.done = true;\n    };\n\n    /**\n     * Handle stuff after the transition.\n     *\n     * @param {Route} route\n     * @param {Object} [state]\n     * @param {String} [anchor]\n     */\n\n    Router.prototype._postTransition = function _postTransition(route, state, anchor) {\n      // handle scroll positions\n      // saved scroll positions take priority\n      // then we check if the path has an anchor\n      var pos = state && state.pos;\n      if (pos && this._saveScrollPosition) {\n        Vue.nextTick(function () {\n          window.scrollTo(pos.x, pos.y);\n        });\n      } else if (anchor) {\n        Vue.nextTick(function () {\n          var el = document.getElementById(anchor.slice(1));\n          if (el) {\n            window.scrollTo(window.scrollX, el.offsetTop);\n          }\n        });\n      }\n    };\n\n    return Router;\n  })();\n\n  function guardComponent(path, handler) {\n    var comp = handler.component;\n    if (Vue.util.isPlainObject(comp)) {\n      comp = handler.component = Vue.extend(comp);\n    }\n    /* istanbul ignore if */\n    if (typeof comp !== 'function') {\n      handler.component = null;\n      warn$1('invalid component for route \"' + path + '\".');\n    }\n  }\n\n  /* Installation */\n\n  Router.installed = false;\n\n  /**\n   * Installation interface.\n   * Install the necessary directives.\n   */\n\n  Router.install = function (externalVue) {\n    /* istanbul ignore if */\n    if (Router.installed) {\n      warn$1('already installed.');\n      return;\n    }\n    Vue = externalVue;\n    applyOverride(Vue);\n    View(Vue);\n    Link(Vue);\n    exports$1.Vue = Vue;\n    Router.installed = true;\n  };\n\n  // auto install\n  /* istanbul ignore if */\n  if (typeof window !== 'undefined' && window.Vue) {\n    window.Vue.use(Router);\n  }\n\n  return Router;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-router/0.7.13/vue-router/dist/vue-router.js\n ** module id = 41\n ** module chunks = 1\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Calendar.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/.npminstall/vue-style-loader/1.0.0/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Calendar.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Calendar.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-style-loader/1.0.0/vue-style-loader!./~/.npminstall/css-loader/0.23.1/css-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./~/.npminstall/less-loader/2.2.3/less-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./src/components/Calendar.vue\n ** module id = 42\n ** module chunks = 1\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Create.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/.npminstall/vue-style-loader/1.0.0/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Create.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Create.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-style-loader/1.0.0/vue-style-loader!./~/.npminstall/css-loader/0.23.1/css-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./~/.npminstall/less-loader/2.2.3/less-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./src/components/Create.vue\n ** module id = 43\n ** module chunks = 1\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Data.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/.npminstall/vue-style-loader/1.0.0/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Data.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Data.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-style-loader/1.0.0/vue-style-loader!./~/.npminstall/css-loader/0.23.1/css-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./~/.npminstall/less-loader/2.2.3/less-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./src/components/Data.vue\n ** module id = 44\n ** module chunks = 1\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Header.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/.npminstall/vue-style-loader/1.0.0/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Header.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Header.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-style-loader/1.0.0/vue-style-loader!./~/.npminstall/css-loader/0.23.1/css-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./~/.npminstall/less-loader/2.2.3/less-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./src/components/Header.vue\n ** module id = 45\n ** module chunks = 1\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Index.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/.npminstall/vue-style-loader/1.0.0/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Index.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Index.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-style-loader/1.0.0/vue-style-loader!./~/.npminstall/css-loader/0.23.1/css-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./~/.npminstall/less-loader/2.2.3/less-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./src/components/Index.vue\n ** module id = 46\n ** module chunks = 1\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Preview.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/.npminstall/vue-style-loader/1.0.0/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Preview.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Preview.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-style-loader/1.0.0/vue-style-loader!./~/.npminstall/css-loader/0.23.1/css-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./~/.npminstall/less-loader/2.2.3/less-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./src/components/Preview.vue\n ** module id = 47\n ** module chunks = 1\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./App.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../node_modules/.npminstall/vue-style-loader/1.0.0/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./App.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./App.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-style-loader/1.0.0/vue-style-loader!./~/.npminstall/css-loader/0.23.1/css-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./src/App.vue\n ** module id = 48\n ** module chunks = 1\n **/","/*!\n * Vuex v1.0.0-rc.2\n * (c) 2016 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Vuex = factory());\n}(this, function () { 'use strict';\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n  };\n\n  var classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n\n  var createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  var toConsumableArray = function (arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  };\n\n  /**\n   * Merge an array of objects into one.\n   *\n   * @param {Array<Object>} arr\n   * @return {Object}\n   */\n\n  function mergeObjects(arr) {\n    return arr.reduce(function (prev, obj) {\n      Object.keys(obj).forEach(function (key) {\n        var existing = prev[key];\n        if (existing) {\n          // allow multiple mutation objects to contain duplicate\n          // handlers for the same mutation type\n          if (Array.isArray(existing)) {\n            prev[key] = existing.concat(obj[key]);\n          } else {\n            prev[key] = [existing].concat(obj[key]);\n          }\n        } else {\n          prev[key] = obj[key];\n        }\n      });\n      return prev;\n    }, {});\n  }\n\n  /**\n   * Check whether the given value is Object or not\n   *\n   * @param {*} obj\n   * @return {Boolean}\n   */\n\n  function isObject(obj) {\n    return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';\n  }\n\n  /**\n   * Get state sub tree by given keys.\n   *\n   * @param {Object} state\n   * @param {Array<String>} nestedKeys\n   * @return {Object}\n   */\n  function getNestedState(state, nestedKeys) {\n    return nestedKeys.reduce(function (state, key) {\n      return state[key];\n    }, state);\n  }\n\n  /**\n   * Hacks to get access to Vue internals.\n   * Maybe we should expose these...\n   */\n\n  var Watcher = void 0;\n  function getWatcher(vm) {\n    if (!Watcher) {\n      var noop = function noop() {};\n      var unwatch = vm.$watch(noop, noop);\n      Watcher = vm._watchers[0].constructor;\n      unwatch();\n    }\n    return Watcher;\n  }\n\n  var Dep = void 0;\n  function getDep(vm) {\n    if (!Dep) {\n      Dep = vm._data.__ob__.dep.constructor;\n    }\n    return Dep;\n  }\n\n  var hook = typeof window !== 'undefined' && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n  function devtoolPlugin(store) {\n    if (!hook) return;\n\n    hook.emit('vuex:init', store);\n\n    hook.on('vuex:travel-to-state', function (targetState) {\n      store.replaceState(targetState);\n    });\n\n    store.subscribe(function (mutation, state) {\n      hook.emit('vuex:mutation', mutation, state);\n    });\n  }\n\n  function override (Vue) {\n    var version = Number(Vue.version.split('.')[0]);\n\n    if (version >= 2) {\n      var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1;\n      Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit });\n    } else {\n      (function () {\n        // override init and inject vuex init procedure\n        // for 1.x backwards compatibility.\n        var _init = Vue.prototype._init;\n        Vue.prototype._init = function () {\n          var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n          options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;\n          _init.call(this, options);\n        };\n      })();\n    }\n\n    /**\n     * Vuex init hook, injected into each instances init hooks list.\n     */\n\n    function vuexInit() {\n      var options = this.$options;\n      var store = options.store;\n      var vuex = options.vuex;\n      // store injection\n\n      if (store) {\n        this.$store = store;\n      } else if (options.parent && options.parent.$store) {\n        this.$store = options.parent.$store;\n      }\n      // vuex option handling\n      if (vuex) {\n        if (!this.$store) {\n          console.warn('[vuex] store not injected. make sure to ' + 'provide the store option in your root component.');\n        }\n        var state = vuex.state;\n        var actions = vuex.actions;\n        var getters = vuex.getters;\n        // handle deprecated state option\n\n        if (state && !getters) {\n          console.warn('[vuex] vuex.state option will been deprecated in 1.0. ' + 'Use vuex.getters instead.');\n          getters = state;\n        }\n        // getters\n        if (getters) {\n          options.computed = options.computed || {};\n          for (var key in getters) {\n            defineVuexGetter(this, key, getters[key]);\n          }\n        }\n        // actions\n        if (actions) {\n          options.methods = options.methods || {};\n          for (var _key in actions) {\n            options.methods[_key] = makeBoundAction(this.$store, actions[_key], _key);\n          }\n        }\n      }\n    }\n\n    /**\n     * Setter for all getter properties.\n     */\n\n    function setter() {\n      throw new Error('vuex getter properties are read-only.');\n    }\n\n    /**\n     * Define a Vuex getter on an instance.\n     *\n     * @param {Vue} vm\n     * @param {String} key\n     * @param {Function} getter\n     */\n\n    function defineVuexGetter(vm, key, getter) {\n      if (typeof getter !== 'function') {\n        console.warn('[vuex] Getter bound to key \\'vuex.getters.' + key + '\\' is not a function.');\n      } else {\n        Object.defineProperty(vm, key, {\n          enumerable: true,\n          configurable: true,\n          get: makeComputedGetter(vm.$store, getter),\n          set: setter\n        });\n      }\n    }\n\n    /**\n     * Make a computed getter, using the same caching mechanism of computed\n     * properties. In addition, it is cached on the raw getter function using\n     * the store's unique cache id. This makes the same getter shared\n     * across all components use the same underlying watcher, and makes\n     * the getter evaluated only once during every flush.\n     *\n     * @param {Store} store\n     * @param {Function} getter\n     */\n\n    function makeComputedGetter(store, getter) {\n      var id = store._getterCacheId;\n\n      // cached\n      if (getter[id]) {\n        return getter[id];\n      }\n      var vm = store._vm;\n      var Watcher = getWatcher(vm);\n      var Dep = getDep(vm);\n      var watcher = new Watcher(vm, function (vm) {\n        return getter(vm.state);\n      }, null, { lazy: true });\n      var computedGetter = function computedGetter() {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n        if (Dep.target) {\n          watcher.depend();\n        }\n        return watcher.value;\n      };\n      getter[id] = computedGetter;\n      return computedGetter;\n    }\n\n    /**\n     * Make a bound-to-store version of a raw action function.\n     *\n     * @param {Store} store\n     * @param {Function} action\n     * @param {String} key\n     */\n\n    function makeBoundAction(store, action, key) {\n      if (typeof action !== 'function') {\n        console.warn('[vuex] Action bound to key \\'vuex.actions.' + key + '\\' is not a function.');\n      }\n      return function vuexBoundAction() {\n        for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        return action.call.apply(action, [this, store].concat(args));\n      };\n    }\n\n    // option merging\n    var merge = Vue.config.optionMergeStrategies.computed;\n    Vue.config.optionMergeStrategies.vuex = function (toVal, fromVal) {\n      if (!toVal) return fromVal;\n      if (!fromVal) return toVal;\n      return {\n        getters: merge(toVal.getters, fromVal.getters),\n        state: merge(toVal.state, fromVal.state),\n        actions: merge(toVal.actions, fromVal.actions)\n      };\n    };\n  }\n\n  var Vue = void 0;\n  var uid = 0;\n\n  var Store = function () {\n\n    /**\n     * @param {Object} options\n     *        - {Object} state\n     *        - {Object} actions\n     *        - {Object} mutations\n     *        - {Array} plugins\n     *        - {Boolean} strict\n     */\n\n    function Store() {\n      var _this = this;\n\n      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var _ref$state = _ref.state;\n      var state = _ref$state === undefined ? {} : _ref$state;\n      var _ref$mutations = _ref.mutations;\n      var mutations = _ref$mutations === undefined ? {} : _ref$mutations;\n      var _ref$modules = _ref.modules;\n      var modules = _ref$modules === undefined ? {} : _ref$modules;\n      var _ref$plugins = _ref.plugins;\n      var plugins = _ref$plugins === undefined ? [] : _ref$plugins;\n      var _ref$strict = _ref.strict;\n      var strict = _ref$strict === undefined ? false : _ref$strict;\n      classCallCheck(this, Store);\n\n      this._getterCacheId = 'vuex_store_' + uid++;\n      this._dispatching = false;\n      this._rootMutations = this._mutations = mutations;\n      this._modules = modules;\n      this._subscribers = [];\n      // bind dispatch to self\n      var dispatch = this.dispatch;\n      this.dispatch = function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        dispatch.apply(_this, args);\n      };\n      // use a Vue instance to store the state tree\n      // suppress warnings just in case the user has added\n      // some funky global mixins\n      if (!Vue) {\n        throw new Error('[vuex] must call Vue.use(Vuex) before creating a store instance.');\n      }\n      var silent = Vue.config.silent;\n      Vue.config.silent = true;\n      this._vm = new Vue({\n        data: {\n          state: state\n        }\n      });\n      Vue.config.silent = silent;\n      this._setupModuleState(state, modules);\n      this._setupModuleMutations(modules);\n      // add extra warnings in strict mode\n      if (strict) {\n        this._setupMutationCheck();\n      }\n      // apply plugins\n      devtoolPlugin(this);\n      plugins.forEach(function (plugin) {\n        return plugin(_this);\n      });\n    }\n\n    /**\n     * Getter for the entire state tree.\n     * Read only.\n     *\n     * @return {Object}\n     */\n\n    createClass(Store, [{\n      key: 'replaceState',\n\n\n      /**\n       * Replace root state.\n       *\n       * @param {Object} state\n       */\n\n      value: function replaceState(state) {\n        this._dispatching = true;\n        this._vm.state = state;\n        this._dispatching = false;\n      }\n\n      /**\n       * Dispatch an action.\n       *\n       * @param {String} type\n       */\n\n    }, {\n      key: 'dispatch',\n      value: function dispatch(type) {\n        var _this2 = this;\n\n        for (var _len2 = arguments.length, payload = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          payload[_key2 - 1] = arguments[_key2];\n        }\n\n        var silent = false;\n        var isObjectStyleDispatch = false;\n        // compatibility for object actions, e.g. FSA\n        if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type.type && arguments.length === 1) {\n          isObjectStyleDispatch = true;\n          payload = type;\n          if (type.silent) silent = true;\n          type = type.type;\n        }\n        var handler = this._mutations[type];\n        var state = this.state;\n        if (handler) {\n          this._dispatching = true;\n          // apply the mutation\n          if (Array.isArray(handler)) {\n            handler.forEach(function (h) {\n              isObjectStyleDispatch ? h(state, payload) : h.apply(undefined, [state].concat(toConsumableArray(payload)));\n            });\n          } else {\n            isObjectStyleDispatch ? handler(state, payload) : handler.apply(undefined, [state].concat(toConsumableArray(payload)));\n          }\n          this._dispatching = false;\n          if (!silent) {\n            (function () {\n              var mutation = isObjectStyleDispatch ? payload : { type: type, payload: payload };\n              _this2._subscribers.forEach(function (sub) {\n                return sub(mutation, state);\n              });\n            })();\n          }\n        } else {\n          console.warn('[vuex] Unknown mutation: ' + type);\n        }\n      }\n\n      /**\n       * Watch state changes on the store.\n       * Same API as Vue's $watch, except when watching a function,\n       * the function gets the state as the first argument.\n       *\n       * @param {Function} fn\n       * @param {Function} cb\n       * @param {Object} [options]\n       */\n\n    }, {\n      key: 'watch',\n      value: function watch(fn, cb, options) {\n        var _this3 = this;\n\n        if (typeof fn !== 'function') {\n          console.error('Vuex store.watch only accepts function.');\n          return;\n        }\n        return this._vm.$watch(function () {\n          return fn(_this3.state);\n        }, cb, options);\n      }\n\n      /**\n       * Subscribe to state changes. Fires after every mutation.\n       */\n\n    }, {\n      key: 'subscribe',\n      value: function subscribe(fn) {\n        var subs = this._subscribers;\n        if (subs.indexOf(fn) < 0) {\n          subs.push(fn);\n        }\n        return function () {\n          var i = subs.indexOf(fn);\n          if (i > -1) {\n            subs.splice(i, 1);\n          }\n        };\n      }\n\n      /**\n       * Hot update mutations & modules.\n       *\n       * @param {Object} options\n       *        - {Object} [mutations]\n       *        - {Object} [modules]\n       */\n\n    }, {\n      key: 'hotUpdate',\n      value: function hotUpdate() {\n        var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n        var mutations = _ref2.mutations;\n        var modules = _ref2.modules;\n\n        this._rootMutations = this._mutations = mutations || this._rootMutations;\n        this._setupModuleMutations(modules || this._modules);\n      }\n\n      /**\n       * Attach sub state tree of each module to the root tree.\n       *\n       * @param {Object} state\n       * @param {Object} modules\n       */\n\n    }, {\n      key: '_setupModuleState',\n      value: function _setupModuleState(state, modules) {\n        var _this4 = this;\n\n        if (!isObject(modules)) return;\n\n        Object.keys(modules).forEach(function (key) {\n          var module = modules[key];\n\n          // set this module's state\n          Vue.set(state, key, module.state || {});\n\n          // retrieve nested modules\n          _this4._setupModuleState(state[key], module.modules);\n        });\n      }\n\n      /**\n       * Bind mutations for each module to its sub tree and\n       * merge them all into one final mutations map.\n       *\n       * @param {Object} updatedModules\n       */\n\n    }, {\n      key: '_setupModuleMutations',\n      value: function _setupModuleMutations(updatedModules) {\n        var modules = this._modules;\n        Object.keys(updatedModules).forEach(function (key) {\n          modules[key] = updatedModules[key];\n        });\n        var updatedMutations = this._createModuleMutations(modules, []);\n        this._mutations = mergeObjects([this._rootMutations].concat(toConsumableArray(updatedMutations)));\n      }\n\n      /**\n       * Helper method for _setupModuleMutations.\n       * The method retrieve nested sub modules and\n       * bind each mutations to its sub tree recursively.\n       *\n       * @param {Object} modules\n       * @param {Array<String>} nestedKeys\n       * @return {Array<Object>}\n       */\n\n    }, {\n      key: '_createModuleMutations',\n      value: function _createModuleMutations(modules, nestedKeys) {\n        var _this5 = this;\n\n        if (!isObject(modules)) return [];\n\n        return Object.keys(modules).map(function (key) {\n          var module = modules[key];\n          var newNestedKeys = nestedKeys.concat(key);\n\n          // retrieve nested modules\n          var nestedMutations = _this5._createModuleMutations(module.modules, newNestedKeys);\n\n          if (!module || !module.mutations) {\n            return mergeObjects(nestedMutations);\n          }\n\n          // bind mutations to sub state tree\n          var mutations = {};\n          Object.keys(module.mutations).forEach(function (name) {\n            var original = module.mutations[name];\n            mutations[name] = function (state) {\n              for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n                args[_key3 - 1] = arguments[_key3];\n              }\n\n              original.apply(undefined, [getNestedState(state, newNestedKeys)].concat(args));\n            };\n          });\n\n          // merge mutations of this module and nested modules\n          return mergeObjects([mutations].concat(toConsumableArray(nestedMutations)));\n        });\n      }\n\n      /**\n       * Setup mutation check: if the vuex instance's state is mutated\n       * outside of a mutation handler, we throw en error. This effectively\n       * enforces all mutations to the state to be trackable and hot-reloadble.\n       * However, this comes at a run time cost since we are doing a deep\n       * watch on the entire state tree, so it is only enalbed with the\n       * strict option is set to true.\n       */\n\n    }, {\n      key: '_setupMutationCheck',\n      value: function _setupMutationCheck() {\n        var _this6 = this;\n\n        var Watcher = getWatcher(this._vm);\n        /* eslint-disable no-new */\n        new Watcher(this._vm, 'state', function () {\n          if (!_this6._dispatching) {\n            throw new Error('[vuex] Do not mutate vuex store state outside mutation handlers.');\n          }\n        }, { deep: true, sync: true });\n        /* eslint-enable no-new */\n      }\n    }, {\n      key: 'state',\n      get: function get() {\n        return this._vm.state;\n      },\n      set: function set(v) {\n        throw new Error('[vuex] Use store.replaceState() to explicit replace store state.');\n      }\n    }]);\n    return Store;\n  }();\n\n  function install(_Vue) {\n    if (Vue) {\n      console.warn('[vuex] already installed. Vue.use(Vuex) should be called only once.');\n      return;\n    }\n    Vue = _Vue;\n    override(Vue);\n  }\n\n  // auto install in dist mode\n  if (typeof window !== 'undefined' && window.Vue) {\n    install(window.Vue);\n  }\n\n  var index = {\n    Store: Store,\n    install: install\n  };\n\n  return index;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vuex/1.0.0-rc.2/vuex/dist/vuex.js\n ** module id = 49\n ** module chunks = 1\n **/","(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.echarts = factory();\n    }\n}(this, function () {var require, define;\n(function () {\n    var mods = {};\n\n    define = function (id, deps, factory) {\n        mods[id] = {\n            id: id,\n            deps: deps,\n            factory: factory,\n            defined: 0,\n            exports: {},\n            require: createRequire(id)\n        };\n    };\n\n    require = createRequire('');\n\n    function normalize(id, baseId) {\n        if (!baseId) {\n            return id;\n        }\n\n        if (id.indexOf('.') === 0) {\n            var basePath = baseId.split('/');\n            var namePath = id.split('/');\n            var baseLen = basePath.length - 1;\n            var nameLen = namePath.length;\n            var cutBaseTerms = 0;\n            var cutNameTerms = 0;\n\n            pathLoop: for (var i = 0; i < nameLen; i++) {\n                switch (namePath[i]) {\n                    case '..':\n                        if (cutBaseTerms < baseLen) {\n                            cutBaseTerms++;\n                            cutNameTerms++;\n                        }\n                        else {\n                            break pathLoop;\n                        }\n                        break;\n                    case '.':\n                        cutNameTerms++;\n                        break;\n                    default:\n                        break pathLoop;\n                }\n            }\n\n            basePath.length = baseLen - cutBaseTerms;\n            namePath = namePath.slice(cutNameTerms);\n\n            return basePath.concat(namePath).join('/');\n        }\n\n        return id;\n    }\n\n    function createRequire(baseId) {\n        var cacheMods = {};\n\n        function localRequire(id, callback) {\n            if (typeof id === 'string') {\n                var exports = cacheMods[id];\n                if (!exports) {\n                    exports = getModExports(normalize(id, baseId));\n                    cacheMods[id] = exports;\n                }\n\n                return exports;\n            }\n            else if (id instanceof Array) {\n                callback = callback || function () {};\n                callback.apply(this, getModsExports(id, callback, baseId));\n            }\n        };\n\n        return localRequire;\n    }\n\n    function getModsExports(ids, factory, baseId) {\n        var es = [];\n        var mod = mods[baseId];\n\n        for (var i = 0, l = Math.min(ids.length, factory.length); i < l; i++) {\n            var id = normalize(ids[i], baseId);\n            var arg;\n            switch (id) {\n                case 'require':\n                    arg = (mod && mod.require) || require;\n                    break;\n                case 'exports':\n                    arg = mod.exports;\n                    break;\n                case 'module':\n                    arg = mod;\n                    break;\n                default:\n                    arg = getModExports(id);\n            }\n            es.push(arg);\n        }\n\n        return es;\n    }\n\n    function getModExports(id) {\n        var mod = mods[id];\n        if (!mod) {\n            throw new Error('No ' + id);\n        }\n\n        if (!mod.defined) {\n            var factory = mod.factory;\n            var factoryReturn = factory.apply(\n                this,\n                getModsExports(mod.deps || [], factory, id)\n            );\n            if (typeof factoryReturn !== 'undefined') {\n                mod.exports = factoryReturn;\n            }\n            mod.defined = 1;\n        }\n\n        return mod.exports;\n    }\n}());\ndefine('echarts/chart/pie', ['require', 'zrender/core/util', '../echarts', './pie/PieSeries', './pie/PieView', '../action/createDataSelectAction', '../visual/dataColor', './pie/pieLayout', '../processor/dataFilter'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var echarts = require('../echarts');\n    require('./pie/PieSeries');\n    require('./pie/PieView');\n    require('../action/createDataSelectAction')('pie', [\n        {\n            type: 'pieToggleSelect',\n            event: 'pieselectchanged',\n            method: 'toggleSelected'\n        },\n        {\n            type: 'pieSelect',\n            event: 'pieselected',\n            method: 'select'\n        },\n        {\n            type: 'pieUnSelect',\n            event: 'pieunselected',\n            method: 'unSelect'\n        }\n    ]);\n    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'pie'));\n    echarts.registerLayout(zrUtil.curry(require('./pie/pieLayout'), 'pie'));\n    echarts.registerProcessor(zrUtil.curry(require('../processor/dataFilter'), 'pie'));\n});\ndefine('echarts/chart/bar', ['require', 'zrender/core/util', '../coord/cartesian/Grid', './bar/BarSeries', './bar/BarView', '../layout/barGrid', '../echarts', '../component/grid'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    require('../coord/cartesian/Grid');\n    require('./bar/BarSeries');\n    require('./bar/BarView');\n    var barLayoutGrid = require('../layout/barGrid');\n    var echarts = require('../echarts');\n    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n    // Visual coding for legend\n    echarts.registerVisual(function (ecModel) {\n        ecModel.eachSeriesByType('bar', function (seriesModel) {\n            var data = seriesModel.getData();\n            data.setVisual('legendSymbol', 'roundRect');\n        });\n    });\n    // In case developer forget to include grid component\n    require('../component/grid');\n});\ndefine('echarts/component/title', ['require', '../echarts', '../util/graphic', '../util/layout'], function (require) {\n    'use strict';\n    var echarts = require('../echarts');\n    var graphic = require('../util/graphic');\n    var layout = require('../util/layout');\n    // Model\n    echarts.extendComponentModel({\n        type: 'title',\n        layoutMode: {\n            type: 'box',\n            ignoreSize: true\n        },\n        defaultOption: {\n            zlevel: 0,\n            z: 6,\n            show: true,\n            text: '',\n            target: 'blank',\n            subtext: '',\n            subtarget: 'blank',\n            left: 0,\n            top: 0,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderColor: '#ccc',\n            borderWidth: 0,\n            padding: 5,\n            itemGap: 10,\n            textStyle: {\n                fontSize: 18,\n                fontWeight: 'bolder',\n                color: '#333'\n            },\n            subtextStyle: { color: '#aaa' }\n        }\n    });\n    // View\n    echarts.extendComponentView({\n        type: 'title',\n        render: function (titleModel, ecModel, api) {\n            this.group.removeAll();\n            if (!titleModel.get('show')) {\n                return;\n            }\n            var group = this.group;\n            var textStyleModel = titleModel.getModel('textStyle');\n            var subtextStyleModel = titleModel.getModel('subtextStyle');\n            var textAlign = titleModel.get('textAlign');\n            var textBaseline = titleModel.get('textBaseline');\n            var textEl = new graphic.Text({\n                    style: {\n                        text: titleModel.get('text'),\n                        textFont: textStyleModel.getFont(),\n                        fill: textStyleModel.getTextColor()\n                    },\n                    z2: 10\n                });\n            var textRect = textEl.getBoundingRect();\n            var subText = titleModel.get('subtext');\n            var subTextEl = new graphic.Text({\n                    style: {\n                        text: subText,\n                        textFont: subtextStyleModel.getFont(),\n                        fill: subtextStyleModel.getTextColor(),\n                        y: textRect.height + titleModel.get('itemGap'),\n                        textBaseline: 'top'\n                    },\n                    z2: 10\n                });\n            var link = titleModel.get('link');\n            var sublink = titleModel.get('sublink');\n            textEl.silent = !link;\n            subTextEl.silent = !sublink;\n            if (link) {\n                textEl.on('click', function () {\n                    window.open(link, '_' + titleModel.get('target'));\n                });\n            }\n            if (sublink) {\n                subTextEl.on('click', function () {\n                    window.open(sublink, '_' + titleModel.get('subtarget'));\n                });\n            }\n            group.add(textEl);\n            subText && group.add(subTextEl);\n            // If no subText, but add subTextEl, there will be an empty line.\n            var groupRect = group.getBoundingRect();\n            var layoutOption = titleModel.getBoxLayoutParams();\n            layoutOption.width = groupRect.width;\n            layoutOption.height = groupRect.height;\n            var layoutRect = layout.getLayoutRect(layoutOption, {\n                    width: api.getWidth(),\n                    height: api.getHeight()\n                }, titleModel.get('padding'));\n            // Adjust text align based on position\n            if (!textAlign) {\n                // Align left if title is on the left. center and right is same\n                textAlign = titleModel.get('left') || titleModel.get('right');\n                if (textAlign === 'middle') {\n                    textAlign = 'center';\n                }\n                // Adjust layout by text align\n                if (textAlign === 'right') {\n                    layoutRect.x += layoutRect.width;\n                } else if (textAlign === 'center') {\n                    layoutRect.x += layoutRect.width / 2;\n                }\n            }\n            if (!textBaseline) {\n                textBaseline = titleModel.get('top') || titleModel.get('bottom');\n                if (textBaseline === 'center') {\n                    textBaseline = 'middle';\n                }\n                if (textBaseline === 'bottom') {\n                    layoutRect.y += layoutRect.height;\n                } else if (textBaseline === 'middle') {\n                    layoutRect.y += layoutRect.height / 2;\n                }\n                textBaseline = textBaseline || 'top';\n            }\n            group.attr('position', [\n                layoutRect.x,\n                layoutRect.y\n            ]);\n            var alignStyle = {\n                    textAlign: textAlign,\n                    textVerticalAlign: textBaseline\n                };\n            textEl.setStyle(alignStyle);\n            subTextEl.setStyle(alignStyle);\n            // Render background\n            // Get groupRect again because textAlign has been changed\n            groupRect = group.getBoundingRect();\n            var padding = layoutRect.margin;\n            var style = titleModel.getItemStyle([\n                    'color',\n                    'opacity'\n                ]);\n            style.fill = titleModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                    shape: {\n                        x: groupRect.x - padding[3],\n                        y: groupRect.y - padding[0],\n                        width: groupRect.width + padding[1] + padding[3],\n                        height: groupRect.height + padding[0] + padding[2]\n                    },\n                    style: style,\n                    silent: true\n                });\n            graphic.subPixelOptimizeRect(rect);\n            group.add(rect);\n        }\n    });\n});\ndefine('echarts/component/grid', ['require', '../util/graphic', 'zrender/core/util', '../echarts', '../coord/cartesian/Grid', './axis'], function (require) {\n    'use strict';\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/core/util');\n    var echarts = require('../echarts');\n    require('../coord/cartesian/Grid');\n    require('./axis');\n    // Grid view\n    echarts.extendComponentView({\n        type: 'grid',\n        render: function (gridModel, ecModel) {\n            this.group.removeAll();\n            if (gridModel.get('show')) {\n                this.group.add(new graphic.Rect({\n                    shape: gridModel.coordinateSystem.getRect(),\n                    style: zrUtil.defaults({ fill: gridModel.get('backgroundColor') }, gridModel.getItemStyle()),\n                    silent: true\n                }));\n            }\n        }\n    });\n    echarts.registerPreprocessor(function (option) {\n        // Only create grid when need\n        if (option.xAxis && option.yAxis && !option.grid) {\n            option.grid = {};\n        }\n    });\n});\ndefine('echarts/scale/Time', ['require', 'zrender/core/util', '../util/number', '../util/format', './Interval'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var IntervalScale = require('./Interval');\n    var intervalScaleProto = IntervalScale.prototype;\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n    // FIXME 公用？\n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n        return lo;\n    };\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n            type: 'time',\n            getLabel: function (val) {\n                var stepLvl = this._stepLvl;\n                var date = new Date(val);\n                return formatUtil.formatTime(stepLvl[0], date);\n            },\n            niceExtent: function (approxTickNum, fixMin, fixMax) {\n                var extent = this._extent;\n                // If extent start and end are same, expand them\n                if (extent[0] === extent[1]) {\n                    // Expand extent\n                    extent[0] -= ONE_DAY;\n                    extent[1] += ONE_DAY;\n                }\n                // If there are no data and extent are [Infinity, -Infinity]\n                if (extent[1] === -Infinity && extent[0] === Infinity) {\n                    var d = new Date();\n                    extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                    extent[0] = extent[1] - ONE_DAY;\n                }\n                this.niceTicks(approxTickNum);\n                // var extent = this._extent;\n                var interval = this._interval;\n                if (!fixMin) {\n                    extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n                }\n                if (!fixMax) {\n                    extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n                }\n            },\n            niceTicks: function (approxTickNum) {\n                approxTickNum = approxTickNum || 10;\n                var extent = this._extent;\n                var span = extent[1] - extent[0];\n                var approxInterval = span / approxTickNum;\n                var scaleLevelsLen = scaleLevels.length;\n                var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n                var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n                var interval = level[2];\n                // Same with interval scale if span is much larger than 1 year\n                if (level[0] === 'year') {\n                    var yearSpan = span / interval;\n                    // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                    // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                    var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n                    interval *= yearStep;\n                }\n                var niceExtent = [\n                        mathCeil(extent[0] / interval) * interval,\n                        mathFloor(extent[1] / interval) * interval\n                    ];\n                this._stepLvl = level;\n                // Interval will be used in getTicks\n                this._interval = interval;\n                this._niceExtent = niceExtent;\n            },\n            parse: function (val) {\n                // val might be float.\n                return +numberUtil.parseDate(val);\n            }\n        });\n    zrUtil.each([\n        'contain',\n        'normalize'\n    ], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n    // Steps from d3\n    var scaleLevels = [\n            [\n                'hh:mm:ss',\n                1,\n                ONE_SECOND\n            ],\n            [\n                'hh:mm:ss',\n                5,\n                ONE_SECOND * 5\n            ],\n            [\n                'hh:mm:ss',\n                10,\n                ONE_SECOND * 10\n            ],\n            [\n                'hh:mm:ss',\n                15,\n                ONE_SECOND * 15\n            ],\n            [\n                'hh:mm:ss',\n                30,\n                ONE_SECOND * 30\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                1,\n                ONE_MINUTE\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                5,\n                ONE_MINUTE * 5\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                10,\n                ONE_MINUTE * 10\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                15,\n                ONE_MINUTE * 15\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                30,\n                ONE_MINUTE * 30\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                1,\n                ONE_HOUR\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                2,\n                ONE_HOUR * 2\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                6,\n                ONE_HOUR * 6\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                12,\n                ONE_HOUR * 12\n            ],\n            [\n                'MM-dd\\nyyyy',\n                1,\n                ONE_DAY\n            ],\n            [\n                'week',\n                7,\n                ONE_DAY * 7\n            ],\n            [\n                'month',\n                1,\n                ONE_DAY * 31\n            ],\n            [\n                'quarter',\n                3,\n                ONE_DAY * 380 / 4\n            ],\n            [\n                'half-year',\n                6,\n                ONE_DAY * 380 / 2\n            ],\n            [\n                'year',\n                1,\n                ONE_DAY * 380\n            ]\n        ];\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function () {\n        return new TimeScale();\n    };\n    return TimeScale;\n});\ndefine('echarts/echarts', ['require', 'zrender/core/env', './model/Global', './ExtensionAPI', './CoordinateSystem', './model/OptionManager', './model/Component', './model/Series', './view/Component', './view/Chart', './util/graphic', 'zrender', 'zrender/core/util', 'zrender/tool/color', 'zrender/mixin/Eventful', 'zrender/core/timsort', './visual/seriesColor', './preprocessor/backwardCompat', './loading/default', './data/List', './model/Model', './util/number', './util/format', 'zrender/core/matrix', 'zrender/core/vector'], function (require) {\n    var env = require('zrender/core/env');\n    var GlobalModel = require('./model/Global');\n    var ExtensionAPI = require('./ExtensionAPI');\n    var CoordinateSystemManager = require('./CoordinateSystem');\n    var OptionManager = require('./model/OptionManager');\n    var ComponentModel = require('./model/Component');\n    var SeriesModel = require('./model/Series');\n    var ComponentView = require('./view/Component');\n    var ChartView = require('./view/Chart');\n    var graphic = require('./util/graphic');\n    var zrender = require('zrender');\n    var zrUtil = require('zrender/core/util');\n    var colorTool = require('zrender/tool/color');\n    var Eventful = require('zrender/mixin/Eventful');\n    var timsort = require('zrender/core/timsort');\n    var each = zrUtil.each;\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    var PRIORITY_VISUAL_BRUSH = 5000;\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flag_in_main_process';\n    var HAS_GRADIENT_OR_PATTERN_BG = '_hasGradientOrPatternBg';\n    var OPTION_UPDATED = '_optionUpdated';\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts(dom, theme, opts) {\n        opts = opts || {};\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLDomElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio\n        });\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = zrUtil.clone(theme);\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = new ExtensionAPI(this);\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n        Eventful.call(this);\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n        // Init mouse events\n        this._initEvents();\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n        this._zr.animation.on('frame', this._onframe, this);\n    }\n    var echartsProto = ECharts.prototype;\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n            this[IN_MAIN_PROCESS] = true;\n            updateMethods.prepareAndUpdate.call(this);\n            this[IN_MAIN_PROCESS] = false;\n            this[OPTION_UPDATED] = false;\n        }\n    };\n    /**\n     * @return {HTMLDomElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n    /**\n     * @param {Object} option\n     * @param {boolean} notMerge\n     * @param {boolean} [lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (true) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n        this[IN_MAIN_PROCESS] = true;\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n        this._model.setOption(option, optionPreprocessorFuncs);\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = true;\n        } else {\n            updateMethods.prepareAndUpdate.call(this);\n            this._zr.refreshImmediately();\n            this[OPTION_UPDATED] = false;\n        }\n        this[IN_MAIN_PROCESS] = false;\n        this._flushPendingActions();\n    };\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({ mainType: componentType }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n        var url = this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = opts && opts.pixelRatio || 1;\n            for (var id in instances) {\n                var chart = instances[id];\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(zrUtil.clone(opts));\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            }\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                        style: {\n                            x: item.left * dpr - left,\n                            y: item.top * dpr - top,\n                            image: item.dom\n                        }\n                    });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        } else {\n            return this.getDataURL(opts);\n        }\n    };\n    var updateMethods = {\n            update: function (payload) {\n                // console.time && console.time('update');\n                var ecModel = this._model;\n                var api = this._api;\n                var coordSysMgr = this._coordSysMgr;\n                var zr = this._zr;\n                // update before setOption\n                if (!ecModel) {\n                    return;\n                }\n                // Fixme First time update ?\n                ecModel.restoreData();\n                // TODO\n                // Save total ecModel here for undo/redo (after restoring data and before processing data).\n                // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n                // Create new coordinate system each update\n                // In LineView may save the old coordinate system and use it to get the orignal point\n                coordSysMgr.create(this._model, this._api);\n                processData.call(this, ecModel, api);\n                stackSeriesData.call(this, ecModel);\n                coordSysMgr.update(ecModel, api);\n                doVisualEncoding.call(this, ecModel, payload);\n                doRender.call(this, ecModel, payload);\n                // Set background\n                var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n                var painter = zr.painter;\n                // TODO all use clearColor ?\n                if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                    zr.configLayer(0, { clearColor: backgroundColor });\n                } else {\n                    // In IE8\n                    if (!env.canvasSupported) {\n                        var colorArr = colorTool.parse(backgroundColor);\n                        backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                        if (colorArr[3] === 0) {\n                            backgroundColor = 'transparent';\n                        }\n                    }\n                    if (backgroundColor.colorStops || backgroundColor.image) {\n                        // Gradient background\n                        // FIXME Fixed layer？\n                        zr.configLayer(0, { clearColor: backgroundColor });\n                        this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n                        this._dom.style.background = 'transparent';\n                    } else {\n                        if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                            zr.configLayer(0, { clearColor: null });\n                        }\n                        this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n                        this._dom.style.background = backgroundColor;\n                    }\n                }    // console.time && console.timeEnd('update');\n            },\n            updateView: function (payload) {\n                var ecModel = this._model;\n                // update before setOption\n                if (!ecModel) {\n                    return;\n                }\n                ecModel.eachSeries(function (seriesModel) {\n                    seriesModel.getData().clearAllVisual();\n                });\n                doVisualEncoding.call(this, ecModel, payload);\n                invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n            },\n            updateVisual: function (payload) {\n                var ecModel = this._model;\n                // update before setOption\n                if (!ecModel) {\n                    return;\n                }\n                ecModel.eachSeries(function (seriesModel) {\n                    seriesModel.getData().clearAllVisual();\n                });\n                doVisualEncoding.call(this, ecModel, payload);\n                invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n            },\n            updateLayout: function (payload) {\n                var ecModel = this._model;\n                // update before setOption\n                if (!ecModel) {\n                    return;\n                }\n                doLayout.call(this, ecModel, payload);\n                invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n            },\n            highlight: function (payload) {\n                toggleHighlight.call(this, 'highlight', payload);\n            },\n            downplay: function (payload) {\n                toggleHighlight.call(this, 'downplay', payload);\n            },\n            prepareAndUpdate: function (payload) {\n                var ecModel = this._model;\n                prepareView.call(this, 'component', ecModel);\n                prepareView.call(this, 'chart', ecModel);\n                updateMethods.update.call(this, payload);\n            }\n        };\n    /**\n     * @param {Object} payload\n     * @private\n     */\n    function toggleHighlight(method, payload) {\n        var ecModel = this._model;\n        // dispatchAction before setOption\n        if (!ecModel) {\n            return;\n        }\n        ecModel.eachComponent({\n            mainType: 'series',\n            query: payload\n        }, function (seriesModel, index) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            if (chartView && chartView.__alive) {\n                chartView[method](seriesModel, ecModel, this._api, payload);\n            }\n        }, this);\n    }\n    /**\n     * Resize the chart\n     */\n    echartsProto.resize = function () {\n        if (true) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n        this[IN_MAIN_PROCESS] = true;\n        this._zr.resize();\n        var optionChanged = this._model && this._model.resetOption('media');\n        updateMethods[optionChanged ? 'prepareAndUpdate' : 'update'].call(this);\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n        this[IN_MAIN_PROCESS] = false;\n        this._flushPendingActions();\n    };\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (true) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n        zr.add(el);\n    };\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {boolean} [silent=false] Whether trigger event.\n     */\n    echartsProto.dispatchAction = function (payload, silent) {\n        var actionWrap = actions[payload.type];\n        if (!actionWrap) {\n            return;\n        }\n        var actionInfo = actionWrap.actionInfo;\n        var updateMethod = actionInfo.update || 'update';\n        // if (__DEV__) {\n        //     zrUtil.assert(\n        //         !this[IN_MAIN_PROCESS],\n        //         '`dispatchAction` should not be called during main process.'\n        //         + 'unless updateMathod is \"none\".'\n        //     );\n        // }\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n        this[IN_MAIN_PROCESS] = true;\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighlightOrDownplay = payload.type === 'highlight' || payload.type === 'downplay';\n        for (var i = 0; i < payloads.length; i++) {\n            var batchItem = payloads[i];\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n            // Highlight and downplay are special.\n            isHighlightOrDownplay && updateMethods[updateMethod].call(this, batchItem);\n        }\n        if (updateMethod !== 'none' && !isHighlightOrDownplay) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            } else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payload.type,\n                batch: eventObjBatch\n            };\n        } else {\n            eventObj = eventObjBatch[0];\n        }\n        this[IN_MAIN_PROCESS] = false;\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n        this._flushPendingActions();\n    };\n    echartsProto._flushPendingActions = function () {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            this.dispatchAction(payload);\n        }\n    };\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n            updateZ(componentModel, component);\n        }, this);\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n            updateZ(seriesModel, chart);\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n    }\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            } else {\n                model = componentType;\n            }\n            // Consider: id same and type changed.\n            var viewId = model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = ComponentModel.parseClassType(model.type);\n                var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                } else {\n                    // Error\n                    return;\n                }\n            }\n            model.__viewId = viewId;\n            view.__alive = true;\n            view.__id = viewId;\n            view.__model = model;\n        }, this);\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n            } else {\n                i++;\n            }\n        }\n    }\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                if (previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            visual.func(ecModel, api, payload);\n        });\n    }\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n            updateZ(componentModel, componentView);\n        }, this);\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n            chartView.group.silent = !!seriesModel.get('silent');\n            updateZ(seriesModel, chartView);\n            updateProgressiveAndBlend(seriesModel, chartView);\n        }, this);\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n    var MOUSE_EVENT_NAMES = [\n            'click',\n            'dblclick',\n            'mouseover',\n            'mouseout',\n            'mousemove',\n            'mousedown',\n            'mouseup',\n            'globalout'\n        ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    var params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }    // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    this.trigger(eveName, el.eventData);\n                }\n            }, this);\n        }, this);\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (true) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n        var api = this._api;\n        var ecModel = this._model;\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n        // Dispose after all views disposed\n        this._zr.dispose();\n        delete instances[this.id];\n    };\n    zrUtil.mixin(ECharts, Eventful);\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ? Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (true) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var actions = [];\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n    var instances = {};\n    var connectedGroups = {};\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n            version: '3.2.3',\n            dependencies: { zrender: '3.1.3' }\n        };\n    function enableConnect(chart) {\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n                    for (var id in instances) {\n                        var otherChart = instances[id];\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    }\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n    }\n    /**\n     * @param {HTMLDomElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (true) {\n            // Check version\n            if (zrender.version.replace('.', '') - 0 < echarts.dependencies.zrender.replace('.', '') - 0) {\n                throw new Error('ZRender ' + zrender.version + ' is too old for ECharts ' + echarts.version + '. Current version need ZRender ' + echarts.dependencies.zrender + '+');\n            }\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n        enableConnect(chart);\n        return chart;\n    };\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || 'g_' + groupIdBase++;\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n    /**\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (zrUtil.isDom(chart)) {\n            chart = echarts.getInstanceByDom(chart);\n        } else if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        if (chart instanceof ECharts && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n    /**\n     * @param  {HTMLDomElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        return instances[key];\n    };\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (true) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo) ? actionInfo.type : [\n                actionInfo,\n                actionInfo = { event: eventName }\n            ][0];\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n        if (!actions[actionType]) {\n            actions[actionType] = {\n                action: action,\n                actionInfo: actionInfo\n            };\n        }\n        eventActionMap[eventName] = actionType;\n    };\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (true) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (true) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n    var parseClassType = ComponentModel.parseClassType;\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts, superClass) {\n        var Clazz = ComponentModel;\n        if (superClass) {\n            var classType = parseClassType(superClass);\n            Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts, superClass) {\n        var Clazz = ComponentView;\n        if (superClass) {\n            var classType = parseClassType(superClass);\n            Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts, superClass) {\n        var Clazz = SeriesModel;\n        if (superClass) {\n            superClass = 'series.' + superClass.replace('series.', '');\n            var classType = parseClassType(superClass);\n            Clazz = SeriesModel.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts, superClass) {\n        var Clazz = ChartView;\n        if (superClass) {\n            superClass.replace('series.', '');\n            var classType = parseClassType(superClass);\n            Clazz = ChartView.getClass(classType.main, true);\n        }\n        return Clazz.extend(opts);\n    };\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, require('./visual/seriesColor'));\n    echarts.registerPreprocessor(require('./preprocessor/backwardCompat'));\n    echarts.registerLoading('default', require('./loading/default'));\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n    // --------\n    // Exports\n    // --------\n    //\n    echarts.List = require('./data/List');\n    echarts.Model = require('./model/Model');\n    echarts.graphic = require('./util/graphic');\n    echarts.number = require('./util/number');\n    echarts.format = require('./util/format');\n    echarts.matrix = require('zrender/core/matrix');\n    echarts.vector = require('zrender/core/vector');\n    echarts.color = require('zrender/tool/color');\n    echarts.util = {};\n    each([\n        'map',\n        'each',\n        'filter',\n        'indexOf',\n        'inherits',\n        'reduce',\n        'filter',\n        'bind',\n        'curry',\n        'isArray',\n        'isString',\n        'isObject',\n        'isFunction',\n        'extend',\n        'defaults'\n    ], function (name) {\n        echarts.util[name] = zrUtil[name];\n    });\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n    return echarts;\n});\ndefine('echarts/scale/Log', ['require', 'zrender/core/util', './Scale', '../util/number', './Interval'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var Scale = require('./Scale');\n    var numberUtil = require('../util/number');\n    // Use some method of IntervalScale\n    var IntervalScale = require('./Interval');\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n    var mathLog = Math.log;\n    var LogScale = Scale.extend({\n            type: 'log',\n            base: 10,\n            getTicks: function () {\n                return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                    return numberUtil.round(mathPow(this.base, val));\n                }, this);\n            },\n            getLabel: intervalScaleProto.getLabel,\n            scale: function (val) {\n                val = scaleProto.scale.call(this, val);\n                return mathPow(this.base, val);\n            },\n            setExtent: function (start, end) {\n                var base = this.base;\n                start = mathLog(start) / mathLog(base);\n                end = mathLog(end) / mathLog(base);\n                intervalScaleProto.setExtent.call(this, start, end);\n            },\n            getExtent: function () {\n                var base = this.base;\n                var extent = scaleProto.getExtent.call(this);\n                extent[0] = mathPow(base, extent[0]);\n                extent[1] = mathPow(base, extent[1]);\n                return extent;\n            },\n            unionExtent: function (extent) {\n                var base = this.base;\n                extent[0] = mathLog(extent[0]) / mathLog(base);\n                extent[1] = mathLog(extent[1]) / mathLog(base);\n                scaleProto.unionExtent.call(this, extent);\n            },\n            niceTicks: function (approxTickNum) {\n                approxTickNum = approxTickNum || 10;\n                var extent = this._extent;\n                var span = extent[1] - extent[0];\n                if (span === Infinity || span <= 0) {\n                    return;\n                }\n                var interval = numberUtil.quantity(span);\n                var err = approxTickNum / span * interval;\n                // Filter ticks to get closer to the desired count.\n                if (err <= 0.5) {\n                    interval *= 10;\n                }\n                // Interval should be integer\n                while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                    interval *= 10;\n                }\n                var niceExtent = [\n                        numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                        numberUtil.round(mathFloor(extent[1] / interval) * interval)\n                    ];\n                this._interval = interval;\n                this._niceExtent = niceExtent;\n            },\n            niceExtent: intervalScaleProto.niceExtent\n        });\n    zrUtil.each([\n        'contain',\n        'normalize'\n    ], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n    LogScale.create = function () {\n        return new LogScale();\n    };\n    return LogScale;\n});\ndefine('echarts/chart/pie/PieView', ['require', '../../util/graphic', 'zrender/core/util', '../../view/Chart'], function (require) {\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/core/util');\n    /**\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n        var data = seriesModel.getData();\n        var dataIndex = this.dataIndex;\n        var name = data.getName(dataIndex);\n        var selectedOffset = seriesModel.get('selectedOffset');\n        api.dispatchAction({\n            type: 'pieToggleSelect',\n            from: uid,\n            name: name,\n            seriesId: seriesModel.id\n        });\n        data.each(function (idx) {\n            toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n        });\n    }\n    /**\n     * @param {module:zrender/graphic/Sector} el\n     * @param {Object} layout\n     * @param {boolean} isSelected\n     * @param {number} selectedOffset\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n        var dx = Math.cos(midAngle);\n        var dy = Math.sin(midAngle);\n        var offset = isSelected ? selectedOffset : 0;\n        var position = [\n                dx * offset,\n                dy * offset\n            ];\n        hasAnimation ? el.animate().when(200, { position: position }).start('bounceOut') : el.attr('position', position);\n    }\n    /**\n     * Piece of pie including Sector, Label, LabelLine\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     */\n    function PiePiece(data, idx) {\n        graphic.Group.call(this);\n        var sector = new graphic.Sector({ z2: 2 });\n        var polyline = new graphic.Polyline();\n        var text = new graphic.Text();\n        this.add(sector);\n        this.add(polyline);\n        this.add(text);\n        this.updateData(data, idx, true);\n        // Hover to change label and labelLine\n        function onEmphasis() {\n            polyline.ignore = polyline.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        function onNormal() {\n            polyline.ignore = polyline.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n        this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n    }\n    var piePieceProto = PiePiece.prototype;\n    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n        var textStyleModel = labelModel.getModel('textStyle');\n        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n        return {\n            fill: textStyleModel.getTextColor() || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n            opacity: data.getItemVisual(idx, 'opacity'),\n            textFont: textStyleModel.getFont(),\n            text: zrUtil.retrieve(data.hostModel.getFormattedLabel(idx, state), data.getName(idx))\n        };\n    }\n    piePieceProto.updateData = function (data, idx, firstCreate) {\n        var sector = this.childAt(0);\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var sectorShape = zrUtil.extend({}, layout);\n        sectorShape.label = null;\n        if (firstCreate) {\n            sector.setShape(sectorShape);\n            sector.shape.endAngle = layout.startAngle;\n            graphic.updateProps(sector, { shape: { endAngle: layout.endAngle } }, seriesModel, idx);\n        } else {\n            graphic.updateProps(sector, { shape: sectorShape }, seriesModel, idx);\n        }\n        // Update common style\n        var itemStyleModel = itemModel.getModel('itemStyle');\n        var visualColor = data.getItemVisual(idx, 'color');\n        sector.useStyle(zrUtil.defaults({\n            lineJoin: 'bevel',\n            fill: visualColor\n        }, itemStyleModel.getModel('normal').getItemStyle()));\n        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n        // Toggle selected\n        toggleItemSelected(this, data.getItemLayout(idx), itemModel.get('selected'), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n        function onEmphasis() {\n            // Sector may has animation of updating data. Force to move to the last frame\n            // Or it may stopped on the wrong shape\n            sector.stopAnimation(true);\n            sector.animateTo({ shape: { r: layout.r + 10 } }, 300, 'elasticOut');\n        }\n        function onNormal() {\n            sector.stopAnimation(true);\n            sector.animateTo({ shape: { r: layout.r } }, 300, 'elasticOut');\n        }\n        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n        if (itemModel.get('hoverAnimation') && seriesModel.ifEnableAnimation()) {\n            sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n        }\n        this._updateLabel(data, idx);\n        graphic.setHoverStyle(this);\n    };\n    piePieceProto._updateLabel = function (data, idx) {\n        var labelLine = this.childAt(1);\n        var labelText = this.childAt(2);\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var visualColor = data.getItemVisual(idx, 'color');\n        graphic.updateProps(labelLine, {\n            shape: {\n                points: labelLayout.linePoints || [\n                    [\n                        labelLayout.x,\n                        labelLayout.y\n                    ],\n                    [\n                        labelLayout.x,\n                        labelLayout.y\n                    ],\n                    [\n                        labelLayout.x,\n                        labelLayout.y\n                    ]\n                ]\n            }\n        }, seriesModel, idx);\n        graphic.updateProps(labelText, {\n            style: {\n                x: labelLayout.x,\n                y: labelLayout.y\n            }\n        }, seriesModel, idx);\n        labelText.attr({\n            style: {\n                textVerticalAlign: labelLayout.verticalAlign,\n                textAlign: labelLayout.textAlign,\n                textFont: labelLayout.font\n            },\n            rotation: labelLayout.rotation,\n            origin: [\n                labelLayout.x,\n                labelLayout.y\n            ],\n            z2: 10\n        });\n        var labelModel = itemModel.getModel('label.normal');\n        var labelHoverModel = itemModel.getModel('label.emphasis');\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n        labelText.hoverIgnore = !labelHoverModel.get('show');\n        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n        // Default use item visual color\n        labelLine.setStyle({\n            stroke: visualColor,\n            opacity: data.getItemVisual(idx, 'opacity')\n        });\n        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n        var smooth = labelLineModel.get('smooth');\n        if (smooth && smooth === true) {\n            smooth = 0.4;\n        }\n        labelLine.setShape({ smooth: smooth });\n    };\n    zrUtil.inherits(PiePiece, graphic.Group);\n    // Pie view\n    var Pie = require('../../view/Chart').extend({\n            type: 'pie',\n            init: function () {\n                var sectorGroup = new graphic.Group();\n                this._sectorGroup = sectorGroup;\n            },\n            render: function (seriesModel, ecModel, api, payload) {\n                if (payload && payload.from === this.uid) {\n                    return;\n                }\n                var data = seriesModel.getData();\n                var oldData = this._data;\n                var group = this.group;\n                var hasAnimation = ecModel.get('animation');\n                var isFirstRender = !oldData;\n                var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n                var selectedMode = seriesModel.get('selectedMode');\n                data.diff(oldData).add(function (idx) {\n                    var piePiece = new PiePiece(data, idx);\n                    if (isFirstRender) {\n                        piePiece.eachChild(function (child) {\n                            child.stopAnimation(true);\n                        });\n                    }\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    data.setItemGraphicEl(idx, piePiece);\n                    group.add(piePiece);\n                }).update(function (newIdx, oldIdx) {\n                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n                    piePiece.updateData(data, newIdx);\n                    piePiece.off('click');\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    group.add(piePiece);\n                    data.setItemGraphicEl(newIdx, piePiece);\n                }).remove(function (idx) {\n                    var piePiece = oldData.getItemGraphicEl(idx);\n                    group.remove(piePiece);\n                }).execute();\n                if (hasAnimation && isFirstRender && data.count() > 0) {\n                    var shape = data.getItemLayout(0);\n                    var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n                    var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n                    group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n                }\n                this._data = data;\n            },\n            _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n                var clipPath = new graphic.Sector({\n                        shape: {\n                            cx: cx,\n                            cy: cy,\n                            r0: 0,\n                            r: r,\n                            startAngle: startAngle,\n                            endAngle: startAngle,\n                            clockwise: clockwise\n                        }\n                    });\n                graphic.initProps(clipPath, { shape: { endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2 } }, seriesModel, cb);\n                return clipPath;\n            }\n        });\n    return Pie;\n});\ndefine('echarts/chart/pie/PieSeries', ['require', '../../data/List', 'zrender/core/util', '../../util/model', '../../data/helper/completeDimensions', '../../component/helper/selectableMixin', '../../echarts'], function (require) {\n    'use strict';\n    var List = require('../../data/List');\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../../util/model');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var dataSelectableMixin = require('../../component/helper/selectableMixin');\n    var PieSeries = require('../../echarts').extendSeriesModel({\n            type: 'series.pie',\n            init: function (option) {\n                PieSeries.superApply(this, 'init', arguments);\n                // Enable legend selection for each data item\n                // Use a function instead of direct access because data reference may changed\n                this.legendDataProvider = function () {\n                    return this._dataBeforeProcessed;\n                };\n                this.updateSelectedMap(option.data);\n                this._defaultLabelLine(option);\n            },\n            mergeOption: function (newOption) {\n                PieSeries.superCall(this, 'mergeOption', newOption);\n                this.updateSelectedMap(this.option.data);\n            },\n            getInitialData: function (option, ecModel) {\n                var dimensions = completeDimensions(['value'], option.data);\n                var list = new List(dimensions, this);\n                list.initData(option.data);\n                return list;\n            },\n            getDataParams: function (dataIndex) {\n                var data = this._data;\n                var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n                var sum = data.getSum('value');\n                // FIXME toFixed?\n                //\n                // Percent is 0 if sum is 0\n                params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n                params.$vars.push('percent');\n                return params;\n            },\n            _defaultLabelLine: function (option) {\n                // Extend labelLine emphasis\n                modelUtil.defaultEmphasis(option.labelLine, ['show']);\n                var labelLineNormalOpt = option.labelLine.normal;\n                var labelLineEmphasisOpt = option.labelLine.emphasis;\n                // Not show label line if `label.normal.show = false`\n                labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.normal.show;\n                labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.label.emphasis.show;\n            },\n            defaultOption: {\n                zlevel: 0,\n                z: 2,\n                legendHoverLink: true,\n                hoverAnimation: true,\n                center: [\n                    '50%',\n                    '50%'\n                ],\n                radius: [\n                    0,\n                    '75%'\n                ],\n                clockwise: true,\n                startAngle: 90,\n                minAngle: 0,\n                selectedOffset: 10,\n                avoidLabelOverlap: true,\n                label: {\n                    normal: {\n                        rotate: false,\n                        show: true,\n                        position: 'outer'\n                    },\n                    emphasis: {}\n                },\n                labelLine: {\n                    normal: {\n                        show: true,\n                        length: 15,\n                        length2: 15,\n                        smooth: false,\n                        lineStyle: {\n                            width: 1,\n                            type: 'solid'\n                        }\n                    }\n                },\n                itemStyle: {\n                    normal: { borderWidth: 1 },\n                    emphasis: {}\n                },\n                animationEasing: 'cubicOut',\n                data: []\n            }\n        });\n    zrUtil.mixin(PieSeries, dataSelectableMixin);\n    return PieSeries;\n});\ndefine('echarts/action/createDataSelectAction', ['require', '../echarts', 'zrender/core/util'], function (require) {\n    var echarts = require('../echarts');\n    var zrUtil = require('zrender/core/util');\n    return function (seriesType, actionInfos) {\n        zrUtil.each(actionInfos, function (actionInfo) {\n            actionInfo.update = 'updateView';\n            /**\n             * @payload\n             * @property {string} seriesName\n             * @property {string} name\n             */\n            echarts.registerAction(actionInfo, function (payload, ecModel) {\n                var selected = {};\n                ecModel.eachComponent({\n                    mainType: 'series',\n                    subType: seriesType,\n                    query: payload\n                }, function (seriesModel) {\n                    if (seriesModel[actionInfo.method]) {\n                        seriesModel[actionInfo.method](payload.name);\n                    }\n                    var data = seriesModel.getData();\n                    // Create selected map\n                    data.each(function (idx) {\n                        var name = data.getName(idx);\n                        selected[name] = seriesModel.isSelected(name) || false;\n                    });\n                });\n                return {\n                    name: payload.name,\n                    selected: selected\n                };\n            });\n        });\n    };\n});\ndefine('zrender/core/util', ['require'], function (require) {\n    // 用于处理merge时无法遍历Date等对象的问题\n    var BUILTIN_OBJECT = {\n            '[object Function]': 1,\n            '[object RegExp]': 1,\n            '[object Date]': 1,\n            '[object Error]': 1,\n            '[object CanvasGradient]': 1,\n            '[object CanvasPattern]': 1,\n            '[object Image]': 1\n        };\n    var objToString = Object.prototype.toString;\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n    /**\n     * @param {*} source\n     * @return {*} 拷贝后的新对象\n     */\n    function clone(source) {\n        if (typeof source == 'object' && source !== null) {\n            var result = source;\n            if (source instanceof Array) {\n                result = [];\n                for (var i = 0, len = source.length; i < len; i++) {\n                    result[i] = clone(source[i]);\n                }\n            } else if (!isBuildInObject(source) && !isDom(source)) {\n                result = {};\n                for (var key in source) {\n                    if (source.hasOwnProperty(key)) {\n                        result[key] = clone(source[key]);\n                    }\n                }\n            }\n            return result;\n        }\n        return source;\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n                if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuildInObject(sourceProp) && !isBuildInObject(targetProp)) {\n                    // 如果需要递归覆盖，就递归调用merge\n                    merge(targetProp, sourceProp, overwrite);\n                } else if (overwrite || !(key in target)) {\n                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n                    // NOTE，在 target[key] 不存在的时候也是直接覆盖\n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n        return target;\n    }\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n    /**\n     * 查询数组中元素的index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    /**\n     * 构造类继承关系\n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz 源类\n     * @param {Function} baseClazz 基类\n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {\n        }\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n        defaults(target, source, overlay);\n    }\n    /**\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (!data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n    /**\n     * 数组或对象遍历\n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        } else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        } else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n    /**\n     * 数组映射\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        } else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        } else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n    /**\n     * 数组过滤\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        } else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n    /**\n     * 数组项查找\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || !!value && type == 'object';\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuildInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return value && value.nodeType === 1 && typeof value.nodeName == 'string';\n    }\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n    var util = {\n            inherits: inherits,\n            mixin: mixin,\n            clone: clone,\n            merge: merge,\n            mergeAll: mergeAll,\n            extend: extend,\n            defaults: defaults,\n            getContext: getContext,\n            createCanvas: createCanvas,\n            indexOf: indexOf,\n            slice: slice,\n            find: find,\n            isArrayLike: isArrayLike,\n            each: each,\n            map: map,\n            reduce: reduce,\n            filter: filter,\n            bind: bind,\n            curry: curry,\n            isArray: isArray,\n            isString: isString,\n            isObject: isObject,\n            isFunction: isFunction,\n            isBuildInObject: isBuildInObject,\n            isDom: isDom,\n            retrieve: retrieve,\n            assert: assert,\n            noop: function () {\n            }\n        };\n    return util;\n});\ndefine('echarts/visual/dataColor', ['require'], function (require) {\n    return function (seriesType, ecModel) {\n        // Pie and funnel may use diferrent scope\n        var paletteScope = {};\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var dataAll = seriesModel.getRawData();\n            var idxMap = {};\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                var data = seriesModel.getData();\n                data.each(function (idx) {\n                    var rawIdx = data.getRawIndex(idx);\n                    idxMap[rawIdx] = idx;\n                });\n                dataAll.each(function (rawIdx) {\n                    // FIXME Performance\n                    var itemModel = dataAll.getItemModel(rawIdx);\n                    var filteredIdx = idxMap[rawIdx];\n                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n                    var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n                    if (!singleDataColor) {\n                        var color = itemModel.get('itemStyle.normal.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n                        // Legend may use the visual info in data before processed\n                        dataAll.setItemVisual(rawIdx, 'color', color);\n                        // Data is not filtered\n                        if (filteredIdx != null) {\n                            data.setItemVisual(filteredIdx, 'color', color);\n                        }\n                    } else {\n                        // Set data all color for legend\n                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n                    }\n                });\n            }\n        });\n    };\n});\ndefine('echarts/chart/pie/pieLayout', ['require', '../../util/number', './labelLayout', 'zrender/core/util'], function (require) {\n    var numberUtil = require('../../util/number');\n    var parsePercent = numberUtil.parsePercent;\n    var labelLayout = require('./labelLayout');\n    var zrUtil = require('zrender/core/util');\n    var PI2 = Math.PI * 2;\n    var RADIAN = Math.PI / 180;\n    return function (seriesType, ecModel, api, payload) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var center = seriesModel.get('center');\n            var radius = seriesModel.get('radius');\n            if (!zrUtil.isArray(radius)) {\n                radius = [\n                    0,\n                    radius\n                ];\n            }\n            if (!zrUtil.isArray(center)) {\n                center = [\n                    center,\n                    center\n                ];\n            }\n            var width = api.getWidth();\n            var height = api.getHeight();\n            var size = Math.min(width, height);\n            var cx = parsePercent(center[0], width);\n            var cy = parsePercent(center[1], height);\n            var r0 = parsePercent(radius[0], size / 2);\n            var r = parsePercent(radius[1], size / 2);\n            var data = seriesModel.getData();\n            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n            var minAngle = seriesModel.get('minAngle') * RADIAN;\n            var sum = data.getSum('value');\n            // Sum may be 0\n            var unitRadian = Math.PI / (sum || data.count()) * 2;\n            var clockwise = seriesModel.get('clockwise');\n            var roseType = seriesModel.get('roseType');\n            // [0...max]\n            var extent = data.getDataExtent('value');\n            extent[0] = 0;\n            // In the case some sector angle is smaller than minAngle\n            var restAngle = PI2;\n            var valueSumLargerThanMinAngle = 0;\n            var currentAngle = startAngle;\n            var dir = clockwise ? 1 : -1;\n            data.each('value', function (value, idx) {\n                var angle;\n                // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n                if (roseType !== 'area') {\n                    angle = sum === 0 ? unitRadian : value * unitRadian;\n                } else {\n                    angle = PI2 / (data.count() || 1);\n                }\n                if (angle < minAngle) {\n                    angle = minAngle;\n                    restAngle -= minAngle;\n                } else {\n                    valueSumLargerThanMinAngle += value;\n                }\n                var endAngle = currentAngle + dir * angle;\n                data.setItemLayout(idx, {\n                    angle: angle,\n                    startAngle: currentAngle,\n                    endAngle: endAngle,\n                    clockwise: clockwise,\n                    cx: cx,\n                    cy: cy,\n                    r0: r0,\n                    r: roseType ? numberUtil.linearMap(value, extent, [\n                        r0,\n                        r\n                    ]) : r\n                });\n                currentAngle = endAngle;\n            }, true);\n            // Some sector is constrained by minAngle\n            // Rest sectors needs recalculate angle\n            if (restAngle < PI2) {\n                // Average the angle if rest angle is not enough after all angles is\n                // Constrained by minAngle\n                if (restAngle <= 0.001) {\n                    var angle = PI2 / data.count();\n                    data.each(function (idx) {\n                        var layout = data.getItemLayout(idx);\n                        layout.startAngle = startAngle + dir * idx * angle;\n                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n                    });\n                } else {\n                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n                    currentAngle = startAngle;\n                    data.each('value', function (value, idx) {\n                        var layout = data.getItemLayout(idx);\n                        var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n                        layout.startAngle = currentAngle;\n                        layout.endAngle = currentAngle + dir * angle;\n                        currentAngle += angle;\n                    });\n                }\n            }\n            labelLayout(seriesModel, r, width, height);\n        });\n    };\n});\ndefine('echarts/processor/dataFilter', [], function () {\n    return function (seriesType, ecModel) {\n        var legendModels = ecModel.findComponents({ mainType: 'legend' });\n        if (!legendModels || !legendModels.length) {\n            return;\n        }\n        ecModel.eachSeriesByType(seriesType, function (series) {\n            var data = series.getData();\n            data.filterSelf(function (idx) {\n                var name = data.getName(idx);\n                // If in any legend component the status is not selected.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(name)) {\n                        return false;\n                    }\n                }\n                return true;\n            }, this);\n        }, this);\n    };\n});\ndefine('echarts/coord/cartesian/Grid', ['require', 'exports', '../../util/layout', '../../coord/axisHelper', 'zrender/core/util', './Cartesian2D', './Axis2D', './GridModel', '../../CoordinateSystem'], function (require, factory) {\n    var layout = require('../../util/layout');\n    var axisHelper = require('../../coord/axisHelper');\n    var zrUtil = require('zrender/core/util');\n    var Cartesian2D = require('./Cartesian2D');\n    var Axis2D = require('./Axis2D');\n    var each = zrUtil.each;\n    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n    var niceScaleExtent = axisHelper.niceScaleExtent;\n    // 依赖 GridModel, AxisModel 做预处理\n    require('./GridModel');\n    /**\n     * Check if the axis is used in the specified grid\n     * @inner\n     */\n    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n        return axisModel.findGridModel() === gridModel;\n    }\n    function getLabelUnionRect(axis) {\n        var axisModel = axis.model;\n        var labels = axisModel.getFormattedLabels();\n        var rect;\n        var step = 1;\n        var labelCount = labels.length;\n        if (labelCount > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.ceil(labelCount / 40);\n        }\n        for (var i = 0; i < labelCount; i += step) {\n            if (!axis.isLabelIgnored(i)) {\n                var singleRect = axisModel.getTextRect(labels[i]);\n                // FIXME consider label rotate\n                rect ? rect.union(singleRect) : rect = singleRect;\n            }\n        }\n        return rect;\n    }\n    function Grid(gridModel, ecModel, api) {\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n         * @private\n         */\n        this._coordsMap = {};\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n         * @private\n         */\n        this._coordsList = [];\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesMap = {};\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesList = [];\n        this._initCartesian(gridModel, ecModel, api);\n        this._model = gridModel;\n    }\n    var gridProto = Grid.prototype;\n    gridProto.type = 'grid';\n    gridProto.getRect = function () {\n        return this._rect;\n    };\n    gridProto.update = function (ecModel, api) {\n        var axesMap = this._axesMap;\n        this._updateScale(ecModel, this._model);\n        function ifAxisCanNotOnZero(otherAxisDim) {\n            var axes = axesMap[otherAxisDim];\n            for (var idx in axes) {\n                var axis = axes[idx];\n                if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        each(axesMap.x, function (xAxis) {\n            niceScaleExtent(xAxis, xAxis.model);\n        });\n        each(axesMap.y, function (yAxis) {\n            niceScaleExtent(yAxis, yAxis.model);\n        });\n        // Fix configuration\n        each(axesMap.x, function (xAxis) {\n            // onZero can not be enabled in these two situations\n            // 1. When any other axis is a category axis\n            // 2. When any other axis not across 0 point\n            if (ifAxisCanNotOnZero('y')) {\n                xAxis.onZero = false;\n            }\n        });\n        each(axesMap.y, function (yAxis) {\n            if (ifAxisCanNotOnZero('x')) {\n                yAxis.onZero = false;\n            }\n        });\n        // Resize again if containLabel is enabled\n        // FIXME It may cause getting wrong grid size in data processing stage\n        this.resize(this._model, api);\n    };\n    /**\n     * Resize the grid\n     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    gridProto.resize = function (gridModel, api) {\n        var gridRect = layout.getLayoutRect(gridModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        this._rect = gridRect;\n        var axesList = this._axesList;\n        adjustAxes();\n        // Minus label size\n        if (gridModel.get('containLabel')) {\n            each(axesList, function (axis) {\n                if (!axis.model.get('axisLabel.inside')) {\n                    var labelUnionRect = getLabelUnionRect(axis);\n                    if (labelUnionRect) {\n                        var dim = axis.isHorizontal() ? 'height' : 'width';\n                        var margin = axis.model.get('axisLabel.margin');\n                        gridRect[dim] -= labelUnionRect[dim] + margin;\n                        if (axis.position === 'top') {\n                            gridRect.y += labelUnionRect.height + margin;\n                        } else if (axis.position === 'left') {\n                            gridRect.x += labelUnionRect.width + margin;\n                        }\n                    }\n                }\n            });\n            adjustAxes();\n        }\n        function adjustAxes() {\n            each(axesList, function (axis) {\n                var isHorizontal = axis.isHorizontal();\n                var extent = isHorizontal ? [\n                        0,\n                        gridRect.width\n                    ] : [\n                        0,\n                        gridRect.height\n                    ];\n                var idx = axis.inverse ? 1 : 0;\n                axis.setExtent(extent[idx], extent[1 - idx]);\n                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n            });\n        }\n    };\n    /**\n     * @param {string} axisType\n     * @param {ndumber} [axisIndex]\n     */\n    gridProto.getAxis = function (axisType, axisIndex) {\n        var axesMapOnDim = this._axesMap[axisType];\n        if (axesMapOnDim != null) {\n            if (axisIndex == null) {\n                // Find first axis\n                for (var name in axesMapOnDim) {\n                    return axesMapOnDim[name];\n                }\n            }\n            return axesMapOnDim[axisIndex];\n        }\n    };\n    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n        if (xAxisIndex != null && yAxisIndex != null) {\n            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n            return this._coordsMap[key];\n        } else {\n            // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n                if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n                    return coordList[i];\n                }\n            }\n        }\n    };\n    /**\n     * Initialize cartesian coordinate systems\n     * @private\n     */\n    gridProto._initCartesian = function (gridModel, ecModel, api) {\n        var axisPositionUsed = {\n                left: false,\n                right: false,\n                top: false,\n                bottom: false\n            };\n        var axesMap = {\n                x: {},\n                y: {}\n            };\n        var axesCount = {\n                x: 0,\n                y: 0\n            };\n        /// Create axis\n        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n        if (!axesCount.x || !axesCount.y) {\n            // Roll back when there no either x or y axis\n            this._axesMap = {};\n            this._axesList = [];\n            return;\n        }\n        this._axesMap = axesMap;\n        /// Create cartesian2d\n        each(axesMap.x, function (xAxis, xAxisIndex) {\n            each(axesMap.y, function (yAxis, yAxisIndex) {\n                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n                var cartesian = new Cartesian2D(key);\n                cartesian.grid = this;\n                this._coordsMap[key] = cartesian;\n                this._coordsList.push(cartesian);\n                cartesian.addAxis(xAxis);\n                cartesian.addAxis(yAxis);\n            }, this);\n        }, this);\n        function createAxisCreator(axisType) {\n            return function (axisModel, idx) {\n                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n                    return;\n                }\n                var axisPosition = axisModel.get('position');\n                if (axisType === 'x') {\n                    // Fix position\n                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n                        // Default bottom of X\n                        axisPosition = 'bottom';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n                        }\n                    }\n                } else {\n                    // Fix position\n                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n                        // Default left of Y\n                        axisPosition = 'left';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n                        }\n                    }\n                }\n                axisPositionUsed[axisPosition] = true;\n                var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [\n                        0,\n                        0\n                    ], axisModel.get('type'), axisPosition);\n                var isCategory = axis.type === 'category';\n                axis.onBand = isCategory && axisModel.get('boundaryGap');\n                axis.inverse = axisModel.get('inverse');\n                axis.onZero = axisModel.get('axisLine.onZero');\n                // Inject axis into axisModel\n                axisModel.axis = axis;\n                // Inject axisModel into axis\n                axis.model = axisModel;\n                // Inject grid info axis\n                axis.grid = this;\n                // Index of axis, can be used as key\n                axis.index = idx;\n                this._axesList.push(axis);\n                axesMap[axisType][idx] = axis;\n                axesCount[axisType]++;\n            };\n        }\n    };\n    /**\n     * Update cartesian properties from series\n     * @param  {module:echarts/model/Option} option\n     * @private\n     */\n    gridProto._updateScale = function (ecModel, gridModel) {\n        // Reset scale\n        zrUtil.each(this._axesList, function (axis) {\n            axis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeries(function (seriesModel) {\n            if (isCartesian2D(seriesModel)) {\n                var axesModels = findAxesModels(seriesModel, ecModel);\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n                    return;\n                }\n                var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n                var data = seriesModel.getData();\n                var xAxis = cartesian.getAxis('x');\n                var yAxis = cartesian.getAxis('y');\n                if (data.type === 'list') {\n                    unionExtent(data, xAxis, seriesModel);\n                    unionExtent(data, yAxis, seriesModel);\n                }\n            }\n        }, this);\n        function unionExtent(data, axis, seriesModel) {\n            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n                axis.scale.unionExtent(data.getDataExtent(dim, axis.scale.type !== 'ordinal'));\n            });\n        }\n    };\n    /**\n     * @inner\n     */\n    function updateAxisTransfrom(axis, coordBase) {\n        var axisExtent = axis.getExtent();\n        var axisExtentSum = axisExtent[0] + axisExtent[1];\n        // Fast transform\n        axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n            return coord + coordBase;\n        } : function (coord) {\n            return axisExtentSum - coord + coordBase;\n        };\n        axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n            return coord - coordBase;\n        } : function (coord) {\n            return axisExtentSum - coord + coordBase;\n        };\n    }\n    var axesTypes = [\n            'xAxis',\n            'yAxis'\n        ];\n    /**\n     * @inner\n     */\n    function findAxesModels(seriesModel, ecModel) {\n        return zrUtil.map(axesTypes, function (axisType) {\n            var axisModel = ecModel.queryComponents({\n                    mainType: axisType,\n                    index: seriesModel.get(axisType + 'Index'),\n                    id: seriesModel.get(axisType + 'Id')\n                })[0];\n            if (true) {\n                if (!axisModel) {\n                    throw new Error(axisType + ' \"' + zrUtil.retrieve(seriesModel.get(axisType + 'Index'), seriesModel.get(axisType + 'Id'), 0) + '\" not found');\n                }\n            }\n            return axisModel;\n        });\n    }\n    /**\n     * @inner\n     */\n    function isCartesian2D(seriesModel) {\n        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n    }\n    Grid.create = function (ecModel, api) {\n        var grids = [];\n        ecModel.eachComponent('grid', function (gridModel, idx) {\n            var grid = new Grid(gridModel, ecModel, api);\n            grid.name = 'grid_' + idx;\n            grid.resize(gridModel, api);\n            gridModel.coordinateSystem = grid;\n            grids.push(grid);\n        });\n        // Inject the coordinateSystems into seriesModel\n        ecModel.eachSeries(function (seriesModel) {\n            if (!isCartesian2D(seriesModel)) {\n                return;\n            }\n            var axesModels = findAxesModels(seriesModel, ecModel);\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n            var gridModel = xAxisModel.findGridModel();\n            if (true) {\n                if (!gridModel) {\n                    throw new Error('Grid \"' + zrUtil.retrieve(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '\" not found');\n                }\n                if (xAxisModel.findGridModel() !== yAxisModel.findGridModel()) {\n                    throw new Error('xAxis and yAxis must use the same grid');\n                }\n            }\n            var grid = gridModel.coordinateSystem;\n            seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        });\n        return grids;\n    };\n    // For deciding which dimensions to use when creating list data\n    Grid.dimensions = Cartesian2D.prototype.dimensions;\n    require('../../CoordinateSystem').register('cartesian2d', Grid);\n    return Grid;\n});\ndefine('echarts/chart/bar/BarSeries', ['require', '../../model/Series', '../helper/createListFromArray'], function (require) {\n    'use strict';\n    var SeriesModel = require('../../model/Series');\n    var createListFromArray = require('../helper/createListFromArray');\n    return SeriesModel.extend({\n        type: 'series.bar',\n        dependencies: [\n            'grid',\n            'polar'\n        ],\n        getInitialData: function (option, ecModel) {\n            if (true) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'cartesian2d') {\n                    throw new Error('Bar only support cartesian2d coordinateSystem');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n        getMarkerPosition: function (value) {\n            var coordSys = this.coordinateSystem;\n            if (coordSys) {\n                // PENDING if clamp ?\n                var pt = coordSys.dataToPoint(value, true);\n                var data = this.getData();\n                var offset = data.getLayout('offset');\n                var size = data.getLayout('size');\n                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n                pt[offsetIndex] += offset + size / 2;\n                return pt;\n            }\n            return [\n                NaN,\n                NaN\n            ];\n        },\n        brushSelector: 'rect',\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n            barMinHeight: 0,\n            itemStyle: {\n                normal: {},\n                emphasis: {}\n            }\n        }\n    });\n});\ndefine('echarts/chart/bar/BarView', ['require', 'zrender/core/util', '../../util/graphic', '../../model/Model', './barItemStyle', '../../echarts'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var graphic = require('../../util/graphic');\n    zrUtil.extend(require('../../model/Model').prototype, require('./barItemStyle'));\n    function fixLayoutWithLineWidth(layout, lineWidth) {\n        var signX = layout.width > 0 ? 1 : -1;\n        var signY = layout.height > 0 ? 1 : -1;\n        // In case width or height are too small.\n        lineWidth = Math.min(lineWidth, Math.abs(layout.width), Math.abs(layout.height));\n        layout.x += signX * lineWidth / 2;\n        layout.y += signY * lineWidth / 2;\n        layout.width -= signX * lineWidth;\n        layout.height -= signY * lineWidth;\n    }\n    return require('../../echarts').extendChartView({\n        type: 'bar',\n        render: function (seriesModel, ecModel, api) {\n            var coordinateSystemType = seriesModel.get('coordinateSystem');\n            if (coordinateSystemType === 'cartesian2d') {\n                this._renderOnCartesian(seriesModel, ecModel, api);\n            }\n            return this.group;\n        },\n        _renderOnCartesian: function (seriesModel, ecModel, api) {\n            var group = this.group;\n            var data = seriesModel.getData();\n            var oldData = this._data;\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var isHorizontal = baseAxis.isHorizontal();\n            var enableAnimation = seriesModel.get('animation');\n            var barBorderWidthQuery = [\n                    'itemStyle',\n                    'normal',\n                    'barBorderWidth'\n                ];\n            function createRect(dataIndex, isUpdate) {\n                var layout = data.getItemLayout(dataIndex);\n                var lineWidth = data.getItemModel(dataIndex).get(barBorderWidthQuery) || 0;\n                fixLayoutWithLineWidth(layout, lineWidth);\n                var rect = new graphic.Rect({ shape: zrUtil.extend({}, layout) });\n                // Animation\n                if (enableAnimation) {\n                    var rectShape = rect.shape;\n                    var animateProperty = isHorizontal ? 'height' : 'width';\n                    var animateTarget = {};\n                    rectShape[animateProperty] = 0;\n                    animateTarget[animateProperty] = layout[animateProperty];\n                    graphic[isUpdate ? 'updateProps' : 'initProps'](rect, { shape: animateTarget }, seriesModel, dataIndex);\n                }\n                return rect;\n            }\n            data.diff(oldData).add(function (dataIndex) {\n                // 空数据\n                if (!data.hasValue(dataIndex)) {\n                    return;\n                }\n                var rect = createRect(dataIndex);\n                data.setItemGraphicEl(dataIndex, rect);\n                group.add(rect);\n            }).update(function (newIndex, oldIndex) {\n                var rect = oldData.getItemGraphicEl(oldIndex);\n                // 空数据\n                if (!data.hasValue(newIndex)) {\n                    group.remove(rect);\n                    return;\n                }\n                if (!rect) {\n                    rect = createRect(newIndex, true);\n                }\n                var layout = data.getItemLayout(newIndex);\n                var lineWidth = data.getItemModel(newIndex).get(barBorderWidthQuery) || 0;\n                fixLayoutWithLineWidth(layout, lineWidth);\n                graphic.updateProps(rect, { shape: layout }, seriesModel, newIndex);\n                data.setItemGraphicEl(newIndex, rect);\n                // Add back\n                group.add(rect);\n            }).remove(function (idx) {\n                var rect = oldData.getItemGraphicEl(idx);\n                if (rect) {\n                    // Not show text when animating\n                    rect.style.text = '';\n                    graphic.updateProps(rect, { shape: { width: 0 } }, seriesModel, idx, function () {\n                        group.remove(rect);\n                    });\n                }\n            }).execute();\n            this._updateStyle(seriesModel, data, isHorizontal);\n            this._data = data;\n        },\n        _updateStyle: function (seriesModel, data, isHorizontal) {\n            function setLabel(style, model, color, labelText, labelPositionOutside) {\n                graphic.setText(style, model, color);\n                style.text = labelText;\n                if (style.textPosition === 'outside') {\n                    style.textPosition = labelPositionOutside;\n                }\n            }\n            data.eachItemGraphicEl(function (rect, idx) {\n                var itemModel = data.getItemModel(idx);\n                var color = data.getItemVisual(idx, 'color');\n                var opacity = data.getItemVisual(idx, 'opacity');\n                var layout = data.getItemLayout(idx);\n                var itemStyleModel = itemModel.getModel('itemStyle.normal');\n                var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n                rect.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n                rect.useStyle(zrUtil.defaults({\n                    fill: color,\n                    opacity: opacity\n                }, itemStyleModel.getBarItemStyle()));\n                var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n                var labelModel = itemModel.getModel('label.normal');\n                var hoverLabelModel = itemModel.getModel('label.emphasis');\n                var rectStyle = rect.style;\n                if (labelModel.get('show')) {\n                    setLabel(rectStyle, labelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'normal'), seriesModel.getRawValue(idx)), labelPositionOutside);\n                } else {\n                    rectStyle.text = '';\n                }\n                if (hoverLabelModel.get('show')) {\n                    setLabel(hoverStyle, hoverLabelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'emphasis'), seriesModel.getRawValue(idx)), labelPositionOutside);\n                } else {\n                    hoverStyle.text = '';\n                }\n                graphic.setHoverStyle(rect, hoverStyle);\n            });\n        },\n        remove: function (ecModel, api) {\n            var group = this.group;\n            if (ecModel.get('animation')) {\n                if (this._data) {\n                    this._data.eachItemGraphicEl(function (el) {\n                        // Not show text when animating\n                        el.style.text = '';\n                        graphic.updateProps(el, { shape: { width: 0 } }, ecModel, el.dataIndex, function () {\n                            group.remove(el);\n                        });\n                    });\n                }\n            } else {\n                group.removeAll();\n            }\n        }\n    });\n});\ndefine('echarts/layout/barGrid', ['require', 'zrender/core/util', '../util/number'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var numberUtil = require('../util/number');\n    var parsePercent = numberUtil.parsePercent;\n    function getSeriesStackId(seriesModel) {\n        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n    }\n    function getAxisKey(axis) {\n        return axis.dim + axis.index;\n    }\n    function calBarWidthAndOffset(barSeries, api) {\n        // Columns info on each category axis. Key is cartesian name\n        var columnsMap = {};\n        zrUtil.each(barSeries, function (seriesModel, idx) {\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var axisExtent = baseAxis.getExtent();\n            var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n                    bandWidth: bandWidth,\n                    remainedWidth: bandWidth,\n                    autoWidthCount: 0,\n                    categoryGap: '20%',\n                    gap: '30%',\n                    stacks: {}\n                };\n            var stacks = columnsOnAxis.stacks;\n            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n            var stackId = getSeriesStackId(seriesModel);\n            if (!stacks[stackId]) {\n                columnsOnAxis.autoWidthCount++;\n            }\n            stacks[stackId] = stacks[stackId] || {\n                width: 0,\n                maxWidth: 0\n            };\n            var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n            var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n            var barGap = seriesModel.get('barGap');\n            var barCategoryGap = seriesModel.get('barCategoryGap');\n            // TODO\n            if (barWidth && !stacks[stackId].width) {\n                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n                stacks[stackId].width = barWidth;\n                columnsOnAxis.remainedWidth -= barWidth;\n            }\n            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n            barGap != null && (columnsOnAxis.gap = barGap);\n            barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n        });\n        var result = {};\n        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n            result[coordSysName] = {};\n            var stacks = columnsOnAxis.stacks;\n            var bandWidth = columnsOnAxis.bandWidth;\n            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n            var remainedWidth = columnsOnAxis.remainedWidth;\n            var autoWidthCount = columnsOnAxis.autoWidthCount;\n            var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n            // Find if any auto calculated bar exceeded maxBarWidth\n            zrUtil.each(stacks, function (column, stack) {\n                var maxWidth = column.maxWidth;\n                if (!column.width && maxWidth && maxWidth < autoWidth) {\n                    maxWidth = Math.min(maxWidth, remainedWidth);\n                    remainedWidth -= maxWidth;\n                    column.width = maxWidth;\n                    autoWidthCount--;\n                }\n            });\n            // Recalculate width again\n            autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n            var widthSum = 0;\n            var lastColumn;\n            zrUtil.each(stacks, function (column, idx) {\n                if (!column.width) {\n                    column.width = autoWidth;\n                }\n                lastColumn = column;\n                widthSum += column.width * (1 + barGapPercent);\n            });\n            if (lastColumn) {\n                widthSum -= lastColumn.width * barGapPercent;\n            }\n            var offset = -widthSum / 2;\n            zrUtil.each(stacks, function (column, stackId) {\n                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n                    offset: offset,\n                    width: column.width\n                };\n                offset += column.width * (1 + barGapPercent);\n            });\n        });\n        return result;\n    }\n    /**\n     * @param {string} seriesType\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function barLayoutGrid(seriesType, ecModel, api) {\n        var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n                return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n            }));\n        var lastStackCoords = {};\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var stackId = getSeriesStackId(seriesModel);\n            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n            var columnOffset = columnLayoutInfo.offset;\n            var columnWidth = columnLayoutInfo.width;\n            var valueAxis = cartesian.getOtherAxis(baseAxis);\n            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n            var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];\n            var coords = cartesian.dataToPoints(data, true);\n            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n            data.setLayout({\n                offset: columnOffset,\n                size: columnWidth\n            });\n            data.each(valueAxis.dim, function (value, idx) {\n                // 空数据\n                if (isNaN(value)) {\n                    return;\n                }\n                if (!lastStackCoords[stackId][idx]) {\n                    lastStackCoords[stackId][idx] = {\n                        p: valueAxisStart,\n                        n: valueAxisStart\n                    };\n                }\n                var sign = value >= 0 ? 'p' : 'n';\n                var coord = coords[idx];\n                var lastCoord = lastStackCoords[stackId][idx][sign];\n                var x, y, width, height;\n                if (valueAxis.isHorizontal()) {\n                    x = lastCoord;\n                    y = coord[1] + columnOffset;\n                    width = coord[0] - lastCoord;\n                    height = columnWidth;\n                    if (Math.abs(width) < barMinHeight) {\n                        width = (width < 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += width;\n                } else {\n                    x = coord[0] + columnOffset;\n                    y = lastCoord;\n                    width = columnWidth;\n                    height = coord[1] - lastCoord;\n                    if (Math.abs(height) < barMinHeight) {\n                        // Include zero to has a positive bar\n                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += height;\n                }\n                data.setItemLayout(idx, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }, true);\n        }, this);\n    }\n    return barLayoutGrid;\n});\ndefine('echarts/util/graphic', ['require', 'zrender/core/util', 'zrender/tool/path', 'zrender/graphic/Path', 'zrender/tool/color', 'zrender/core/matrix', 'zrender/core/vector', 'zrender/graphic/Gradient', 'zrender/container/Group', 'zrender/graphic/Image', 'zrender/graphic/Text', 'zrender/graphic/shape/Circle', 'zrender/graphic/shape/Sector', 'zrender/graphic/shape/Ring', 'zrender/graphic/shape/Polygon', 'zrender/graphic/shape/Polyline', 'zrender/graphic/shape/Rect', 'zrender/graphic/shape/Line', 'zrender/graphic/shape/BezierCurve', 'zrender/graphic/shape/Arc', 'zrender/graphic/CompoundPath', 'zrender/graphic/LinearGradient', 'zrender/graphic/RadialGradient', 'zrender/core/BoundingRect'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var pathTool = require('zrender/tool/path');\n    var round = Math.round;\n    var Path = require('zrender/graphic/Path');\n    var colorTool = require('zrender/tool/color');\n    var matrix = require('zrender/core/matrix');\n    var vector = require('zrender/core/vector');\n    var Gradient = require('zrender/graphic/Gradient');\n    var graphic = {};\n    graphic.Group = require('zrender/container/Group');\n    graphic.Image = require('zrender/graphic/Image');\n    graphic.Text = require('zrender/graphic/Text');\n    graphic.Circle = require('zrender/graphic/shape/Circle');\n    graphic.Sector = require('zrender/graphic/shape/Sector');\n    graphic.Ring = require('zrender/graphic/shape/Ring');\n    graphic.Polygon = require('zrender/graphic/shape/Polygon');\n    graphic.Polyline = require('zrender/graphic/shape/Polyline');\n    graphic.Rect = require('zrender/graphic/shape/Rect');\n    graphic.Line = require('zrender/graphic/shape/Line');\n    graphic.BezierCurve = require('zrender/graphic/shape/BezierCurve');\n    graphic.Arc = require('zrender/graphic/shape/Arc');\n    graphic.CompoundPath = require('zrender/graphic/CompoundPath');\n    graphic.LinearGradient = require('zrender/graphic/LinearGradient');\n    graphic.RadialGradient = require('zrender/graphic/RadialGradient');\n    graphic.BoundingRect = require('zrender/core/BoundingRect');\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                } else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n            this.resizePath(path, rect);\n        }\n        return path;\n    };\n    graphic.mergePath = pathTool.mergePath, graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n        var pathRect = path.getBoundingRect();\n        var m = pathRect.calculateTransform(rect);\n        path.applyTransform(m);\n    };\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x, originWidth === 0 ? 0 : 1);\n        shape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y, originHeight === 0 ? 0 : 1);\n        return param;\n    };\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                if (hoverStyle.hasOwnProperty(name)) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n            el.__normalStl = normalStyle;\n            el.__hoverStlDirty = false;\n        }\n    }\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n        cacheElementStl(el);\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        } else {\n            el.setStyle(el.__hoverStl);\n            el.z2 += 1;\n        }\n        el.__isHover = true;\n    }\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        } else {\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n        el.__isHover = false;\n    }\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group' ? el.traverse(function (child) {\n            if (child.type !== 'group') {\n                doSingleEnterHover(child);\n            }\n        }) : doSingleEnterHover(el);\n    }\n    function doLeaveHover(el) {\n        el.type === 'group' ? el.traverse(function (child) {\n            if (child.type !== 'group') {\n                doSingleLeaveHover(child);\n            }\n        }) : doSingleLeaveHover(el);\n    }\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n    /**\n     * @inner\n     */\n    function onElementMouseOver() {\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n    /**\n     * @inner\n     */\n    function onElementMouseOut() {\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n    /**\n     * Set hover style of element\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     */\n    graphic.setHoverStyle = function (el, hoverStyle) {\n        el.type === 'group' ? el.traverse(function (child) {\n            if (child.type !== 'group') {\n                setElementHoverStl(child, hoverStyle);\n            }\n        }) : setElementHoverStl(el, hoverStyle);\n        // Remove previous bound handlers\n        el.on('mouseover', onElementMouseOver).on('mouseout', onElementMouseOut);\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis).on('normal', leaveEmphasis);\n    };\n    /**\n     * Set text option in the style\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string} color\n     */\n    graphic.setText = function (textStyle, labelModel, color) {\n        var labelPosition = labelModel.getShallow('position') || 'inside';\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n        var textStyleModel = labelModel.getModel('textStyle');\n        zrUtil.extend(textStyle, {\n            textDistance: labelModel.getShallow('distance') || 5,\n            textFont: textStyleModel.getFont(),\n            textPosition: labelPosition,\n            textFill: textStyleModel.getTextColor() || labelColor\n        });\n    };\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        var animationEnabled = animatableModel && (animatableModel.ifEnableAnimation ? animatableModel.ifEnableAnimation() : animatableModel.getShallow('animation'));\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel && animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel && animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel && animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(dataIndex);\n            }\n            duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb) : (el.attr(props), cb && cb());\n        } else {\n            el.attr(props);\n            cb && cb();\n        }\n    }\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n        return mat;\n    };\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} vertex [x, y]\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (vertex, transform, invert) {\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], vertex, transform);\n    };\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);\n        var vertex = [\n                direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n                direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n            ];\n        vertex = graphic.applyTransform(vertex, transform, invert);\n        return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n    };\n    /**\n     * Apply group transition animation from g1 to g2\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                    position: vector.clone(el.position),\n                    rotation: el.rotation\n                };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }    // else {\n                     //     if (el.previousProps) {\n                     //         graphic.updateProps\n                     //     }\n                     // }\n            }\n        });\n    };\n    return graphic;\n});\ndefine('echarts/component/axis', ['require', '../coord/cartesian/AxisModel', './axis/AxisView'], function (require) {\n    'use strict';\n    require('../coord/cartesian/AxisModel');\n    require('./axis/AxisView');\n});\ndefine('echarts/util/layout', ['require', 'zrender/core/util', 'zrender/core/BoundingRect', './number', './format'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var BoundingRect = require('zrender/core/BoundingRect');\n    var numberUtil = require('./number');\n    var formatUtil = require('./format');\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n    var layout = {};\n    var LOCATION_PARAMS = [\n            'left',\n            'right',\n            'top',\n            'bottom',\n            'width',\n            'height'\n        ];\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                } else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            } else {\n                var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                } else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n            if (child.newline) {\n                return;\n            }\n            position[0] = x;\n            position[1] = y;\n            orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n        });\n    }\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n        margin = formatUtil.normalizeCssArray(margin || 0);\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (positionInfo, containerRect, margin) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n        // If width and height are not given\n        // 1. Graph should not exceeds the container\n        // 2. Aspect must be keeped\n        // 3. Graph should take the space as more as possible\n        if (isNaN(width) && isNaN(height)) {\n            if (aspect > containerWidth / containerHeight) {\n                width = containerWidth * 0.8;\n            } else {\n                height = containerHeight * 0.8;\n            }\n        }\n        if (aspect != null) {\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n        case 'center':\n            left = containerWidth / 2 - width / 2 - margin[3];\n            break;\n        case 'right':\n            left = containerWidth - width - horizontalMargin;\n            break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n        case 'middle':\n        case 'center':\n            top = containerHeight / 2 - height / 2 - margin[0];\n            break;\n        case 'bottom':\n            top = containerHeight - height - verticalMargin;\n            break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - top - (bottom || 0);\n        }\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n    /**\n     * Position group of component in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     */\n    layout.positionGroup = function (group, positionInfo, containerRect, margin) {\n        var groupRect = group.getBoundingRect();\n        positionInfo = zrUtil.extend(zrUtil.clone(positionInfo), {\n            width: groupRect.width,\n            height: groupRect.height\n        });\n        positionInfo = layout.getLayoutRect(positionInfo, containerRect, margin);\n        group.attr('position', [\n            positionInfo.x - groupRect.x,\n            positionInfo.y - groupRect.y\n        ]);\n    };\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n        var hNames = [\n                'width',\n                'left',\n                'right'\n            ];\n        // Order by priority.\n        var vNames = [\n                'height',\n                'top',\n                'bottom'\n            ];\n        // Order by priority.\n        var hResult = merge(hNames);\n        var vResult = merge(vNames);\n        copy(hNames, targetOption, hResult);\n        copy(vNames, targetOption, vResult);\n        function merge(names) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = opt.ignoreSize ? 1 : 2;\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }    // Case: newOption: {width: ..., right: ...},\n                 // Than we can make sure user only want those two, and ignore\n                 // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            } else {\n                // Chose another param from targetOption by priority.\n                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n    return layout;\n});\ndefine('echarts/util/number', ['require'], function (require) {\n    var number = {};\n    var RADIAN_EPSILON = 0.0001;\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n        if (subDomain === 0) {\n            return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;\n        }\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                } else if (val >= domain[1]) {\n                    return range[1];\n                }\n            } else {\n                if (val >= domain[0]) {\n                    return range[0];\n                } else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        } else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function (percent, all) {\n        switch (percent) {\n        case 'center':\n        case 'middle':\n            percent = '50%';\n            break;\n        case 'left':\n        case 'top':\n            percent = '0%';\n            break;\n        case 'right':\n        case 'bottom':\n            percent = '100%';\n            break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n            return parseFloat(percent);\n        }\n        return percent == null ? NaN : +percent;\n    };\n    /**\n     * Fix rounding error of float numbers\n     * @param {number} x\n     * @return {number}\n     */\n    number.round = function (x, precision) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // PENDING\n        return +(+x).toFixed(precision);\n    };\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n        var dotIndex = str.indexOf('.');\n        if (dotIndex < 0) {\n            return 0;\n        }\n        return str.length - 1 - dotIndex;\n    };\n    /**\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number}  precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        return Math.max(-dataQuantity + sizeQuantity, 0);\n    };\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n    /**\n     * @param {string|Date|number} value\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        } else if (typeof value === 'string') {\n            // Treat as ISO format. See issue #3623\n            var ret = new Date(value);\n            if (isNaN(+ret)) {\n                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local\n                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));\n            }\n            return ret;\n        }\n        return new Date(Math.round(value));\n    };\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));\n    };\n    // \"Nice Numbers for Graph Labels\" of Graphic Gems\n    /**\n     * find a “nice” number approximately equal to x. Round the number if round = true, take ceiling if round = false\n     * The primary observation is that the “nicest” numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     * @param  {number} val\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exp10 = number.quantity(val);\n        var f = val / exp10;\n        // between 1 and 10\n        var nf;\n        if (round) {\n            if (f < 1.5) {\n                nf = 1;\n            } else if (f < 2.5) {\n                nf = 2;\n            } else if (f < 4) {\n                nf = 3;\n            } else if (f < 7) {\n                nf = 5;\n            } else {\n                nf = 10;\n            }\n        } else {\n            if (f < 1) {\n                nf = 1;\n            } else if (f < 2) {\n                nf = 2;\n            } else if (f < 3) {\n                nf = 3;\n            } else if (f < 5) {\n                nf = 5;\n            } else {\n                nf = 10;\n            }\n        }\n        return nf * exp10;\n    };\n    return number;\n});\ndefine('echarts/util/format', ['require', 'zrender/core/util', './number', 'zrender/contain/text'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var numberUtil = require('./number');\n    var textContain = require('zrender/contain/text');\n    var formatUtil = {};\n    /**\n     * 每三位默认加,格式化\n     * @type {string|number} x\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g, '$1,') + (x.length > 1 ? '.' + x[1] : '');\n    };\n    /**\n     * @param {string} str\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str) {\n        return str.toLowerCase().replace(/-(.)/g, function (match, group1) {\n            return group1.toUpperCase();\n        });\n    };\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     */\n    formatUtil.normalizeCssArray = function (val) {\n        var len = val.length;\n        if (typeof val === 'number') {\n            return [\n                val,\n                val,\n                val,\n                val\n            ];\n        } else if (len === 2) {\n            // vertical | horizontal\n            return [\n                val[0],\n                val[1],\n                val[0],\n                val[1]\n            ];\n        } else if (len === 3) {\n            // top | horizontal | bottom\n            return [\n                val[0],\n                val[1],\n                val[2],\n                val[1]\n            ];\n        }\n        return val;\n    };\n    formatUtil.encodeHTML = function (source) {\n        return String(source).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;');\n    };\n    var TPL_VAR_ALIAS = [\n            'a',\n            'b',\n            'c',\n            'd',\n            'e',\n            'f',\n            'g'\n        ];\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n    /**\n     * Template formatter\n     * @param  {string} tpl\n     * @param  {Array.<Object>|Object} paramsList\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), paramsList[seriesIdx][$vars[k]]);\n            }\n        }\n        return tpl;\n    };\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? '0' + str : str;\n    };\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value) {\n        if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {\n            tpl = 'MM-dd\\nyyyy';\n        }\n        var date = numberUtil.parseDate(value);\n        var y = date.getFullYear();\n        var M = date.getMonth() + 1;\n        var d = date.getDate();\n        var h = date.getHours();\n        var m = date.getMinutes();\n        var s = date.getSeconds();\n        tpl = tpl.replace('MM', s2d(M)).toLowerCase().replace('yyyy', y).replace('yy', y % 100).replace('dd', s2d(d)).replace('d', d).replace('hh', s2d(h)).replace('h', h).replace('mm', s2d(m)).replace('m', m).replace('ss', s2d(s)).replace('s', s);\n        return tpl;\n    };\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n    formatUtil.truncateText = textContain.truncateText;\n    return formatUtil;\n});\ndefine('echarts/scale/Interval', ['require', '../util/number', '../util/format', './Scale'], function (require) {\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var Scale = require('./Scale');\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n            type: 'interval',\n            _interval: 0,\n            setExtent: function (start, end) {\n                var thisExtent = this._extent;\n                //start,end may be a Number like '25',so...\n                if (!isNaN(start)) {\n                    thisExtent[0] = parseFloat(start);\n                }\n                if (!isNaN(end)) {\n                    thisExtent[1] = parseFloat(end);\n                }\n            },\n            unionExtent: function (other) {\n                var extent = this._extent;\n                other[0] < extent[0] && (extent[0] = other[0]);\n                other[1] > extent[1] && (extent[1] = other[1]);\n                // unionExtent may called by it's sub classes\n                IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n            },\n            getInterval: function () {\n                if (!this._interval) {\n                    this.niceTicks();\n                }\n                return this._interval;\n            },\n            setInterval: function (interval) {\n                this._interval = interval;\n                // Dropped auto calculated niceExtent and use user setted extent\n                // We assume user wan't to set both interval, min, max to get a better result\n                this._niceExtent = this._extent.slice();\n            },\n            getTicks: function () {\n                if (!this._interval) {\n                    this.niceTicks();\n                }\n                var interval = this._interval;\n                var extent = this._extent;\n                var ticks = [];\n                // Consider this case: using dataZoom toolbox, zoom and zoom.\n                var safeLimit = 10000;\n                if (interval) {\n                    var niceExtent = this._niceExtent;\n                    var precision = getPrecisionSafe(interval) + 2;\n                    if (extent[0] < niceExtent[0]) {\n                        ticks.push(extent[0]);\n                    }\n                    var tick = niceExtent[0];\n                    while (tick <= niceExtent[1]) {\n                        ticks.push(tick);\n                        // Avoid rounding error\n                        tick = roundingErrorFix(tick + interval, precision);\n                        if (ticks.length > safeLimit) {\n                            return [];\n                        }\n                    }\n                    if (extent[1] > niceExtent[1]) {\n                        ticks.push(extent[1]);\n                    }\n                }\n                return ticks;\n            },\n            getTicksLabels: function () {\n                var labels = [];\n                var ticks = this.getTicks();\n                for (var i = 0; i < ticks.length; i++) {\n                    labels.push(this.getLabel(ticks[i]));\n                }\n                return labels;\n            },\n            getLabel: function (data) {\n                return formatUtil.addCommas(data);\n            },\n            niceTicks: function (splitNumber) {\n                splitNumber = splitNumber || 5;\n                var extent = this._extent;\n                var span = extent[1] - extent[0];\n                if (!isFinite(span)) {\n                    return;\n                }\n                // User may set axis min 0 and data are all negative\n                // FIXME If it needs to reverse ?\n                if (span < 0) {\n                    span = -span;\n                    extent.reverse();\n                }\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceSpan = numberUtil.nice(span, false);\n                var step = roundingErrorFix(numberUtil.nice(span / splitNumber, true), Math.max(getPrecisionSafe(extent[0]), getPrecisionSafe(extent[1])) + 2);\n                var precision = getPrecisionSafe(step) + 2;\n                // Niced extent inside original extent\n                var niceExtent = [\n                        roundingErrorFix(mathCeil(extent[0] / step) * step, precision),\n                        roundingErrorFix(mathFloor(extent[1] / step) * step, precision)\n                    ];\n                this._interval = step;\n                this._niceExtent = niceExtent;\n            },\n            niceExtent: function (splitNumber, fixMin, fixMax) {\n                var extent = this._extent;\n                // If extent start and end are same, expand them\n                if (extent[0] === extent[1]) {\n                    if (extent[0] !== 0) {\n                        // Expand extent\n                        var expandSize = extent[0];\n                        // In the fowllowing case\n                        //      Axis has been fixed max 100\n                        //      Plus data are all 100 and axis extent are [100, 100].\n                        // Extend to the both side will cause expanded max is larger than fixed max.\n                        // So only expand to the smaller side.\n                        if (!fixMax) {\n                            extent[1] += expandSize / 2;\n                            extent[0] -= expandSize / 2;\n                        } else {\n                            extent[0] -= expandSize / 2;\n                        }\n                    } else {\n                        extent[1] = 1;\n                    }\n                }\n                var span = extent[1] - extent[0];\n                // If there are no data and extent are [Infinity, -Infinity]\n                if (!isFinite(span)) {\n                    extent[0] = 0;\n                    extent[1] = 1;\n                }\n                this.niceTicks(splitNumber);\n                // var extent = this._extent;\n                var interval = this._interval;\n                if (!fixMin) {\n                    extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);\n                }\n                if (!fixMax) {\n                    extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);\n                }\n            }\n        });\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n    return IntervalScale;\n});\ndefine('zrender/core/env', [], function () {\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            canvasSupported: true\n        };\n    } else {\n        env = detect(navigator.userAgent);\n    }\n    return env;\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/) || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/);\n        // IE 12 and 12+\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox)\n            browser.firefox = true, browser.version = firefox[1];\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            canvasSupported: document.createElement('canvas').getContext ? true : false,\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            pointerEventsSupported: 'onpointerdown' in window && (browser.edge || browser.ie && browser.version >= 10)\n        };\n    }\n});\ndefine('echarts/ExtensionAPI', ['require', 'zrender/core/util'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var echartsAPIList = [\n            'getDom',\n            'getZr',\n            'getWidth',\n            'getHeight',\n            'dispatchAction',\n            'isDisposed',\n            'on',\n            'off',\n            'getDataURL',\n            'getConnectedDataURL',\n            'getModel',\n            'getOption'\n        ];\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n    return ExtensionAPI;\n});\ndefine('echarts/model/Global', ['require', 'zrender/core/util', '../util/model', './Model', './Component', './globalDefault', './mixin/colorPalette'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../util/model');\n    var Model = require('./Model');\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n    var ComponentModel = require('./Component');\n    var globalDefault = require('./globalDefault');\n    var OPTION_INNER_KEY = '\u0000_ec_inner';\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n            constructor: GlobalModel,\n            init: function (option, parentModel, theme, optionManager) {\n                theme = theme || {};\n                this.option = null;\n                // Mark as not initialized.\n                /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n                this._theme = new Model(theme);\n                /**\n             * @type {module:echarts/model/OptionManager}\n             */\n                this._optionManager = optionManager;\n            },\n            setOption: function (option, optionPreprocessorFuncs) {\n                zrUtil.assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');\n                this._optionManager.setOption(option, optionPreprocessorFuncs);\n                this.resetOption();\n            },\n            resetOption: function (type) {\n                var optionChanged = false;\n                var optionManager = this._optionManager;\n                if (!type || type === 'recreate') {\n                    var baseOption = optionManager.mountOption(type === 'recreate');\n                    if (!this.option || type === 'recreate') {\n                        initBase.call(this, baseOption);\n                    } else {\n                        this.restoreData();\n                        this.mergeOption(baseOption);\n                    }\n                    optionChanged = true;\n                }\n                if (type === 'timeline' || type === 'media') {\n                    this.restoreData();\n                }\n                if (!type || type === 'recreate' || type === 'timeline') {\n                    var timelineOption = optionManager.getTimelineOption(this);\n                    timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n                }\n                if (!type || type === 'recreate' || type === 'media') {\n                    var mediaOptions = optionManager.getMediaOption(this, this._api);\n                    if (mediaOptions.length) {\n                        each(mediaOptions, function (mediaOption) {\n                            this.mergeOption(mediaOption, optionChanged = true);\n                        }, this);\n                    }\n                }\n                return optionChanged;\n            },\n            mergeOption: function (newOption) {\n                var option = this.option;\n                var componentsMap = this._componentsMap;\n                var newCptTypes = [];\n                // 如果不存在对应的 component model 则直接 merge\n                each(newOption, function (componentOption, mainType) {\n                    if (componentOption == null) {\n                        return;\n                    }\n                    if (!ComponentModel.hasClass(mainType)) {\n                        option[mainType] = option[mainType] == null ? zrUtil.clone(componentOption) : zrUtil.merge(option[mainType], componentOption, true);\n                    } else {\n                        newCptTypes.push(mainType);\n                    }\n                });\n                // FIXME OPTION 同步是否要改回原来的\n                ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n                this._seriesIndices = this._seriesIndices || [];\n                function visitComponent(mainType, dependencies) {\n                    var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n                    var mapResult = modelUtil.mappingToExists(componentsMap[mainType], newCptOptionList);\n                    makeKeyInfo(mainType, mapResult);\n                    var dependentModels = getComponentsByTypes(componentsMap, dependencies);\n                    option[mainType] = [];\n                    componentsMap[mainType] = [];\n                    each(mapResult, function (resultItem, index) {\n                        var componentModel = resultItem.exist;\n                        var newCptOption = resultItem.option;\n                        zrUtil.assert(isObject(newCptOption) || componentModel, 'Empty component definition');\n                        // Consider where is no new option and should be merged using {},\n                        // see removeEdgeAndAdd in topologicalTravel and\n                        // ComponentModel.getAllClassMainTypes.\n                        if (!newCptOption) {\n                            componentModel.mergeOption({}, this);\n                            componentModel.optionUpdated({}, false);\n                        } else {\n                            var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\n                            if (componentModel && componentModel instanceof ComponentModelClass) {\n                                componentModel.mergeOption(newCptOption, this);\n                                componentModel.optionUpdated(newCptOption, false);\n                            } else {\n                                // PENDING Global as parent ?\n                                var extraOpt = zrUtil.extend({\n                                        dependentModels: dependentModels,\n                                        componentIndex: index\n                                    }, resultItem.keyInfo);\n                                componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);\n                                componentModel.init(newCptOption, this, this, extraOpt);\n                                // Call optionUpdated after init.\n                                // newCptOption has been used as componentModel.option\n                                // and may be merged with theme and default, so pass null\n                                // to avoid confusion.\n                                componentModel.optionUpdated(null, true);\n                            }\n                        }\n                        componentsMap[mainType][index] = componentModel;\n                        option[mainType][index] = componentModel.option;\n                    }, this);\n                    // Backup series for filtering.\n                    if (mainType === 'series') {\n                        this._seriesIndices = createSeriesIndices(componentsMap.series);\n                    }\n                }\n            },\n            getOption: function () {\n                var option = zrUtil.clone(this.option);\n                each(option, function (opts, mainType) {\n                    if (ComponentModel.hasClass(mainType)) {\n                        var opts = modelUtil.normalizeToArray(opts);\n                        for (var i = opts.length - 1; i >= 0; i--) {\n                            // Remove options with inner id.\n                            if (modelUtil.isIdInner(opts[i])) {\n                                opts.splice(i, 1);\n                            }\n                        }\n                        option[mainType] = opts;\n                    }\n                });\n                delete option[OPTION_INNER_KEY];\n                return option;\n            },\n            getTheme: function () {\n                return this._theme;\n            },\n            getComponent: function (mainType, idx) {\n                var list = this._componentsMap[mainType];\n                if (list) {\n                    return list[idx || 0];\n                }\n            },\n            queryComponents: function (condition) {\n                var mainType = condition.mainType;\n                if (!mainType) {\n                    return [];\n                }\n                var index = condition.index;\n                var id = condition.id;\n                var name = condition.name;\n                var cpts = this._componentsMap[mainType];\n                if (!cpts || !cpts.length) {\n                    return [];\n                }\n                var result;\n                if (index != null) {\n                    if (!isArray(index)) {\n                        index = [index];\n                    }\n                    result = filter(map(index, function (idx) {\n                        return cpts[idx];\n                    }), function (val) {\n                        return !!val;\n                    });\n                } else if (id != null) {\n                    var isIdArray = isArray(id);\n                    result = filter(cpts, function (cpt) {\n                        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;\n                    });\n                } else if (name != null) {\n                    var isNameArray = isArray(name);\n                    result = filter(cpts, function (cpt) {\n                        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;\n                    });\n                } else {\n                    // Return all components with mainType\n                    result = cpts;\n                }\n                return filterBySubType(result, condition);\n            },\n            findComponents: function (condition) {\n                var query = condition.query;\n                var mainType = condition.mainType;\n                var queryCond = getQueryCond(query);\n                var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap[mainType];\n                return doFilter(filterBySubType(result, condition));\n                function getQueryCond(q) {\n                    var indexAttr = mainType + 'Index';\n                    var idAttr = mainType + 'Id';\n                    var nameAttr = mainType + 'Name';\n                    return q && (q.hasOwnProperty(indexAttr) || q.hasOwnProperty(idAttr) || q.hasOwnProperty(nameAttr)) ? {\n                        mainType: mainType,\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    } : null;\n                }\n                function doFilter(res) {\n                    return condition.filter ? filter(res, condition.filter) : res;\n                }\n            },\n            eachComponent: function (mainType, cb, context) {\n                var componentsMap = this._componentsMap;\n                if (typeof mainType === 'function') {\n                    context = cb;\n                    cb = mainType;\n                    each(componentsMap, function (components, componentType) {\n                        each(components, function (component, index) {\n                            cb.call(context, componentType, component, index);\n                        });\n                    });\n                } else if (zrUtil.isString(mainType)) {\n                    each(componentsMap[mainType], cb, context);\n                } else if (isObject(mainType)) {\n                    var queryResult = this.findComponents(mainType);\n                    each(queryResult, cb, context);\n                }\n            },\n            getSeriesByName: function (name) {\n                var series = this._componentsMap.series;\n                return filter(series, function (oneSeries) {\n                    return oneSeries.name === name;\n                });\n            },\n            getSeriesByIndex: function (seriesIndex) {\n                return this._componentsMap.series[seriesIndex];\n            },\n            getSeriesByType: function (subType) {\n                var series = this._componentsMap.series;\n                return filter(series, function (oneSeries) {\n                    return oneSeries.subType === subType;\n                });\n            },\n            getSeries: function () {\n                return this._componentsMap.series.slice();\n            },\n            eachSeries: function (cb, context) {\n                assertSeriesInitialized(this);\n                each(this._seriesIndices, function (rawSeriesIndex) {\n                    var series = this._componentsMap.series[rawSeriesIndex];\n                    cb.call(context, series, rawSeriesIndex);\n                }, this);\n            },\n            eachRawSeries: function (cb, context) {\n                each(this._componentsMap.series, cb, context);\n            },\n            eachSeriesByType: function (subType, cb, context) {\n                assertSeriesInitialized(this);\n                each(this._seriesIndices, function (rawSeriesIndex) {\n                    var series = this._componentsMap.series[rawSeriesIndex];\n                    if (series.subType === subType) {\n                        cb.call(context, series, rawSeriesIndex);\n                    }\n                }, this);\n            },\n            eachRawSeriesByType: function (subType, cb, context) {\n                return each(this.getSeriesByType(subType), cb, context);\n            },\n            isSeriesFiltered: function (seriesModel) {\n                assertSeriesInitialized(this);\n                return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n            },\n            filterSeries: function (cb, context) {\n                assertSeriesInitialized(this);\n                var filteredSeries = filter(this._componentsMap.series, cb, context);\n                this._seriesIndices = createSeriesIndices(filteredSeries);\n            },\n            restoreData: function () {\n                var componentsMap = this._componentsMap;\n                this._seriesIndices = createSeriesIndices(componentsMap.series);\n                var componentTypes = [];\n                each(componentsMap, function (components, componentType) {\n                    componentTypes.push(componentType);\n                });\n                ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {\n                    each(componentsMap[componentType], function (component) {\n                        component.restoreData();\n                    });\n                });\n            }\n        });\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        for (var name in theme) {\n            // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理\n            if (!ComponentModel.hasClass(name)) {\n                if (typeof theme[name] === 'object') {\n                    option[name] = !option[name] ? zrUtil.clone(theme[name]) : zrUtil.merge(option[name], theme[name], false);\n                } else {\n                    if (option[name] == null) {\n                        option[name] = theme[name];\n                    }\n                }\n            }\n        }\n    }\n    function initBase(baseOption) {\n        baseOption = baseOption;\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n        /**\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = {};\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n        mergeTheme(baseOption, this._theme.option);\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n        this.mergeOption(baseOption);\n    }\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap[type] || []).slice();\n        });\n        return ret;\n    }\n    /**\n     * @inner\n     */\n    function makeKeyInfo(mainType, mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n        // Ensure that each id is distinct.\n        var idMap = {};\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && (idMap[existCpt.id] = item);\n        });\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n            zrUtil.assert(!opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item, 'id duplicates: ' + (opt && opt.id));\n            opt && opt.id != null && (idMap[opt.id] = item);\n            // Complete subType\n            if (isObject(opt)) {\n                var subType = determineSubType(mainType, opt, item.exist);\n                item.keyInfo = {\n                    mainType: mainType,\n                    subType: subType\n                };\n            }\n        });\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n            if (!isObject(opt)) {\n                return;\n            }\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name : '\u0000-';\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            } else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            } else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\u0000' + keyInfo.name + '\u0000' + idNum++;\n                } while (idMap[keyInfo.id]);\n            }\n            idMap[keyInfo.id] = item;\n        });\n    }\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType : ComponentModel.determineSubType(mainType, newCptOption);\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {\n            return cpt.subType === condition.subType;\n        }) : components;\n    }\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (true) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Series has not been initialized yet.');\n            }\n        }\n    }\n    zrUtil.mixin(GlobalModel, require('./mixin/colorPalette'));\n    return GlobalModel;\n});\ndefine('echarts/model/OptionManager', ['require', 'zrender/core/util', '../util/model', './Component'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n    var QUERY_REG = /^(min|max)?(.+)$/;\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n    OptionManager.prototype = {\n        constructor: OptionManager,\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n            // FIXME\n            // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);\n            this._newBaseOption = newParsedOption.baseOption;\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            } else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n            // TODO\n            // 如果没有reset功能则不clone。\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n            return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);\n        },\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);\n                }\n            }\n            return option;\n        },\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n            // FIXME\n            // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\n                });\n            }\n            // Otherwise return nothing.\n            this._currentMediaIndices = indices;\n            return result;\n        }\n    };\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    } else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n        // Preprocess.\n        each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {\n            return media.option;\n        })), function (option) {\n            each(optionPreprocessorFuncs, function (preProcess) {\n                preProcess(option, isNew);\n            });\n        });\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n                width: ecWidth,\n                height: ecHeight,\n                aspectratio: ecWidth / ecHeight\n            };\n        var applicatable = true;\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n        return applicatable;\n    }\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        } else if (operator === 'max') {\n            return real <= expect;\n        } else {\n            // Equals\n            return real === expect;\n        }\n    }\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n            var oldCptOpt = oldOption[mainType];\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            } else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;\n                });\n            }\n        });\n    }\n    return OptionManager;\n});\ndefine('echarts/CoordinateSystem', ['require'], function (require) {\n    'use strict';\n    var coordinateSystemCreators = {};\n    function CoordinateSystemManager() {\n        this._coordinateSystems = [];\n    }\n    CoordinateSystemManager.prototype = {\n        constructor: CoordinateSystemManager,\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            for (var type in coordinateSystemCreators) {\n                var list = coordinateSystemCreators[type].create(ecModel, api);\n                list && (coordinateSystems = coordinateSystems.concat(list));\n            }\n            this._coordinateSystems = coordinateSystems;\n        },\n        update: function (ecModel, api) {\n            var coordinateSystems = this._coordinateSystems;\n            for (var i = 0; i < coordinateSystems.length; i++) {\n                // FIXME MUST have\n                coordinateSystems[i].update && coordinateSystems[i].update(ecModel, api);\n            }\n        }\n    };\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n    return CoordinateSystemManager;\n});\ndefine('echarts/model/Series', ['require', 'zrender/core/util', '../util/format', '../util/model', './Component', './mixin/colorPalette', 'zrender/core/env'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var formatUtil = require('../util/format');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var colorPaletteMixin = require('./mixin/colorPalette');\n    var env = require('zrender/core/env');\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n    var SeriesModel = ComponentModel.extend({\n            type: 'series.__base__',\n            seriesIndex: 0,\n            coordinateSystem: null,\n            defaultOption: null,\n            legendDataProvider: null,\n            visualColorAccessPath: 'itemStyle.normal.color',\n            init: function (option, parentModel, ecModel, extraOpt) {\n                /**\n             * @type {number}\n             * @readOnly\n             */\n                this.seriesIndex = this.componentIndex;\n                this.mergeDefaultAndTheme(option, ecModel);\n                /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n                this._dataBeforeProcessed = this.getInitialData(option, ecModel);\n                // If we reverse the order (make this._data firstly, and then make\n                // this._dataBeforeProcessed by cloneShallow), cloneShallow will\n                // cause this._data.graph.data !== this._data when using\n                // module:echarts/data/Graph or module:echarts/data/Tree.\n                // See module:echarts/data/helper/linkList\n                this._data = this._dataBeforeProcessed.cloneShallow();\n            },\n            mergeDefaultAndTheme: function (option, ecModel) {\n                zrUtil.merge(option, ecModel.getTheme().get(this.subType));\n                zrUtil.merge(option, this.getDefaultOption());\n                // Default label emphasis `position` and `show`\n                // FIXME Set label in mergeOption\n                modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n                this.fillDataTextStyle(option.data);\n            },\n            mergeOption: function (newSeriesOption, ecModel) {\n                newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n                this.fillDataTextStyle(newSeriesOption.data);\n                var data = this.getInitialData(newSeriesOption, ecModel);\n                // TODO Merge data?\n                if (data) {\n                    this._data = data;\n                    this._dataBeforeProcessed = data.cloneShallow();\n                }\n            },\n            fillDataTextStyle: function (data) {\n                // Default data label emphasis `position` and `show`\n                // FIXME Tree structure data ?\n                // FIXME Performance ?\n                if (data) {\n                    for (var i = 0; i < data.length; i++) {\n                        if (data[i] && data[i].label) {\n                            modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n                        }\n                    }\n                }\n            },\n            getInitialData: function () {\n            },\n            getData: function (dataType) {\n                return dataType == null ? this._data : this._data.getLinkedData(dataType);\n            },\n            setData: function (data) {\n                this._data = data;\n            },\n            getRawData: function () {\n                return this._dataBeforeProcessed;\n            },\n            coordDimToDataDim: function (coordDim) {\n                return [coordDim];\n            },\n            dataDimToCoordDim: function (dataDim) {\n                return dataDim;\n            },\n            getBaseAxis: function () {\n                var coordSys = this.coordinateSystem;\n                return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n            },\n            formatTooltip: function (dataIndex, multipleSeries, dataType) {\n                function formatArrayValue(value) {\n                    return zrUtil.map(value, function (val, idx) {\n                        var dimInfo = data.getDimensionInfo(idx);\n                        var dimType = dimInfo && dimInfo.type;\n                        if (dimType === 'ordinal') {\n                            return val;\n                        } else if (dimType === 'time') {\n                            return multipleSeries ? '' : formatUtil.formatTime('yyyy/mm/dd hh:mm:ss', val);\n                        } else {\n                            return addCommas(val);\n                        }\n                    }).filter(function (val) {\n                        return !!val;\n                    }).join(', ');\n                }\n                var data = this._data;\n                var value = this.getRawValue(dataIndex);\n                var formattedValue = zrUtil.isArray(value) ? formatArrayValue(value) : addCommas(value);\n                var name = data.getName(dataIndex);\n                var color = data.getItemVisual(dataIndex, 'color');\n                var colorEl = '<span style=\"display:inline-block;margin-right:5px;' + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '\"></span>';\n                var seriesName = this.name;\n                // FIXME\n                if (seriesName === '\u0000-') {\n                    // Not show '-'\n                    seriesName = '';\n                }\n                return !multipleSeries ? (seriesName && encodeHTML(seriesName) + '<br />') + colorEl + (name ? encodeHTML(name) + ' : ' + formattedValue : formattedValue) : colorEl + encodeHTML(this.name) + ' : ' + formattedValue;\n            },\n            ifEnableAnimation: function () {\n                if (env.node) {\n                    return false;\n                }\n                var animationEnabled = this.getShallow('animation');\n                if (animationEnabled) {\n                    if (this.getData().count() > this.getShallow('animationThreshold')) {\n                        animationEnabled = false;\n                    }\n                }\n                return animationEnabled;\n            },\n            restoreData: function () {\n                this._data = this._dataBeforeProcessed.cloneShallow();\n            },\n            getColorFromPalette: function (name, scope) {\n                var ecModel = this.ecModel;\n                // PENDING\n                var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n                if (!color) {\n                    color = ecModel.getColorFromPalette(name, scope);\n                }\n                return color;\n            },\n            getAxisTooltipDataIndex: null\n        });\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n    return SeriesModel;\n});\ndefine('echarts/model/Component', ['require', './Model', 'zrender/core/util', '../util/component', '../util/clazz', '../util/layout', './mixin/boxLayout'], function (require) {\n    var Model = require('./Model');\n    var zrUtil = require('zrender/core/util');\n    var arrayPush = Array.prototype.push;\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var layout = require('../util/layout');\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n            type: 'component',\n            id: '',\n            name: '',\n            mainType: '',\n            subType: '',\n            componentIndex: 0,\n            defaultOption: null,\n            ecModel: null,\n            dependentModels: [],\n            uid: null,\n            layoutMode: null,\n            $constructor: function (option, parentModel, ecModel, extraOpt) {\n                Model.call(this, option, parentModel, ecModel, extraOpt);\n                // Set dependentModels, componentIndex, name, id, mainType, subType.\n                zrUtil.extend(this, extraOpt);\n                this.uid = componentUtil.getUID('componentModel');\n            },\n            init: function (option, parentModel, ecModel, extraOpt) {\n                this.mergeDefaultAndTheme(option, ecModel);\n            },\n            mergeDefaultAndTheme: function (option, ecModel) {\n                var layoutMode = this.layoutMode;\n                var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};\n                var themeModel = ecModel.getTheme();\n                zrUtil.merge(option, themeModel.get(this.mainType));\n                zrUtil.merge(option, this.getDefaultOption());\n                if (layoutMode) {\n                    layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                }\n            },\n            mergeOption: function (option) {\n                zrUtil.merge(this.option, option, true);\n                var layoutMode = this.layoutMode;\n                if (layoutMode) {\n                    layout.mergeLayoutParam(this.option, option, layoutMode);\n                }\n            },\n            optionUpdated: function (newCptOption, isInit) {\n            },\n            getDefaultOption: function () {\n                if (!this.hasOwnProperty('__defaultOption')) {\n                    var optList = [];\n                    var Class = this.constructor;\n                    while (Class) {\n                        var opt = Class.prototype.defaultOption;\n                        opt && optList.push(opt);\n                        Class = Class.superClass;\n                    }\n                    var defaultOption = {};\n                    for (var i = optList.length - 1; i >= 0; i--) {\n                        defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                    }\n                    this.__defaultOption = defaultOption;\n                }\n                return this.__defaultOption;\n            }\n        });\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n    //         this.uid = componentUtil.getUID('componentModel');\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(ComponentModel, { registerWhenExtend: true });\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n    zrUtil.mixin(ComponentModel, require('./mixin/boxLayout'));\n    return ComponentModel;\n});\ndefine('echarts/view/Component', ['require', 'zrender/container/Group', '../util/component', '../util/clazz'], function (require) {\n    var Group = require('zrender/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n    Component.prototype = {\n        constructor: Component,\n        init: function (ecModel, api) {\n        },\n        render: function (componentModel, ecModel, api, payload) {\n        },\n        dispose: function () {\n        }\n    };\n    var componentProto = Component.prototype;\n    componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function (seriesModel, ecModel, api, payload) {\n    };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, { registerWhenExtend: true });\n    return Component;\n});\ndefine('echarts/view/Chart', ['require', 'zrender/container/Group', '../util/component', '../util/clazz'], function (require) {\n    var Group = require('zrender/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    function Chart() {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n    Chart.prototype = {\n        type: 'chart',\n        init: function (ecModel, api) {\n        },\n        render: function (seriesModel, ecModel, api, payload) {\n        },\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n        dispose: function () {\n        }\n    };\n    var chartProto = Chart.prototype;\n    chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function (seriesModel, ecModel, api, payload) {\n        this.render(seriesModel, ecModel, api, payload);\n    };\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = payload && payload.dataIndex;\n        var name = payload && payload.name;\n        if (dataIndex != null) {\n            var dataIndices = dataIndex instanceof Array ? dataIndex : [dataIndex];\n            for (var i = 0, len = dataIndices.length; i < len; i++) {\n                elSetState(data.getItemGraphicEl(dataIndices[i]), state);\n            }\n        } else if (name) {\n            var names = name instanceof Array ? name : [name];\n            for (var i = 0, len = names.length; i < len; i++) {\n                var dataIndex = data.indexOfName(names[i]);\n                elSetState(data.getItemGraphicEl(dataIndex), state);\n            }\n        } else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart);\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, { registerWhenExtend: true });\n    return Chart;\n});\ndefine('zrender/zrender', ['require', './core/guid', './core/env', './Handler', './Storage', './animation/Animation', './dom/HandlerProxy', './Painter'], function (require) {\n    var guid = require('./core/guid');\n    var env = require('./core/env');\n    var Handler = require('./Handler');\n    var Storage = require('./Storage');\n    var Animation = require('./animation/Animation');\n    var HandlerProxy = require('./dom/HandlerProxy');\n    var useVML = !env.canvasSupported;\n    var painterCtors = { canvas: require('./Painter') };\n    var instances = {};\n    // ZRender实例map索引\n    var zrender = {};\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.1.3';\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function (dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        } else {\n            for (var key in instances) {\n                instances[key].dispose();\n            }\n            instances = {};\n        }\n        return zrender;\n    };\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n    function delInstance(id) {\n        delete instances[id];\n    }\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     */\n    var ZRender = function (id, dom, opts) {\n        opts = opts || {};\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n        /**\n         * @type {string}\n         */\n        this.id = id;\n        var self = this;\n        var storage = new Storage();\n        var rendererType = opts.renderer;\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        } else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n        this.storage = storage;\n        this.painter = painter;\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy);\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: function () {\n                    if (self._needsRefresh) {\n                        self.refreshImmediately();\n                    }\n                    if (self._needsRefreshHover) {\n                        self.refreshHoverImmediately();\n                    }\n                }\n            }\n        });\n        this.animation.start();\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n        // 修改 storage.delFromMap, 每次删除元素之前删除动画\n        // FIXME 有点ugly\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n            oldDelFromMap.call(storage, elId);\n            el && el.removeSelfFromZr(self);\n        };\n        storage.addToMap = function (el) {\n            oldAddToMap.call(storage, el);\n            el.addSelfToZr(self);\n        };\n    };\n    ZRender.prototype = {\n        constructor: ZRender,\n        getId: function () {\n            return this.id;\n        },\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n        refresh: function () {\n            this._needsRefresh = true;\n        },\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n        resize: function () {\n            this.painter.resize();\n            this.handler.resize();\n        },\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n        getWidth: function () {\n            return this.painter.getWidth();\n        },\n        getHeight: function () {\n            return this.painter.getHeight();\n        },\n        pathToImage: function (e, width, height) {\n            var id = guid();\n            return this.painter.pathToImage(id, e, width, height);\n        },\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n        on: function (eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n        off: function (eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n        dispose: function () {\n            this.animation.stop();\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n            this.animation = this.storage = this.painter = this.handler = null;\n            delInstance(this.id);\n        }\n    };\n    return zrender;\n});\ndefine('zrender/mixin/Eventful', ['require'], function (require) {\n    var arrySlice = Array.prototype.slice;\n    /**\n     * 事件分发器\n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n    Eventful.prototype = {\n        constructor: Eventful,\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n            if (!handler || !event) {\n                return this;\n            }\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n            return this;\n        },\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n            if (!handler || !event) {\n                return this;\n            }\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n            return this;\n        },\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n        off: function (event, handler) {\n            var _h = this._$handlers;\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            } else {\n                delete _h[event];\n            }\n            return this;\n        },\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                    case 1:\n                        _h[i]['h'].call(_h[i]['ctx']);\n                        break;\n                    case 2:\n                        _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                        break;\n                    case 3:\n                        _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                        break;\n                    default:\n                        // have more than 2 given arguments\n                        _h[i]['h'].apply(_h[i]['ctx'], args);\n                        break;\n                    }\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    } else {\n                        i++;\n                    }\n                }\n            }\n            return this;\n        },\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                    case 1:\n                        _h[i]['h'].call(ctx);\n                        break;\n                    case 2:\n                        _h[i]['h'].call(ctx, args[1]);\n                        break;\n                    case 3:\n                        _h[i]['h'].call(ctx, args[1], args[2]);\n                        break;\n                    default:\n                        // have more than 2 given arguments\n                        _h[i]['h'].apply(ctx, args);\n                        break;\n                    }\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    } else {\n                        i++;\n                    }\n                }\n            }\n            return this;\n        }\n    };\n    // 对象可以通过 onxxxx 绑定事件\n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n    return Eventful;\n});\ndefine('zrender/tool/color', ['require'], function (require) {\n    var kCSSColorTable = {\n            'transparent': [\n                0,\n                0,\n                0,\n                0\n            ],\n            'aliceblue': [\n                240,\n                248,\n                255,\n                1\n            ],\n            'antiquewhite': [\n                250,\n                235,\n                215,\n                1\n            ],\n            'aqua': [\n                0,\n                255,\n                255,\n                1\n            ],\n            'aquamarine': [\n                127,\n                255,\n                212,\n                1\n            ],\n            'azure': [\n                240,\n                255,\n                255,\n                1\n            ],\n            'beige': [\n                245,\n                245,\n                220,\n                1\n            ],\n            'bisque': [\n                255,\n                228,\n                196,\n                1\n            ],\n            'black': [\n                0,\n                0,\n                0,\n                1\n            ],\n            'blanchedalmond': [\n                255,\n                235,\n                205,\n                1\n            ],\n            'blue': [\n                0,\n                0,\n                255,\n                1\n            ],\n            'blueviolet': [\n                138,\n                43,\n                226,\n                1\n            ],\n            'brown': [\n                165,\n                42,\n                42,\n                1\n            ],\n            'burlywood': [\n                222,\n                184,\n                135,\n                1\n            ],\n            'cadetblue': [\n                95,\n                158,\n                160,\n                1\n            ],\n            'chartreuse': [\n                127,\n                255,\n                0,\n                1\n            ],\n            'chocolate': [\n                210,\n                105,\n                30,\n                1\n            ],\n            'coral': [\n                255,\n                127,\n                80,\n                1\n            ],\n            'cornflowerblue': [\n                100,\n                149,\n                237,\n                1\n            ],\n            'cornsilk': [\n                255,\n                248,\n                220,\n                1\n            ],\n            'crimson': [\n                220,\n                20,\n                60,\n                1\n            ],\n            'cyan': [\n                0,\n                255,\n                255,\n                1\n            ],\n            'darkblue': [\n                0,\n                0,\n                139,\n                1\n            ],\n            'darkcyan': [\n                0,\n                139,\n                139,\n                1\n            ],\n            'darkgoldenrod': [\n                184,\n                134,\n                11,\n                1\n            ],\n            'darkgray': [\n                169,\n                169,\n                169,\n                1\n            ],\n            'darkgreen': [\n                0,\n                100,\n                0,\n                1\n            ],\n            'darkgrey': [\n                169,\n                169,\n                169,\n                1\n            ],\n            'darkkhaki': [\n                189,\n                183,\n                107,\n                1\n            ],\n            'darkmagenta': [\n                139,\n                0,\n                139,\n                1\n            ],\n            'darkolivegreen': [\n                85,\n                107,\n                47,\n                1\n            ],\n            'darkorange': [\n                255,\n                140,\n                0,\n                1\n            ],\n            'darkorchid': [\n                153,\n                50,\n                204,\n                1\n            ],\n            'darkred': [\n                139,\n                0,\n                0,\n                1\n            ],\n            'darksalmon': [\n                233,\n                150,\n                122,\n                1\n            ],\n            'darkseagreen': [\n                143,\n                188,\n                143,\n                1\n            ],\n            'darkslateblue': [\n                72,\n                61,\n                139,\n                1\n            ],\n            'darkslategray': [\n                47,\n                79,\n                79,\n                1\n            ],\n            'darkslategrey': [\n                47,\n                79,\n                79,\n                1\n            ],\n            'darkturquoise': [\n                0,\n                206,\n                209,\n                1\n            ],\n            'darkviolet': [\n                148,\n                0,\n                211,\n                1\n            ],\n            'deeppink': [\n                255,\n                20,\n                147,\n                1\n            ],\n            'deepskyblue': [\n                0,\n                191,\n                255,\n                1\n            ],\n            'dimgray': [\n                105,\n                105,\n                105,\n                1\n            ],\n            'dimgrey': [\n                105,\n                105,\n                105,\n                1\n            ],\n            'dodgerblue': [\n                30,\n                144,\n                255,\n                1\n            ],\n            'firebrick': [\n                178,\n                34,\n                34,\n                1\n            ],\n            'floralwhite': [\n                255,\n                250,\n                240,\n                1\n            ],\n            'forestgreen': [\n                34,\n                139,\n                34,\n                1\n            ],\n            'fuchsia': [\n                255,\n                0,\n                255,\n                1\n            ],\n            'gainsboro': [\n                220,\n                220,\n                220,\n                1\n            ],\n            'ghostwhite': [\n                248,\n                248,\n                255,\n                1\n            ],\n            'gold': [\n                255,\n                215,\n                0,\n                1\n            ],\n            'goldenrod': [\n                218,\n                165,\n                32,\n                1\n            ],\n            'gray': [\n                128,\n                128,\n                128,\n                1\n            ],\n            'green': [\n                0,\n                128,\n                0,\n                1\n            ],\n            'greenyellow': [\n                173,\n                255,\n                47,\n                1\n            ],\n            'grey': [\n                128,\n                128,\n                128,\n                1\n            ],\n            'honeydew': [\n                240,\n                255,\n                240,\n                1\n            ],\n            'hotpink': [\n                255,\n                105,\n                180,\n                1\n            ],\n            'indianred': [\n                205,\n                92,\n                92,\n                1\n            ],\n            'indigo': [\n                75,\n                0,\n                130,\n                1\n            ],\n            'ivory': [\n                255,\n                255,\n                240,\n                1\n            ],\n            'khaki': [\n                240,\n                230,\n                140,\n                1\n            ],\n            'lavender': [\n                230,\n                230,\n                250,\n                1\n            ],\n            'lavenderblush': [\n                255,\n                240,\n                245,\n                1\n            ],\n            'lawngreen': [\n                124,\n                252,\n                0,\n                1\n            ],\n            'lemonchiffon': [\n                255,\n                250,\n                205,\n                1\n            ],\n            'lightblue': [\n                173,\n                216,\n                230,\n                1\n            ],\n            'lightcoral': [\n                240,\n                128,\n                128,\n                1\n            ],\n            'lightcyan': [\n                224,\n                255,\n                255,\n                1\n            ],\n            'lightgoldenrodyellow': [\n                250,\n                250,\n                210,\n                1\n            ],\n            'lightgray': [\n                211,\n                211,\n                211,\n                1\n            ],\n            'lightgreen': [\n                144,\n                238,\n                144,\n                1\n            ],\n            'lightgrey': [\n                211,\n                211,\n                211,\n                1\n            ],\n            'lightpink': [\n                255,\n                182,\n                193,\n                1\n            ],\n            'lightsalmon': [\n                255,\n                160,\n                122,\n                1\n            ],\n            'lightseagreen': [\n                32,\n                178,\n                170,\n                1\n            ],\n            'lightskyblue': [\n                135,\n                206,\n                250,\n                1\n            ],\n            'lightslategray': [\n                119,\n                136,\n                153,\n                1\n            ],\n            'lightslategrey': [\n                119,\n                136,\n                153,\n                1\n            ],\n            'lightsteelblue': [\n                176,\n                196,\n                222,\n                1\n            ],\n            'lightyellow': [\n                255,\n                255,\n                224,\n                1\n            ],\n            'lime': [\n                0,\n                255,\n                0,\n                1\n            ],\n            'limegreen': [\n                50,\n                205,\n                50,\n                1\n            ],\n            'linen': [\n                250,\n                240,\n                230,\n                1\n            ],\n            'magenta': [\n                255,\n                0,\n                255,\n                1\n            ],\n            'maroon': [\n                128,\n                0,\n                0,\n                1\n            ],\n            'mediumaquamarine': [\n                102,\n                205,\n                170,\n                1\n            ],\n            'mediumblue': [\n                0,\n                0,\n                205,\n                1\n            ],\n            'mediumorchid': [\n                186,\n                85,\n                211,\n                1\n            ],\n            'mediumpurple': [\n                147,\n                112,\n                219,\n                1\n            ],\n            'mediumseagreen': [\n                60,\n                179,\n                113,\n                1\n            ],\n            'mediumslateblue': [\n                123,\n                104,\n                238,\n                1\n            ],\n            'mediumspringgreen': [\n                0,\n                250,\n                154,\n                1\n            ],\n            'mediumturquoise': [\n                72,\n                209,\n                204,\n                1\n            ],\n            'mediumvioletred': [\n                199,\n                21,\n                133,\n                1\n            ],\n            'midnightblue': [\n                25,\n                25,\n                112,\n                1\n            ],\n            'mintcream': [\n                245,\n                255,\n                250,\n                1\n            ],\n            'mistyrose': [\n                255,\n                228,\n                225,\n                1\n            ],\n            'moccasin': [\n                255,\n                228,\n                181,\n                1\n            ],\n            'navajowhite': [\n                255,\n                222,\n                173,\n                1\n            ],\n            'navy': [\n                0,\n                0,\n                128,\n                1\n            ],\n            'oldlace': [\n                253,\n                245,\n                230,\n                1\n            ],\n            'olive': [\n                128,\n                128,\n                0,\n                1\n            ],\n            'olivedrab': [\n                107,\n                142,\n                35,\n                1\n            ],\n            'orange': [\n                255,\n                165,\n                0,\n                1\n            ],\n            'orangered': [\n                255,\n                69,\n                0,\n                1\n            ],\n            'orchid': [\n                218,\n                112,\n                214,\n                1\n            ],\n            'palegoldenrod': [\n                238,\n                232,\n                170,\n                1\n            ],\n            'palegreen': [\n                152,\n                251,\n                152,\n                1\n            ],\n            'paleturquoise': [\n                175,\n                238,\n                238,\n                1\n            ],\n            'palevioletred': [\n                219,\n                112,\n                147,\n                1\n            ],\n            'papayawhip': [\n                255,\n                239,\n                213,\n                1\n            ],\n            'peachpuff': [\n                255,\n                218,\n                185,\n                1\n            ],\n            'peru': [\n                205,\n                133,\n                63,\n                1\n            ],\n            'pink': [\n                255,\n                192,\n                203,\n                1\n            ],\n            'plum': [\n                221,\n                160,\n                221,\n                1\n            ],\n            'powderblue': [\n                176,\n                224,\n                230,\n                1\n            ],\n            'purple': [\n                128,\n                0,\n                128,\n                1\n            ],\n            'red': [\n                255,\n                0,\n                0,\n                1\n            ],\n            'rosybrown': [\n                188,\n                143,\n                143,\n                1\n            ],\n            'royalblue': [\n                65,\n                105,\n                225,\n                1\n            ],\n            'saddlebrown': [\n                139,\n                69,\n                19,\n                1\n            ],\n            'salmon': [\n                250,\n                128,\n                114,\n                1\n            ],\n            'sandybrown': [\n                244,\n                164,\n                96,\n                1\n            ],\n            'seagreen': [\n                46,\n                139,\n                87,\n                1\n            ],\n            'seashell': [\n                255,\n                245,\n                238,\n                1\n            ],\n            'sienna': [\n                160,\n                82,\n                45,\n                1\n            ],\n            'silver': [\n                192,\n                192,\n                192,\n                1\n            ],\n            'skyblue': [\n                135,\n                206,\n                235,\n                1\n            ],\n            'slateblue': [\n                106,\n                90,\n                205,\n                1\n            ],\n            'slategray': [\n                112,\n                128,\n                144,\n                1\n            ],\n            'slategrey': [\n                112,\n                128,\n                144,\n                1\n            ],\n            'snow': [\n                255,\n                250,\n                250,\n                1\n            ],\n            'springgreen': [\n                0,\n                255,\n                127,\n                1\n            ],\n            'steelblue': [\n                70,\n                130,\n                180,\n                1\n            ],\n            'tan': [\n                210,\n                180,\n                140,\n                1\n            ],\n            'teal': [\n                0,\n                128,\n                128,\n                1\n            ],\n            'thistle': [\n                216,\n                191,\n                216,\n                1\n            ],\n            'tomato': [\n                255,\n                99,\n                71,\n                1\n            ],\n            'turquoise': [\n                64,\n                224,\n                208,\n                1\n            ],\n            'violet': [\n                238,\n                130,\n                238,\n                1\n            ],\n            'wheat': [\n                245,\n                222,\n                179,\n                1\n            ],\n            'white': [\n                255,\n                255,\n                255,\n                1\n            ],\n            'whitesmoke': [\n                245,\n                245,\n                245,\n                1\n            ],\n            'yellow': [\n                255,\n                255,\n                0,\n                1\n            ],\n            'yellowgreen': [\n                154,\n                205,\n                50,\n                1\n            ]\n        };\n    function clampCssByte(i) {\n        // Clamp to integer 0 .. 255.\n        i = Math.round(i);\n        // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n    function clampCssAngle(i) {\n        // Clamp to integer 0 .. 360.\n        i = Math.round(i);\n        // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n    function clampCssFloat(f) {\n        // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n    function parseCssInt(str) {\n        // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n    function parseCssFloat(str) {\n        // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        } else if (h > 1) {\n            h -= 1;\n        }\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n        }\n        return m1;\n    }\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n    /**\n     * @param {string} colorStr\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr) {\n        if (!colorStr) {\n            return;\n        }\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            return kCSSColorTable[str].slice();    // dup.\n        }\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);\n                // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 4095)) {\n                    return;    // Covers NaN.\n                }\n                return [\n                    (iv & 3840) >> 4 | (iv & 3840) >> 8,\n                    iv & 240 | (iv & 240) >> 4,\n                    iv & 15 | (iv & 15) << 4,\n                    1\n                ];\n            } else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);\n                // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 16777215)) {\n                    return;    // Covers NaN.\n                }\n                return [\n                    (iv & 16711680) >> 16,\n                    (iv & 65280) >> 8,\n                    iv & 255,\n                    1\n                ];\n            }\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;\n            // To allow case fallthrough.\n            switch (fname) {\n            case 'rgba':\n                if (params.length !== 4) {\n                    return;\n                }\n                alpha = parseCssFloat(params.pop());\n            // jshint ignore:line\n            // Fall through.\n            case 'rgb':\n                if (params.length !== 3) {\n                    return;\n                }\n                return [\n                    parseCssInt(params[0]),\n                    parseCssInt(params[1]),\n                    parseCssInt(params[2]),\n                    alpha\n                ];\n            case 'hsla':\n                if (params.length !== 4) {\n                    return;\n                }\n                params[3] = parseCssFloat(params[3]);\n                return hsla2rgba(params);\n            case 'hsl':\n                if (params.length !== 3) {\n                    return;\n                }\n                return hsla2rgba(params);\n            default:\n                return;\n            }\n        }\n        return;\n    }\n    /**\n     * @param {Array.<number>} hsla\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla) {\n        var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;\n        // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n        var rgba = [\n                clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n                clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n                clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n            ];\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n        return rgba;\n    }\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n        var vMin = Math.min(R, G, B);\n        // Min. value of RGB\n        var vMax = Math.max(R, G, B);\n        // Max. value of RGB\n        var delta = vMax - vMin;\n        // Delta RGB value\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        } else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            } else {\n                S = delta / (2 - vMax - vMin);\n            }\n            var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n            var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n            var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            } else if (G === vMax) {\n                H = 1 / 3 + deltaR - deltaB;\n            } else if (B === vMax) {\n                H = 2 / 3 + deltaG - deltaR;\n            }\n            if (H < 0) {\n                H += 1;\n            }\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n        var hsla = [\n                H * 360,\n                S,\n                L\n            ];\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n        return hsla;\n    }\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                } else {\n                    colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n        }\n    }\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>}\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n            return;\n        }\n        out = out || [\n            0,\n            0,\n            0,\n            0\n        ];\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n            return;\n        }\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n        var color = stringify([\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ], 'rgba');\n        return fullOutput ? {\n            color: color,\n            leftIndex: leftIndex,\n            rightIndex: rightIndex,\n            value: value\n        } : color;\n    }\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n    /**\n     * @param {Array.<string>} colors Color list.\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color.\n     */\n    function stringify(arrColor, type) {\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n    return {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n});\ndefine('zrender/core/timsort', [], function () {\n    var DEFAULT_MIN_MERGE = 32;\n    var DEFAULT_MIN_GALLOPING = 7;\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n    function minRunLength(n) {\n        var r = 0;\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n        return n + r;\n    }\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n        if (runHi === hi) {\n            return 1;\n        }\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n            reverseRun(array, lo, runHi);\n        } else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n        return runHi - lo;\n    }\n    function reverseRun(array, lo, hi) {\n        hi--;\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n        for (; start < hi; start++) {\n            var pivot = array[start];\n            var left = lo;\n            var right = start;\n            var mid;\n            while (left < right) {\n                mid = left + right >>> 1;\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            var n = start - left;\n            switch (n) {\n            case 3:\n                array[left + 3] = array[left + 2];\n            case 2:\n                array[left + 2] = array[left + 1];\n            case 1:\n                array[left + 1] = array[left];\n                break;\n            default:\n                while (n > 0) {\n                    array[left + n] = array[left + n - 1];\n                    n--;\n                }\n            }\n            array[left] = pivot;\n        }\n    }\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            lastOffset += hint;\n            offset += hint;\n        } else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            } else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        } else {\n            maxOffset = length - hint;\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            lastOffset += hint;\n            offset += hint;\n        }\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            } else {\n                lastOffset = m + 1;\n            }\n        }\n        return offset;\n    }\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n        length = array.length;\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n        var tmp = [];\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n        runStart = [];\n        runLength = [];\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                } else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n                mergeAt(n);\n            }\n        }\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n            runLength[i] = length1 + length2;\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n            stackSize--;\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n            if (length1 === 0) {\n                return;\n            }\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n            if (length2 === 0) {\n                return;\n            }\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            } else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n            array[dest++] = array[cursor2++];\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    } else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n                if (exit) {\n                    break;\n                }\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = array[cursor2++];\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n                if (exit) {\n                    break;\n                }\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n                _minGallop += 2;\n            }\n            minGallop = _minGallop;\n            minGallop < 1 && (minGallop = 1);\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            } else if (length1 === 0) {\n                throw new Error();    // throw new Error('mergeLow preconditions were not respected');\n            } else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n        function mergeHigh(start1, length1, start2, length2) {\n            var i = 0;\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n            array[dest--] = array[cursor1--];\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n                return;\n            }\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n                array[dest] = tmp[cursor2];\n                return;\n            }\n            var _minGallop = minGallop;\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    } else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n                if (exit) {\n                    break;\n                }\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest--] = tmp[cursor2--];\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest--] = array[cursor1--];\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n                if (exit) {\n                    break;\n                }\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n                _minGallop += 2;\n            }\n            minGallop = _minGallop;\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n                array[dest] = tmp[cursor2];\n            } else if (length2 === 0) {\n                throw new Error();    // throw new Error('mergeHigh preconditions were not respected');\n            } else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n        var remaining = hi - lo;\n        if (remaining < 2) {\n            return;\n        }\n        var runLength = 0;\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n        var ts = new TimSort(array, compare);\n        var minRun = minRunLength(remaining);\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n        ts.forceMergeRuns();\n    }\n    return sort;\n});\ndefine('echarts/visual/seriesColor', ['require', 'zrender/graphic/Gradient'], function (require) {\n    var Gradient = require('zrender/graphic/Gradient');\n    return function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) || seriesModel.getColorFromPalette(seriesModel.get('name'));\n            // Default color\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(idx, 'color', color(seriesModel.getDataParams(idx)));\n                    });\n                }\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n});\ndefine('echarts/preprocessor/backwardCompat', ['require', 'zrender/core/util', './helper/compatStyle'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var compatStyle = require('./helper/compatStyle');\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n    var LAYOUT_PROPERTIES = [\n            [\n                'x',\n                'left'\n            ],\n            [\n                'y',\n                'top'\n            ],\n            [\n                'x2',\n                'right'\n            ],\n            [\n                'y2',\n                'bottom'\n            ]\n        ];\n    var COMPATITABLE_COMPONENTS = [\n            'grid',\n            'geo',\n            'parallel',\n            'legend',\n            'toolbox',\n            'title',\n            'visualMap',\n            'dataZoom',\n            'timeline'\n        ];\n    var COMPATITABLE_SERIES = [\n            'bar',\n            'boxplot',\n            'candlestick',\n            'chord',\n            'effectScatter',\n            'funnel',\n            'gauge',\n            'lines',\n            'graph',\n            'heatmap',\n            'line',\n            'map',\n            'parallel',\n            'pie',\n            'radar',\n            'sankey',\n            'scatter',\n            'treemap'\n        ];\n    var each = zrUtil.each;\n    return function (option) {\n        each(option.series, function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n            var seriesType = seriesOpt.type;\n            compatStyle(seriesOpt);\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n});\ndefine('echarts/loading/default', ['require', '../util/graphic', 'zrender/core/util'], function (require) {\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/core/util');\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    return function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n                style: { fill: opts.maskColor },\n                zlevel: opts.zlevel,\n                z: 10000\n            });\n        var arc = new graphic.Arc({\n                shape: {\n                    startAngle: -PI / 2,\n                    endAngle: -PI / 2 + 0.1,\n                    r: 10\n                },\n                style: {\n                    stroke: opts.color,\n                    lineCap: 'round',\n                    lineWidth: 5\n                },\n                zlevel: opts.zlevel,\n                z: 10001\n            });\n        var labelRect = new graphic.Rect({\n                style: {\n                    fill: 'none',\n                    text: opts.text,\n                    textPosition: 'right',\n                    textDistance: 10,\n                    textFill: opts.textColor\n                },\n                zlevel: opts.zlevel,\n                z: 10001\n            });\n        arc.animateShape(true).when(1000, { endAngle: PI * 3 / 2 }).start('circularInOut');\n        arc.animateShape(true).when(1000, { startAngle: PI * 3 / 2 }).delay(300).start('circularInOut');\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n});\ndefine('zrender/core/matrix', [], function () {\n    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n    /**\n     * 3x2矩阵操作类\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n            create: function () {\n                var out = new ArrayCtor(6);\n                matrix.identity(out);\n                return out;\n            },\n            identity: function (out) {\n                out[0] = 1;\n                out[1] = 0;\n                out[2] = 0;\n                out[3] = 1;\n                out[4] = 0;\n                out[5] = 0;\n                return out;\n            },\n            copy: function (out, m) {\n                out[0] = m[0];\n                out[1] = m[1];\n                out[2] = m[2];\n                out[3] = m[3];\n                out[4] = m[4];\n                out[5] = m[5];\n                return out;\n            },\n            mul: function (out, m1, m2) {\n                // Consider matrix.mul(m, m2, m);\n                // where out is the same as m2.\n                // So use temp variable to escape error.\n                var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n                var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n                var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n                var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n                var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n                var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n                out[0] = out0;\n                out[1] = out1;\n                out[2] = out2;\n                out[3] = out3;\n                out[4] = out4;\n                out[5] = out5;\n                return out;\n            },\n            translate: function (out, a, v) {\n                out[0] = a[0];\n                out[1] = a[1];\n                out[2] = a[2];\n                out[3] = a[3];\n                out[4] = a[4] + v[0];\n                out[5] = a[5] + v[1];\n                return out;\n            },\n            rotate: function (out, a, rad) {\n                var aa = a[0];\n                var ac = a[2];\n                var atx = a[4];\n                var ab = a[1];\n                var ad = a[3];\n                var aty = a[5];\n                var st = Math.sin(rad);\n                var ct = Math.cos(rad);\n                out[0] = aa * ct + ab * st;\n                out[1] = -aa * st + ab * ct;\n                out[2] = ac * ct + ad * st;\n                out[3] = -ac * st + ct * ad;\n                out[4] = ct * atx + st * aty;\n                out[5] = ct * aty - st * atx;\n                return out;\n            },\n            scale: function (out, a, v) {\n                var vx = v[0];\n                var vy = v[1];\n                out[0] = a[0] * vx;\n                out[1] = a[1] * vy;\n                out[2] = a[2] * vx;\n                out[3] = a[3] * vy;\n                out[4] = a[4] * vx;\n                out[5] = a[5] * vy;\n                return out;\n            },\n            invert: function (out, a) {\n                var aa = a[0];\n                var ac = a[2];\n                var atx = a[4];\n                var ab = a[1];\n                var ad = a[3];\n                var aty = a[5];\n                var det = aa * ad - ab * ac;\n                if (!det) {\n                    return null;\n                }\n                det = 1 / det;\n                out[0] = ad * det;\n                out[1] = -ab * det;\n                out[2] = -ac * det;\n                out[3] = aa * det;\n                out[4] = (ac * aty - ad * atx) * det;\n                out[5] = (ab * atx - aa * aty) * det;\n                return out;\n            }\n        };\n    return matrix;\n});\ndefine('echarts/model/Model', ['require', 'zrender/core/util', '../util/clazz', './mixin/lineStyle', './mixin/areaStyle', './mixin/textStyle', './mixin/itemStyle'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var clazzUtil = require('../util/clazz');\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;    // Simple optimization\n                                 // if (this.init) {\n                                 //     if (arguments.length <= 4) {\n                                 //         this.init(option, parentModel, ecModel, extraOpt);\n                                 //     }\n                                 //     else {\n                                 //         this.init.apply(this, arguments);\n                                 //     }\n                                 // }\n    }\n    Model.prototype = {\n        constructor: Model,\n        init: null,\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n        get: function (path, ignoreParent) {\n            if (!path) {\n                return this.option;\n            }\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n            var obj = this.option;\n            var parentModel = this.parentModel;\n            for (var i = 0; i < path.length; i++) {\n                // Ignore empty\n                if (!path[i]) {\n                    continue;\n                }\n                // obj could be number/string/... (like 0)\n                obj = obj && typeof obj === 'object' ? obj[path[i]] : null;\n                if (obj == null) {\n                    break;\n                }\n            }\n            if (obj == null && parentModel && !ignoreParent) {\n                obj = parentModel.get(path);\n            }\n            return obj;\n        },\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n            var val = option == null ? option : option[key];\n            var parentModel = this.parentModel;\n            if (val == null && parentModel && !ignoreParent) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n        getModel: function (path, parentModel) {\n            var obj = this.get(path, true);\n            var thisParentModel = this.parentModel;\n            var model = new Model(obj, parentModel || thisParentModel && thisParentModel.getModel(path), this.ecModel);\n            return model;\n        },\n        isEmpty: function () {\n            return this.option == null;\n        },\n        restoreData: function () {\n        },\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        }\n    };\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n    var mixin = zrUtil.mixin;\n    mixin(Model, require('./mixin/lineStyle'));\n    mixin(Model, require('./mixin/areaStyle'));\n    mixin(Model, require('./mixin/textStyle'));\n    mixin(Model, require('./mixin/itemStyle'));\n    return Model;\n});\ndefine('echarts/data/List', ['require', '../model/Model', './DataDiffer', 'zrender/core/util', '../util/model'], function (require) {\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED ? Array : globalObj.Int32Array;\n    var dataCtors = {\n            'float': Float64Array,\n            'int': Int32Array,\n            'ordinal': Array,\n            'number': Array,\n            'time': Array\n        };\n    var Model = require('../model/Model');\n    var DataDiffer = require('./DataDiffer');\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../util/model');\n    var isObject = zrUtil.isObject;\n    var TRANSFERABLE_PROPERTIES = [\n            'stackedOn',\n            'hasItemOption',\n            '_nameList',\n            '_idList',\n            '_rawData'\n        ];\n    var transferProperties = function (a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n        a.__wrappedMethods = b.__wrappedMethods;\n    };\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string>} dimensions\n     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n        dimensions = dimensions || [\n            'x',\n            'y'\n        ];\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    stackable: false,\n                    type: 'number'\n                };\n            } else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n            }\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n    var listProto = List.prototype;\n    listProto.type = 'list';\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n        if (true) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n        this._rawData = data;\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n        var dimensions = this.dimensions;\n        var size = data.length;\n        var dimensionInfoMap = this._dimensionInfos;\n        var idList = [];\n        var nameRepeatCount = {};\n        nameList = nameList || [];\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(value instanceof Array ? value[dimIndex] : value, dimensionInfoMap[dimName]);\n        };\n        for (var idx = 0; idx < data.length; idx++) {\n            var dataItem = data[idx];\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n            }\n            indices.push(idx);\n        }\n        // Use the name in option and create id\n        for (var i = 0; i < data.length; i++) {\n            if (!nameList[i]) {\n                if (data[i] && data[i].name != null) {\n                    nameList[i] = data[i].name;\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = data[i] && data[i].id;\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n        // If value not exists\n        if (dataIndex == null) {\n            return NaN;\n        }\n        var value = storage[dim] && storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if (value >= 0 && stackedValue > 0 || value <= 0 && stackedValue < 0) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n        return values;\n    };\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (dimensionInfos[dimensions[i]].type !== 'ordinal' && isNaN(this.get(dimensions[i], idx))) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getDataExtent = function (dim, stack) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = dimInfo && dimInfo.stackable && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + !!stack];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                value < min && (min = value);\n                value > max && (max = value);\n            }\n            return this._extent[dim + !!stack] = [\n                min,\n                max\n            ];\n        } else {\n            return [\n                Infinity,\n                -Infinity\n            ];\n        }\n    };\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            } else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            } else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {number}\n     */\n    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n        var nearestIdx = -1;\n        if (dimData) {\n            var minDist = Number.MAX_VALUE;\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var diff = value - this.get(dim, i, stack);\n                var dist = Math.abs(diff);\n                if (diff <= maxDistance && (dist < minDist || dist === minDist && diff > 0)) {\n                    minDist = dist;\n                    nearestIdx = i;\n                }\n            }\n        }\n        return nearestIdx;\n    };\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData[this.getRawIndex(idx)];\n    };\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || this.getRawIndex(idx) + '';\n    };\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n        context = context || this;\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n            case 0:\n                cb.call(context, i);\n                break;\n            case 1:\n                cb.call(context, this.get(dims[0], i, stack), i);\n                break;\n            case 2:\n                cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                break;\n            default:\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dims[k], i, stack);\n                }\n                // Index\n                value[k] = i;\n                cb.apply(context, value);\n            }\n        }\n    };\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n        dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n        context = context || this;\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (dimSize === 1) {\n                keep = cb.call(context, this.get(dimensions[0], i, stack), i);\n            } else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n        this.indices = newIndices;\n        // Reset data extent\n        this._extent = {};\n        return this;\n    };\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel);\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(originalStorage[dim].length);\n            } else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n        var storage = list._storage;\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n        return list;\n    };\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n        return list;\n    };\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n    };\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        return new DataDiffer(otherList ? otherList.indices : [], this.indices, function (idx) {\n            return otherIdList[idx] || idx + '';\n        }, function (idx) {\n            return idList[idx] || idx + '';\n        });\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n    /**\n     * Set layout property.\n     * @param {string} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n    };\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} ignoreParent\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n        this._graphicEls[idx] = el;\n    };\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n        // FIXME\n        list._storage = this._storage;\n        transferProperties(list, this);\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n        return list;\n    };\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = [\n        'cloneShallow',\n        'downSample',\n        'map'\n    ];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n    return List;\n});\ndefine('zrender/core/vector', [], function () {\n    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * 二维向量类\n     * @exports zrender/tool/vector\n     */\n    var vector = {\n            create: function (x, y) {\n                var out = new ArrayCtor(2);\n                if (x == null) {\n                    x = 0;\n                }\n                if (y == null) {\n                    y = 0;\n                }\n                out[0] = x;\n                out[1] = y;\n                return out;\n            },\n            copy: function (out, v) {\n                out[0] = v[0];\n                out[1] = v[1];\n                return out;\n            },\n            clone: function (v) {\n                var out = new ArrayCtor(2);\n                out[0] = v[0];\n                out[1] = v[1];\n                return out;\n            },\n            set: function (out, a, b) {\n                out[0] = a;\n                out[1] = b;\n                return out;\n            },\n            add: function (out, v1, v2) {\n                out[0] = v1[0] + v2[0];\n                out[1] = v1[1] + v2[1];\n                return out;\n            },\n            scaleAndAdd: function (out, v1, v2, a) {\n                out[0] = v1[0] + v2[0] * a;\n                out[1] = v1[1] + v2[1] * a;\n                return out;\n            },\n            sub: function (out, v1, v2) {\n                out[0] = v1[0] - v2[0];\n                out[1] = v1[1] - v2[1];\n                return out;\n            },\n            len: function (v) {\n                return Math.sqrt(this.lenSquare(v));\n            },\n            lenSquare: function (v) {\n                return v[0] * v[0] + v[1] * v[1];\n            },\n            mul: function (out, v1, v2) {\n                out[0] = v1[0] * v2[0];\n                out[1] = v1[1] * v2[1];\n                return out;\n            },\n            div: function (out, v1, v2) {\n                out[0] = v1[0] / v2[0];\n                out[1] = v1[1] / v2[1];\n                return out;\n            },\n            dot: function (v1, v2) {\n                return v1[0] * v2[0] + v1[1] * v2[1];\n            },\n            scale: function (out, v, s) {\n                out[0] = v[0] * s;\n                out[1] = v[1] * s;\n                return out;\n            },\n            normalize: function (out, v) {\n                var d = vector.len(v);\n                if (d === 0) {\n                    out[0] = 0;\n                    out[1] = 0;\n                } else {\n                    out[0] = v[0] / d;\n                    out[1] = v[1] / d;\n                }\n                return out;\n            },\n            distance: function (v1, v2) {\n                return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n            },\n            distanceSquare: function (v1, v2) {\n                return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n            },\n            negate: function (out, v) {\n                out[0] = -v[0];\n                out[1] = -v[1];\n                return out;\n            },\n            lerp: function (out, v1, v2, t) {\n                out[0] = v1[0] + t * (v2[0] - v1[0]);\n                out[1] = v1[1] + t * (v2[1] - v1[1]);\n                return out;\n            },\n            applyTransform: function (out, v, m) {\n                var x = v[0];\n                var y = v[1];\n                out[0] = m[0] * x + m[2] * y + m[4];\n                out[1] = m[1] * x + m[3] * y + m[5];\n                return out;\n            },\n            min: function (out, v1, v2) {\n                out[0] = Math.min(v1[0], v2[0]);\n                out[1] = Math.min(v1[1], v2[1]);\n                return out;\n            },\n            max: function (out, v1, v2) {\n                out[0] = Math.max(v1[0], v2[0]);\n                out[1] = Math.max(v1[1], v2[1]);\n                return out;\n            }\n        };\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n    return vector;\n});\ndefine('echarts/scale/Scale', ['require', '../util/clazz'], function (require) {\n    var clazzUtil = require('../util/clazz');\n    function Scale() {\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [\n            Infinity,\n            -Infinity\n        ];\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n        this.init && this.init.apply(this, arguments);\n    }\n    var scaleProto = Scale.prototype;\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);    // not setExtent because in log axis it may transformed to power\n                                                           // this.setExtent(extent[0], extent[1]);\n    };\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, { registerWhenExtend: true });\n    return Scale;\n});\ndefine('echarts/coord/axisHelper', ['require', '../scale/Ordinal', '../scale/Interval', '../scale/Time', '../scale/Log', '../scale/Scale', '../util/number', 'zrender/core/util', 'zrender/contain/text'], function (require) {\n    var OrdinalScale = require('../scale/Ordinal');\n    var IntervalScale = require('../scale/Interval');\n    require('../scale/Time');\n    require('../scale/Log');\n    var Scale = require('../scale/Scale');\n    var numberUtil = require('../util/number');\n    var zrUtil = require('zrender/core/util');\n    var textContain = require('zrender/contain/text');\n    var axisHelper = {};\n    /**\n     * Get axis scale extent before niced.\n     */\n    axisHelper.getScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var originalExtent = scale.getExtent();\n        var span = originalExtent[1] - originalExtent[0];\n        if (scale.type === 'ordinal') {\n            // If series has no data, scale extent may be wrong\n            if (!isFinite(span)) {\n                return [\n                    0,\n                    0\n                ];\n            } else {\n                return originalExtent;\n            }\n        }\n        var min = model.getMin ? model.getMin() : model.get('min');\n        var max = model.getMax ? model.getMax() : model.get('max');\n        var crossZero = model.getNeedCrossZero ? model.getNeedCrossZero() : !model.get('scale');\n        var boundaryGap = model.get('boundaryGap');\n        if (!zrUtil.isArray(boundaryGap)) {\n            boundaryGap = [\n                boundaryGap || 0,\n                boundaryGap || 0\n            ];\n        }\n        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n        var fixMin = true;\n        var fixMax = true;\n        // Add boundary gap\n        if (min == null) {\n            min = originalExtent[0] - boundaryGap[0] * span;\n            fixMin = false;\n        }\n        if (max == null) {\n            max = originalExtent[1] + boundaryGap[1] * span;\n            fixMax = false;\n        }\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n        // Evaluate if axis needs cross zero\n        if (crossZero) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n        return [\n            min,\n            max\n        ];\n    };\n    axisHelper.niceScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var extent = axisHelper.getScaleExtent(axis, model);\n        var fixMin = (model.getMin ? model.getMin() : model.get('min')) != null;\n        var fixMax = (model.getMax ? model.getMax() : model.get('max')) != null;\n        var splitNumber = model.get('splitNumber');\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent(splitNumber, fixMin, fixMax);\n        // Use minInterval to constraint the calculated interval.\n        // If calculated interval is less than minInterval. increase the interval quantity until\n        // it is larger than minInterval.\n        // For example:\n        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n        //  an integer axis.\n        var minInterval = model.get('minInterval');\n        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n            var interval = scale.getInterval();\n            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n            // while (interval < minInterval) {\n            //     var quantity = numberUtil.quantity(interval);\n            //     interval = quantity * 10;\n            //     scaleQuantity *= 10;\n            // }\n            extent = scale.getExtent();\n            scale.setExtent(intervalScale * extent[0], extent[1] * intervalScale);\n            scale.niceExtent(splitNumber);\n        }\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function (model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n            // Buildin scale\n            case 'category':\n                return new OrdinalScale(model.getCategories(), [\n                    Infinity,\n                    -Infinity\n                ]);\n            case 'value':\n                return new IntervalScale();\n            // Extended scale, like time and log\n            default:\n                return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !(min > 0 && max > 0 || min < 0 && max < 0);\n    };\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // 不同角的axis和label，不只是horizontal和vertical.\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(labels[i], font, 'center', 'top');\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }    // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            } else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val);\n                };\n            }(labelFormatter);\n            return zrUtil.map(labels, labelFormatter);\n        } else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(axis.type === 'category' ? scale.getLabel(tick) : tick, idx);\n            }, this);\n        } else {\n            return labels;\n        }\n    };\n    return axisHelper;\n});\ndefine('echarts/coord/cartesian/Cartesian2D', ['require', 'zrender/core/util', './Cartesian'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var Cartesian = require('./Cartesian');\n    function Cartesian2D(name) {\n        Cartesian.call(this, name);\n    }\n    Cartesian2D.prototype = {\n        constructor: Cartesian2D,\n        type: 'cartesian2d',\n        dimensions: [\n            'x',\n            'y'\n        ],\n        getBaseAxis: function () {\n            return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n        },\n        containPoint: function (point) {\n            var axisX = this.getAxis('x');\n            var axisY = this.getAxis('y');\n            return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n        },\n        containData: function (data) {\n            return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n        },\n        dataToPoints: function (data, stack) {\n            return data.mapArray([\n                'x',\n                'y'\n            ], function (x, y) {\n                return this.dataToPoint([\n                    x,\n                    y\n                ]);\n            }, stack, this);\n        },\n        dataToPoint: function (data, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n            ];\n        },\n        pointToData: function (point, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n            ];\n        },\n        getOtherAxis: function (axis) {\n            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n        }\n    };\n    zrUtil.inherits(Cartesian2D, Cartesian);\n    return Cartesian2D;\n});\ndefine('echarts/coord/cartesian/Axis2D', ['require', 'zrender/core/util', '../Axis', './axisLabelInterval'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var Axis = require('../Axis');\n    var axisLabelInterval = require('./axisLabelInterval');\n    /**\n     * Extend axis 2d\n     * @constructor module:echarts/coord/cartesian/Axis2D\n     * @extends {module:echarts/coord/cartesian/Axis}\n     * @param {string} dim\n     * @param {*} scale\n     * @param {Array.<number>} coordExtent\n     * @param {string} axisType\n     * @param {string} position\n     */\n    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n        Axis.call(this, dim, scale, coordExtent);\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = axisType || 'value';\n        /**\n         * Axis position\n         *  - 'top'\n         *  - 'bottom'\n         *  - 'left'\n         *  - 'right'\n         */\n        this.position = position || 'bottom';\n    };\n    Axis2D.prototype = {\n        constructor: Axis2D,\n        index: 0,\n        onZero: false,\n        model: null,\n        isHorizontal: function () {\n            var position = this.position;\n            return position === 'top' || position === 'bottom';\n        },\n        getGlobalExtent: function () {\n            var ret = this.getExtent();\n            ret[0] = this.toGlobalCoord(ret[0]);\n            ret[1] = this.toGlobalCoord(ret[1]);\n            return ret;\n        },\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                labelInterval = this._labelInterval = axisLabelInterval(this);\n            }\n            return labelInterval;\n        },\n        isLabelIgnored: function (idx) {\n            if (this.type === 'category') {\n                var labelInterval = this.getLabelInterval();\n                return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);\n            }\n        },\n        toLocalCoord: null,\n        toGlobalCoord: null\n    };\n    zrUtil.inherits(Axis2D, Axis);\n    return Axis2D;\n});\ndefine('echarts/coord/cartesian/GridModel', ['require', './AxisModel', '../../model/Component'], function (require) {\n    'use strict';\n    require('./AxisModel');\n    var ComponentModel = require('../../model/Component');\n    return ComponentModel.extend({\n        type: 'grid',\n        dependencies: [\n            'xAxis',\n            'yAxis'\n        ],\n        layoutMode: 'box',\n        coordinateSystem: null,\n        defaultOption: {\n            show: false,\n            zlevel: 0,\n            z: 0,\n            left: '10%',\n            top: 60,\n            right: '10%',\n            bottom: 60,\n            containLabel: false,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderWidth: 1,\n            borderColor: '#ccc'\n        }\n    });\n});\ndefine('zrender/tool/path', ['require', '../graphic/Path', '../core/PathProxy', './transformPath', '../core/matrix'], function (require) {\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n    var transformPath = require('./transformPath');\n    var matrix = require('../core/matrix');\n    // command chars\n    var cc = [\n            'm',\n            'M',\n            'l',\n            'L',\n            'v',\n            'V',\n            'h',\n            'H',\n            'z',\n            'Z',\n            'c',\n            'C',\n            'q',\n            'Q',\n            't',\n            'T',\n            's',\n            'S',\n            'a',\n            'A'\n        ];\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n    var vMag = function (v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function (u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function (u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n    };\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180);\n        var xp = mathCos(psi) * (x1 - x2) / 2 + mathSin(psi) * (y1 - y2) / 2;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2 + mathCos(psi) * (y1 - y2) / 2;\n        var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n        var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n        var cx = (x1 + x2) / 2 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n        var theta = vAngle([\n                1,\n                0\n            ], [\n                (xp - cxp) / rx,\n                (yp - cyp) / ry\n            ]);\n        var u = [\n                (xp - cxp) / rx,\n                (yp - cyp) / ry\n            ];\n        var v = [\n                (-1 * xp - cxp) / rx,\n                (-1 * yp - cyp) / ry\n            ];\n        var dTheta = vAngle(u, v);\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n        // command string\n        var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n                var x1 = cpx;\n                var y1 = cpy;\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                case 'l':\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'L':\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'm':\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.M;\n                    path.addData(cmd, cpx, cpy);\n                    c = 'l';\n                    break;\n                case 'M':\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.M;\n                    path.addData(cmd, cpx, cpy);\n                    c = 'L';\n                    break;\n                case 'h':\n                    cpx += p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'H':\n                    cpx = p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'v':\n                    cpy += p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'V':\n                    cpy = p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'C':\n                    cmd = CMD.C;\n                    path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n                    cpx = p[off - 2];\n                    cpy = p[off - 1];\n                    break;\n                case 'c':\n                    cmd = CMD.C;\n                    path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n                    cpx += p[off - 2];\n                    cpy += p[off - 1];\n                    break;\n                case 'S':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.C) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cmd = CMD.C;\n                    x1 = p[off++];\n                    y1 = p[off++];\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                    break;\n                case 's':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.C) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cmd = CMD.C;\n                    x1 = cpx + p[off++];\n                    y1 = cpy + p[off++];\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                    break;\n                case 'Q':\n                    x1 = p[off++];\n                    y1 = p[off++];\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, x1, y1, cpx, cpy);\n                    break;\n                case 'q':\n                    x1 = p[off++] + cpx;\n                    y1 = p[off++] + cpy;\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, x1, y1, cpx, cpy);\n                    break;\n                case 'T':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.Q) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                    break;\n                case 't':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.Q) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                    break;\n                case 'A':\n                    rx = p[off++];\n                    ry = p[off++];\n                    psi = p[off++];\n                    fa = p[off++];\n                    fs = p[off++];\n                    x1 = cpx, y1 = cpy;\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.A;\n                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n                    break;\n                case 'a':\n                    rx = p[off++];\n                    ry = p[off++];\n                    psi = p[off++];\n                    fa = p[off++];\n                    fs = p[off++];\n                    x1 = cpx, y1 = cpy;\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.A;\n                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n                    break;\n                }\n            }\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n            prevCmd = cmd;\n        }\n        path.toStatic();\n        return path;\n    }\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        var transform;\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            path.setData(pathProxy.data);\n            transform && transformPath(path, transform);\n            // Svg and vml renderer don't have context\n            var ctx = path.getContext();\n            if (ctx) {\n                path.rebuildPath(ctx);\n            }\n        };\n        opts.applyTransform = function (m) {\n            if (!transform) {\n                transform = matrix.create();\n            }\n            matrix.mul(transform, m, transform);\n            this.dirty(true);\n        };\n        return opts;\n    }\n    return {\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (pathEl.__dirty) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n            var pathBundle = new Path(opts);\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n            return pathBundle;\n        }\n    };\n});\ndefine('zrender/graphic/Path', ['require', './Displayable', '../core/util', '../core/PathProxy', '../contain/path', './Pattern'], function (require) {\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n    var Pattern = require('./Pattern');\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n    var abs = Math.abs;\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = new PathProxy();\n    }\n    Path.prototype = {\n        constructor: Path,\n        type: 'path',\n        __dirtyPath: true,\n        strokeContainThreshold: 5,\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!fill.colorStops;\n            var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n            var hasFillPattern = hasFill && !!fill.image;\n            var hasStrokePattern = hasStroke && !!stroke.image;\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n            if (this.__dirty) {\n                var rect = this.getBoundingRect();\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            } else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            } else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n            var ctxLineDash = !!ctx.setLineDash;\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n                path = this.path.beginPath(ctx);\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n                this.buildPath(path, this.shape, false);\n                // Clear path dirty flag\n                this.__dirtyPath = false;\n            } else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n            hasFill && path.fill(ctx);\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n            hasStroke && path.stroke(ctx);\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n            this.restoreTransform(ctx);\n            // Draw rect text\n            if (style.text || style.text === 0) {\n                // var rect = this.getBoundingRect();\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n        buildPath: function (ctx, shapeCfg, inBundle) {\n        },\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n            return rect;\n        },\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            } else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        shape[name] = key[name];\n                    }\n                } else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n        }\n    };\n    /**\n     * 扩展一个 Path element, 比如星形，圆等。\n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n            defaults.init && defaults.init.call(this, opts);\n        };\n        zrUtil.inherits(Sub, Path);\n        // FIXME 不能 extend position, rotation 等引用对象\n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n        return Sub;\n    };\n    zrUtil.inherits(Path, Displayable);\n    return Path;\n});\ndefine('zrender/graphic/Gradient', ['require'], function (require) {\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n        this.colorStops = colorStops || [];\n    };\n    Gradient.prototype = {\n        constructor: Gradient,\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n                offset: offset,\n                color: color\n            });\n        }\n    };\n    return Gradient;\n});\ndefine('zrender/container/Group', ['require', '../core/util', '../Element', '../core/BoundingRect'], function (require) {\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n        opts = opts || {};\n        Element.call(this, opts);\n        for (var key in opts) {\n            this[key] = opts[key];\n        }\n        this._children = [];\n        this.__storage = null;\n        this.__dirty = true;\n    };\n    Group.prototype = {\n        constructor: Group,\n        isGroup: true,\n        type: 'group',\n        silent: false,\n        children: function () {\n            return this._children.slice();\n        },\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n            }\n        },\n        childCount: function () {\n            return this._children.length;\n        },\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n                this._children.push(child);\n                this._doAdd(child);\n            }\n            return this;\n        },\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n            return this;\n        },\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n            child.parent = this;\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n            zr && zr.refresh();\n        },\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n            child.parent = null;\n            if (storage) {\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n            zr && zr.refresh();\n            return this;\n        },\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromMap(child.id);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n            return this;\n        },\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            // TODO Transform\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                } else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n    zrUtil.inherits(Group, Element);\n    return Group;\n});\ndefine('zrender/graphic/Text', ['require', './Displayable', '../core/util', '../contain/text'], function (require) {\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var textContain = require('../contain/text');\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n    Text.prototype = {\n        constructor: Text,\n        type: 'text',\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n            if (text) {\n                this.setTransform(ctx);\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(text, font, style.textAlign, 'top');\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                    case 'middle':\n                        y -= rect.height / 2 - rect.lineHeight / 2;\n                        break;\n                    case 'bottom':\n                        y -= rect.height - rect.lineHeight / 2;\n                        break;\n                    default:\n                        y += rect.lineHeight / 2;\n                    }\n                } else {\n                    textBaseline = style.textBaseline;\n                }\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n                var lineHeight = textContain.measureText('国', ctx.font).width;\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n                this.restoreTransform(ctx);\n            }\n        },\n        getBoundingRect: function () {\n            if (!this._rect) {\n                var style = this.style;\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(style.text + '', style.textFont || style.font, style.textAlign, textVerticalAlign ? 'top' : style.textBaseline);\n                switch (textVerticalAlign) {\n                case 'middle':\n                    rect.y -= rect.height / 2;\n                    break;\n                case 'bottom':\n                    rect.y -= rect.height;\n                    break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                this._rect = rect;\n            }\n            return this._rect;\n        }\n    };\n    zrUtil.inherits(Text, Displayable);\n    return Text;\n});\ndefine('zrender/graphic/Image', ['require', './Displayable', '../core/BoundingRect', '../core/util', '../core/LRU'], function (require) {\n    var Displayable = require('./Displayable');\n    var BoundingRect = require('../core/BoundingRect');\n    var zrUtil = require('../core/util');\n    var LRU = require('../core/LRU');\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n    ZImage.prototype = {\n        constructor: ZImage,\n        type: 'image',\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }    // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                } else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n            if (image) {\n                // 图片已经加载完成\n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n                var width = style.width || image.width;\n                var height = style.height || image.height;\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // 图片加载失败\n                if (!image.width || !image.height) {\n                    return;\n                }\n                // 设置transform\n                this.setTransform(ctx);\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n                } else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n                } else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n                // 如果没设置宽和高的话自动根据图片宽高设置\n                if (style.width == null) {\n                    style.width = width;\n                }\n                if (style.height == null) {\n                    style.height = height;\n                }\n                this.restoreTransform(ctx);\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n            }\n        },\n        getBoundingRect: function () {\n            var style = this.style;\n            if (!this._rect) {\n                this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n            }\n            return this._rect;\n        }\n    };\n    zrUtil.inherits(ZImage, Displayable);\n    return ZImage;\n});\ndefine('zrender/graphic/shape/Circle', ['require', '../Path'], function (require) {\n    'use strict';\n    return require('../Path').extend({\n        type: 'circle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n        buildPath: function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Ring', ['require', '../Path'], function (require) {\n    return require('../Path').extend({\n        type: 'ring',\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Sector', ['require', '../Path'], function (require) {\n    return require('../Path').extend({\n        type: 'sector',\n        shape: {\n            cx: 0,\n            cy: 0,\n            r0: 0,\n            r: 0,\n            startAngle: 0,\n            endAngle: Math.PI * 2,\n            clockwise: true\n        },\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n            ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n            ctx.closePath();\n        }\n    });\n});\ndefine('zrender/graphic/shape/Rect', ['require', '../helper/roundRect', '../Path'], function (require) {\n    var roundRectHelper = require('../helper/roundRect');\n    return require('../Path').extend({\n        type: 'rect',\n        shape: {\n            r: 0,\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            } else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n});\ndefine('zrender/graphic/shape/Polygon', ['require', '../helper/poly', '../Path'], function (require) {\n    var polyHelper = require('../helper/poly');\n    return require('../Path').extend({\n        type: 'polygon',\n        shape: {\n            points: null,\n            smooth: false,\n            smoothConstraint: null\n        },\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Polyline', ['require', '../helper/poly', '../Path'], function (require) {\n    var polyHelper = require('../helper/poly');\n    return require('../Path').extend({\n        type: 'polyline',\n        shape: {\n            points: null,\n            smooth: false,\n            smoothConstraint: null\n        },\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Line', ['require', '../Path'], function (require) {\n    return require('../Path').extend({\n        type: 'line',\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            percent: 1\n        },\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n            ctx.moveTo(x1, y1);\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n});\ndefine('zrender/graphic/shape/BezierCurve', ['require', '../../core/curve', '../../core/vector', '../Path'], function (require) {\n    'use strict';\n    var curveTool = require('../../core/curve');\n    var vec2 = require('../../core/vector');\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n    var out = [];\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        } else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    return require('../Path').extend({\n        type: 'bezier-curve',\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            percent: 1\n        },\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n            ctx.moveTo(x1, y1);\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(x1, cpx1, x2, percent, out);\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(y1, cpy1, y2, percent, out);\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n                ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n            } else {\n                if (percent < 1) {\n                    cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n            }\n        },\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Arc', ['require', '../Path'], function (require) {\n    return require('../Path').extend({\n        type: 'arc',\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            startAngle: 0,\n            endAngle: Math.PI * 2,\n            clockwise: true\n        },\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n});\ndefine('zrender/graphic/RadialGradient', ['require', '../core/util', './Gradient'], function (require) {\n    'use strict';\n    var zrUtil = require('../core/util');\n    var Gradient = require('./Gradient');\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        this.x = x == null ? 0.5 : x;\n        this.y = y == null ? 0.5 : y;\n        this.r = r == null ? 0.5 : r;\n        // Can be cloned\n        this.type = 'radial';\n        // If use global coord\n        this.global = globalCoord || false;\n        Gradient.call(this, colorStops);\n    };\n    RadialGradient.prototype = { constructor: RadialGradient };\n    zrUtil.inherits(RadialGradient, Gradient);\n    return RadialGradient;\n});\ndefine('zrender/graphic/LinearGradient', ['require', '../core/util', './Gradient'], function (require) {\n    'use strict';\n    var zrUtil = require('../core/util');\n    var Gradient = require('./Gradient');\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        this.x = x == null ? 0 : x;\n        this.y = y == null ? 0 : y;\n        this.x2 = x2 == null ? 1 : x2;\n        this.y2 = y2 == null ? 0 : y2;\n        // Can be cloned\n        this.type = 'linear';\n        // If use global coord\n        this.global = globalCoord || false;\n        Gradient.call(this, colorStops);\n    };\n    LinearGradient.prototype = { constructor: LinearGradient };\n    zrUtil.inherits(LinearGradient, Gradient);\n    return LinearGradient;\n});\ndefine('zrender/graphic/CompoundPath', ['require', './Path'], function (require) {\n    var Path = require('./Path');\n    return Path.extend({\n        type: 'compound',\n        shape: { paths: null },\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n});\ndefine('zrender/core/BoundingRect', ['require', './vector', './matrix'], function (require) {\n    'use strict';\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathAbs = Math.abs;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n    BoundingRect.prototype = {\n        constructor: BoundingRect,\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n            this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n            this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n            this.x = x;\n            this.y = y;\n        },\n        applyTransform: function () {\n            var min = [];\n            var max = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                min[0] = this.x;\n                min[1] = this.y;\n                max[0] = this.x + this.width;\n                max[1] = this.y + this.height;\n                v2ApplyTransform(min, min, m);\n                v2ApplyTransform(max, max, m);\n                this.x = mathMin(min[0], max[0]);\n                this.y = mathMin(min[1], max[1]);\n                this.width = mathAbs(max[0] - min[0]);\n                this.height = mathAbs(max[1] - min[1]);\n            };\n        }(),\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n            var m = matrix.create();\n            // 矩阵右乘\n            matrix.translate(m, m, [\n                -a.x,\n                -a.y\n            ]);\n            matrix.scale(m, m, [\n                sx,\n                sy\n            ]);\n            matrix.translate(m, m, [\n                b.x,\n                b.y\n            ]);\n            return m;\n        },\n        intersect: function (b) {\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n            return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n        },\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        }\n    };\n    return BoundingRect;\n});\ndefine('zrender/contain/text', ['require', '../core/util', '../core/BoundingRect'], function (require) {\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n    var retrieve = util.retrieve;\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText 可以被覆盖以兼容不支持 Canvas 的环境\n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n        return width;\n    }\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n        var width = getTextWidth(text, textFont);\n        // FIXME 高度计算比较粗暴\n        var lineHeight = getTextWidth('国', textFont);\n        var height = textLineLen * lineHeight;\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n        switch (textBaseline) {\n        case 'bottom':\n        case 'alphabetic':\n            rect.y -= lineHeight;\n            break;\n        case 'middle':\n            rect.y -= lineHeight / 2;\n            break;    // case 'hanging':\n                      // case 'top':\n        }\n        // FIXME Right to left language\n        switch (textAlign) {\n        case 'end':\n        case 'right':\n            rect.x -= rect.width;\n            break;\n        case 'center':\n            rect.x -= rect.width / 2;\n            break;    // case 'start':\n                      // case 'left':\n        }\n        return rect;\n    }\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n        var x = rect.x;\n        var y = rect.y;\n        var height = rect.height;\n        var width = rect.width;\n        var textHeight = textRect.height;\n        var halfHeight = height / 2 - textHeight / 2;\n        var textAlign = 'left';\n        switch (textPosition) {\n        case 'left':\n            x -= distance;\n            y += halfHeight;\n            textAlign = 'right';\n            break;\n        case 'right':\n            x += distance + width;\n            y += halfHeight;\n            textAlign = 'left';\n            break;\n        case 'top':\n            x += width / 2;\n            y -= distance + textHeight;\n            textAlign = 'center';\n            break;\n        case 'bottom':\n            x += width / 2;\n            y += height + distance;\n            textAlign = 'center';\n            break;\n        case 'inside':\n            x += width / 2;\n            y += halfHeight;\n            textAlign = 'center';\n            break;\n        case 'insideLeft':\n            x += distance;\n            y += halfHeight;\n            textAlign = 'left';\n            break;\n        case 'insideRight':\n            x += width - distance;\n            y += halfHeight;\n            textAlign = 'right';\n            break;\n        case 'insideTop':\n            x += width / 2;\n            y += distance;\n            textAlign = 'center';\n            break;\n        case 'insideBottom':\n            x += width / 2;\n            y += height - textHeight - distance;\n            textAlign = 'center';\n            break;\n        case 'insideTopLeft':\n            x += distance;\n            y += distance;\n            textAlign = 'left';\n            break;\n        case 'insideTopRight':\n            x += width - distance;\n            y += distance;\n            textAlign = 'right';\n            break;\n        case 'insideBottomLeft':\n            x += distance;\n            y += height - textHeight - distance;\n            break;\n        case 'insideBottomRight':\n            x += width - distance;\n            y += height - textHeight - distance;\n            textAlign = 'right';\n            break;\n        }\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'top'\n        };\n    }\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n        options = options || {};\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('国', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1);\n        // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n        contentWidth = containerWidth - ellipsisWidth;\n        var textLines = (text + '').split('\\n');\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n                var subLength = j === 0 ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n            textLines[i] = textLine;\n        }\n        return textLines.join('\\n');\n    }\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n    var textContain = {\n            getWidth: getTextWidth,\n            getBoundingRect: getTextRect,\n            adjustTextPositionOnRect: adjustTextPositionOnRect,\n            truncateText: truncateText,\n            measureText: function (text, textFont) {\n                var ctx = util.getContext();\n                ctx.font = textFont || '12px sans-serif';\n                return ctx.measureText(text);\n            }\n        };\n    return textContain;\n});\ndefine('echarts/util/model', ['require', './format', './number', '../model/Model', 'zrender/core/util'], function (require) {\n    var formatUtil = require('./format');\n    var nubmerUtil = require('./number');\n    var Model = require('../model/Model');\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = {};\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array ? value : value == null ? [] : [value];\n    };\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             textStyle: {\n     *                 fontSize: 18\n     *             }\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n    modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n            // Default emphasis option from normal\n            zrUtil.each(subOpts, function (subOptName) {\n                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n                if (val != null) {\n                    emphasisOpt[subOptName] = val;\n                }\n            });\n        }\n    };\n    modelUtil.LABEL_OPTIONS = [\n        'position',\n        'show',\n        'textStyle',\n        'distance',\n        'formatter'\n    ];\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return zrUtil.isObject(dataItem) && !(dataItem instanceof Array);    // // markLine data can be array\n                                                                             // && !(dataItem[0] && zrUtil.isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {\n            value = +nubmerUtil.parseDate(value);\n        }\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return value == null || value === '' ? NaN : +value;    // If string (like '-'), using '+' parse to NaN\n    };\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n            var seriesIndex = this.seriesIndex;\n            var seriesName = this.name;\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: seriesIndex,\n                seriesName: seriesName,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: data.getItemVisual(dataIndex, 'color'),\n                $vars: [\n                    'seriesName',\n                    'name',\n                    'value'\n                ]\n            };\n        },\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && params.value instanceof Array) {\n                params.value = params.value[dimIndex];\n            }\n            var formatter = itemModel.get([\n                    'label',\n                    status,\n                    'formatter'\n                ]);\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            } else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return zrUtil.isObject(dataItem) && !(dataItem instanceof Array) ? dataItem.value : dataItem;\n            }\n        },\n        formatTooltip: zrUtil.noop\n    };\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n        var result = zrUtil.map(exists || [], function (obj, index) {\n                return { exist: obj };\n            });\n        // Mapping by id or name if specified.\n        zrUtil.each(newCptOptions, function (cptOption, index) {\n            if (!zrUtil.isObject(cptOption)) {\n                return;\n            }\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option && cptOption.id != null && result[i].exist.id === cptOption.id + '') {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option && (exist.id == null || cptOption.id == null) && cptOption.name != null && !modelUtil.isIdInner(cptOption) && !modelUtil.isIdInner(exist) && exist.name === cptOption.name + '') {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n        // Otherwise mapping by index.\n        zrUtil.each(newCptOptions, function (cptOption, index) {\n            if (!zrUtil.isObject(cptOption)) {\n                return;\n            }\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option && !modelUtil.isIdInner(exist) && cptOption.id == null) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n            if (i >= result.length) {\n                result.push({ option: cptOption });\n            }\n        });\n        return result;\n    };\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return zrUtil.isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\u0000_ec_\u0000') === 0;\n    };\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n        return [\n            mapToArray(mapA),\n            mapToArray(mapB)\n        ];\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    } else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    } else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({\n                            seriesId: i,\n                            dataIndex: dataIndices\n                        });\n                    }\n                }\n            }\n            return result;\n        }\n    };\n    return modelUtil;\n});\ndefine('echarts/model/globalDefault', [], function () {\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    return {\n        color: [\n            '#c23531',\n            '#2f4554',\n            '#61a0a8',\n            '#d48265',\n            '#91c7ae',\n            '#749f83',\n            '#ca8622',\n            '#bda29a',\n            '#6e7074',\n            '#546570',\n            '#c4ccd3'\n        ],\n        textStyle: {\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n        blendMode: null,\n        animation: true,\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n        animationThreshold: 2000,\n        progressiveThreshold: 3000,\n        progressive: 400,\n        hoverLayerThreshold: 3000\n    };\n});\ndefine('echarts/model/mixin/colorPalette', [], function () {\n    return {\n        clearColorPalette: function () {\n            this._colorIdx = 0;\n            this._colorNameMap = {};\n        },\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = scope._colorIdx || 0;\n            var colorNameMap = scope._colorNameMap || (scope._colorNameMap = {});\n            if (colorNameMap[name]) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            scope._colorIdx = (colorIdx + 1) % colorPalette.length;\n            return color;\n        }\n    };\n});\ndefine('zrender/core/PathProxy', ['require', './curve', './vector', './bbox', './BoundingRect', '../config'], function (require) {\n    'use strict';\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n    var dpr = require('../config').devicePixelRatio;\n    var CMD = {\n            M: 1,\n            L: 2,\n            C: 3,\n            Q: 4,\n            A: 5,\n            Z: 6,\n            R: 7\n        };\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n    var hasTypedArray = typeof Float32Array != 'undefined';\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function () {\n        /**\n         * Path data. Stored as flat array\n         * @type {Array.<Object>}\n         */\n        this.data = [];\n        this._len = 0;\n        this._ctx = null;\n        this._xi = 0;\n        this._yi = 0;\n        this._x0 = 0;\n        this._y0 = 0;\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        this._ux = 0;\n        this._uy = 0;\n    };\n    /**\n     * 快速计算Path包围盒（并不是最小包围盒）\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n        constructor: PathProxy,\n        _lineDash: null,\n        _dashOffset: 0,\n        _dashIdx: 0,\n        _dashSum: 0,\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n        getContext: function () {\n            return this._ctx;\n        },\n        beginPath: function (ctx) {\n            this._ctx = ctx;\n            ctx && ctx.beginPath();\n            ctx && (this.dpr = ctx.dpr);\n            // Reset\n            this._len = 0;\n            if (this._lineDash) {\n                this._lineDash = null;\n                this._dashOffset = 0;\n            }\n            return this;\n        },\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n            this._x0 = x;\n            this._y0 = y;\n            this._xi = x;\n            this._yi = y;\n            return this;\n        },\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy || this._len < 5;\n            this.addData(CMD.L, x, y);\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n            return this;\n        },\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n            this._xi = mathCos(endAngle) * r + cx;\n            this._xi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n        closePath: function () {\n            this.addData(CMD.Z);\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n                this._dashIdx = 0;\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n        len: function () {\n            return this._len;\n        },\n        setData: function (data) {\n            var len = data.length;\n            if (!(this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n            this._len = len;\n        },\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && this.data instanceof Float32Array) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n        addData: function (cmd) {\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                // 因为之前的数组已经转换成静态的 Float32Array\n                // 所以不够用时需要扩展一个新的动态数组\n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n            this._prevCmd = cmd;\n        },\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n        _needsDash: function () {\n            return this._lineDash;\n        },\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n            while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n            var x;\n            var y;\n            var tmpLen = 0;\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n            while (t <= 1) {\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n                t += lineDash[idx] / bezierLen;\n                idx = (idx + 1) % nDash;\n            }\n            // Finish the last segment and calculate the new offset\n            idx % 2 !== 0 && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = data[i];\n                    yi = data[i + 1];\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                case CMD.M:\n                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                    // 在 closePath 的时候使用\n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    min2[0] = x0;\n                    min2[1] = y0;\n                    max2[0] = x0;\n                    max2[1] = y0;\n                    break;\n                case CMD.L:\n                    bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc 判断的开销比较大\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var startAngle = data[i++];\n                    var endAngle = data[i++] + startAngle;\n                    // TODO Arc 旋转\n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    if (i == 1) {\n                        // 直接使用 arc 命令\n                        // 第一个命令起点还未定义\n                        x0 = mathCos(startAngle) * rx + cx;\n                        y0 = mathSin(startAngle) * ry + cy;\n                    }\n                    bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n                    xi = mathCos(endAngle) * rx + cx;\n                    yi = mathSin(endAngle) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    // Use fromLine\n                    bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                    break;\n                case CMD.Z:\n                    xi = x0;\n                    yi = y0;\n                    break;\n                }\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n            return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n        },\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = d[i];\n                    yi = d[i + 1];\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                case CMD.M:\n                    x0 = xi = d[i++];\n                    y0 = yi = d[i++];\n                    ctx.moveTo(xi, yi);\n                    break;\n                case CMD.L:\n                    x = d[i++];\n                    y = d[i++];\n                    // Not draw too small seg between\n                    if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                        ctx.lineTo(x, y);\n                        xi = x;\n                        yi = y;\n                    }\n                    break;\n                case CMD.C:\n                    ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n                    xi = d[i - 2];\n                    yi = d[i - 1];\n                    break;\n                case CMD.Q:\n                    ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                    xi = d[i - 2];\n                    yi = d[i - 1];\n                    break;\n                case CMD.A:\n                    var cx = d[i++];\n                    var cy = d[i++];\n                    var rx = d[i++];\n                    var ry = d[i++];\n                    var theta = d[i++];\n                    var dTheta = d[i++];\n                    var psi = d[i++];\n                    var fs = d[i++];\n                    var r = rx > ry ? rx : ry;\n                    var scaleX = rx > ry ? 1 : rx / ry;\n                    var scaleY = rx > ry ? ry / rx : 1;\n                    var isEllipse = Math.abs(rx - ry) > 0.001;\n                    var endAngle = theta + dTheta;\n                    if (isEllipse) {\n                        ctx.translate(cx, cy);\n                        ctx.rotate(psi);\n                        ctx.scale(scaleX, scaleY);\n                        ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                        ctx.scale(1 / scaleX, 1 / scaleY);\n                        ctx.rotate(-psi);\n                        ctx.translate(-cx, -cy);\n                    } else {\n                        ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                    }\n                    if (i == 1) {\n                        // 直接使用 arc 命令\n                        // 第一个命令起点还未定义\n                        x0 = mathCos(theta) * rx + cx;\n                        y0 = mathSin(theta) * ry + cy;\n                    }\n                    xi = mathCos(endAngle) * rx + cx;\n                    yi = mathSin(endAngle) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = d[i];\n                    y0 = yi = d[i + 1];\n                    ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                    break;\n                case CMD.Z:\n                    ctx.closePath();\n                    xi = x0;\n                    yi = y0;\n                }\n            }\n        }\n    };\n    PathProxy.CMD = CMD;\n    return PathProxy;\n});\ndefine('zrender/tool/transformPath', ['require', '../core/PathProxy', '../core/vector'], function (require) {\n    var CMD = require('../core/PathProxy').CMD;\n    var vec2 = require('../core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n    var points = [\n            [],\n            [],\n            []\n        ];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n            switch (cmd) {\n            case M:\n                nPoint = 1;\n                break;\n            case L:\n                nPoint = 1;\n                break;\n            case C:\n                nPoint = 3;\n                break;\n            case Q:\n                nPoint = 2;\n                break;\n            case A:\n                var x = m[4];\n                var y = m[5];\n                var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                // cx\n                data[i++] += x;\n                // cy\n                data[i++] += y;\n                // Scale rx and ry\n                // FIXME Assume psi is 0 here\n                data[i++] *= sx;\n                data[i++] *= sy;\n                // Start angle\n                data[i++] += angle;\n                // end angle\n                data[i++] += angle;\n                // FIXME psi\n                i += 2;\n                j = i;\n                break;\n            case R:\n                // x0, y0\n                p[0] = data[i++];\n                p[1] = data[i++];\n                v2ApplyTransform(p, p, m);\n                data[j++] = p[0];\n                data[j++] = p[1];\n                // x1, y1\n                p[0] += data[i++];\n                p[1] += data[i++];\n                v2ApplyTransform(p, p, m);\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n    return transformPath;\n});\ndefine('echarts/util/clazz', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var clazz = {};\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    /**\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n            var ret = {\n                    main: '',\n                    sub: ''\n                };\n            if (componentType) {\n                componentType = componentType.split(TYPE_DELIMITER);\n                ret.main = componentType[0] || '';\n                ret.sub = componentType[1] || '';\n            }\n            return ret;\n        };\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass) {\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                } else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n            zrUtil.extend(ExtendedClass.prototype, proto);\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n            return ExtendedClass;\n        };\n    };\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                componentType = parseClassType(componentType);\n                if (!componentType.sub) {\n                    if (true) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                } else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\n            var Clazz = storage[componentTypeMain];\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error('Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.');\n            }\n            return Clazz;\n        };\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n            var result = [];\n            var obj = storage[componentType.main];\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            } else {\n                result.push(obj);\n            }\n            return result;\n        };\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n        entity.parseClassType = parseClassType;\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n        return entity;\n    };\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n    };\n    return clazz;\n});\ndefine('zrender/graphic/Displayable', ['require', '../core/util', './Style', '../Element', './mixin/RectText'], function (require) {\n    var zrUtil = require('../core/util');\n    var Style = require('./Style');\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n        opts = opts || {};\n        Element.call(this, opts);\n        // Extend properties\n        for (var name in opts) {\n            if (opts.hasOwnProperty(name) && name !== 'style') {\n                this[name] = opts[name];\n            }\n        }\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];    // FIXME Stateful must be mixined after style is setted\n                                  // Stateful.call(this, opts);\n    }\n    Displayable.prototype = {\n        constructor: Displayable,\n        type: 'displayable',\n        __dirty: true,\n        invisible: false,\n        z: 0,\n        z2: 0,\n        zlevel: 0,\n        draggable: false,\n        dragging: false,\n        silent: false,\n        culling: false,\n        cursor: 'pointer',\n        rectHover: false,\n        progressive: -1,\n        beforeBrush: function (ctx) {\n        },\n        afterBrush: function (ctx) {\n        },\n        brush: function (ctx, prevEl) {\n        },\n        getBoundingRect: function () {\n        },\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n        dirty: function () {\n            this.__dirty = true;\n            this._rect = null;\n            this.__zr && this.__zr.refresh();\n        },\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            } else {\n                this.style.set(value);\n            }\n        },\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n    zrUtil.inherits(Displayable, Element);\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n    return Displayable;\n});\ndefine('zrender/contain/path', ['require', '../core/PathProxy', './line', './cubic', './quadratic', './arc', './util', '../core/curve', './windingLine'], function (require) {\n    'use strict';\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n    var windingLine = require('./windingLine');\n    var containStroke = line.containStroke;\n    var PI2 = Math.PI * 2;\n    var EPSILON = 0.0001;\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n    // 临时数组\n    var roots = [\n            -1,\n            -1,\n            -1\n        ];\n    var extrema = [\n            -1,\n            -1\n        ];\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        } else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = t === 0 || t === 1 ? 0.5 : 1;\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) {\n                    // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // 分成三段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    } else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    } else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                } else {\n                    // 分成两段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    } else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        } else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {\n                        // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    } else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            } else {\n                // Remove one endpoint.\n                var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {\n                    // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n    // TODO\n    // Arc 旋转\n    function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 0.0001) {\n            return 0;\n        }\n        if (diff % PI2 < 0.0001) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        } else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }    // 如果被任何一个 subpath 包含\n                     // if (w !== 0) {\n                     //     return true;\n                     // }\n            }\n            if (i == 1) {\n                // 如果第一个命令是 L, C, Q\n                // 则 previous point 同绘制命令的第一个 point\n                //\n                // 第一个命令为 Arc 的情况下会在后面特殊处理\n                xi = data[i];\n                yi = data[i + 1];\n                x0 = xi;\n                y0 = yi;\n            }\n            switch (cmd) {\n            case CMD.M:\n                // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                // 在 closePath 的时候使用\n                x0 = data[i++];\n                y0 = data[i++];\n                xi = x0;\n                yi = y0;\n                break;\n            case CMD.L:\n                if (isStroke) {\n                    if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n                    w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                }\n                xi = data[i++];\n                yi = data[i++];\n                break;\n            case CMD.C:\n                if (isStroke) {\n                    if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n                }\n                xi = data[i++];\n                yi = data[i++];\n                break;\n            case CMD.Q:\n                if (isStroke) {\n                    if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n                }\n                xi = data[i++];\n                yi = data[i++];\n                break;\n            case CMD.A:\n                // TODO Arc 判断的开销比较大\n                var cx = data[i++];\n                var cy = data[i++];\n                var rx = data[i++];\n                var ry = data[i++];\n                var theta = data[i++];\n                var dTheta = data[i++];\n                // TODO Arc 旋转\n                var psi = data[i++];\n                var anticlockwise = 1 - data[i++];\n                var x1 = Math.cos(theta) * rx + cx;\n                var y1 = Math.sin(theta) * ry + cy;\n                // 不是直接使用 arc 命令\n                if (i > 1) {\n                    w += windingLine(xi, yi, x1, y1, x, y);\n                } else {\n                    // 第一个命令起点还未定义\n                    x0 = x1;\n                    y0 = y1;\n                }\n                // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n                var _x = (x - cx) * ry / rx + cx;\n                if (isStroke) {\n                    if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n                        return true;\n                    }\n                } else {\n                    w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n                }\n                xi = Math.cos(theta + dTheta) * rx + cx;\n                yi = Math.sin(theta + dTheta) * ry + cy;\n                break;\n            case CMD.R:\n                x0 = xi = data[i++];\n                y0 = yi = data[i++];\n                var width = data[i++];\n                var height = data[i++];\n                var x1 = x0 + width;\n                var y1 = y0 + height;\n                if (isStroke) {\n                    if (containStroke(x0, y0, x1, y0, lineWidth, x, y) || containStroke(x1, y0, x1, y1, lineWidth, x, y) || containStroke(x1, y1, x0, y1, lineWidth, x, y) || containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    // FIXME Clockwise ?\n                    w += windingLine(x1, y0, x1, y1, x, y);\n                    w += windingLine(x0, y1, x0, y0, x, y);\n                }\n                break;\n            case CMD.Z:\n                if (isStroke) {\n                    if (containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    // Close a subpath\n                    w += windingLine(xi, yi, x0, y0, x, y);    // 如果被任何一个 subpath 包含\n                                                               // FIXME subpaths may overlap\n                                                               // if (w !== 0) {\n                                                               //     return true;\n                                                               // }\n                }\n                xi = x0;\n                yi = y0;\n                break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n    return {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n});\ndefine('echarts/model/mixin/lineStyle', ['require', './makeStyleMapper'], function (require) {\n    var getLineStyle = require('./makeStyleMapper')([\n            [\n                'lineWidth',\n                'width'\n            ],\n            [\n                'stroke',\n                'color'\n            ],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]);\n    return {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n        getLineDash: function () {\n            var lineType = this.get('type');\n            return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [\n                5,\n                5\n            ] : [\n                2,\n                2\n            ];\n        }\n    };\n});\ndefine('echarts/scale/Ordinal', ['require', 'zrender/core/util', './Scale'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var Scale = require('./Scale');\n    var scaleProto = Scale.prototype;\n    var OrdinalScale = Scale.extend({\n            type: 'ordinal',\n            init: function (data, extent) {\n                this._data = data;\n                this._extent = extent || [\n                    0,\n                    data.length - 1\n                ];\n            },\n            parse: function (val) {\n                return typeof val === 'string' ? zrUtil.indexOf(this._data, val) : Math.round(val);\n            },\n            contain: function (rank) {\n                rank = this.parse(rank);\n                return scaleProto.contain.call(this, rank) && this._data[rank] != null;\n            },\n            normalize: function (val) {\n                return scaleProto.normalize.call(this, this.parse(val));\n            },\n            scale: function (val) {\n                return Math.round(scaleProto.scale.call(this, val));\n            },\n            getTicks: function () {\n                var ticks = [];\n                var extent = this._extent;\n                var rank = extent[0];\n                while (rank <= extent[1]) {\n                    ticks.push(rank);\n                    rank++;\n                }\n                return ticks;\n            },\n            getLabel: function (n) {\n                return this._data[n];\n            },\n            count: function () {\n                return this._extent[1] - this._extent[0] + 1;\n            },\n            niceTicks: zrUtil.noop,\n            niceExtent: zrUtil.noop\n        });\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n    return OrdinalScale;\n});\ndefine('zrender/graphic/Pattern', ['require'], function (require) {\n    var Pattern = function (image, repeat) {\n        this.image = image;\n        this.repeat = repeat;\n        // Can be cloned\n        this.type = 'pattern';\n    };\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n        return this._canvasPattern || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n    };\n    return Pattern;\n});\ndefine('echarts/model/mixin/areaStyle', ['require', './makeStyleMapper'], function (require) {\n    return {\n        getAreaStyle: require('./makeStyleMapper')([\n            [\n                'fill',\n                'color'\n            ],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['opacity'],\n            ['shadowColor']\n        ])\n    };\n});\ndefine('echarts/model/mixin/textStyle', ['require', 'zrender/contain/text'], function (require) {\n    var textContain = require('zrender/contain/text');\n    function getShallow(model, path) {\n        return model && model.getShallow(path);\n    }\n    return {\n        getTextColor: function () {\n            var ecModel = this.ecModel;\n            return this.getShallow('color') || ecModel && ecModel.get('textStyle.color');\n        },\n        getFont: function () {\n            var ecModel = this.ecModel;\n            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n            return [\n                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n            ].join(' ');\n        },\n        getTextRect: function (text) {\n            var textStyle = this.get('textStyle') || {};\n            return textContain.getBoundingRect(text, this.getFont(), textStyle.align, textStyle.baseline);\n        },\n        truncateText: function (text, containerWidth, ellipsis, options) {\n            return textContain.truncateText(text, containerWidth, this.getFont(), ellipsis, options);\n        }\n    };\n});\ndefine('echarts/model/mixin/itemStyle', ['require', './makeStyleMapper'], function (require) {\n    var getItemStyle = require('./makeStyleMapper')([\n            [\n                'fill',\n                'color'\n            ],\n            [\n                'stroke',\n                'borderColor'\n            ],\n            [\n                'lineWidth',\n                'borderWidth'\n            ],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]);\n    return {\n        getItemStyle: function (excludes) {\n            var style = getItemStyle.call(this, excludes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [\n                5,\n                5\n            ] : [\n                1,\n                1\n            ];\n        }\n    };\n});\ndefine('zrender/graphic/Style', ['require'], function (require) {\n    var STYLE_COMMON_PROPS = [\n            [\n                'shadowBlur',\n                0\n            ],\n            [\n                'shadowOffsetX',\n                0\n            ],\n            [\n                'shadowOffsetY',\n                0\n            ],\n            [\n                'shadowColor',\n                '#000'\n            ],\n            [\n                'lineCap',\n                'butt'\n            ],\n            [\n                'lineJoin',\n                'miter'\n            ],\n            [\n                'miterLimit',\n                10\n            ]\n        ];\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n    function createLinearGradient(ctx, obj, rect) {\n        // var size =\n        var x = obj.x;\n        var x2 = obj.x2;\n        var y = obj.y;\n        var y2 = obj.y2;\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n        return canvasGradient;\n    }\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n        var x = obj.x;\n        var y = obj.y;\n        var r = obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n        return canvasGradient;\n    }\n    Style.prototype = {\n        constructor: Style,\n        fill: '#000000',\n        stroke: null,\n        opacity: 1,\n        lineDash: null,\n        lineDashOffset: 0,\n        shadowBlur: 0,\n        shadowOffsetX: 0,\n        shadowOffsetY: 0,\n        lineWidth: 1,\n        strokeNoScale: false,\n        text: null,\n        textFill: '#000',\n        textStroke: null,\n        textPosition: 'inside',\n        textBaseline: null,\n        textAlign: null,\n        textVerticalAlign: null,\n        textDistance: 5,\n        textShadowBlur: 0,\n        textShadowOffsetX: 0,\n        textShadowOffsetY: 0,\n        textTransform: false,\n        textRotation: 0,\n        blend: null,\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n            if (firstDraw || style.fill !== prevStyle.fill) {\n                ctx.fillStyle = style.fill;\n            }\n            if (firstDraw || style.stroke !== prevStyle.stroke) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if (firstDraw || style.opacity !== prevStyle.opacity) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n            if (firstDraw || style.blend !== prevStyle.blend) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n            }\n        },\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name) && (overwrite || !target.hasOwnProperty(name))) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            } else {\n                this.extendFrom(obj, true);\n            }\n        },\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n            }\n            return canvasGradient;\n        }\n    };\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n    return Style;\n});\ndefine('zrender/graphic/mixin/RectText', ['require', '../../contain/text', '../../core/BoundingRect'], function (require) {\n    var textContain = require('../../contain/text');\n    var BoundingRect = require('../../core/BoundingRect');\n    var tmpRect = new BoundingRect();\n    var RectText = function () {\n    };\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n    RectText.prototype = {\n        constructor: RectText,\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n            // FIXME\n            ctx.save();\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            } else {\n                this.setTransform(ctx);\n            }\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                    case 'middle':\n                        y -= textRect.height / 2 - textRect.lineHeight / 2;\n                        break;\n                    case 'bottom':\n                        y -= textRect.height - textRect.lineHeight / 2;\n                        break;\n                    default:\n                        y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            } else {\n                var res = textContain.adjustTextPositionOnRect(textPosition, rect, textRect, distance);\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n            var textLines = text.split('\\n');\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n            for (var i = 0; i < textLines.length; i++) {\n                textFill && ctx.fillText(textLines[i], x, y);\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n            ctx.restore();\n        }\n    };\n    return RectText;\n});\ndefine('zrender/Element', ['require', './core/guid', './mixin/Eventful', './mixin/Transformable', './mixin/Animatable', './core/util'], function (require) {\n    'use strict';\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n        /**\n         * 画布元素ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n    Element.prototype = {\n        type: 'element',\n        name: '',\n        __zr: null,\n        ignore: false,\n        clipPath: null,\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n            case 'horizontal':\n                dy = 0;\n                break;\n            case 'vertical':\n                dx = 0;\n                break;\n            }\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [\n                    1,\n                    0,\n                    0,\n                    1,\n                    0,\n                    0\n                ];\n            }\n            m[4] += dx;\n            m[5] += dy;\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n        beforeUpdate: function () {\n        },\n        afterUpdate: function () {\n        },\n        update: function () {\n            this.updateTransform();\n        },\n        traverse: function (cb, context) {\n        },\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            } else {\n                this[key] = value;\n            }\n        },\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            } else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n            this.dirty(false);\n            return this;\n        },\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n            this.dirty(false);\n        },\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n                this.dirty(false);\n            }\n        },\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // 添加动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // 移除动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n    return Element;\n});\ndefine('echarts/model/mixin/makeStyleMapper', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    return function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n                properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n});\ndefine('echarts/coord/cartesian/Cartesian', ['require', 'zrender/core/util'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    function dimAxisMapper(dim) {\n        return this._axes[dim];\n    }\n    /**\n     * @alias module:echarts/coord/Cartesian\n     * @constructor\n     */\n    var Cartesian = function (name) {\n        this._axes = {};\n        this._dimList = [];\n        /**\n         * @type {string}\n         */\n        this.name = name || '';\n    };\n    Cartesian.prototype = {\n        constructor: Cartesian,\n        type: 'cartesian',\n        getAxis: function (dim) {\n            return this._axes[dim];\n        },\n        getAxes: function () {\n            return zrUtil.map(this._dimList, dimAxisMapper, this);\n        },\n        getAxesByScale: function (scaleType) {\n            scaleType = scaleType.toLowerCase();\n            return zrUtil.filter(this.getAxes(), function (axis) {\n                return axis.scale.type === scaleType;\n            });\n        },\n        addAxis: function (axis) {\n            var dim = axis.dim;\n            this._axes[dim] = axis;\n            this._dimList.push(dim);\n        },\n        dataToCoord: function (val) {\n            return this._dataCoordConvert(val, 'dataToCoord');\n        },\n        coordToData: function (val) {\n            return this._dataCoordConvert(val, 'coordToData');\n        },\n        _dataCoordConvert: function (input, method) {\n            var dimList = this._dimList;\n            var output = input instanceof Array ? [] : {};\n            for (var i = 0; i < dimList.length; i++) {\n                var dim = dimList[i];\n                var axis = this._axes[dim];\n                output[dim] = axis[method](input[dim]);\n            }\n            return output;\n        }\n    };\n    return Cartesian;\n});\ndefine('zrender/core/guid', [], function () {\n    var idStart = 2311;\n    return function () {\n        return idStart++;\n    };\n});\ndefine('zrender/mixin/Transformable', ['require', '../core/matrix', '../core/vector'], function (require) {\n    'use strict';\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n    var EPSILON = 0.00005;\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * 平移\n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [\n                0,\n                0\n            ];\n        }\n        if (opts.rotation == null) {\n            /**\n             * 旋转\n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * 缩放\n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [\n                1,\n                1\n            ];\n        }\n        /**\n         * 旋转和缩放的原点\n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n    /**\n     * 判断是否需要有坐标变换\n     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n    };\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n        m = m || matrix.create();\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        } else {\n            mIdentity(m);\n        }\n        // 应用父节点变换\n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            } else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // 保存这个变换矩阵\n        this.transform = m;\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n    transformableProto.getLocalTransform = function (m) {\n        m = m || [];\n        mIdentity(m);\n        var origin = this.origin;\n        var scale = this.scale;\n        var rotation = this.rotation;\n        var position = this.position;\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n        m[4] += position[0];\n        m[5] += position[1];\n        return m;\n    };\n    /**\n     * 将自己的transform应用到context上\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        } else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n    transformableProto.restoreTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    };\n    var tmpTransform = [];\n    /**\n     * 分解`transform`矩阵到`position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [\n                1,\n                1\n            ];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [\n            sx,\n            sy\n        ];\n    };\n    /**\n     * 变换坐标位置到 shape 的局部坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [\n                x,\n                y\n            ];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n    /**\n     * 变换局部坐标位置到全局坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [\n                x,\n                y\n            ];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n    return Transformable;\n});\ndefine('zrender/mixin/Animatable', ['require', '../animation/Animator', '../core/util', '../core/log'], function (require) {\n    'use strict';\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n    Animatable.prototype = {\n        constructor: Animatable,\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            } else {\n                target = el;\n            }\n            if (!target) {\n                log('Property \"' + path + '\" is not existed in element ' + el.id);\n                return;\n            }\n            var animators = el.animators;\n            var animator = new Animator(target, loop);\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            }).done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n            animators.push(animator);\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n            return animator;\n        },\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n            return this;\n        },\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }    // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }    // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }    // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }    // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i].done(done).start(easing);\n            }\n        },\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n                    } else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                } else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    } else {\n                        // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n            if (propertyCount > 0) {\n                this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n            }\n            return this;\n        }\n    };\n    return Animatable;\n});\ndefine('echarts/util/component', ['require', 'zrender/core/util', './clazz'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var clazz = require('./clazz');\n    var parseClassType = clazz.parseClassType;\n    var base = 0;\n    var componentUtil = {};\n    var DELIMITER = '_';\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [\n            type || '',\n            base++,\n            Math.random()\n        ].join(DELIMITER);\n    };\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n        var subTypeDefaulters = {};\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n        return entity;\n    };\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);\n            }\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n            zrUtil.each(fullNameList, function (name) {\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n            return {\n                graph: graph,\n                noEntryList: noEntryList\n            };\n        }\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {\n                    predecessor: [],\n                    successor: []\n                };\n            }\n            return graph[name];\n        }\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n    return componentUtil;\n});\ndefine('echarts/model/mixin/boxLayout', ['require'], function (require) {\n    return {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n});\ndefine('echarts/coord/Axis', ['require', '../util/number', 'zrender/core/util'], function (require) {\n    var numberUtil = require('../util/number');\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = require('zrender/core/util');\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n    var normalizedExtent = [\n            0,\n            1\n        ];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [\n            0,\n            0\n        ];\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n    };\n    Axis.prototype = {\n        constructor: Axis,\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n        getExtent: function () {\n            var ret = this._extent.slice();\n            return ret;\n        },\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);\n        },\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n            return this.scale.scale(t);\n        },\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            } else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n            return Math.abs(size) / len;\n        }\n    };\n    return Axis;\n});\ndefine('echarts/coord/cartesian/axisLabelInterval', ['require', 'zrender/core/util', '../axisHelper'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var axisHelper = require('../axisHelper');\n    return function (axis) {\n        var axisModel = axis.model;\n        var labelModel = axisModel.getModel('axisLabel');\n        var labelInterval = labelModel.get('interval');\n        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n            return labelInterval === 'auto' ? 0 : labelInterval;\n        }\n        return axisHelper.getAxisLabelInterval(zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis), axisModel.getFormattedLabels(), labelModel.getModel('textStyle').getFont(), axis.isHorizontal());\n    };\n});\ndefine('zrender/core/log', ['require', '../config'], function (require) {\n    var config = require('../config');\n    /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n         */\n    return function () {\n        if (config.debugMode === 0) {\n            return;\n        } else if (config.debugMode == 1) {\n            for (var k in arguments) {\n                throw new Error(arguments[k]);\n            }\n        } else if (config.debugMode > 1) {\n            for (var k in arguments) {\n                console.log(arguments[k]);\n            }\n        }\n    };    /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>' \n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n});\ndefine('zrender/animation/Animator', ['require', './Clip', '../tool/color', '../core/util'], function (require) {\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n    var arraySlice = Array.prototype.slice;\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        } else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n                }\n            }\n        }\n    }\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            } else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            } else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        } else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n            }\n        } else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n                }\n            }\n        }\n    }\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n    }\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n            return arraySlice.call(value);\n        }\n        return value;\n    }\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n    function createTrackClip(animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n        // For vertices morphing\n        var arrDim = isValueArray && isArrayLike(firstVal[0]) ? 2 : 1;\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function (a, b) {\n            return a.time - b.time;\n        });\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n            // Check if value is equal, deep check if value is array\n            if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                } else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            } else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n        if (isValueColor) {\n            var rgba = [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n        }\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            } else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            } else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n            var range = kfPercents[frame + 1] - kfPercents[frame];\n            if (range === 0) {\n                return;\n            } else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n                } else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n                        value = rgba2String(rgba);\n                    } else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    } else {\n                        value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n                    }\n                    setter(target, propName, value);\n                }\n            } else {\n                if (isValueArray) {\n                    interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n                } else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n                        value = rgba2String(rgba);\n                    } else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    } else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(target, propName, value);\n                }\n            }\n        };\n        var clip = new Clip({\n                target: animator._target,\n                life: trackMaxTime,\n                loop: animator._loop,\n                delay: animator._delay,\n                onframe: onframe,\n                ondestroy: oneTrackDone\n            });\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n        return clip;\n    }\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function (target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n        this._loop = loop || false;\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n        this._clipCount = 0;\n        this._delay = 0;\n        this._doneList = [];\n        this._onframeList = [];\n        this._clipList = [];\n    };\n    Animator.prototype = {\n        when: function (time, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        start: function (easing) {\n            var self = this;\n            var clipCount = 0;\n            var oneTrackDone = function () {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n            var lastClip;\n            for (var propName in this._tracks) {\n                var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName);\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n                    lastClip = clip;\n                }\n            }\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        done: function (cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n    return Animator;\n});\ndefine('echarts/coord/cartesian/AxisModel', ['require', '../../model/Component', 'zrender/core/util', '../axisModelCreator', '../axisModelCommonMixin'], function (require) {\n    'use strict';\n    var ComponentModel = require('../../model/Component');\n    var zrUtil = require('zrender/core/util');\n    var axisModelCreator = require('../axisModelCreator');\n    var AxisModel = ComponentModel.extend({\n            type: 'cartesian2dAxis',\n            axis: null,\n            init: function () {\n                AxisModel.superApply(this, 'init', arguments);\n                this._resetRange();\n            },\n            mergeOption: function () {\n                AxisModel.superApply(this, 'mergeOption', arguments);\n                this._resetRange();\n            },\n            restoreData: function () {\n                AxisModel.superApply(this, 'restoreData', arguments);\n                this._resetRange();\n            },\n            setRange: function (rangeStart, rangeEnd) {\n                this.option.rangeStart = rangeStart;\n                this.option.rangeEnd = rangeEnd;\n            },\n            getMin: function () {\n                var option = this.option;\n                return option.rangeStart != null ? option.rangeStart : option.min;\n            },\n            getMax: function () {\n                var option = this.option;\n                return option.rangeEnd != null ? option.rangeEnd : option.max;\n            },\n            getNeedCrossZero: function () {\n                var option = this.option;\n                return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;\n            },\n            findGridModel: function () {\n                return this.ecModel.queryComponents({\n                    mainType: 'grid',\n                    index: this.get('gridIndex'),\n                    id: this.get('gridId')\n                })[0];\n            },\n            _resetRange: function () {\n                // rangeStart and rangeEnd is readonly.\n                this.option.rangeStart = this.option.rangeEnd = null;\n            }\n        });\n    function getAxisType(axisDim, option) {\n        // Default axis with data is category axis\n        return option.type || (option.data ? 'category' : 'value');\n    }\n    zrUtil.merge(AxisModel.prototype, require('../axisModelCommonMixin'));\n    var extraOption = { offset: 0 };\n    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n    return AxisModel;\n});\ndefine('zrender/animation/Clip', ['require', './easing'], function (require) {\n    var easingFuncs = require('./easing');\n    function Clip(options) {\n        this._target = options.target;\n        // 生命周期\n        this._life = options.life || 1000;\n        // 延时\n        this._delay = options.delay || 0;\n        // 开始时间\n        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n        this._initialized = false;\n        // 是否循环\n        this.loop = options.loop == null ? false : options.loop;\n        this.gap = options.gap || 0;\n        this.easing = options.easing || 'Linear';\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n    }\n    Clip.prototype = {\n        constructor: Clip,\n        step: function (globalTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n            var percent = (globalTime - this._startTime) / this._life;\n            // 还没开始\n            if (percent < 0) {\n                return;\n            }\n            percent = Math.min(percent, 1);\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n            this.fire('frame', schedule);\n            // 结束\n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart(globalTime);\n                    // 重新开始周期\n                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n                    return 'restart';\n                }\n                // 动画完成将这个控制器标识为待删除\n                // 在Animation.update中进行批量删除\n                this._needsRemove = true;\n                return 'destroy';\n            }\n            return null;\n        },\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n            this._needsRemove = false;\n        },\n        fire: function (eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        }\n    };\n    return Clip;\n});\ndefine('echarts/coord/axisModelCreator', ['require', './axisDefault', 'zrender/core/util', '../model/Component', '../util/layout'], function (require) {\n    var axisDefault = require('./axisDefault');\n    var zrUtil = require('zrender/core/util');\n    var ComponentModel = require('../model/Component');\n    var layout = require('../util/layout');\n    // FIXME axisType is fixed ?\n    var AXIS_TYPES = [\n            'value',\n            'category',\n            'time',\n            'log'\n        ];\n    /**\n     * Generate sub axis model class\n     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n     * @param {module:echarts/model/Component} BaseAxisModelClass\n     * @param {Function} axisTypeDefaulter\n     * @param {Object} [extraDefaultOption]\n     */\n    return function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n        zrUtil.each(AXIS_TYPES, function (axisType) {\n            BaseAxisModelClass.extend({\n                type: axisName + 'Axis.' + axisType,\n                mergeDefaultAndTheme: function (option, ecModel) {\n                    var layoutMode = this.layoutMode;\n                    var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};\n                    var themeModel = ecModel.getTheme();\n                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n                    zrUtil.merge(option, this.getDefaultOption());\n                    option.type = axisTypeDefaulter(axisName, option);\n                    if (layoutMode) {\n                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                    }\n                },\n                defaultOption: zrUtil.mergeAll([\n                    {},\n                    axisDefault[axisType + 'Axis'],\n                    extraDefaultOption\n                ], true)\n            });\n        });\n        ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n    };\n});\ndefine('echarts/coord/axisModelCommonMixin', ['require', 'zrender/core/util', './axisHelper'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var axisHelper = require('./axisHelper');\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        } else {\n            return obj;\n        }\n    }\n    /**\n     * Get categories\n     */\n    function getCategories() {\n        return this.get('type') === 'category' && zrUtil.map(this.get('data'), getName);\n    }\n    /**\n     * Format labels\n     * @return {Array.<string>}\n     */\n    function getFormattedLabels() {\n        return axisHelper.getFormattedLabels(this.axis, this.get('axisLabel.formatter'));\n    }\n    return {\n        getFormattedLabels: getFormattedLabels,\n        getCategories: getCategories\n    };\n});\ndefine('zrender/animation/easing', [], function () {\n    var easing = {\n            linear: function (k) {\n                return k;\n            },\n            quadraticIn: function (k) {\n                return k * k;\n            },\n            quadraticOut: function (k) {\n                return k * (2 - k);\n            },\n            quadraticInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k;\n                }\n                return -0.5 * (--k * (k - 2) - 1);\n            },\n            cubicIn: function (k) {\n                return k * k * k;\n            },\n            cubicOut: function (k) {\n                return --k * k * k + 1;\n            },\n            cubicInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k * k;\n                }\n                return 0.5 * ((k -= 2) * k * k + 2);\n            },\n            quarticIn: function (k) {\n                return k * k * k * k;\n            },\n            quarticOut: function (k) {\n                return 1 - --k * k * k * k;\n            },\n            quarticInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k * k * k;\n                }\n                return -0.5 * ((k -= 2) * k * k * k - 2);\n            },\n            quinticIn: function (k) {\n                return k * k * k * k * k;\n            },\n            quinticOut: function (k) {\n                return --k * k * k * k * k + 1;\n            },\n            quinticInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k * k * k * k;\n                }\n                return 0.5 * ((k -= 2) * k * k * k * k + 2);\n            },\n            sinusoidalIn: function (k) {\n                return 1 - Math.cos(k * Math.PI / 2);\n            },\n            sinusoidalOut: function (k) {\n                return Math.sin(k * Math.PI / 2);\n            },\n            sinusoidalInOut: function (k) {\n                return 0.5 * (1 - Math.cos(Math.PI * k));\n            },\n            exponentialIn: function (k) {\n                return k === 0 ? 0 : Math.pow(1024, k - 1);\n            },\n            exponentialOut: function (k) {\n                return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n            },\n            exponentialInOut: function (k) {\n                if (k === 0) {\n                    return 0;\n                }\n                if (k === 1) {\n                    return 1;\n                }\n                if ((k *= 2) < 1) {\n                    return 0.5 * Math.pow(1024, k - 1);\n                }\n                return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n            },\n            circularIn: function (k) {\n                return 1 - Math.sqrt(1 - k * k);\n            },\n            circularOut: function (k) {\n                return Math.sqrt(1 - --k * k);\n            },\n            circularInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return -0.5 * (Math.sqrt(1 - k * k) - 1);\n                }\n                return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n            },\n            elasticIn: function (k) {\n                var s;\n                var a = 0.1;\n                var p = 0.4;\n                if (k === 0) {\n                    return 0;\n                }\n                if (k === 1) {\n                    return 1;\n                }\n                if (!a || a < 1) {\n                    a = 1;\n                    s = p / 4;\n                } else {\n                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n                }\n                return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n            },\n            elasticOut: function (k) {\n                var s;\n                var a = 0.1;\n                var p = 0.4;\n                if (k === 0) {\n                    return 0;\n                }\n                if (k === 1) {\n                    return 1;\n                }\n                if (!a || a < 1) {\n                    a = 1;\n                    s = p / 4;\n                } else {\n                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n                }\n                return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n            },\n            elasticInOut: function (k) {\n                var s;\n                var a = 0.1;\n                var p = 0.4;\n                if (k === 0) {\n                    return 0;\n                }\n                if (k === 1) {\n                    return 1;\n                }\n                if (!a || a < 1) {\n                    a = 1;\n                    s = p / 4;\n                } else {\n                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n                }\n                if ((k *= 2) < 1) {\n                    return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n                }\n                return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n            },\n            backIn: function (k) {\n                var s = 1.70158;\n                return k * k * ((s + 1) * k - s);\n            },\n            backOut: function (k) {\n                var s = 1.70158;\n                return --k * k * ((s + 1) * k + s) + 1;\n            },\n            backInOut: function (k) {\n                var s = 1.70158 * 1.525;\n                if ((k *= 2) < 1) {\n                    return 0.5 * (k * k * ((s + 1) * k - s));\n                }\n                return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n            },\n            bounceIn: function (k) {\n                return 1 - easing.bounceOut(1 - k);\n            },\n            bounceOut: function (k) {\n                if (k < 1 / 2.75) {\n                    return 7.5625 * k * k;\n                } else if (k < 2 / 2.75) {\n                    return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n                } else if (k < 2.5 / 2.75) {\n                    return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n                } else {\n                    return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n                }\n            },\n            bounceInOut: function (k) {\n                if (k < 0.5) {\n                    return easing.bounceIn(k * 2) * 0.5;\n                }\n                return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n            }\n        };\n    return easing;\n});\ndefine('echarts/coord/axisDefault', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var defaultOption = {\n            show: true,\n            zlevel: 0,\n            z: 0,\n            inverse: false,\n            name: '',\n            nameLocation: 'end',\n            nameRotate: null,\n            nameTruncate: {\n                maxWidth: null,\n                ellipsis: '...',\n                placeholder: '.'\n            },\n            nameTextStyle: {},\n            nameGap: 15,\n            silent: false,\n            triggerEvent: false,\n            tooltip: { show: false },\n            axisLine: {\n                show: true,\n                onZero: true,\n                lineStyle: {\n                    color: '#333',\n                    width: 1,\n                    type: 'solid'\n                }\n            },\n            axisTick: {\n                show: true,\n                inside: false,\n                length: 5,\n                lineStyle: { width: 1 }\n            },\n            axisLabel: {\n                show: true,\n                inside: false,\n                rotate: 0,\n                margin: 8,\n                textStyle: { fontSize: 12 }\n            },\n            splitLine: {\n                show: true,\n                lineStyle: {\n                    color: ['#ccc'],\n                    width: 1,\n                    type: 'solid'\n                }\n            },\n            splitArea: {\n                show: false,\n                areaStyle: {\n                    color: [\n                        'rgba(250,250,250,0.3)',\n                        'rgba(200,200,200,0.3)'\n                    ]\n                }\n            }\n        };\n    var categoryAxis = zrUtil.merge({\n            boundaryGap: true,\n            splitLine: { show: false },\n            axisTick: {\n                alignWithLabel: false,\n                interval: 'auto'\n            },\n            axisLabel: { interval: 'auto' }\n        }, defaultOption);\n    var valueAxis = zrUtil.merge({\n            boundaryGap: [\n                0,\n                0\n            ],\n            splitNumber: 5\n        }, defaultOption);\n    // FIXME\n    var timeAxis = zrUtil.defaults({\n            scale: true,\n            min: 'dataMin',\n            max: 'dataMax'\n        }, valueAxis);\n    var logAxis = zrUtil.defaults({ logBase: 10 }, valueAxis);\n    logAxis.scale = true;\n    return {\n        categoryAxis: categoryAxis,\n        valueAxis: valueAxis,\n        timeAxis: timeAxis,\n        logAxis: logAxis\n    };\n});\ndefine('zrender/config', [], function () {\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config默认配置项\n     * @exports zrender/config\n     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n     */\n    var config = {\n            debugMode: 0,\n            devicePixelRatio: dpr\n        };\n    return config;\n});\ndefine('echarts/chart/helper/createListFromArray', ['require', '../../data/List', '../../data/helper/completeDimensions', 'zrender/core/util', '../../util/model', '../../CoordinateSystem'], function (require) {\n    'use strict';\n    var List = require('../../data/List');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../../util/model');\n    var CoordinateSystem = require('../../CoordinateSystem');\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n        if (true) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = registeredCoordSys && registeredCoordSys.dimensions || [\n                'x',\n                'y'\n            ];\n            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));\n        }\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n        var list = new List(dimensions, seriesModel);\n        var nameList = createNameList(axesInfo, data);\n        var categories = {};\n        var dimValueGetter = categoryIndex >= 0 && ifNeedCompleteOrdinalData(data) ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex ? dataIndex : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            } : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName] || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n        return list;\n    }\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';\n    }\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n            cartesian2d: function (data, seriesModel, ecModel) {\n                var axesModels = zrUtil.map([\n                        'xAxis',\n                        'yAxis'\n                    ], function (name) {\n                        return ecModel.queryComponents({\n                            mainType: name,\n                            index: seriesModel.get(name + 'Index'),\n                            id: seriesModel.get(name + 'Id')\n                        })[0];\n                    });\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n                if (true) {\n                    if (!xAxisModel) {\n                        throw new Error('xAxis \"' + zrUtil.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('xAxisId'), 0) + '\" not found');\n                    }\n                    if (!yAxisModel) {\n                        throw new Error('yAxis \"' + zrUtil.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('yAxisId'), 0) + '\" not found');\n                    }\n                }\n                var xAxisType = xAxisModel.get('type');\n                var yAxisType = yAxisModel.get('type');\n                var dimensions = [\n                        {\n                            name: 'x',\n                            type: getDimTypeByAxis(xAxisType),\n                            stackable: isStackable(xAxisType)\n                        },\n                        {\n                            name: 'y',\n                            type: getDimTypeByAxis(yAxisType),\n                            stackable: isStackable(yAxisType)\n                        }\n                    ];\n                var isXAxisCateogry = xAxisType === 'category';\n                var isYAxisCategory = yAxisType === 'category';\n                completeDimensions(dimensions, data, [\n                    'x',\n                    'y',\n                    'z'\n                ]);\n                var categoryAxesModels = {};\n                if (isXAxisCateogry) {\n                    categoryAxesModels.x = xAxisModel;\n                }\n                if (isYAxisCategory) {\n                    categoryAxesModels.y = yAxisModel;\n                }\n                return {\n                    dimensions: dimensions,\n                    categoryIndex: isXAxisCateogry ? 0 : isYAxisCategory ? 1 : -1,\n                    categoryAxesModels: categoryAxesModels\n                };\n            },\n            polar: function (data, seriesModel, ecModel) {\n                var polarModel = ecModel.queryComponents({\n                        mainType: 'polar',\n                        index: seriesModel.get('polarIndex'),\n                        id: seriesModel.get('polarId')\n                    })[0];\n                var angleAxisModel = polarModel.findAxisModel('angleAxis');\n                var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n                if (true) {\n                    if (!angleAxisModel) {\n                        throw new Error('angleAxis option not found');\n                    }\n                    if (!radiusAxisModel) {\n                        throw new Error('radiusAxis option not found');\n                    }\n                }\n                var radiusAxisType = radiusAxisModel.get('type');\n                var angleAxisType = angleAxisModel.get('type');\n                var dimensions = [\n                        {\n                            name: 'radius',\n                            type: getDimTypeByAxis(radiusAxisType),\n                            stackable: isStackable(radiusAxisType)\n                        },\n                        {\n                            name: 'angle',\n                            type: getDimTypeByAxis(angleAxisType),\n                            stackable: isStackable(angleAxisType)\n                        }\n                    ];\n                var isAngleAxisCateogry = angleAxisType === 'category';\n                var isRadiusAxisCateogry = radiusAxisType === 'category';\n                completeDimensions(dimensions, data, [\n                    'radius',\n                    'angle',\n                    'value'\n                ]);\n                var categoryAxesModels = {};\n                if (isRadiusAxisCateogry) {\n                    categoryAxesModels.radius = radiusAxisModel;\n                }\n                if (isAngleAxisCateogry) {\n                    categoryAxesModels.angle = angleAxisModel;\n                }\n                return {\n                    dimensions: dimensions,\n                    categoryIndex: isAngleAxisCateogry ? 1 : isRadiusAxisCateogry ? 0 : -1,\n                    categoryAxesModels: categoryAxesModels\n                };\n            },\n            geo: function (data, seriesModel, ecModel) {\n                // TODO Region\n                // 多个散点图系列在同一个地区的时候\n                return {\n                    dimensions: completeDimensions([\n                        { name: 'lng' },\n                        { name: 'lat' }\n                    ], data, [\n                        'lng',\n                        'lat',\n                        'value'\n                    ])\n                };\n            }\n        };\n    function createNameList(result, data) {\n        var nameList = [];\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                } else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n        return nameList;\n    }\n    return createListFromArray;\n});\ndefine('zrender/core/curve', ['require', './vector'], function (require) {\n    'use strict';\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 0.0001;\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n    // 临时变量\n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * 计算三次贝塞尔值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n    }\n    /**\n     * 计算三次贝塞尔导数值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n    }\n    /**\n     * 计算三次贝塞尔方程根，使用盛金公式\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1 - p0);\n        var d = p0 - val;\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n        var n = 0;\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            } else {\n                var t1 = -c / b;\n                //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        } else {\n            var disc = B * B - 4 * A * C;\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;\n                // t1, a is not zero\n                var t2 = -K / 2;\n                // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            } else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                } else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                } else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            } else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n    /**\n     * 计算三次贝塞尔方程极限值的位置\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} 有效数目\n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n            }\n        } else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            } else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n    /**\n     * 细分三次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n    /**\n     * 投射点到三次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] 投射点\n     * @return {number}\n     */\n    function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n        _v0[0] = x;\n        _v0[1] = y;\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n            d1 = v2DistSquare(_v1, _v0);\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            } else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                } else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n    /**\n     * 计算二次方贝塞尔值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n    /**\n     * 计算二次方贝塞尔导数值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n    /**\n     * 计算二次方贝塞尔方程根\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        } else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            } else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n    /**\n     * 计算二次贝塞尔方程极限值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        } else {\n            return (p0 - p1) / divider;\n        }\n    }\n    /**\n     * 细分二次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n    /**\n     * 投射点到二次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out 投射点\n     * @return {number}\n     */\n    function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        _v0[0] = x;\n        _v0[1] = y;\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n            var d1 = v2DistSquare(_v1, _v0);\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            } else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                } else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n    return {\n        cubicAt: cubicAt,\n        cubicDerivativeAt: cubicDerivativeAt,\n        cubicRootAt: cubicRootAt,\n        cubicExtrema: cubicExtrema,\n        cubicSubdivide: cubicSubdivide,\n        cubicProjectPoint: cubicProjectPoint,\n        quadraticAt: quadraticAt,\n        quadraticDerivativeAt: quadraticDerivativeAt,\n        quadraticRootAt: quadraticRootAt,\n        quadraticExtremum: quadraticExtremum,\n        quadraticSubdivide: quadraticSubdivide,\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n});\ndefine('zrender/core/bbox', ['require', './vector', './curve'], function (require) {\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n    var PI2 = Math.PI * 2;\n    /**\n     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points 顶点数组\n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function (points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n    var xDim = [];\n    var yDim = [];\n    /**\n     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function (x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n    /**\n     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function (x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n        var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n    /**\n     * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff % PI2 < 0.0001 && diff > 0.0001) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % PI2;\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % PI2;\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        } else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n    return bbox;\n});\ndefine('echarts/data/DataDiffer', ['require'], function (require) {\n    'use strict';\n    function defaultKeyGetter(item) {\n        return item;\n    }\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n        this._old = oldArr;\n        this._new = newArr;\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    }\n    DataDiffer.prototype = {\n        constructor: DataDiffer,\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n            var oldKeyGetter = this._oldKeyGetter;\n            var newKeyGetter = this._newKeyGetter;\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    } else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                } else {\n                    this._remove && this._remove(i);\n                }\n            }\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    } else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    function initIndexMap(arr, map, keyArr, keyGetter) {\n        for (var i = 0; i < arr.length; i++) {\n            var key = keyGetter(arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            } else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n    return DataDiffer;\n});\ndefine('echarts/data/helper/completeDimensions', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    /**\n     * Complete the dimensions array guessed from the data structure.\n     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n     * @param  {Array.<string>} defaultNames    Default names to fill not necessary dimensions, like ['value']\n     * @param  {string} extraPrefix             Prefix of name when filling the left dimensions.\n     * @return {Array.<string>}\n     */\n    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n        if (!data) {\n            return dimensions;\n        }\n        var value0 = retrieveValue(data[0]);\n        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n        defaultNames = defaultNames || [];\n        extraPrefix = extraPrefix || 'extra';\n        for (var i = 0; i < dimSize; i++) {\n            if (!dimensions[i]) {\n                var name = defaultNames[i] || extraPrefix + (i - defaultNames.length);\n                dimensions[i] = guessOrdinal(data, i) ? {\n                    type: 'ordinal',\n                    name: name\n                } : name;\n            }\n        }\n        return dimensions;\n    }\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                var value = retrieveValue(data[i]);\n                if (!zrUtil.isArray(value)) {\n                    return false;\n                }\n                var value = value[dimIndex];\n                if (value != null && isFinite(value)) {\n                    return false;\n                } else if (zrUtil.isString(value) && value !== '-') {\n                    return true;\n                }\n            }\n            return false;\n        };\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value : o;\n    }\n    return completeDimensions;\n});\ndefine('zrender/contain/cubic', ['require', '../core/curve'], function (require) {\n    var curve = require('../core/curve');\n    return {\n        containStroke: function (x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n            return d <= _l / 2;\n        }\n    };\n});\ndefine('zrender/contain/line', [], function () {\n    return {\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n                return false;\n            }\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n            } else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n});\ndefine('zrender/contain/quadratic', ['require', '../core/curve'], function (require) {\n    var curve = require('../core/curve');\n    return {\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n            return d <= _l / 2;\n        }\n    };\n});\ndefine('zrender/contain/arc', ['require', './util'], function (require) {\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n    return {\n        containStroke: function (cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n            if (d - _l > r || d + _l < r) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 0.0001) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n        }\n    };\n});\ndefine('zrender/contain/util', ['require'], function (require) {\n    var PI2 = Math.PI * 2;\n    return {\n        normalizeRadian: function (angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n});\ndefine('zrender/contain/windingLine', [], function () {\n    return function windingLine(x0, y0, x1, y1, x, y) {\n        if (y > y0 && y > y1 || y < y0 && y < y1) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n        var x_ = t * (x1 - x0) + x0;\n        return x_ > x ? dir : 0;\n    };\n});\ndefine('echarts/chart/bar/barItemStyle', ['require', '../../model/mixin/makeStyleMapper'], function (require) {\n    var getBarItemStyle = require('../../model/mixin/makeStyleMapper')([\n            [\n                'fill',\n                'color'\n            ],\n            [\n                'stroke',\n                'borderColor'\n            ],\n            [\n                'lineWidth',\n                'borderWidth'\n            ],\n            [\n                'stroke',\n                'barBorderColor'\n            ],\n            [\n                'lineWidth',\n                'barBorderWidth'\n            ],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]);\n    return {\n        getBarItemStyle: function (excludes) {\n            var style = getBarItemStyle.call(this, excludes);\n            if (this.getBorderLineDash) {\n                var lineDash = this.getBorderLineDash();\n                lineDash && (style.lineDash = lineDash);\n            }\n            return style;\n        }\n    };\n});\ndefine('zrender/core/LRU', ['require'], function (require) {\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function () {\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n        this._len = 0;\n    };\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function (val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function (entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        } else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function (entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        } else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        } else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function () {\n        return this._len;\n    };\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function (val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function (maxSize) {\n        this._list = new LinkedList();\n        this._map = {};\n        this._maxSize = maxSize || 10;\n    };\n    var LRUProto = LRU.prototype;\n    /**\n     * @param  {string} key\n     * @param  {} value\n     */\n    LRUProto.put = function (key, value) {\n        var list = this._list;\n        var map = this._map;\n        if (map[key] == null) {\n            var len = list.len();\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n            }\n            var entry = list.insert(value);\n            entry.key = key;\n            map[key] = entry;\n        }\n    };\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function (key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n            return entry.value;\n        }\n    };\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function () {\n        this._list.clear();\n        this._map = {};\n    };\n    return LRU;\n});\ndefine('zrender/graphic/helper/poly', ['require', './smoothSpline', './smoothBezier'], function (require) {\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n    return {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n                    }\n                } else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n                closePath && ctx.closePath();\n            }\n        }\n    };\n});\ndefine('zrender/graphic/helper/smoothSpline', ['require', '../../core/vector'], function (require) {\n    var vec2 = require('../../core/vector');\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n    }\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points 线段顶点数组\n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    return function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n            var w = pos - idx;\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            } else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n            var w2 = w * w;\n            var w3 = w * w2;\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n});\ndefine('zrender/graphic/helper/smoothBezier', ['require', '../../core/vector'], function (require) {\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n    /**\n     * 贝塞尔平滑曲线\n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points 线段顶点数组\n     * @param {number} smooth 平滑等级, 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n     *                           整个折线的包围盒做一个并集用来约束控制点。\n     * @param {Array} 计算出来的控制点数组\n     */\n    return function (points, smooth, isLoop, constraint) {\n        var cps = [];\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n        var min, max;\n        if (constraint) {\n            min = [\n                Infinity,\n                Infinity\n            ];\n            max = [\n                -Infinity,\n                -Infinity\n            ];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // 与指定的包围盒做并集\n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            } else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                } else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n            vec2.sub(v, nextPoint, prevPoint);\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n        return cps;\n    };\n});\ndefine('zrender/graphic/helper/roundRect', ['require'], function (require) {\n    return {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            } else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                } else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                } else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                } else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            } else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n});\ndefine('zrender/Storage', ['require', './core/util', './core/env', './container/Group', './core/timsort'], function (require) {\n    'use strict';\n    var util = require('./core/util');\n    var env = require('./core/env');\n    var Group = require('./container/Group');\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = require('./core/timsort');\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     * 内容仓库 (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        // 所有常规形状，id索引的map\n        this._elements = {};\n        this._roots = [];\n        this._displayList = [];\n        this._displayListLen = 0;\n    };\n    Storage.prototype = {\n        constructor: Storage,\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n            el.beforeUpdate();\n            if (el.__dirty) {\n                el.update();\n            }\n            el.afterUpdate();\n            var clipPath = el.clipPath;\n            if (clipPath) {\n                // clipPath 的变换是基于 group 的变换\n                clipPath.parent = el;\n                clipPath.updateTransform();\n                // FIXME 效率影响\n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                    clipPaths.push(clipPath);\n                } else {\n                    clipPaths = [clipPath];\n                }\n            }\n            if (el.isGroup) {\n                var children = el._children;\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n                // Mark group clean here\n                el.__dirty = false;\n            } else {\n                el.__clipPaths = clipPaths;\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n        addRoot: function (el) {\n            // Element has been added\n            if (this._elements[el.id]) {\n                return;\n            }\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n            this.addToMap(el);\n            this._roots.push(el);\n        },\n        delRoot: function (elId) {\n            if (elId == null) {\n                // 不指定elId清空\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n                this._elements = {};\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n                return;\n            }\n            if (elId instanceof Array) {\n                for (var i = 0, l = elId.length; i < l; i++) {\n                    this.delRoot(elId[i]);\n                }\n                return;\n            }\n            var el;\n            if (typeof elId == 'string') {\n                el = this._elements[elId];\n            } else {\n                el = elId;\n            }\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromMap(el.id);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n        addToMap: function (el) {\n            if (el instanceof Group) {\n                el.__storage = this;\n            }\n            el.dirty(false);\n            this._elements[el.id] = el;\n            return this;\n        },\n        get: function (elId) {\n            return this._elements[elId];\n        },\n        delFromMap: function (elId) {\n            var elements = this._elements;\n            var el = elements[elId];\n            if (el) {\n                delete elements[elId];\n                if (el instanceof Group) {\n                    el.__storage = null;\n                }\n            }\n            return this;\n        },\n        dispose: function () {\n            this._elements = this._renderList = this._roots = null;\n        },\n        displayableSortFunc: shapeCompareFunc\n    };\n    return Storage;\n});\ndefine('zrender/Handler', ['require', './core/util', './mixin/Draggable', './mixin/Eventful'], function (require) {\n    'use strict';\n    var util = require('./core/util');\n    var Draggable = require('./mixin/Draggable');\n    var Eventful = require('./mixin/Eventful');\n    function makeEventPacket(eveType, target, event) {\n        return {\n            type: eveType,\n            event: event,\n            target: target,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta\n        };\n    }\n    function EmptyProxy() {\n    }\n    EmptyProxy.prototype.dispose = function () {\n    };\n    var handlerNames = [\n            'click',\n            'dblclick',\n            'mousewheel',\n            'mouseout',\n            'mouseup',\n            'mousedown',\n            'mousemove'\n        ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {HTMLElement} root Main HTML element for painting.\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     */\n    var Handler = function (storage, painter, proxy) {\n        Eventful.call(this);\n        this.storage = storage;\n        this.painter = painter;\n        proxy = proxy || new EmptyProxy();\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n        // Attach handler\n        proxy.handler = this;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._hovered;\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n        Draggable.call(this);\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n    Handler.prototype = {\n        constructor: Handler,\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n            var hovered = this.findHover(x, y, null);\n            var lastHovered = this._hovered;\n            var proxy = this.proxy;\n            this._hovered = hovered;\n            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n            // Mouse out on previous hovered element\n            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n            // Mouse over on a new element\n            if (hovered && hovered !== lastHovered) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n            this.trigger('globalout', { event: event });\n        },\n        resize: function (event) {\n            this._hovered = null;\n        },\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n        dispose: function () {\n            this.proxy.dispose();\n            this.storage = this.proxy = this.painter = null;\n        },\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n        dispatchToElement: function (targetEl, eventName, event) {\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetEl, event);\n            var el = targetEl;\n            while (el) {\n                el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n                el.trigger(eventName, eventPacket);\n                el = el.parent;\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n            if (!eventPacket.cancelBubble) {\n                // 冒泡到顶级 zrender 对象\n                this.trigger(eventName, eventPacket);\n                // 分发事件到用户自定义层\n                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof layer[eventHandler] == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n        findHover: function (x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            for (var i = list.length - 1; i >= 0; i--) {\n                if (!list[i].silent && list[i] !== exclude && !list[i].ignore && isHover(list[i], x, y)) {\n                    return list[i];\n                }\n            }\n        }\n    };\n    // Common handlers\n    util.each([\n        'click',\n        'mousedown',\n        'mouseup',\n        'mousewheel',\n        'dblclick'\n    ], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY, null);\n            if (name === 'mousedown') {\n                this._downel = hovered;\n                // In case click triggered before mouseup\n                this._upel = hovered;\n            } else if (name === 'mosueup') {\n                this._upel = hovered;\n            } else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            while (el) {\n                // If ancestor is silent or clipped by ancestor\n                if (el.silent || el.clipPath && !el.clipPath.contain(x, y)) {\n                    return false;\n                }\n                el = el.parent;\n            }\n            return true;\n        }\n        return false;\n    }\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n    return Handler;\n});\ndefine('zrender/animation/Animation', ['require', '../core/util', '../core/event', './requestAnimationFrame', './Animator'], function (require) {\n    'use strict';\n    var util = require('../core/util');\n    var Dispatcher = require('../core/event').Dispatcher;\n    var requestAnimationFrame = require('./requestAnimationFrame');\n    var Animator = require('./Animator');\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n        options = options || {};\n        this.stage = options.stage || {};\n        this.onframe = options.onframe || function () {\n        };\n        // private properties\n        this._clips = [];\n        this._running = false;\n        this._time;\n        this._pausedTime;\n        this._pauseStart;\n        this._paused = false;\n        Dispatcher.call(this);\n    };\n    Animation.prototype = {\n        constructor: Animation,\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        removeClip: function (clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n        _update: function () {\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                } else {\n                    i++;\n                }\n            }\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n            this._time = time;\n            this.onframe(delta);\n            this.trigger('frame', delta);\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n        _startLoop: function () {\n            var self = this;\n            this._running = true;\n            function step() {\n                if (self._running) {\n                    requestAnimationFrame(step);\n                    !self._paused && self._update();\n                }\n            }\n            requestAnimationFrame(step);\n        },\n        start: function () {\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n            this._startLoop();\n        },\n        stop: function () {\n            this._running = false;\n        },\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += new Date().getTime() - this._pauseStart;\n                this._paused = false;\n            }\n        },\n        clear: function () {\n            this._clips = [];\n        },\n        animate: function (target, options) {\n            options = options || {};\n            var animator = new Animator(target, options.loop, options.getter, options.setter);\n            return animator;\n        }\n    };\n    util.mixin(Animation, Dispatcher);\n    return Animation;\n});\ndefine('zrender/dom/HandlerProxy', ['require', '../core/event', '../core/util', '../mixin/Eventful', '../core/env', '../core/GestureMgr'], function (require) {\n    var eventTool = require('../core/event');\n    var zrUtil = require('../core/util');\n    var Eventful = require('../mixin/Eventful');\n    var env = require('../core/env');\n    var GestureMgr = require('../core/GestureMgr');\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n    var TOUCH_CLICK_DELAY = 300;\n    var mouseHandlerNames = [\n            'click',\n            'dblclick',\n            'mousewheel',\n            'mouseout',\n            'mouseup',\n            'mousedown',\n            'mousemove'\n        ];\n    var touchHandlerNames = [\n            'touchstart',\n            'touchend',\n            'touchmove'\n        ];\n    function eventNameFix(name) {\n        return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n    }\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n        stage === 'start' && gestureMgr.clear();\n        var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null), proxy.dom);\n        stage === 'end' && gestureMgr.clear();\n        if (gestureInfo) {\n            // eventTool.stop(event);\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n        }\n    }\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n    function useTouchEvent() {\n        return env.touchEventsSupported;\n    }\n    var domHandlers = {\n            mousemove: function (event) {\n                event = normalizeEvent(this.dom, event);\n                this.trigger('mousemove', event);\n            },\n            mouseout: function (event) {\n                event = normalizeEvent(this.dom, event);\n                var element = event.toElement || event.relatedTarget;\n                if (element != this.dom) {\n                    while (element && element.nodeType != 9) {\n                        // 忽略包含在root中的dom引起的mouseOut\n                        if (element === this.dom) {\n                            return;\n                        }\n                        element = element.parentNode;\n                    }\n                }\n                this.trigger('mouseout', event);\n            },\n            touchstart: function (event) {\n                // Default mouse behaviour should not be disabled here.\n                // For example, page may needs to be slided.\n                event = normalizeEvent(this.dom, event);\n                this._lastTouchMoment = new Date();\n                processGesture(this, event, 'start');\n                // 平板补充一次findHover\n                // this._mobileFindFixed(event);\n                // Trigger mousemove and mousedown\n                domHandlers.mousemove.call(this, event);\n                domHandlers.mousedown.call(this, event);\n                setTouchTimer(this);\n            },\n            touchmove: function (event) {\n                event = normalizeEvent(this.dom, event);\n                processGesture(this, event, 'change');\n                // Mouse move should always be triggered no matter whether\n                // there is gestrue event, because mouse move and pinch may\n                // be used at the same time.\n                domHandlers.mousemove.call(this, event);\n                setTouchTimer(this);\n            },\n            touchend: function (event) {\n                event = normalizeEvent(this.dom, event);\n                processGesture(this, event, 'end');\n                domHandlers.mouseup.call(this, event);\n                // click event should always be triggered no matter whether\n                // there is gestrue event. System click can not be prevented.\n                if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                    domHandlers.click.call(this, event);\n                }\n                setTouchTimer(this);\n            }\n        };\n    // Common handlers\n    zrUtil.each([\n        'click',\n        'mousedown',\n        'mouseup',\n        'mousewheel',\n        'dblclick'\n    ], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n    /**\n     * 为控制类实例初始化dom 事件处理函数\n     *\n     * @inner\n     * @param {module:zrender/Handler} instance 控制类实例\n     */\n    function initDomHandler(instance) {\n        for (var i = 0; i < touchHandlerNames.length; i++) {\n            var name = touchHandlerNames[i];\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        }\n        for (var i = 0; i < mouseHandlerNames.length; i++) {\n            var name = mouseHandlerNames[i];\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        }\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n        this.dom = dom;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n        this._handlers = {};\n        initDomHandler(this);\n        if (useTouchEvent()) {\n            mountHandlers(touchHandlerNames, this);    // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                                                       // addEventListener(root, 'mouseout', this._mouseoutHandler);\n        }\n        // Considering some devices that both enable touch and mouse event (like MS Surface\n        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n        // mouse event can not be handle in those devices.\n        mountHandlers(mouseHandlerNames, this);\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n    return HandlerDomProxy;\n});\ndefine('zrender/Painter', ['require', './config', './core/util', './core/log', './core/BoundingRect', './core/timsort', './Layer', './animation/requestAnimationFrame', './graphic/Image'], function (require) {\n    'use strict';\n    var config = require('./config');\n    var util = require('./core/util');\n    var log = require('./core/log');\n    var BoundingRect = require('./core/BoundingRect');\n    var timsort = require('./core/timsort');\n    var Layer = require('./Layer');\n    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n        if (layer.isBuildin) {\n            return true;\n        }\n        if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n            return false;\n        }\n        return true;\n    }\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) {\n            // Can both be null or undefined\n            return false;\n        }\n        if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n            var path = clipPath.path;\n            clipPath.setTransform(ctx);\n            path.beginPath(ctx);\n            clipPath.buildPath(path, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n        var domRootStyle = domRoot.style;\n        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n        domRootStyle.position = 'relative';\n        domRootStyle.overflow = 'hidden';\n        domRootStyle.width = width + 'px';\n        domRootStyle.height = height + 'px';\n        return domRoot;\n    }\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root 绘图容器\n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === 'CANVAS';\n        opts = opts || {};\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * 绘图容器\n         * @type {HTMLElement}\n         */\n        this.root = root;\n        var rootStyle = root.style;\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n            root.innerHTML = '';\n        }\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n        if (!singleCanvas) {\n            this._width = this._getWidth();\n            this._height = this._getHeight();\n            var domRoot = this._domRoot = createRoot(this._width, this._height);\n            root.appendChild(domRoot);\n        } else {\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n        }\n        this.pathToImage = this._createPathToImage();\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n        this._hoverElements = [];\n    };\n    Painter.prototype = {\n        constructor: Painter,\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        getViewportRoot: function () {\n            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n        },\n        refresh: function (paintAll) {\n            var list = this.storage.getDisplayList(true);\n            var zlevelList = this._zlevelList;\n            this._paintList(list, paintAll);\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.isBuildin && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n            this.refreshHover();\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n            return this;\n        },\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                    style: el.style,\n                    shape: el.shape\n                });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(100000);\n            }\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n        _startProgessive: function () {\n            var self = this;\n            if (!self._furtherProgressive) {\n                return;\n            }\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n            self._progress++;\n            requestAnimationFrame(step);\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n                    self._doPaintList(self.storage.getDisplayList());\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    } else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n        _paintList: function (list, paintAll) {\n            if (paintAll == null) {\n                paintAll = false;\n            }\n            this._updateLayerStatus(list);\n            this._clearProgressive();\n            this.eachBuildinLayer(preProcessLayer);\n            this._doPaintList(list, paintAll);\n            this.eachBuildinLayer(postProcessLayer);\n        },\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n            // var invTransform = [];\n            var scope;\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n                var elFrame = el.__frame;\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n                    // Reset scope\n                    scope = {};\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n                    if (!currentLayer.isBuildin) {\n                        log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n                    }\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n                        if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n                        layerProgress = currentProgressiveLayer.__progress;\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                } else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n                el.__dirty = false;\n            }\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if ((currentLayer.__dirty || forcePaint) && !el.invisible && el.style.opacity !== 0 && !(m && !m[0] && !m[3]) && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n                var clipPaths = el.__clipPaths;\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.isBuildin = true;\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n                this.insertLayer(zlevel, layer);\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n            return layer;\n        },\n        insertLayer: function (zlevel, layer) {\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n            if (prevLayer) {\n                var prevDom = prevLayer.dom;\n                if (prevDom.nextSibling) {\n                    domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n                } else {\n                    domRoot.appendChild(layer.dom);\n                }\n            } else {\n                if (domRoot.firstChild) {\n                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                } else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n            layersMap[zlevel] = layer;\n        },\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n        eachBuildinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (!layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n        getLayers: function () {\n            return this._layers;\n        },\n        _updateLayerStatus: function (list) {\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n            this.eachBuildinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n                    currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                } else {\n                    el.__frame = -1;\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n            // 层中的元素数量有发生变化\n            this.eachBuildinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n        clear: function () {\n            this.eachBuildinLayer(this._clearLayer);\n            return this;\n        },\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                } else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n                var layer = this._layers[zlevel];\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n            width = width || this._getWidth();\n            height = height || this._getHeight();\n            domRoot.style.display = '';\n            // 优化没有实际改变的resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n                for (var id in this._layers) {\n                    this._layers[id].resize(width, height);\n                }\n                this.refresh(true);\n            }\n            this._width = width;\n            this._height = height;\n            return this;\n        },\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n        dispose: function () {\n            this.root.innerHTML = '';\n            this.root = this.storage = this._domRoot = this._layers = null;\n        },\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n            var displayList = this.storage.getDisplayList(true);\n            var scope = {};\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n            return imageLayer.dom;\n        },\n        getWidth: function () {\n            return this._width;\n        },\n        getHeight: function () {\n            return this._height;\n        },\n        _getWidth: function () {\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n            // FIXME Better way to get the width and height when element has not been append to the document\n            return (root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width)) - (parseInt10(stl.paddingLeft) || 0) - (parseInt10(stl.paddingRight) || 0) | 0;\n        },\n        _getHeight: function () {\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n            return (root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height)) - (parseInt10(stl.paddingTop) || 0) - (parseInt10(stl.paddingBottom) || 0) | 0;\n        },\n        _pathToImage: function (id, path, width, height, dpr) {\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n            ctx.clearRect(0, 0, width * dpr, height * dpr);\n            var pathTransform = {\n                    position: path.position,\n                    rotation: path.rotation,\n                    scale: path.scale\n                };\n            path.position = [\n                0,\n                0,\n                0\n            ];\n            path.rotation = 0;\n            path.scale = [\n                1,\n                1\n            ];\n            if (path) {\n                path.brush(ctx);\n            }\n            var ImageShape = require('./graphic/Image');\n            var imgShape = new ImageShape({\n                    id: id,\n                    style: {\n                        x: 0,\n                        y: 0,\n                        image: canvas\n                    }\n                });\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n            return imgShape;\n        },\n        _createPathToImage: function () {\n            var me = this;\n            return function (id, e, width, height) {\n                return me._pathToImage(id, e, width, height, me.dpr);\n            };\n        }\n    };\n    return Painter;\n});\ndefine('zrender/mixin/Draggable', ['require'], function (require) {\n    function Draggable() {\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);    // this._dropTarget = null;\n                                                      // this._draggingTarget = null;\n                                                      // this._x = 0;\n                                                      // this._y = 0;\n    }\n    Draggable.prototype = {\n        constructor: Draggable,\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n            }\n        },\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n                var x = e.offsetX;\n                var y = e.offsetY;\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(draggingTarget, 'drag', e.event);\n                var dropTarget = this.findHover(x, y, draggingTarget);\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n            if (this._dropTarget) {\n                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n            }\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n    };\n    return Draggable;\n});\ndefine('zrender/core/event', ['require', '../mixin/Eventful'], function (require) {\n    'use strict';\n    var Eventful = require('../mixin/Eventful');\n    var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {\n            left: 0,\n            top: 0\n        };\n    }\n    function clientToLocal(el, e, out) {\n        // clientX/clientY is according to view port.\n        var box = getBoundingClientRect(el);\n        out = out || {};\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n        return out;\n    }\n    /**\n     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标\n     */\n    function normalizeEvent(el, e) {\n        e = e || window.event;\n        if (e.zrX != null) {\n            return e;\n        }\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n        if (!isTouch) {\n            clientToLocal(el, e, e);\n            e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        } else {\n            var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e);\n        }\n        return e;\n    }\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        } else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        } else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n    /**\n     * 停止冒泡和阻止默认行为\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event对象\n     */\n    var stop = isDomLevel2 ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        } : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n    return {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n        stop: stop,\n        Dispatcher: Eventful\n    };\n});\ndefine('zrender/animation/requestAnimationFrame', ['require'], function (require) {\n    return typeof window !== 'undefined' && (window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n        setTimeout(func, 16);\n    };\n});\ndefine('zrender/core/GestureMgr', ['require', './event'], function (require) {\n    'use strict';\n    var eventUtil = require('./event');\n    var GestureMgr = function () {\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n    GestureMgr.prototype = {\n        constructor: GestureMgr,\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n            if (!touches) {\n                return;\n            }\n            var trackItem = {\n                    points: [],\n                    touches: [],\n                    target: target,\n                    event: event\n                };\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch);\n                trackItem.points.push([\n                    pos.zrX,\n                    pos.zrY\n                ]);\n                trackItem.touches.push(touch);\n            }\n            this._track.push(trackItem);\n        },\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n    var recognizers = {\n            pinch: function (track, event) {\n                var trackLen = track.length;\n                if (!trackLen) {\n                    return;\n                }\n                var pinchEnd = (track[trackLen - 1] || {}).points;\n                var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n                if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n                    var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                    !isFinite(pinchScale) && (pinchScale = 1);\n                    event.pinchScale = pinchScale;\n                    var pinchCenter = center(pinchEnd);\n                    event.pinchX = pinchCenter[0];\n                    event.pinchY = pinchCenter[1];\n                    return {\n                        type: 'pinch',\n                        target: track[0].target,\n                        event: event\n                    };\n                }\n            }    // Only pinch currently.\n        };\n    return GestureMgr;\n});\ndefine('zrender/Layer', ['require', './core/util', './config', './graphic/Style', './graphic/Pattern'], function (require) {\n    var util = require('./core/util');\n    var config = require('./config');\n    var Style = require('./graphic/Style');\n    var Pattern = require('./graphic/Pattern');\n    function returnFalse() {\n        return false;\n    }\n    /**\n     * 创建dom\n     *\n     * @inner\n     * @param {string} id dom id 待用\n     * @param {string} type dom type，such as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n        var newDomStyle = newDom.style;\n        // 没append呢，请原谅我这样写，清晰~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n        // id不作为索引用，避免可能造成的重名，定义为私有属性\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function (id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }    // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n        var domStyle = dom.style;\n        if (domStyle) {\n            // Not in node\n            dom.onselectstart = returnFalse;\n            // 避免页面选中的尴尬\n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n        }\n        this.domBack = null;\n        this.ctxBack = null;\n        this.painter = painter;\n        this.config = null;\n        // Configs\n        /**\n         * 每次清空画布的颜色\n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * 是否开启动态模糊\n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n    Layer.prototype = {\n        constructor: Layer,\n        elCount: 0,\n        __dirty: true,\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n            this.ctx.dpr = this.dpr;\n        },\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n        resize: function (width, height) {\n            var dpr = this.dpr;\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n            var dpr = this.dpr;\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n            }\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }    // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n    return Layer;\n});\ndefine('echarts/preprocessor/helper/compatStyle', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var POSSIBLE_STYLES = [\n            'areaStyle',\n            'lineStyle',\n            'nodeStyle',\n            'linkStyle',\n            'chordStyle',\n            'label',\n            'labelLine'\n        ];\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (itemStyleOpt) {\n            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n                var normalItemStyleOpt = itemStyleOpt.normal;\n                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].normal) {\n                        opt[styleName].normal = normalItemStyleOpt[styleName];\n                    } else {\n                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                    }\n                    normalItemStyleOpt[styleName] = null;\n                }\n                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].emphasis) {\n                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                    } else {\n                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                    }\n                    emphasisItemStyleOpt[styleName] = null;\n                }\n            });\n        }\n    }\n    return function (seriesOpt) {\n        if (!seriesOpt) {\n            return;\n        }\n        compatItemStyle(seriesOpt);\n        compatItemStyle(seriesOpt.markPoint);\n        compatItemStyle(seriesOpt.markLine);\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n            }\n            // mark point data\n            var markPoint = seriesOpt.markPoint;\n            if (markPoint && markPoint.data) {\n                var mpData = markPoint.data;\n                for (var i = 0; i < mpData.length; i++) {\n                    compatItemStyle(mpData[i]);\n                }\n            }\n            // mark line data\n            var markLine = seriesOpt.markLine;\n            if (markLine && markLine.data) {\n                var mlData = markLine.data;\n                for (var i = 0; i < mlData.length; i++) {\n                    if (zrUtil.isArray(mlData[i])) {\n                        compatItemStyle(mlData[i][0]);\n                        compatItemStyle(mlData[i][1]);\n                    } else {\n                        compatItemStyle(mlData[i]);\n                    }\n                }\n            }\n        }\n    };\n});\ndefine('echarts/component/helper/selectableMixin', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    return {\n        updateSelectedMap: function (targetList) {\n            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n                targetMap[target.name] = target;\n                return targetMap;\n            }, {});\n        },\n        select: function (name) {\n            var targetMap = this._selectTargetMap;\n            var target = targetMap[name];\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                zrUtil.each(targetMap, function (target) {\n                    target.selected = false;\n                });\n            }\n            target && (target.selected = true);\n        },\n        unSelect: function (name) {\n            var target = this._selectTargetMap[name];\n            // var selectedMode = this.get('selectedMode');\n            // selectedMode !== 'single' && target && (target.selected = false);\n            target && (target.selected = false);\n        },\n        toggleSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            if (target != null) {\n                this[target.selected ? 'unSelect' : 'select'](name);\n                return target.selected;\n            }\n        },\n        isSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            return target && target.selected;\n        }\n    };\n});\ndefine('echarts/component/axis/AxisView', ['require', 'zrender/core/util', '../../util/graphic', './AxisBuilder', '../../echarts'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var graphic = require('../../util/graphic');\n    var AxisBuilder = require('./AxisBuilder');\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n    var getInterval = AxisBuilder.getInterval;\n    var axisBuilderAttrs = [\n            'axisLine',\n            'axisLabel',\n            'axisTick',\n            'axisName'\n        ];\n    var selfBuilderAttrs = [\n            'splitArea',\n            'splitLine'\n        ];\n    // function getAlignWithLabel(model, axisModel) {\n    //     var alignWithLabel = model.get('alignWithLabel');\n    //     if (alignWithLabel === 'auto') {\n    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n    //     }\n    //     return alignWithLabel;\n    // }\n    var AxisView = require('../../echarts').extendComponentView({\n            type: 'axis',\n            render: function (axisModel, ecModel) {\n                this.group.removeAll();\n                var oldAxisGroup = this._axisGroup;\n                this._axisGroup = new graphic.Group();\n                this.group.add(this._axisGroup);\n                if (!axisModel.get('show')) {\n                    return;\n                }\n                var gridModel = axisModel.findGridModel();\n                var layout = layoutAxis(gridModel, axisModel);\n                var axisBuilder = new AxisBuilder(axisModel, layout);\n                zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n                this._axisGroup.add(axisBuilder.getGroup());\n                zrUtil.each(selfBuilderAttrs, function (name) {\n                    if (axisModel.get(name + '.show')) {\n                        this['_' + name](axisModel, gridModel, layout.labelInterval);\n                    }\n                }, this);\n                graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n            },\n            _splitLine: function (axisModel, gridModel, labelInterval) {\n                var axis = axisModel.axis;\n                var splitLineModel = axisModel.getModel('splitLine');\n                var lineStyleModel = splitLineModel.getModel('lineStyle');\n                var lineColors = lineStyleModel.get('color');\n                var lineInterval = getInterval(splitLineModel, labelInterval);\n                lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n                var gridRect = gridModel.coordinateSystem.getRect();\n                var isHorizontal = axis.isHorizontal();\n                var lineCount = 0;\n                var ticksCoords = axis.getTicksCoords();\n                var ticks = axis.scale.getTicks();\n                var p1 = [];\n                var p2 = [];\n                // Simple optimization\n                // Batching the lines if color are the same\n                var lineStyle = lineStyleModel.getLineStyle();\n                for (var i = 0; i < ticksCoords.length; i++) {\n                    if (ifIgnoreOnTick(axis, i, lineInterval)) {\n                        continue;\n                    }\n                    var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n                    if (isHorizontal) {\n                        p1[0] = tickCoord;\n                        p1[1] = gridRect.y;\n                        p2[0] = tickCoord;\n                        p2[1] = gridRect.y + gridRect.height;\n                    } else {\n                        p1[0] = gridRect.x;\n                        p1[1] = tickCoord;\n                        p2[0] = gridRect.x + gridRect.width;\n                        p2[1] = tickCoord;\n                    }\n                    var colorIndex = lineCount++ % lineColors.length;\n                    this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                        anid: 'line_' + ticks[i],\n                        shape: {\n                            x1: p1[0],\n                            y1: p1[1],\n                            x2: p2[0],\n                            y2: p2[1]\n                        },\n                        style: zrUtil.defaults({ stroke: lineColors[colorIndex] }, lineStyle),\n                        silent: true\n                    })));\n                }\n            },\n            _splitArea: function (axisModel, gridModel, labelInterval) {\n                var axis = axisModel.axis;\n                var splitAreaModel = axisModel.getModel('splitArea');\n                var areaStyleModel = splitAreaModel.getModel('areaStyle');\n                var areaColors = areaStyleModel.get('color');\n                var gridRect = gridModel.coordinateSystem.getRect();\n                var ticksCoords = axis.getTicksCoords();\n                var ticks = axis.scale.getTicks();\n                var prevX = axis.toGlobalCoord(ticksCoords[0]);\n                var prevY = axis.toGlobalCoord(ticksCoords[0]);\n                var count = 0;\n                var areaInterval = getInterval(splitAreaModel, labelInterval);\n                var areaStyle = areaStyleModel.getAreaStyle();\n                areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n                for (var i = 1; i < ticksCoords.length; i++) {\n                    if (ifIgnoreOnTick(axis, i, areaInterval)) {\n                        continue;\n                    }\n                    var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n                    var x;\n                    var y;\n                    var width;\n                    var height;\n                    if (axis.isHorizontal()) {\n                        x = prevX;\n                        y = gridRect.y;\n                        width = tickCoord - x;\n                        height = gridRect.height;\n                    } else {\n                        x = gridRect.x;\n                        y = prevY;\n                        width = gridRect.width;\n                        height = tickCoord - y;\n                    }\n                    var colorIndex = count++ % areaColors.length;\n                    this._axisGroup.add(new graphic.Rect({\n                        anid: 'area_' + ticks[i],\n                        shape: {\n                            x: x,\n                            y: y,\n                            width: width,\n                            height: height\n                        },\n                        style: zrUtil.defaults({ fill: areaColors[colorIndex] }, areaStyle),\n                        silent: true\n                    }));\n                    prevX = x + width;\n                    prevY = y + height;\n                }\n            }\n        });\n    AxisView.extend({ type: 'xAxis' });\n    AxisView.extend({ type: 'yAxis' });\n    /**\n     * @inner\n     */\n    function layoutAxis(gridModel, axisModel) {\n        var grid = gridModel.coordinateSystem;\n        var axis = axisModel.axis;\n        var layout = {};\n        var rawAxisPosition = axis.position;\n        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n        var axisDim = axis.dim;\n        // [left, right, top, bottom]\n        var rect = grid.getRect();\n        var rectBound = [\n                rect.x,\n                rect.x + rect.width,\n                rect.y,\n                rect.y + rect.height\n            ];\n        var axisOffset = axisModel.get('offset') || 0;\n        var posMap = {\n                x: {\n                    top: rectBound[2] - axisOffset,\n                    bottom: rectBound[3] + axisOffset\n                },\n                y: {\n                    left: rectBound[0] - axisOffset,\n                    right: rectBound[1] + axisOffset\n                }\n            };\n        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n        function getZero(dim, val) {\n            var theAxis = grid.getAxis(dim);\n            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n        }\n        // Axis position\n        layout.position = [\n            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n        ];\n        // Axis rotation\n        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n        // Tick and label direction, x y is axisDim\n        var dirMap = {\n                top: -1,\n                bottom: 1,\n                left: -1,\n                right: 1\n            };\n        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n        if (axis.onZero) {\n            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;\n        }\n        if (axisModel.getModel('axisTick').get('inside')) {\n            layout.tickDirection = -layout.tickDirection;\n        }\n        if (axisModel.getModel('axisLabel').get('inside')) {\n            layout.labelDirection = -layout.labelDirection;\n        }\n        // Special label rotation\n        var labelRotation = axisModel.getModel('axisLabel').get('rotate');\n        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n        // label interval when auto mode.\n        layout.labelInterval = axis.getLabelInterval();\n        // Over splitLine and splitArea\n        layout.z2 = 1;\n        return layout;\n    }\n});\ndefine('echarts/chart/pie/labelLayout', ['require', 'zrender/contain/text'], function (require) {\n    'use strict';\n    var textContain = require('zrender/contain/text');\n    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n        list.sort(function (a, b) {\n            return a.y - b.y;\n        });\n        // 压\n        function shiftDown(start, end, delta, dir) {\n            for (var j = start; j < end; j++) {\n                list[j].y += delta;\n                if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n                    shiftUp(j, delta / 2);\n                    return;\n                }\n            }\n            shiftUp(end - 1, delta / 2);\n        }\n        // 弹\n        function shiftUp(end, delta) {\n            for (var j = end; j >= 0; j--) {\n                list[j].y -= delta;\n                if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n                    break;\n                }\n            }\n        }\n        function changeX(list, isDownList, cx, cy, r, dir) {\n            var lastDeltaX = dir > 0 ? isDownList ? Number.MAX_VALUE : 0 : isDownList ? Number.MAX_VALUE : 0;\n            // 上\n            for (var i = 0, l = list.length; i < l; i++) {\n                // Not change x for center label\n                if (list[i].position === 'center') {\n                    continue;\n                }\n                var deltaY = Math.abs(list[i].y - cy);\n                var length = list[i].len;\n                var length2 = list[i].len2;\n                var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n                if (isDownList && deltaX >= lastDeltaX) {\n                    // 右下，左下\n                    deltaX = lastDeltaX - 10;\n                }\n                if (!isDownList && deltaX <= lastDeltaX) {\n                    // 右上，左上\n                    deltaX = lastDeltaX + 10;\n                }\n                list[i].x = cx + deltaX * dir;\n                lastDeltaX = deltaX;\n            }\n        }\n        var lastY = 0;\n        var delta;\n        var len = list.length;\n        var upList = [];\n        var downList = [];\n        for (var i = 0; i < len; i++) {\n            delta = list[i].y - lastY;\n            if (delta < 0) {\n                shiftDown(i, len, -delta, dir);\n            }\n            lastY = list[i].y + list[i].height;\n        }\n        if (viewHeight - lastY < 0) {\n            shiftUp(len - 1, lastY - viewHeight);\n        }\n        for (var i = 0; i < len; i++) {\n            if (list[i].y >= cy) {\n                downList.push(list[i]);\n            } else {\n                upList.push(list[i]);\n            }\n        }\n        changeX(upList, false, cx, cy, r, dir);\n        changeX(downList, true, cx, cy, r, dir);\n    }\n    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n        var leftList = [];\n        var rightList = [];\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            if (labelLayoutList[i].x < cx) {\n                leftList.push(labelLayoutList[i]);\n            } else {\n                rightList.push(labelLayoutList[i]);\n            }\n        }\n        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            var linePoints = labelLayoutList[i].linePoints;\n            if (linePoints) {\n                var dist = linePoints[1][0] - linePoints[2][0];\n                if (labelLayoutList[i].x < cx) {\n                    linePoints[2][0] = labelLayoutList[i].x + 3;\n                } else {\n                    linePoints[2][0] = labelLayoutList[i].x - 3;\n                }\n                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n                linePoints[1][0] = linePoints[2][0] + dist;\n            }\n        }\n    }\n    return function (seriesModel, r, viewWidth, viewHeight) {\n        var data = seriesModel.getData();\n        var labelLayoutList = [];\n        var cx;\n        var cy;\n        var hasLabelRotate = false;\n        data.each(function (idx) {\n            var layout = data.getItemLayout(idx);\n            var itemModel = data.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            // Use position in normal or emphasis\n            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n            var labelLineModel = itemModel.getModel('labelLine.normal');\n            var labelLineLen = labelLineModel.get('length');\n            var labelLineLen2 = labelLineModel.get('length2');\n            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n            var dx = Math.cos(midAngle);\n            var dy = Math.sin(midAngle);\n            var textX;\n            var textY;\n            var linePoints;\n            var textAlign;\n            cx = layout.cx;\n            cy = layout.cy;\n            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n            if (labelPosition === 'center') {\n                textX = layout.cx;\n                textY = layout.cy;\n                textAlign = 'center';\n            } else {\n                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n                textX = x1 + dx * 3;\n                textY = y1 + dy * 3;\n                if (!isLabelInside) {\n                    // For roseType\n                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n                    var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n                    var y3 = y2;\n                    textX = x3 + (dx < 0 ? -5 : 5);\n                    textY = y3;\n                    linePoints = [\n                        [\n                            x1,\n                            y1\n                        ],\n                        [\n                            x2,\n                            y2\n                        ],\n                        [\n                            x3,\n                            y3\n                        ]\n                    ];\n                }\n                textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n            }\n            var font = labelModel.getModel('textStyle').getFont();\n            var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n            var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n            var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n            hasLabelRotate = !!labelRotate;\n            layout.label = {\n                x: textX,\n                y: textY,\n                position: labelPosition,\n                height: textRect.height,\n                len: labelLineLen,\n                len2: labelLineLen2,\n                linePoints: linePoints,\n                textAlign: textAlign,\n                verticalAlign: 'middle',\n                font: font,\n                rotation: labelRotate\n            };\n            // Not layout the inside label\n            if (!isLabelInside) {\n                labelLayoutList.push(layout.label);\n            }\n        });\n        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n        }\n    };\n});\ndefine('echarts/component/axis/AxisBuilder', ['require', 'zrender/core/util', '../../util/format', '../../util/graphic', '../../model/Model', '../../util/number', 'zrender/core/vector'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n    var Model = require('../../model/Model');\n    var numberUtil = require('../../util/number');\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = require('zrender/core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n    var PI = Math.PI;\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = { componentType: axisModel.mainType };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotation] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     */\n    var AxisBuilder = function (axisModel, opt) {\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n        // Default value\n        zrUtil.defaults(opt, {\n            labelOffset: 0,\n            nameDirection: 1,\n            tickDirection: 1,\n            labelDirection: 1,\n            silent: true\n        });\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n                position: opt.position.slice(),\n                rotation: opt.rotation\n            });\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n        this._dumbGroup = dumbGroup;\n    };\n    AxisBuilder.prototype = {\n        constructor: AxisBuilder,\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n        add: function (name) {\n            builders[name].call(this);\n        },\n        getGroup: function () {\n            return this.group;\n        }\n    };\n    var builders = {\n            axisLine: function () {\n                var opt = this.opt;\n                var axisModel = this.axisModel;\n                if (!axisModel.get('axisLine.show')) {\n                    return;\n                }\n                var extent = this.axisModel.axis.getExtent();\n                var matrix = this._transform;\n                var pt1 = [\n                        extent[0],\n                        0\n                    ];\n                var pt2 = [\n                        extent[1],\n                        0\n                    ];\n                if (matrix) {\n                    v2ApplyTransform(pt1, pt1, matrix);\n                    v2ApplyTransform(pt2, pt2, matrix);\n                }\n                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                    anid: 'line',\n                    shape: {\n                        x1: pt1[0],\n                        y1: pt1[1],\n                        x2: pt2[0],\n                        y2: pt2[1]\n                    },\n                    style: zrUtil.extend({ lineCap: 'round' }, axisModel.getModel('axisLine.lineStyle').getLineStyle()),\n                    strokeContainThreshold: opt.strokeContainThreshold || 5,\n                    silent: true,\n                    z2: 1\n                })));\n            },\n            axisTick: function () {\n                var axisModel = this.axisModel;\n                if (!axisModel.get('axisTick.show')) {\n                    return;\n                }\n                var axis = axisModel.axis;\n                var tickModel = axisModel.getModel('axisTick');\n                var opt = this.opt;\n                var lineStyleModel = tickModel.getModel('lineStyle');\n                var tickLen = tickModel.get('length');\n                var tickInterval = getInterval(tickModel, opt.labelInterval);\n                var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n                var ticks = axis.scale.getTicks();\n                var pt1 = [];\n                var pt2 = [];\n                var matrix = this._transform;\n                for (var i = 0; i < ticksCoords.length; i++) {\n                    // Only ordinal scale support tick interval\n                    if (ifIgnoreOnTick(axis, i, tickInterval)) {\n                        continue;\n                    }\n                    var tickCoord = ticksCoords[i];\n                    pt1[0] = tickCoord;\n                    pt1[1] = 0;\n                    pt2[0] = tickCoord;\n                    pt2[1] = opt.tickDirection * tickLen;\n                    if (matrix) {\n                        v2ApplyTransform(pt1, pt1, matrix);\n                        v2ApplyTransform(pt2, pt2, matrix);\n                    }\n                    // Tick line, Not use group transform to have better line draw\n                    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                        anid: 'tick_' + ticks[i],\n                        shape: {\n                            x1: pt1[0],\n                            y1: pt1[1],\n                            x2: pt2[0],\n                            y2: pt2[1]\n                        },\n                        style: zrUtil.defaults(lineStyleModel.getLineStyle(), { stroke: axisModel.get('axisLine.lineStyle.color') }),\n                        z2: 2,\n                        silent: true\n                    })));\n                }\n            },\n            axisLabel: function () {\n                var opt = this.opt;\n                var axisModel = this.axisModel;\n                var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n                if (!show) {\n                    return;\n                }\n                var axis = axisModel.axis;\n                var labelModel = axisModel.getModel('axisLabel');\n                var textStyleModel = labelModel.getModel('textStyle');\n                var labelMargin = labelModel.get('margin');\n                var ticks = axis.scale.getTicks();\n                var labels = axisModel.getFormattedLabels();\n                // Special label rotate.\n                var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;\n                // To radian.\n                labelRotation = labelRotation * PI / 180;\n                var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);\n                var categoryData = axisModel.get('data');\n                var textEls = [];\n                var silent = isSilent(axisModel);\n                var triggerEvent = axisModel.get('triggerEvent');\n                for (var i = 0; i < ticks.length; i++) {\n                    if (ifIgnoreOnTick(axis, i, opt.labelInterval)) {\n                        continue;\n                    }\n                    var itemTextStyleModel = textStyleModel;\n                    if (categoryData && categoryData[i] && categoryData[i].textStyle) {\n                        itemTextStyleModel = new Model(categoryData[i].textStyle, textStyleModel, axisModel.ecModel);\n                    }\n                    var textColor = itemTextStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n                    var tickCoord = axis.dataToCoord(ticks[i]);\n                    var pos = [\n                            tickCoord,\n                            opt.labelOffset + opt.labelDirection * labelMargin\n                        ];\n                    var labelBeforeFormat = axis.scale.getLabel(ticks[i]);\n                    var textEl = new graphic.Text({\n                            anid: 'label_' + ticks[i],\n                            style: {\n                                text: labels[i],\n                                textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n                                textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,\n                                textFont: itemTextStyleModel.getFont(),\n                                fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor\n                            },\n                            position: pos,\n                            rotation: labelLayout.rotation,\n                            silent: silent,\n                            z2: 10\n                        });\n                    // Pack data for mouse event\n                    if (triggerEvent) {\n                        textEl.eventData = makeAxisEventDataBase(axisModel);\n                        textEl.eventData.targetType = 'axisLabel';\n                        textEl.eventData.value = labelBeforeFormat;\n                    }\n                    // FIXME\n                    this._dumbGroup.add(textEl);\n                    textEl.updateTransform();\n                    textEls.push(textEl);\n                    this.group.add(textEl);\n                    textEl.decomposeTransform();\n                }\n                function isTwoLabelOverlapped(current, next) {\n                    var firstRect = current && current.getBoundingRect().clone();\n                    var nextRect = next && next.getBoundingRect().clone();\n                    if (firstRect && nextRect) {\n                        firstRect.applyTransform(current.getLocalTransform());\n                        nextRect.applyTransform(next.getLocalTransform());\n                        return firstRect.intersect(nextRect);\n                    }\n                }\n                if (axis.type !== 'category') {\n                    // If min or max are user set, we need to check\n                    // If the tick on min(max) are overlap on their neighbour tick\n                    // If they are overlapped, we need to hide the min(max) tick label\n                    if (axisModel.getMin ? axisModel.getMin() : axisModel.get('min')) {\n                        var firstLabel = textEls[0];\n                        var nextLabel = textEls[1];\n                        if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n                            firstLabel.ignore = true;\n                        }\n                    }\n                    if (axisModel.getMax ? axisModel.getMax() : axisModel.get('max')) {\n                        var lastLabel = textEls[textEls.length - 1];\n                        var prevLabel = textEls[textEls.length - 2];\n                        if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n                            lastLabel.ignore = true;\n                        }\n                    }\n                }\n            },\n            axisName: function () {\n                var opt = this.opt;\n                var axisModel = this.axisModel;\n                var name = retrieve(opt.axisName, axisModel.get('name'));\n                if (!name) {\n                    return;\n                }\n                var nameLocation = axisModel.get('nameLocation');\n                var nameDirection = opt.nameDirection;\n                var textStyleModel = axisModel.getModel('nameTextStyle');\n                var gap = axisModel.get('nameGap') || 0;\n                var extent = this.axisModel.axis.getExtent();\n                var gapSignal = extent[0] > extent[1] ? -1 : 1;\n                var pos = [\n                        nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2,\n                        nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n                    ];\n                var labelLayout;\n                var nameRotation = axisModel.get('nameRotate');\n                if (nameRotation != null) {\n                    nameRotation = nameRotation * PI / 180;    // To radian.\n                }\n                var axisNameAvailableWidth;\n                if (nameLocation === 'middle') {\n                    labelLayout = innerTextLayout(opt, nameRotation != null ? nameRotation : opt.rotation, nameDirection);\n                } else {\n                    labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n                    axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                    if (axisNameAvailableWidth != null) {\n                        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n                        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                    }\n                }\n                var textFont = textStyleModel.getFont();\n                var truncateOpt = axisModel.get('nameTruncate', true) || {};\n                var ellipsis = truncateOpt.ellipsis;\n                var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);\n                var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n                        minChar: 2,\n                        placeholder: truncateOpt.placeholder\n                    }) : name;\n                var tooltipOpt = axisModel.get('tooltip', true);\n                var mainType = axisModel.mainType;\n                var formatterParams = {\n                        componentType: mainType,\n                        name: name,\n                        $vars: ['name']\n                    };\n                formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n                var textEl = new graphic.Text({\n                        anid: 'name',\n                        __fullText: name,\n                        __truncatedText: truncatedText,\n                        style: {\n                            text: truncatedText,\n                            textFont: textFont,\n                            fill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n                            textAlign: labelLayout.textAlign,\n                            textVerticalAlign: labelLayout.verticalAlign\n                        },\n                        position: pos,\n                        rotation: labelLayout.rotation,\n                        silent: isSilent(axisModel),\n                        z2: 1,\n                        tooltip: tooltipOpt && tooltipOpt.show ? zrUtil.extend({\n                            content: name,\n                            formatter: function () {\n                                return name;\n                            },\n                            formatterParams: formatterParams\n                        }, tooltipOpt) : null\n                    });\n                if (axisModel.get('triggerEvent')) {\n                    textEl.eventData = makeAxisEventDataBase(axisModel);\n                    textEl.eventData.targetType = 'axisName';\n                    textEl.eventData.name = name;\n                }\n                // FIXME\n                this._dumbGroup.add(textEl);\n                textEl.updateTransform();\n                this.group.add(textEl);\n                textEl.decomposeTransform();\n            }\n        };\n    /**\n     * @inner\n     */\n    function innerTextLayout(opt, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n        if (isRadianAroundZero(rotationDiff)) {\n            // Label is parallel with axis line.\n            verticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        } else if (isRadianAroundZero(rotationDiff - PI)) {\n            // Label is inverse parallel with axis line.\n            verticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        } else {\n            verticalAlign = 'middle';\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            } else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n    /**\n     * @inner\n     */\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            verticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            verticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        } else {\n            verticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            } else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n    /**\n     * @inner\n     */\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent') || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n    }\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n            var rawTick;\n            var scale = axis.scale;\n            return scale.type === 'ordinal' && (typeof interval === 'function' ? (rawTick = scale.getTicks()[i], !interval(rawTick, scale.getLabel(rawTick))) : i % (interval + 1));\n        };\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n            var interval = model.get('interval');\n            if (interval == null || interval == 'auto') {\n                interval = labelInterval;\n            }\n            return interval;\n        };\n    return AxisBuilder;\n});\ndefine('zrender', ['zrender/zrender'], function (zrender) { return zrender;});\ndefine('echarts', ['echarts/echarts'], function (echarts) { return echarts;});\nvar echarts = require('echarts');\n\necharts.graphic = require('echarts/util/graphic');\necharts.number = require('echarts/util/number');\necharts.format = require('echarts/util/format');\n\n\nrequire('echarts/chart/bar');\n\nrequire('echarts/chart/pie');\n\n\nrequire('echarts/component/grid');\n\nrequire('echarts/component/title');\n\n\n\n\nreturn echarts;\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/echarts.js\n ** module id = 50\n ** module chunks = 1\n **/"],"sourceRoot":""}